import { n as _defineProperty, t as _objectSpread2 } from "./objectSpread2-b6TJfdPE.js";
if (typeof window < "u") {
	var _window$__svelte, _window$__svelte$v, _window, _window$__svelte2;
	((_window$__svelte$v = (_window$__svelte = (_window$__svelte2 = (_window = window).__svelte) == null ? _window.__svelte = {} : _window$__svelte2).v) == null ? _window$__svelte.v = /* @__PURE__ */ new Set() : _window$__svelte$v).add("5");
}
const HYDRATION_ERROR = {}, UNINITIALIZED = Symbol();
var is_array = Array.isArray, index_of = Array.prototype.indexOf, array_from = Array.from, object_keys = Object.keys, define_property = Object.defineProperty, get_descriptor = Object.getOwnPropertyDescriptor, get_descriptors = Object.getOwnPropertyDescriptors, object_prototype = Object.prototype, array_prototype = Array.prototype, get_prototype_of = Object.getPrototypeOf, is_extensible = Object.isExtensible;
function is_function(C) {
	return typeof C == "function";
}
const noop = () => {};
function run(C) {
	return C();
}
function run_all(C) {
	for (var T = 0; T < C.length; T++) C[T]();
}
function deferred$1() {
	var C, T;
	return {
		promise: new Promise((E, D) => {
			C = E, T = D;
		}),
		resolve: C,
		reject: T
	};
}
function to_array(C, T) {
	if (Array.isArray(C)) return C;
	if (T === void 0 || !(Symbol.iterator in C)) return Array.from(C);
	let E = [];
	for (let D of C) if (E.push(D), E.length === T) break;
	return E;
}
const CLEAN = 1024, DIRTY = 2048, MAYBE_DIRTY = 4096, INERT = 8192, EFFECT_TRANSPARENT = 65536, EFFECT_PRESERVED = 1 << 19, USER_EFFECT = 1 << 20, WAS_MARKED = 32768, REACTION_IS_UPDATING = 1 << 21, ERROR_VALUE = 1 << 23, STATE_SYMBOL = Symbol("$state"), LEGACY_PROPS = Symbol("legacy props"), LOADING_ATTR_SYMBOL = Symbol(""), STALE_REACTION = new class extends Error {
	constructor(...T) {
		super(...T), _defineProperty(this, "name", "StaleReactionError"), _defineProperty(this, "message", "The reaction that called `getAbortSignal()` was re-run or destroyed");
	}
}();
function lifecycle_outside_component(C) {
	throw Error("https://svelte.dev/e/lifecycle_outside_component");
}
function async_derived_orphan() {
	throw Error("https://svelte.dev/e/async_derived_orphan");
}
function effect_in_teardown(C) {
	throw Error("https://svelte.dev/e/effect_in_teardown");
}
function effect_in_unowned_derived() {
	throw Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function effect_orphan(C) {
	throw Error("https://svelte.dev/e/effect_orphan");
}
function effect_update_depth_exceeded() {
	throw Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function hydration_failed() {
	throw Error("https://svelte.dev/e/hydration_failed");
}
function props_invalid_value(C) {
	throw Error("https://svelte.dev/e/props_invalid_value");
}
function state_descriptors_fixed() {
	throw Error("https://svelte.dev/e/state_descriptors_fixed");
}
function state_prototype_fixed() {
	throw Error("https://svelte.dev/e/state_prototype_fixed");
}
function state_unsafe_mutation() {
	throw Error("https://svelte.dev/e/state_unsafe_mutation");
}
function svelte_boundary_reset_onerror() {
	throw Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}
function hydration_mismatch(C) {
	console.warn("https://svelte.dev/e/hydration_mismatch");
}
function select_multiple_invalid_value() {
	console.warn("https://svelte.dev/e/select_multiple_invalid_value");
}
function svelte_boundary_reset_noop() {
	console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}
let hydrating = !1;
function set_hydrating(C) {
	hydrating = C;
}
let hydrate_node;
function set_hydrate_node(C) {
	if (C === null) throw hydration_mismatch(), HYDRATION_ERROR;
	return hydrate_node = C;
}
function hydrate_next() {
	return set_hydrate_node(/* @__PURE__ */ get_next_sibling(hydrate_node));
}
function reset(C) {
	if (hydrating) {
		if (/* @__PURE__ */ get_next_sibling(hydrate_node) !== null) throw hydration_mismatch(), HYDRATION_ERROR;
		hydrate_node = C;
	}
}
function next(C = 1) {
	if (hydrating) {
		for (var T = C, E = hydrate_node; T--;) E = /* @__PURE__ */ get_next_sibling(E);
		hydrate_node = E;
	}
}
function skip_nodes(C = !0) {
	for (var T = 0, E = hydrate_node;;) {
		if (E.nodeType === 8) {
			var D = E.data;
			if (D === "]") {
				if (T === 0) return E;
				--T;
			} else (D === "[" || D === "[!") && (T += 1);
		}
		var O = /* @__PURE__ */ get_next_sibling(E);
		C && E.remove(), E = O;
	}
}
function read_hydration_instruction(C) {
	if (!C || C.nodeType !== 8) throw hydration_mismatch(), HYDRATION_ERROR;
	return C.data;
}
function equals(C) {
	return C === this.v;
}
function safe_not_equal(C, T) {
	return C == C ? C !== T || typeof C == "object" && !!C || typeof C == "function" : T == T;
}
function safe_equals(C) {
	return !safe_not_equal(C, this.v);
}
let legacy_mode_flag = !1;
function enable_legacy_mode_flag() {
	legacy_mode_flag = !0;
}
var empty = [];
function snapshot(C, T = !1, E = !1) {
	return clone(C, /* @__PURE__ */ new Map(), "", empty, null, E);
}
function clone(C, T, E, D, O = null, F = !1) {
	if (typeof C == "object" && C) {
		var I = T.get(C);
		if (I !== void 0) return I;
		if (C instanceof Map) return new Map(C);
		if (C instanceof Set) return new Set(C);
		if (is_array(C)) {
			var L = Array(C.length);
			T.set(C, L), O !== null && T.set(O, L);
			for (var B = 0; B < C.length; B += 1) {
				var V = C[B];
				B in C && (L[B] = clone(V, T, E, D, null, F));
			}
			return L;
		}
		if (get_prototype_of(C) === object_prototype) {
			for (var U in L = {}, T.set(C, L), O !== null && T.set(O, L), C) L[U] = clone(C[U], T, E, D, null, F);
			return L;
		}
		if (C instanceof Date) return structuredClone(C);
		if (typeof C.toJSON == "function" && !F) return clone(C.toJSON(), T, E, D, C);
	}
	if (C instanceof EventTarget) return C;
	try {
		return structuredClone(C);
	} catch (T) {
		return C;
	}
}
let component_context = null;
function set_component_context(C) {
	component_context = C;
}
function getContext(C) {
	return get_or_init_context_map("getContext").get(C);
}
function setContext(C, T) {
	return get_or_init_context_map("setContext").set(C, T), T;
}
function push(C, T = !1, E) {
	component_context = {
		p: component_context,
		i: !1,
		c: null,
		e: null,
		s: C,
		x: null,
		l: legacy_mode_flag && !T ? {
			s: null,
			u: null,
			$: []
		} : null
	};
}
function pop(C) {
	var T = component_context, E = T.e;
	if (E !== null) {
		T.e = null;
		for (var D of E) create_user_effect(D);
	}
	return C !== void 0 && (T.x = C), T.i = !0, component_context = T.p, C == null ? {} : C;
}
function is_runes() {
	return !legacy_mode_flag || component_context !== null && component_context.l === null;
}
function get_or_init_context_map(C) {
	var T, E;
	return component_context === null && lifecycle_outside_component(C), (E = (T = component_context).c) == null ? T.c = new Map(get_parent_context(component_context) || void 0) : E;
}
function get_parent_context(C) {
	let T = C.p;
	for (; T !== null;) {
		let C = T.c;
		if (C !== null) return C;
		T = T.p;
	}
	return null;
}
var micro_tasks = [];
function run_micro_tasks() {
	var C = micro_tasks;
	micro_tasks = [], run_all(C);
}
function queue_micro_task(C) {
	if (micro_tasks.length === 0 && !is_flushing_sync) {
		var T = micro_tasks;
		queueMicrotask(() => {
			T === micro_tasks && run_micro_tasks();
		});
	}
	micro_tasks.push(C);
}
function flush_tasks() {
	for (; micro_tasks.length > 0;) run_micro_tasks();
}
function handle_error(C) {
	var T = active_effect;
	if (T === null) return active_reaction.f |= ERROR_VALUE, C;
	if (T.f & 32768) invoke_error_boundary(C, T);
	else {
		if (!(T.f & 128)) throw C;
		T.b.error(C);
	}
}
function invoke_error_boundary(C, T) {
	for (; T !== null;) {
		if (T.f & 128) try {
			T.b.error(C);
			return;
		} catch (T) {
			C = T;
		}
		T = T.parent;
	}
	throw C;
}
function _checkPrivateRedeclaration(C, T) {
	if (T.has(C)) throw TypeError("Cannot initialize the same private elements twice on an object");
}
function _classPrivateMethodInitSpec(C, T) {
	_checkPrivateRedeclaration(C, T), T.add(C);
}
function _classPrivateFieldInitSpec(C, T, E) {
	_checkPrivateRedeclaration(C, T), T.set(C, E);
}
function _assertClassBrand(C, T, E) {
	if (typeof C == "function" ? C === T : C.has(T)) return arguments.length < 3 ? T : E;
	throw TypeError("Private element is not present on this object");
}
function _classPrivateFieldGet2(C, T) {
	return C.get(_assertClassBrand(C, T));
}
function _classPrivateFieldSet2(C, T, E) {
	return C.set(_assertClassBrand(C, T), E), E;
}
function asyncGeneratorStep(C, T, E, D, O, F, I) {
	try {
		var L = C[F](I), z = L.value;
	} catch (C) {
		E(C);
		return;
	}
	L.done ? T(z) : Promise.resolve(z).then(D, O);
}
function _asyncToGenerator(C) {
	return function() {
		var T = this, E = arguments;
		return new Promise(function(D, O) {
			var F = C.apply(T, E);
			function I(C) {
				asyncGeneratorStep(F, D, O, I, L, "next", C);
			}
			function L(C) {
				asyncGeneratorStep(F, D, O, I, L, "throw", C);
			}
			I(void 0);
		});
	};
}
var batches = /* @__PURE__ */ new Set();
let current_batch = null, previous_batch = null, batch_values = null;
var queued_root_effects = [], last_scheduled_effect = null, is_flushing = !1;
let is_flushing_sync = !1;
var _commit_callbacks = /* @__PURE__ */ new WeakMap(), _discard_callbacks = /* @__PURE__ */ new WeakMap(), _pending$1 = /* @__PURE__ */ new WeakMap(), _blocking_pending = /* @__PURE__ */ new WeakMap(), _deferred = /* @__PURE__ */ new WeakMap(), _dirty_effects = /* @__PURE__ */ new WeakMap(), _maybe_dirty_effects = /* @__PURE__ */ new WeakMap(), _Batch_brand = /* @__PURE__ */ new WeakSet(), Batch = class T {
	constructor() {
		_classPrivateMethodInitSpec(this, _Batch_brand), _defineProperty(this, "committed", !1), _defineProperty(this, "current", /* @__PURE__ */ new Map()), _defineProperty(this, "previous", /* @__PURE__ */ new Map()), _classPrivateFieldInitSpec(this, _commit_callbacks, /* @__PURE__ */ new Set()), _classPrivateFieldInitSpec(this, _discard_callbacks, /* @__PURE__ */ new Set()), _classPrivateFieldInitSpec(this, _pending$1, 0), _classPrivateFieldInitSpec(this, _blocking_pending, 0), _classPrivateFieldInitSpec(this, _deferred, null), _classPrivateFieldInitSpec(this, _dirty_effects, []), _classPrivateFieldInitSpec(this, _maybe_dirty_effects, []), _defineProperty(this, "skipped_effects", /* @__PURE__ */ new Set()), _defineProperty(this, "is_fork", !1);
	}
	process(C) {
		queued_root_effects = [], previous_batch = null, this.apply();
		var T = {
			parent: null,
			effect: null,
			effects: [],
			render_effects: [],
			block_effects: []
		};
		for (let E of C) _assertClassBrand(_Batch_brand, this, _traverse_effect_tree).call(this, E, T);
		if (this.is_fork || _assertClassBrand(_Batch_brand, this, _resolve).call(this), _classPrivateFieldGet2(_blocking_pending, this) > 0 || this.is_fork) _assertClassBrand(_Batch_brand, this, _defer_effects).call(this, T.effects), _assertClassBrand(_Batch_brand, this, _defer_effects).call(this, T.render_effects), _assertClassBrand(_Batch_brand, this, _defer_effects).call(this, T.block_effects);
		else {
			var E;
			previous_batch = this, current_batch = null, flush_queued_effects(T.render_effects), flush_queued_effects(T.effects), previous_batch = null, (E = _classPrivateFieldGet2(_deferred, this)) == null || E.resolve();
		}
		batch_values = null;
	}
	capture(C, T) {
		this.previous.has(C) || this.previous.set(C, T), C.f & 8388608 || (this.current.set(C, C.v), batch_values == null || batch_values.set(C, C.v));
	}
	activate() {
		current_batch = this, this.apply();
	}
	deactivate() {
		current_batch = null, batch_values = null;
	}
	flush() {
		if (this.activate(), queued_root_effects.length > 0) {
			if (flush_effects(), current_batch !== null && current_batch !== this) return;
		} else _classPrivateFieldGet2(_pending$1, this) === 0 && this.process([]);
		this.deactivate();
	}
	discard() {
		for (let C of _classPrivateFieldGet2(_discard_callbacks, this)) C(this);
		_classPrivateFieldGet2(_discard_callbacks, this).clear();
	}
	increment(C) {
		_classPrivateFieldSet2(_pending$1, this, _classPrivateFieldGet2(_pending$1, this) + 1), C && _classPrivateFieldSet2(_blocking_pending, this, _classPrivateFieldGet2(_blocking_pending, this) + 1);
	}
	decrement(C) {
		_classPrivateFieldSet2(_pending$1, this, _classPrivateFieldGet2(_pending$1, this) - 1), C && _classPrivateFieldSet2(_blocking_pending, this, _classPrivateFieldGet2(_blocking_pending, this) - 1), this.revive();
	}
	revive() {
		for (let C of _classPrivateFieldGet2(_dirty_effects, this)) set_signal_status(C, DIRTY), schedule_effect(C);
		for (let C of _classPrivateFieldGet2(_maybe_dirty_effects, this)) set_signal_status(C, MAYBE_DIRTY), schedule_effect(C);
		_classPrivateFieldSet2(_dirty_effects, this, []), _classPrivateFieldSet2(_maybe_dirty_effects, this, []), this.flush();
	}
	oncommit(C) {
		_classPrivateFieldGet2(_commit_callbacks, this).add(C);
	}
	ondiscard(C) {
		_classPrivateFieldGet2(_discard_callbacks, this).add(C);
	}
	settled() {
		var C;
		return ((C = _classPrivateFieldGet2(_deferred, this)) == null ? _classPrivateFieldSet2(_deferred, this, deferred$1()) : C).promise;
	}
	static ensure() {
		if (current_batch === null) {
			let C = current_batch = new T();
			batches.add(current_batch), is_flushing_sync || T.enqueue(() => {
				current_batch === C && C.flush();
			});
		}
		return current_batch;
	}
	static enqueue(C) {
		queue_micro_task(C);
	}
	apply() {}
};
function _traverse_effect_tree(C, T) {
	C.f ^= CLEAN;
	for (var E = C.first; E !== null;) {
		var D, O = E.f, F = (O & 96) != 0, I = F && (O & 1024) != 0 || (O & 8192) != 0 || this.skipped_effects.has(E);
		if (E.f & 128 && (D = E.b) != null && D.is_pending() && (T = {
			parent: T,
			effect: E,
			effects: [],
			render_effects: [],
			block_effects: []
		}), !I && E.fn !== null) {
			F ? E.f ^= CLEAN : O & 4 ? T.effects.push(E) : is_dirty(E) && (E.f & 16 && T.block_effects.push(E), update_effect(E));
			var L = E.first;
			if (L !== null) {
				E = L;
				continue;
			}
		}
		var z = E.parent;
		for (E = E.next; E === null && z !== null;) z === T.effect && (_assertClassBrand(_Batch_brand, this, _defer_effects).call(this, T.effects), _assertClassBrand(_Batch_brand, this, _defer_effects).call(this, T.render_effects), _assertClassBrand(_Batch_brand, this, _defer_effects).call(this, T.block_effects), T = T.parent), E = z.next, z = z.parent;
	}
}
function _defer_effects(C) {
	for (let T of C) (T.f & 2048 ? _classPrivateFieldGet2(_dirty_effects, this) : _classPrivateFieldGet2(_maybe_dirty_effects, this)).push(T), set_signal_status(T, CLEAN);
}
function _resolve() {
	if (_classPrivateFieldGet2(_blocking_pending, this) === 0) {
		for (let C of _classPrivateFieldGet2(_commit_callbacks, this)) C();
		_classPrivateFieldGet2(_commit_callbacks, this).clear();
	}
	_classPrivateFieldGet2(_pending$1, this) === 0 && _assertClassBrand(_Batch_brand, this, _commit$1).call(this);
}
function _commit$1() {
	if (batches.size > 1) {
		this.previous.clear();
		var C = batch_values, T = !0, E = {
			parent: null,
			effect: null,
			effects: [],
			render_effects: [],
			block_effects: []
		};
		for (let C of batches) {
			if (C === this) {
				T = !1;
				continue;
			}
			let D = [];
			for (let [E, O] of this.current) {
				if (C.current.has(E)) if (T && O !== C.current.get(E)) C.current.set(E, O);
				else continue;
				D.push(E);
			}
			if (D.length === 0) continue;
			let O = [...C.current.keys()].filter((C) => !this.current.has(C));
			if (O.length > 0) {
				let T = /* @__PURE__ */ new Set(), F = /* @__PURE__ */ new Map();
				for (let C of D) mark_effects(C, O, T, F);
				if (queued_root_effects.length > 0) {
					current_batch = C, C.apply();
					for (let T of queued_root_effects) _assertClassBrand(_Batch_brand, C, _traverse_effect_tree).call(C, T, E);
					queued_root_effects = [], C.deactivate();
				}
			}
		}
		current_batch = null, batch_values = C;
	}
	this.committed = !0, batches.delete(this);
}
function flushSync(C) {
	var T = is_flushing_sync;
	is_flushing_sync = !0;
	try {
		var E;
		for (C && (current_batch !== null && flush_effects(), E = C());;) {
			if (flush_tasks(), queued_root_effects.length === 0 && (current_batch == null || current_batch.flush(), queued_root_effects.length === 0)) return last_scheduled_effect = null, E;
			flush_effects();
		}
	} finally {
		is_flushing_sync = T;
	}
}
function flush_effects() {
	var C = is_updating_effect;
	is_flushing = !0;
	try {
		var T = 0;
		for (set_is_updating_effect(!0); queued_root_effects.length > 0;) {
			var E = Batch.ensure();
			T++ > 1e3 && infinite_loop_guard(), E.process(queued_root_effects), old_values.clear();
		}
	} finally {
		is_flushing = !1, set_is_updating_effect(C), last_scheduled_effect = null;
	}
}
function infinite_loop_guard() {
	try {
		effect_update_depth_exceeded();
	} catch (C) {
		invoke_error_boundary(C, last_scheduled_effect);
	}
}
let eager_block_effects = null;
function flush_queued_effects(C) {
	var T = C.length;
	if (T !== 0) {
		for (var E = 0; E < T;) {
			var D = C[E++];
			if (!(D.f & 24576) && is_dirty(D) && (eager_block_effects = /* @__PURE__ */ new Set(), update_effect(D), D.deps === null && D.first === null && D.nodes_start === null && (D.teardown === null && D.ac === null ? unlink_effect(D) : D.fn = null), (eager_block_effects == null ? void 0 : eager_block_effects.size) > 0)) {
				old_values.clear();
				for (let C of eager_block_effects) {
					if (C.f & 24576) continue;
					let T = [C], E = C.parent;
					for (; E !== null;) eager_block_effects.has(E) && (eager_block_effects.delete(E), T.push(E)), E = E.parent;
					for (let C = T.length - 1; C >= 0; C--) {
						let E = T[C];
						E.f & 24576 || update_effect(E);
					}
				}
				eager_block_effects.clear();
			}
		}
		eager_block_effects = null;
	}
}
function mark_effects(C, T, E, D) {
	if (!E.has(C) && (E.add(C), C.reactions !== null)) for (let O of C.reactions) {
		let C = O.f;
		C & 2 ? mark_effects(O, T, E, D) : C & 4194320 && !(C & 2048) && depends_on(O, T, D) && (set_signal_status(O, DIRTY), schedule_effect(O));
	}
}
function depends_on(C, T, E) {
	let D = E.get(C);
	if (D !== void 0) return D;
	if (C.deps !== null) for (let D of C.deps) {
		if (T.includes(D)) return !0;
		if (D.f & 2 && depends_on(D, T, E)) return E.set(D, !0), !0;
	}
	return E.set(C, !1), !1;
}
function schedule_effect(C) {
	for (var T = last_scheduled_effect = C; T.parent !== null;) {
		T = T.parent;
		var E = T.f;
		if (is_flushing && T === active_effect && E & 16 && !(E & 262144)) return;
		if (E & 96) {
			if (!(E & 1024)) return;
			T.f ^= CLEAN;
		}
	}
	queued_root_effects.push(T);
}
function createSubscriber(C) {
	let T = 0, E = source(0), D;
	return () => {
		effect_tracking() && (get(E), render_effect(() => (T === 0 && (D = untrack(() => C(() => increment(E)))), T += 1, () => {
			queue_micro_task(() => {
				--T, T === 0 && (D == null || D(), D = void 0, increment(E));
			});
		})));
	};
}
var flags = EFFECT_PRESERVED | 65664;
function boundary(C, T, E) {
	new Boundary(C, T, E);
}
var _pending = /* @__PURE__ */ new WeakMap(), _anchor = /* @__PURE__ */ new WeakMap(), _hydrate_open = /* @__PURE__ */ new WeakMap(), _props$1 = /* @__PURE__ */ new WeakMap(), _children = /* @__PURE__ */ new WeakMap(), _effect = /* @__PURE__ */ new WeakMap(), _main_effect = /* @__PURE__ */ new WeakMap(), _pending_effect = /* @__PURE__ */ new WeakMap(), _failed_effect = /* @__PURE__ */ new WeakMap(), _offscreen_fragment = /* @__PURE__ */ new WeakMap(), _pending_anchor = /* @__PURE__ */ new WeakMap(), _local_pending_count = /* @__PURE__ */ new WeakMap(), _pending_count = /* @__PURE__ */ new WeakMap(), _is_creating_fallback = /* @__PURE__ */ new WeakMap(), _effect_pending = /* @__PURE__ */ new WeakMap(), _effect_pending_subscriber = /* @__PURE__ */ new WeakMap(), _Boundary_brand = /* @__PURE__ */ new WeakSet(), Boundary = class {
	constructor(T, E, D) {
		_classPrivateMethodInitSpec(this, _Boundary_brand), _defineProperty(this, "parent", void 0), _classPrivateFieldInitSpec(this, _pending, !1), _classPrivateFieldInitSpec(this, _anchor, void 0), _classPrivateFieldInitSpec(this, _hydrate_open, hydrating ? hydrate_node : null), _classPrivateFieldInitSpec(this, _props$1, void 0), _classPrivateFieldInitSpec(this, _children, void 0), _classPrivateFieldInitSpec(this, _effect, void 0), _classPrivateFieldInitSpec(this, _main_effect, null), _classPrivateFieldInitSpec(this, _pending_effect, null), _classPrivateFieldInitSpec(this, _failed_effect, null), _classPrivateFieldInitSpec(this, _offscreen_fragment, null), _classPrivateFieldInitSpec(this, _pending_anchor, null), _classPrivateFieldInitSpec(this, _local_pending_count, 0), _classPrivateFieldInitSpec(this, _pending_count, 0), _classPrivateFieldInitSpec(this, _is_creating_fallback, !1), _classPrivateFieldInitSpec(this, _effect_pending, null), _classPrivateFieldInitSpec(this, _effect_pending_subscriber, createSubscriber(() => (_classPrivateFieldSet2(_effect_pending, this, source(_classPrivateFieldGet2(_local_pending_count, this))), () => {
			_classPrivateFieldSet2(_effect_pending, this, null);
		}))), _classPrivateFieldSet2(_anchor, this, T), _classPrivateFieldSet2(_props$1, this, E), _classPrivateFieldSet2(_children, this, D), this.parent = active_effect.b, _classPrivateFieldSet2(_pending, this, !!_classPrivateFieldGet2(_props$1, this).pending), _classPrivateFieldSet2(_effect, this, block(() => {
			if (active_effect.b = this, hydrating) {
				let C = _classPrivateFieldGet2(_hydrate_open, this);
				hydrate_next(), C.nodeType === 8 && C.data === "[!" ? _assertClassBrand(_Boundary_brand, this, _hydrate_pending_content).call(this) : _assertClassBrand(_Boundary_brand, this, _hydrate_resolved_content).call(this);
			} else {
				var C = _assertClassBrand(_Boundary_brand, this, _get_anchor).call(this);
				try {
					_classPrivateFieldSet2(_main_effect, this, branch(() => D(C)));
				} catch (C) {
					this.error(C);
				}
				_classPrivateFieldGet2(_pending_count, this) > 0 ? _assertClassBrand(_Boundary_brand, this, _show_pending_snippet).call(this) : _classPrivateFieldSet2(_pending, this, !1);
			}
			return () => {
				var C;
				(C = _classPrivateFieldGet2(_pending_anchor, this)) == null || C.remove();
			};
		}, flags)), hydrating && _classPrivateFieldSet2(_anchor, this, hydrate_node);
	}
	is_pending() {
		return _classPrivateFieldGet2(_pending, this) || !!this.parent && this.parent.is_pending();
	}
	has_pending_snippet() {
		return !!_classPrivateFieldGet2(_props$1, this).pending;
	}
	update_pending_count(C) {
		_assertClassBrand(_Boundary_brand, this, _update_pending_count).call(this, C), _classPrivateFieldSet2(_local_pending_count, this, _classPrivateFieldGet2(_local_pending_count, this) + C), _classPrivateFieldGet2(_effect_pending, this) && internal_set(_classPrivateFieldGet2(_effect_pending, this), _classPrivateFieldGet2(_local_pending_count, this));
	}
	get_effect_pending() {
		return _classPrivateFieldGet2(_effect_pending_subscriber, this).call(this), get(_classPrivateFieldGet2(_effect_pending, this));
	}
	error(C) {
		var T = _classPrivateFieldGet2(_props$1, this).onerror;
		let E = _classPrivateFieldGet2(_props$1, this).failed;
		if (_classPrivateFieldGet2(_is_creating_fallback, this) || !T && !E) throw C;
		_classPrivateFieldGet2(_main_effect, this) && (destroy_effect(_classPrivateFieldGet2(_main_effect, this)), _classPrivateFieldSet2(_main_effect, this, null)), _classPrivateFieldGet2(_pending_effect, this) && (destroy_effect(_classPrivateFieldGet2(_pending_effect, this)), _classPrivateFieldSet2(_pending_effect, this, null)), _classPrivateFieldGet2(_failed_effect, this) && (destroy_effect(_classPrivateFieldGet2(_failed_effect, this)), _classPrivateFieldSet2(_failed_effect, this, null)), hydrating && (set_hydrate_node(_classPrivateFieldGet2(_hydrate_open, this)), next(), set_hydrate_node(skip_nodes()));
		var D = !1, O = !1;
		let F = () => {
			if (D) {
				svelte_boundary_reset_noop();
				return;
			}
			D = !0, O && svelte_boundary_reset_onerror(), Batch.ensure(), _classPrivateFieldSet2(_local_pending_count, this, 0), _classPrivateFieldGet2(_failed_effect, this) !== null && pause_effect(_classPrivateFieldGet2(_failed_effect, this), () => {
				_classPrivateFieldSet2(_failed_effect, this, null);
			}), _classPrivateFieldSet2(_pending, this, this.has_pending_snippet()), _classPrivateFieldSet2(_main_effect, this, _assertClassBrand(_Boundary_brand, this, _run).call(this, () => (_classPrivateFieldSet2(_is_creating_fallback, this, !1), branch(() => _classPrivateFieldGet2(_children, this).call(this, _classPrivateFieldGet2(_anchor, this)))))), _classPrivateFieldGet2(_pending_count, this) > 0 ? _assertClassBrand(_Boundary_brand, this, _show_pending_snippet).call(this) : _classPrivateFieldSet2(_pending, this, !1);
		};
		var I = active_reaction;
		try {
			set_active_reaction(null), O = !0, T == null || T(C, F), O = !1;
		} catch (C) {
			invoke_error_boundary(C, _classPrivateFieldGet2(_effect, this) && _classPrivateFieldGet2(_effect, this).parent);
		} finally {
			set_active_reaction(I);
		}
		E && queue_micro_task(() => {
			_classPrivateFieldSet2(_failed_effect, this, _assertClassBrand(_Boundary_brand, this, _run).call(this, () => {
				Batch.ensure(), _classPrivateFieldSet2(_is_creating_fallback, this, !0);
				try {
					return branch(() => {
						E(_classPrivateFieldGet2(_anchor, this), () => C, () => F);
					});
				} catch (C) {
					return invoke_error_boundary(C, _classPrivateFieldGet2(_effect, this).parent), null;
				} finally {
					_classPrivateFieldSet2(_is_creating_fallback, this, !1);
				}
			}));
		});
	}
};
function _hydrate_resolved_content() {
	try {
		_classPrivateFieldSet2(_main_effect, this, branch(() => _classPrivateFieldGet2(_children, this).call(this, _classPrivateFieldGet2(_anchor, this))));
	} catch (C) {
		this.error(C);
	}
	_classPrivateFieldSet2(_pending, this, !1);
}
function _hydrate_pending_content() {
	let C = _classPrivateFieldGet2(_props$1, this).pending;
	C && (_classPrivateFieldSet2(_pending_effect, this, branch(() => C(_classPrivateFieldGet2(_anchor, this)))), Batch.enqueue(() => {
		var C = _assertClassBrand(_Boundary_brand, this, _get_anchor).call(this);
		_classPrivateFieldSet2(_main_effect, this, _assertClassBrand(_Boundary_brand, this, _run).call(this, () => (Batch.ensure(), branch(() => _classPrivateFieldGet2(_children, this).call(this, C))))), _classPrivateFieldGet2(_pending_count, this) > 0 ? _assertClassBrand(_Boundary_brand, this, _show_pending_snippet).call(this) : (pause_effect(_classPrivateFieldGet2(_pending_effect, this), () => {
			_classPrivateFieldSet2(_pending_effect, this, null);
		}), _classPrivateFieldSet2(_pending, this, !1));
	}));
}
function _get_anchor() {
	var C = _classPrivateFieldGet2(_anchor, this);
	return _classPrivateFieldGet2(_pending, this) && (_classPrivateFieldSet2(_pending_anchor, this, create_text()), _classPrivateFieldGet2(_anchor, this).before(_classPrivateFieldGet2(_pending_anchor, this)), C = _classPrivateFieldGet2(_pending_anchor, this)), C;
}
function _run(C) {
	var T = active_effect, E = active_reaction, D = component_context;
	set_active_effect(_classPrivateFieldGet2(_effect, this)), set_active_reaction(_classPrivateFieldGet2(_effect, this)), set_component_context(_classPrivateFieldGet2(_effect, this).ctx);
	try {
		return C();
	} catch (C) {
		return handle_error(C), null;
	} finally {
		set_active_effect(T), set_active_reaction(E), set_component_context(D);
	}
}
function _show_pending_snippet() {
	let C = _classPrivateFieldGet2(_props$1, this).pending;
	_classPrivateFieldGet2(_main_effect, this) !== null && (_classPrivateFieldSet2(_offscreen_fragment, this, document.createDocumentFragment()), _classPrivateFieldGet2(_offscreen_fragment, this).append(_classPrivateFieldGet2(_pending_anchor, this)), move_effect(_classPrivateFieldGet2(_main_effect, this), _classPrivateFieldGet2(_offscreen_fragment, this))), _classPrivateFieldGet2(_pending_effect, this) === null && _classPrivateFieldSet2(_pending_effect, this, branch(() => C(_classPrivateFieldGet2(_anchor, this))));
}
function _update_pending_count(C) {
	if (!this.has_pending_snippet()) {
		if (this.parent) {
			var T;
			_assertClassBrand(_Boundary_brand, T = this.parent, _update_pending_count).call(T, C);
		}
		return;
	}
	_classPrivateFieldSet2(_pending_count, this, _classPrivateFieldGet2(_pending_count, this) + C), _classPrivateFieldGet2(_pending_count, this) === 0 && (_classPrivateFieldSet2(_pending, this, !1), _classPrivateFieldGet2(_pending_effect, this) && pause_effect(_classPrivateFieldGet2(_pending_effect, this), () => {
		_classPrivateFieldSet2(_pending_effect, this, null);
	}), _classPrivateFieldGet2(_offscreen_fragment, this) && (_classPrivateFieldGet2(_anchor, this).before(_classPrivateFieldGet2(_offscreen_fragment, this)), _classPrivateFieldSet2(_offscreen_fragment, this, null)));
}
function _OverloadYield(C, T) {
	this.v = C, this.k = T;
}
function AsyncGenerator(C) {
	var T, E;
	function D(T, E) {
		try {
			var F = C[T](E), I = F.value, L = I instanceof _OverloadYield;
			Promise.resolve(L ? I.v : I).then(function(E) {
				if (L) {
					var z = T === "return" ? "return" : "next";
					if (!I.k || E.done) return D(z, E);
					E = C[z](E).value;
				}
				O(F.done ? "return" : "normal", E);
			}, function(C) {
				D("throw", C);
			});
		} catch (C) {
			O("throw", C);
		}
	}
	function O(C, O) {
		switch (C) {
			case "return":
				T.resolve({
					value: O,
					done: !0
				});
				break;
			case "throw":
				T.reject(O);
				break;
			default: T.resolve({
				value: O,
				done: !1
			});
		}
		(T = T.next) ? D(T.key, T.arg) : E = null;
	}
	this._invoke = function(C, O) {
		return new Promise(function(F, I) {
			var L = {
				key: C,
				arg: O,
				resolve: F,
				reject: I,
				next: null
			};
			E ? E = E.next = L : (T = E = L, D(C, O));
		});
	}, typeof C.return != "function" && (this.return = void 0);
}
AsyncGenerator.prototype[typeof Symbol == "function" && Symbol.asyncIterator || "@@asyncIterator"] = function() {
	return this;
}, AsyncGenerator.prototype.next = function(C) {
	return this._invoke("next", C);
}, AsyncGenerator.prototype.throw = function(C) {
	return this._invoke("throw", C);
}, AsyncGenerator.prototype.return = function(C) {
	return this._invoke("return", C);
};
function flatten(C, T, E, D) {
	let O = is_runes() ? derived$1 : derived_safe_equal;
	if (E.length === 0 && C.length === 0) {
		D(T.map(O));
		return;
	}
	var F = current_batch, I = active_effect, L = capture();
	function z() {
		Promise.all(E.map((C) => /* @__PURE__ */ async_derived(C))).then((C) => {
			L();
			try {
				D([...T.map(O), ...C]);
			} catch (C) {
				I.f & 16384 || invoke_error_boundary(C, I);
			}
			F == null || F.deactivate(), unset_context();
		}).catch((C) => {
			invoke_error_boundary(C, I);
		});
	}
	C.length > 0 ? Promise.all(C).then(() => {
		L();
		try {
			return z();
		} finally {
			F == null || F.deactivate(), unset_context();
		}
	}) : z();
}
function capture() {
	var C = active_effect, T = active_reaction, E = component_context, D = current_batch;
	return function(O = !0) {
		set_active_effect(C), set_active_reaction(T), set_component_context(E), O && (D == null || D.activate());
	};
}
function unset_context() {
	set_active_effect(null), set_active_reaction(null), set_component_context(null);
}
/* @__NO_SIDE_EFFECTS__ */
function derived$1(C) {
	var T = 2 | DIRTY, E = active_reaction !== null && active_reaction.f & 2 ? active_reaction : null;
	return active_effect !== null && (active_effect.f |= EFFECT_PRESERVED), {
		ctx: component_context,
		deps: null,
		effects: null,
		equals,
		f: T,
		fn: C,
		reactions: null,
		rv: 0,
		v: UNINITIALIZED,
		wv: 0,
		parent: E == null ? active_effect : E,
		ac: null
	};
}
/* @__NO_SIDE_EFFECTS__ */
function async_derived(C, T) {
	let E = active_effect;
	E === null && async_derived_orphan();
	var D = E.b, O = void 0, F = source(UNINITIALIZED), I = !active_reaction, z = /* @__PURE__ */ new Map();
	return async_effect(() => {
		var T = deferred$1();
		O = T.promise;
		try {
			Promise.resolve(C()).then(T.resolve, T.reject).then(() => {
				E === current_batch && E.committed && E.deactivate(), unset_context();
			});
		} catch (C) {
			T.reject(C), unset_context();
		}
		var E = current_batch;
		if (I) {
			var L, B = !D.is_pending();
			D.update_pending_count(1), E.increment(B), (L = z.get(E)) == null || L.reject(STALE_REACTION), z.delete(E), z.set(E, T);
		}
		let V = (C, T = void 0) => {
			if (E.activate(), T) T !== STALE_REACTION && (F.f |= ERROR_VALUE, internal_set(F, T));
			else {
				F.f & 8388608 && (F.f ^= ERROR_VALUE), internal_set(F, C);
				for (let [C, T] of z) {
					if (z.delete(C), C === E) break;
					T.reject(STALE_REACTION);
				}
			}
			I && (D.update_pending_count(-1), E.decrement(B));
		};
		T.promise.then(V, (C) => V(null, C || "unknown"));
	}), teardown(() => {
		for (let C of z.values()) C.reject(STALE_REACTION);
	}), new Promise((C) => {
		function T(E) {
			function D() {
				E === O ? C(F) : T(O);
			}
			E.then(D, D);
		}
		T(O);
	});
}
/* @__NO_SIDE_EFFECTS__ */
function user_derived(C) {
	let T = /* @__PURE__ */ derived$1(C);
	return push_reaction_value(T), T;
}
/* @__NO_SIDE_EFFECTS__ */
function derived_safe_equal(C) {
	let T = /* @__PURE__ */ derived$1(C);
	return T.equals = safe_equals, T;
}
function destroy_derived_effects(C) {
	var T = C.effects;
	if (T !== null) {
		C.effects = null;
		for (var E = 0; E < T.length; E += 1) destroy_effect(T[E]);
	}
}
function get_derived_parent_effect(C) {
	for (var T = C.parent; T !== null;) {
		if (!(T.f & 2)) return T;
		T = T.parent;
	}
	return null;
}
function execute_derived(C) {
	var T, E = active_effect;
	set_active_effect(get_derived_parent_effect(C));
	try {
		C.f &= ~WAS_MARKED, destroy_derived_effects(C), T = update_reaction(C);
	} finally {
		set_active_effect(E);
	}
	return T;
}
function update_derived(C) {
	var T = execute_derived(C);
	C.equals(T) || (C.v = T, C.wv = increment_write_version()), !is_destroying_effect && (batch_values === null ? set_signal_status(C, C.f & 512 ? CLEAN : MAYBE_DIRTY) : effect_tracking() && batch_values.set(C, C.v));
}
let eager_effects = /* @__PURE__ */ new Set();
const old_values = /* @__PURE__ */ new Map();
var eager_effects_deferred = !1;
function source(C, T) {
	return {
		f: 0,
		v: C,
		reactions: null,
		equals,
		rv: 0,
		wv: 0
	};
}
/* @__NO_SIDE_EFFECTS__ */
function state(C, T) {
	let E = source(C, T);
	return push_reaction_value(E), E;
}
/* @__NO_SIDE_EFFECTS__ */
function mutable_source(C, T = !1, E = !0) {
	let D = source(C);
	if (T || (D.equals = safe_equals), legacy_mode_flag && E && component_context !== null && component_context.l !== null) {
		var O, F;
		((F = (O = component_context.l).s) == null ? O.s = [] : F).push(D);
	}
	return D;
}
function mutate(C, T) {
	return set(C, untrack(() => get(C))), T;
}
function set(C, T, E = !1) {
	return active_reaction !== null && (!untracking || active_reaction.f & 131072) && is_runes() && active_reaction.f & 4325394 && !(current_sources != null && current_sources.includes(C)) && state_unsafe_mutation(), internal_set(C, E ? proxy(T) : T);
}
function internal_set(C, T) {
	if (!C.equals(T)) {
		var E = C.v;
		is_destroying_effect ? old_values.set(C, T) : old_values.set(C, E), C.v = T;
		var D = Batch.ensure();
		D.capture(C, E), C.f & 2 && (C.f & 2048 && execute_derived(C), set_signal_status(C, C.f & 512 ? CLEAN : MAYBE_DIRTY)), C.wv = increment_write_version(), mark_reactions(C, DIRTY), is_runes() && active_effect !== null && active_effect.f & 1024 && !(active_effect.f & 96) && (untracked_writes === null ? set_untracked_writes([C]) : untracked_writes.push(C)), !D.is_fork && eager_effects.size > 0 && !eager_effects_deferred && flush_eager_effects();
	}
	return T;
}
function flush_eager_effects() {
	eager_effects_deferred = !1;
	let C = Array.from(eager_effects);
	for (let T of C) T.f & 1024 && set_signal_status(T, MAYBE_DIRTY), is_dirty(T) && update_effect(T);
	eager_effects.clear();
}
function update(C, T = 1) {
	var E = get(C), D = T === 1 ? E++ : E--;
	return set(C, E), D;
}
function increment(C) {
	set(C, C.v + 1);
}
function mark_reactions(C, T) {
	var E = C.reactions;
	if (E !== null) for (var D = is_runes(), O = E.length, F = 0; F < O; F++) {
		var I = E[F], L = I.f;
		if (!(!D && I === active_effect)) {
			var z = (L & DIRTY) === 0;
			if (z && set_signal_status(I, T), L & 2) {
				var B = I;
				batch_values == null || batch_values.delete(B), L & 32768 || (L & 512 && (I.f |= WAS_MARKED), mark_reactions(B, MAYBE_DIRTY));
			} else z && (L & 16 && eager_block_effects !== null && eager_block_effects.add(I), schedule_effect(I));
		}
	}
}
function proxy(C) {
	if (typeof C != "object" || !C || STATE_SYMBOL in C) return C;
	let T = get_prototype_of(C);
	if (T !== object_prototype && T !== array_prototype) return C;
	var E = /* @__PURE__ */ new Map(), D = is_array(C), O = /* @__PURE__ */ state(0), F = null, I = update_version, B = (C) => {
		if (update_version === I) return C();
		var T = active_reaction, E = update_version;
		set_active_reaction(null), set_update_version(I);
		var D = C();
		return set_active_reaction(T), set_update_version(E), D;
	};
	return D && E.set("length", /* @__PURE__ */ state(C.length, F)), new Proxy(C, {
		defineProperty(C, T, D) {
			(!("value" in D) || D.configurable === !1 || D.enumerable === !1 || D.writable === !1) && state_descriptors_fixed();
			var O = E.get(T);
			return O === void 0 ? O = B(() => {
				var C = /* @__PURE__ */ state(D.value, F);
				return E.set(T, C), C;
			}) : set(O, D.value, !0), !0;
		},
		deleteProperty(C, T) {
			var D = E.get(T);
			if (D === void 0) {
				if (T in C) {
					let C = B(() => /* @__PURE__ */ state(UNINITIALIZED, F));
					E.set(T, C), increment(O);
				}
			} else set(D, UNINITIALIZED), increment(O);
			return !0;
		},
		get(T, D, O) {
			var I;
			if (D === STATE_SYMBOL) return C;
			var z = E.get(D), V = D in T;
			if (z === void 0 && (!V || (I = get_descriptor(T, D)) != null && I.writable) && (z = B(() => /* @__PURE__ */ state(proxy(V ? T[D] : UNINITIALIZED), F)), E.set(D, z)), z !== void 0) {
				var U = get(z);
				return U === UNINITIALIZED ? void 0 : U;
			}
			return Reflect.get(T, D, O);
		},
		getOwnPropertyDescriptor(C, T) {
			var D = Reflect.getOwnPropertyDescriptor(C, T);
			if (D && "value" in D) {
				var O = E.get(T);
				O && (D.value = get(O));
			} else if (D === void 0) {
				var F = E.get(T), I = F == null ? void 0 : F.v;
				if (F !== void 0 && I !== UNINITIALIZED) return {
					enumerable: !0,
					configurable: !0,
					value: I,
					writable: !0
				};
			}
			return D;
		},
		has(C, T) {
			var D;
			if (T === STATE_SYMBOL) return !0;
			var O = E.get(T), I = O !== void 0 && O.v !== UNINITIALIZED || Reflect.has(C, T);
			return (O !== void 0 || active_effect !== null && (!I || (D = get_descriptor(C, T)) != null && D.writable)) && (O === void 0 && (O = B(() => /* @__PURE__ */ state(I ? proxy(C[T]) : UNINITIALIZED, F)), E.set(T, O)), get(O) === UNINITIALIZED) ? !1 : I;
		},
		set(C, T, I, z) {
			var V = E.get(T), U = T in C;
			if (D && T === "length") for (var W = I; W < V.v; W += 1) {
				var K = E.get(W + "");
				K === void 0 ? W in C && (K = B(() => /* @__PURE__ */ state(UNINITIALIZED, F)), E.set(W + "", K)) : set(K, UNINITIALIZED);
			}
			if (V === void 0) {
				var J;
				(!U || (J = get_descriptor(C, T)) != null && J.writable) && (V = B(() => /* @__PURE__ */ state(void 0, F)), set(V, proxy(I)), E.set(T, V));
			} else {
				U = V.v !== UNINITIALIZED;
				var Y = B(() => proxy(I));
				set(V, Y);
			}
			var X = Reflect.getOwnPropertyDescriptor(C, T);
			if (X != null && X.set && X.set.call(z, I), !U) {
				if (D && typeof T == "string") {
					var Z = E.get("length"), Q = Number(T);
					Number.isInteger(Q) && Q >= Z.v && set(Z, Q + 1);
				}
				increment(O);
			}
			return !0;
		},
		ownKeys(C) {
			get(O);
			var T = Reflect.ownKeys(C).filter((C) => {
				var T = E.get(C);
				return T === void 0 || T.v !== UNINITIALIZED;
			});
			for (var [D, F] of E) F.v !== UNINITIALIZED && !(D in C) && T.push(D);
			return T;
		},
		setPrototypeOf() {
			state_prototype_fixed();
		}
	});
}
function get_proxied_value(C) {
	try {
		if (typeof C == "object" && C && STATE_SYMBOL in C) return C[STATE_SYMBOL];
	} catch (C) {}
	return C;
}
function is(C, T) {
	return Object.is(get_proxied_value(C), get_proxied_value(T));
}
var $window, is_firefox, first_child_getter, next_sibling_getter;
function init_operations() {
	if ($window === void 0) {
		$window = window, document, is_firefox = /Firefox/.test(navigator.userAgent);
		var C = Element.prototype, T = Node.prototype, E = Text.prototype;
		first_child_getter = get_descriptor(T, "firstChild").get, next_sibling_getter = get_descriptor(T, "nextSibling").get, is_extensible(C) && (C.__click = void 0, C.__className = void 0, C.__attributes = null, C.__style = void 0, C.__e = void 0), is_extensible(E) && (E.__t = void 0);
	}
}
function create_text(C = "") {
	return document.createTextNode(C);
}
/* @__NO_SIDE_EFFECTS__ */
function get_first_child(C) {
	return first_child_getter.call(C);
}
/* @__NO_SIDE_EFFECTS__ */
function get_next_sibling(C) {
	return next_sibling_getter.call(C);
}
function child(C, T) {
	if (!hydrating) return /* @__PURE__ */ get_first_child(C);
	var E = /* @__PURE__ */ get_first_child(hydrate_node);
	if (E === null) E = hydrate_node.appendChild(create_text());
	else if (T && E.nodeType !== 3) {
		var D = create_text();
		return E == null || E.before(D), set_hydrate_node(D), D;
	}
	return set_hydrate_node(E), E;
}
function first_child(C, T = !1) {
	if (!hydrating) {
		var E = /* @__PURE__ */ get_first_child(C);
		return E instanceof Comment && E.data === "" ? /* @__PURE__ */ get_next_sibling(E) : E;
	}
	if (T && (hydrate_node == null ? void 0 : hydrate_node.nodeType) !== 3) {
		var D = create_text();
		return hydrate_node == null || hydrate_node.before(D), set_hydrate_node(D), D;
	}
	return hydrate_node;
}
function sibling(C, T = 1, E = !1) {
	let D = hydrating ? hydrate_node : C;
	for (var O; T--;) O = D, D = /* @__PURE__ */ get_next_sibling(D);
	if (!hydrating) return D;
	if (E && (D == null ? void 0 : D.nodeType) !== 3) {
		var F = create_text();
		return D === null ? O == null || O.after(F) : D.before(F), set_hydrate_node(F), F;
	}
	return set_hydrate_node(D), D;
}
function clear_text_content(C) {
	C.textContent = "";
}
function should_defer_append() {
	return !1;
}
function autofocus(C, T) {
	if (T) {
		let T = document.body;
		C.autofocus = !0, queue_micro_task(() => {
			document.activeElement === T && C.focus();
		});
	}
}
function remove_textarea_child(C) {
	hydrating && /* @__PURE__ */ get_first_child(C) !== null && clear_text_content(C);
}
var listening_to_form_reset = !1;
function add_form_reset_listener() {
	listening_to_form_reset || (listening_to_form_reset = !0, document.addEventListener("reset", (C) => {
		Promise.resolve().then(() => {
			if (!C.defaultPrevented) for (let E of C.target.elements) {
				var T;
				(T = E.__on_r) == null || T.call(E);
			}
		});
	}, { capture: !0 }));
}
function listen(C, T, E, D = !0) {
	D && E();
	for (var O of T) C.addEventListener(O, E);
	teardown(() => {
		for (var D of T) C.removeEventListener(D, E);
	});
}
function without_reactive_context(C) {
	var T = active_reaction, E = active_effect;
	set_active_reaction(null), set_active_effect(null);
	try {
		return C();
	} finally {
		set_active_reaction(T), set_active_effect(E);
	}
}
function listen_to_event_and_reset_event(C, T, E, D = E) {
	C.addEventListener(T, () => without_reactive_context(E));
	let O = C.__on_r;
	O ? C.__on_r = () => {
		O(), D(!0);
	} : C.__on_r = () => D(!0), add_form_reset_listener();
}
function validate_effect(C) {
	active_effect === null && (active_reaction === null && effect_orphan(C), effect_in_unowned_derived()), is_destroying_effect && effect_in_teardown(C);
}
function push_effect(C, T) {
	var E = T.last;
	E === null ? T.last = T.first = C : (E.next = C, C.prev = E, T.last = C);
}
function create_effect(C, T, E, D = !0) {
	var O = active_effect;
	O !== null && O.f & 8192 && (C |= INERT);
	var F = {
		ctx: component_context,
		deps: null,
		nodes_start: null,
		nodes_end: null,
		f: C | 2560,
		first: null,
		fn: T,
		last: null,
		next: null,
		parent: O,
		b: O && O.b,
		prev: null,
		teardown: null,
		transitions: null,
		wv: 0,
		ac: null
	};
	if (E) try {
		update_effect(F), F.f |= 32768;
	} catch (C) {
		throw destroy_effect(F), C;
	}
	else T !== null && schedule_effect(F);
	if (D) {
		var I = F;
		if (E && I.deps === null && I.teardown === null && I.nodes_start === null && I.first === I.last && !(I.f & 524288) && (I = I.first, C & 16 && C & 65536 && I !== null && (I.f |= EFFECT_TRANSPARENT)), I !== null && (I.parent = O, O !== null && push_effect(I, O), active_reaction !== null && active_reaction.f & 2 && !(C & 64))) {
			var L, z = active_reaction;
			((L = z.effects) == null ? z.effects = [] : L).push(I);
		}
	}
	return F;
}
function effect_tracking() {
	return active_reaction !== null && !untracking;
}
function teardown(C) {
	let T = create_effect(8, null, !1);
	return set_signal_status(T, CLEAN), T.teardown = C, T;
}
function user_effect(C) {
	validate_effect("$effect");
	var T = active_effect.f;
	if (!active_reaction && T & 32 && !(T & 32768)) {
		var E, D = component_context;
		((E = D.e) == null ? D.e = [] : E).push(C);
	} else return create_user_effect(C);
}
function create_user_effect(C) {
	return create_effect(4 | USER_EFFECT, C, !1);
}
function user_pre_effect(C) {
	return validate_effect("$effect.pre"), create_effect(8 | USER_EFFECT, C, !0);
}
function effect_root(C) {
	Batch.ensure();
	let T = create_effect(64 | EFFECT_PRESERVED, C, !0);
	return () => {
		destroy_effect(T);
	};
}
function component_root(C) {
	Batch.ensure();
	let T = create_effect(64 | EFFECT_PRESERVED, C, !0);
	return (C = {}) => new Promise((E) => {
		C.outro ? pause_effect(T, () => {
			destroy_effect(T), E(void 0);
		}) : (destroy_effect(T), E(void 0));
	});
}
function effect(C) {
	return create_effect(4, C, !1);
}
function async_effect(C) {
	return create_effect(4194304 | EFFECT_PRESERVED, C, !0);
}
function render_effect(C, T = 0) {
	return create_effect(8 | T, C, !0);
}
function template_effect(C, T = [], E = [], D = [], O = !1) {
	flatten(D, T, E, (T) => {
		create_effect(O ? 4 : 8, () => C(...T.map(get)), !0);
	});
}
function block(C, T = 0) {
	return create_effect(16 | T, C, !0);
}
function branch(C, T = !0) {
	return create_effect(32 | EFFECT_PRESERVED, C, !0, T);
}
function execute_effect_teardown(C) {
	var T = C.teardown;
	if (T !== null) {
		let C = is_destroying_effect, E = active_reaction;
		set_is_destroying_effect(!0), set_active_reaction(null);
		try {
			T.call(null);
		} finally {
			set_is_destroying_effect(C), set_active_reaction(E);
		}
	}
}
function destroy_effect_children(C, T = !1) {
	var E = C.first;
	for (C.first = C.last = null; E !== null;) {
		let C = E.ac;
		C !== null && without_reactive_context(() => {
			C.abort(STALE_REACTION);
		});
		var D = E.next;
		E.f & 64 ? E.parent = null : destroy_effect(E, T), E = D;
	}
}
function destroy_block_effect_children(C) {
	for (var T = C.first; T !== null;) {
		var E = T.next;
		T.f & 32 || destroy_effect(T), T = E;
	}
}
function destroy_effect(C, T = !0) {
	var E = !1;
	(T || C.f & 262144) && C.nodes_start !== null && C.nodes_end !== null && (remove_effect_dom(C.nodes_start, C.nodes_end), E = !0), destroy_effect_children(C, T && !E), remove_reactions(C, 0), set_signal_status(C, 16384);
	var D = C.transitions;
	if (D !== null) for (let C of D) C.stop();
	execute_effect_teardown(C);
	var O = C.parent;
	O !== null && O.first !== null && unlink_effect(C), C.next = C.prev = C.teardown = C.ctx = C.deps = C.fn = C.nodes_start = C.nodes_end = C.ac = null;
}
function remove_effect_dom(C, T) {
	for (; C !== null;) {
		var E = C === T ? null : /* @__PURE__ */ get_next_sibling(C);
		C.remove(), C = E;
	}
}
function unlink_effect(C) {
	var T = C.parent, E = C.prev, D = C.next;
	E !== null && (E.next = D), D !== null && (D.prev = E), T !== null && (T.first === C && (T.first = D), T.last === C && (T.last = E));
}
function pause_effect(C, T, E = !0) {
	var D = [];
	pause_children(C, D, !0), run_out_transitions(D, () => {
		E && destroy_effect(C), T && T();
	});
}
function run_out_transitions(C, T) {
	var E = C.length;
	if (E > 0) {
		var D = () => --E || T();
		for (var O of C) O.out(D);
	} else T();
}
function pause_children(C, T, E) {
	if (!(C.f & 8192)) {
		if (C.f ^= INERT, C.transitions !== null) for (let D of C.transitions) (D.is_global || E) && T.push(D);
		for (var D = C.first; D !== null;) {
			var O = D.next, F = (D.f & 65536) != 0 || (D.f & 32) != 0 && (C.f & 16) != 0;
			pause_children(D, T, F ? E : !1), D = O;
		}
	}
}
function resume_effect(C) {
	resume_children(C, !0);
}
function resume_children(C, T) {
	if (C.f & 8192) {
		C.f ^= INERT, C.f & 1024 || (set_signal_status(C, DIRTY), schedule_effect(C));
		for (var E = C.first; E !== null;) {
			var D = E.next, O = (E.f & 65536) != 0 || (E.f & 32) != 0;
			resume_children(E, O ? T : !1), E = D;
		}
		if (C.transitions !== null) for (let E of C.transitions) (E.is_global || T) && E.in();
	}
}
function move_effect(C, T) {
	for (var E = C.nodes_start, D = C.nodes_end; E !== null;) {
		var O = E === D ? null : /* @__PURE__ */ get_next_sibling(E);
		T.append(E), E = O;
	}
}
let is_updating_effect = !1;
function set_is_updating_effect(C) {
	is_updating_effect = C;
}
let is_destroying_effect = !1;
function set_is_destroying_effect(C) {
	is_destroying_effect = C;
}
let active_reaction = null, untracking = !1;
function set_active_reaction(C) {
	active_reaction = C;
}
let active_effect = null;
function set_active_effect(C) {
	active_effect = C;
}
let current_sources = null;
function push_reaction_value(C) {
	active_reaction !== null && (current_sources === null ? current_sources = [C] : current_sources.push(C));
}
var new_deps = null, skipped_deps = 0;
let untracked_writes = null;
function set_untracked_writes(C) {
	untracked_writes = C;
}
let write_version = 1;
var read_version = 0;
let update_version = read_version;
function set_update_version(C) {
	update_version = C;
}
function increment_write_version() {
	return ++write_version;
}
function is_dirty(C) {
	var T = C.f;
	if (T & 2048) return !0;
	if (T & 2 && (C.f &= ~WAS_MARKED), T & 4096) {
		var E = C.deps;
		if (E !== null) for (var D = E.length, O = 0; O < D; O++) {
			var F = E[O];
			if (is_dirty(F) && update_derived(F), F.wv > C.wv) return !0;
		}
		T & 512 && batch_values === null && set_signal_status(C, CLEAN);
	}
	return !1;
}
function schedule_possible_effect_self_invalidation(C, T, E = !0) {
	var D = C.reactions;
	if (D !== null && !(current_sources != null && current_sources.includes(C))) for (var O = 0; O < D.length; O++) {
		var F = D[O];
		F.f & 2 ? schedule_possible_effect_self_invalidation(F, T, !1) : T === F && (E ? set_signal_status(F, DIRTY) : F.f & 1024 && set_signal_status(F, MAYBE_DIRTY), schedule_effect(F));
	}
}
function update_reaction(C) {
	var T = new_deps, E = skipped_deps, D = untracked_writes, O = active_reaction, F = current_sources, I = component_context, L = untracking, z = update_version, B = C.f;
	new_deps = null, skipped_deps = 0, untracked_writes = null, active_reaction = B & 96 ? null : C, current_sources = null, set_component_context(C.ctx), untracking = !1, update_version = ++read_version, C.ac !== null && (without_reactive_context(() => {
		C.ac.abort(STALE_REACTION);
	}), C.ac = null);
	try {
		C.f |= REACTION_IS_UPDATING;
		var V = C.fn, U = V(), W = C.deps;
		if (new_deps !== null) {
			var G;
			if (remove_reactions(C, skipped_deps), W !== null && skipped_deps > 0) for (W.length = skipped_deps + new_deps.length, G = 0; G < new_deps.length; G++) W[skipped_deps + G] = new_deps[G];
			else C.deps = W = new_deps;
			if (is_updating_effect && effect_tracking() && C.f & 512) for (G = skipped_deps; G < W.length; G++) {
				var K, J;
				((J = (K = W[G]).reactions) == null ? K.reactions = [] : J).push(C);
			}
		} else W !== null && skipped_deps < W.length && (remove_reactions(C, skipped_deps), W.length = skipped_deps);
		if (is_runes() && untracked_writes !== null && !untracking && W !== null && !(C.f & 6146)) for (G = 0; G < untracked_writes.length; G++) schedule_possible_effect_self_invalidation(untracked_writes[G], C);
		return O !== null && O !== C && (read_version++, untracked_writes !== null && (D === null ? D = untracked_writes : D.push(...untracked_writes))), C.f & 8388608 && (C.f ^= ERROR_VALUE), U;
	} catch (C) {
		return handle_error(C);
	} finally {
		C.f ^= REACTION_IS_UPDATING, new_deps = T, skipped_deps = E, untracked_writes = D, active_reaction = O, current_sources = F, set_component_context(I), untracking = L, update_version = z;
	}
}
function remove_reaction(C, T) {
	let E = T.reactions;
	if (E !== null) {
		var D = index_of.call(E, C);
		if (D !== -1) {
			var O = E.length - 1;
			O === 0 ? E = T.reactions = null : (E[D] = E[O], E.pop());
		}
	}
	E === null && T.f & 2 && (new_deps === null || !new_deps.includes(T)) && (set_signal_status(T, MAYBE_DIRTY), T.f & 512 && (T.f ^= 512, T.f &= ~WAS_MARKED), destroy_derived_effects(T), remove_reactions(T, 0));
}
function remove_reactions(C, T) {
	var E = C.deps;
	if (E !== null) for (var D = T; D < E.length; D++) remove_reaction(C, E[D]);
}
function update_effect(C) {
	var T = C.f;
	if (!(T & 16384)) {
		set_signal_status(C, CLEAN);
		var E = active_effect, D = is_updating_effect;
		active_effect = C, is_updating_effect = !0;
		try {
			T & 16 ? destroy_block_effect_children(C) : destroy_effect_children(C), execute_effect_teardown(C);
			var O = update_reaction(C);
			C.teardown = typeof O == "function" ? O : null, C.wv = write_version;
		} finally {
			is_updating_effect = D, active_effect = E;
		}
	}
}
function tick() {
	return _tick.apply(this, arguments);
}
function _tick() {
	return _tick = _asyncToGenerator(function* () {
		yield Promise.resolve(), flushSync();
	}), _tick.apply(this, arguments);
}
function get(C) {
	var T = (C.f & 2) != 0;
	if (active_reaction !== null && !untracking && !(active_effect !== null && active_effect.f & 16384) && !(current_sources != null && current_sources.includes(C))) {
		var E = active_reaction.deps;
		if (active_reaction.f & 2097152) C.rv < read_version && (C.rv = read_version, new_deps === null && E !== null && E[skipped_deps] === C ? skipped_deps++ : new_deps === null ? new_deps = [C] : new_deps.includes(C) || new_deps.push(C));
		else {
			var D, O;
			((O = (D = active_reaction).deps) == null ? D.deps = [] : O).push(C);
			var F = C.reactions;
			F === null ? C.reactions = [active_reaction] : F.includes(active_reaction) || F.push(active_reaction);
		}
	}
	if (is_destroying_effect) {
		if (old_values.has(C)) return old_values.get(C);
		if (T) {
			var I = C, L = I.v;
			return (!(I.f & 1024) && I.reactions !== null || depends_on_old_values(I)) && (L = execute_derived(I)), old_values.set(I, L), L;
		}
	} else if (T) {
		if (I = C, batch_values != null && batch_values.has(I)) return batch_values.get(I);
		is_dirty(I) && update_derived(I), is_updating_effect && effect_tracking() && !(I.f & 512) && reconnect(I);
	} else if (batch_values != null && batch_values.has(C)) return batch_values.get(C);
	if (C.f & 8388608) throw C.v;
	return C.v;
}
function reconnect(C) {
	if (C.deps !== null) {
		C.f ^= 512;
		for (let E of C.deps) {
			var T;
			((T = E.reactions) == null ? E.reactions = [] : T).push(C), E.f & 2 && !(E.f & 512) && reconnect(E);
		}
	}
}
function depends_on_old_values(C) {
	if (C.v === UNINITIALIZED) return !0;
	if (C.deps === null) return !1;
	for (let T of C.deps) if (old_values.has(T) || T.f & 2 && depends_on_old_values(T)) return !0;
	return !1;
}
function untrack(C) {
	var T = untracking;
	try {
		return untracking = !0, C();
	} finally {
		untracking = T;
	}
}
var STATUS_MASK = ~(MAYBE_DIRTY | 3072);
function set_signal_status(C, T) {
	C.f = C.f & STATUS_MASK | T;
}
function exclude_from_object(C, T) {
	var E = {};
	for (var D in C) T.includes(D) || (E[D] = C[D]);
	for (var O of Object.getOwnPropertySymbols(C)) Object.propertyIsEnumerable.call(C, O) && !T.includes(O) && (E[O] = C[O]);
	return E;
}
function deep_read_state(C) {
	if (!(typeof C != "object" || !C || C instanceof EventTarget)) {
		if (STATE_SYMBOL in C) deep_read(C);
		else if (!Array.isArray(C)) for (let T in C) {
			let E = C[T];
			typeof E == "object" && E && STATE_SYMBOL in E && deep_read(E);
		}
	}
}
function deep_read(C, T = /* @__PURE__ */ new Set()) {
	if (typeof C == "object" && C && !(C instanceof EventTarget) && !T.has(C)) {
		for (let E in T.add(C), C instanceof Date && C.getTime(), C) try {
			deep_read(C[E], T);
		} catch (C) {}
		let E = get_prototype_of(C);
		if (E !== Object.prototype && E !== Array.prototype && E !== Map.prototype && E !== Set.prototype && E !== Date.prototype) {
			let T = get_descriptors(E);
			for (let E in T) {
				let D = T[E].get;
				if (D) try {
					D.call(C);
				} catch (C) {}
			}
		}
	}
}
const all_registered_events = /* @__PURE__ */ new Set(), root_event_handles = /* @__PURE__ */ new Set();
function replay_events(C) {
	if (!hydrating) return;
	C.removeAttribute("onload"), C.removeAttribute("onerror");
	let T = C.__e;
	T !== void 0 && (C.__e = void 0, queueMicrotask(() => {
		C.isConnected && C.dispatchEvent(T);
	}));
}
function create_event(C, T, E, D = {}) {
	function O(C) {
		if (D.capture || handle_event_propagation.call(T, C), !C.cancelBubble) return without_reactive_context(() => E == null ? void 0 : E.call(this, C));
	}
	return C.startsWith("pointer") || C.startsWith("touch") || C === "wheel" ? queue_micro_task(() => {
		T.addEventListener(C, O, D);
	}) : T.addEventListener(C, O, D), O;
}
function event(C, T, E, D, O) {
	var F = {
		capture: D,
		passive: O
	}, I = create_event(C, T, E, F);
	(T === document.body || T === window || T === document || T instanceof HTMLMediaElement) && teardown(() => {
		T.removeEventListener(C, I, F);
	});
}
function delegate(C) {
	for (var T = 0; T < C.length; T++) all_registered_events.add(C[T]);
	for (var E of root_event_handles) E(C);
}
var last_propagated_event = null;
function handle_event_propagation(C) {
	var T, E = this, D = E.ownerDocument, O = C.type, F = ((T = C.composedPath) == null ? void 0 : T.call(C)) || [], I = F[0] || C.target;
	last_propagated_event = C;
	var L = 0, z = last_propagated_event === C && C.__root;
	if (z) {
		var B = F.indexOf(z);
		if (B !== -1 && (E === document || E === window)) {
			C.__root = E;
			return;
		}
		var V = F.indexOf(E);
		if (V === -1) return;
		B <= V && (L = B);
	}
	if (I = F[L] || C.target, I !== E) {
		define_property(C, "currentTarget", {
			configurable: !0,
			get() {
				return I || D;
			}
		});
		var U = active_reaction, G = active_effect;
		set_active_reaction(null), set_active_effect(null);
		try {
			for (var K, J = []; I !== null;) {
				var Y = I.assignedSlot || I.parentNode || I.host || null;
				try {
					var X = I["__" + O];
					X != null && (!I.disabled || C.target === I) && X.call(I, C);
				} catch (C) {
					K ? J.push(C) : K = C;
				}
				if (C.cancelBubble || Y === E || Y === null) break;
				I = Y;
			}
			if (K) {
				for (let C of J) queueMicrotask(() => {
					throw C;
				});
				throw K;
			}
		} finally {
			C.__root = E, delete C.currentTarget, set_active_reaction(U), set_active_effect(G);
		}
	}
}
function create_fragment_from_html(C) {
	var T = document.createElement("template");
	return T.innerHTML = C.replaceAll("<!>", "<!---->"), T.content;
}
function assign_nodes(C, T) {
	var E = active_effect;
	E.nodes_start === null && (E.nodes_start = C, E.nodes_end = T);
}
/* @__NO_SIDE_EFFECTS__ */
function from_html(C, T) {
	var E = (T & 1) != 0, D = (T & 2) != 0, O, F = !C.startsWith("<!>");
	return () => {
		if (hydrating) return assign_nodes(hydrate_node, null), hydrate_node;
		O === void 0 && (O = create_fragment_from_html(F ? C : "<!>" + C), E || (O = /* @__PURE__ */ get_first_child(O)));
		var T = D || is_firefox ? document.importNode(O, !0) : O.cloneNode(!0);
		if (E) {
			var I = /* @__PURE__ */ get_first_child(T), L = T.lastChild;
			assign_nodes(I, L);
		} else assign_nodes(T, T);
		return T;
	};
}
/* @__NO_SIDE_EFFECTS__ */
function from_namespace(C, T, E = "svg") {
	var D = !C.startsWith("<!>"), O = (T & 1) != 0, F = `<${E}>${D ? C : "<!>" + C}</${E}>`, I;
	return () => {
		if (hydrating) return assign_nodes(hydrate_node, null), hydrate_node;
		if (!I) {
			var C = /* @__PURE__ */ get_first_child(create_fragment_from_html(F));
			if (O) for (I = document.createDocumentFragment(); /* @__PURE__ */ get_first_child(C);) I.appendChild(/* @__PURE__ */ get_first_child(C));
			else I = /* @__PURE__ */ get_first_child(C);
		}
		var T = I.cloneNode(!0);
		if (O) {
			var E = /* @__PURE__ */ get_first_child(T), D = T.lastChild;
			assign_nodes(E, D);
		} else assign_nodes(T, T);
		return T;
	};
}
/* @__NO_SIDE_EFFECTS__ */
function from_svg(C, T) {
	return /* @__PURE__ */ from_namespace(C, T, "svg");
}
function with_script(C) {
	return () => run_scripts(C());
}
function run_scripts(C) {
	if (hydrating) return C;
	let T = C.nodeType === 11, E = C.tagName === "SCRIPT" ? [C] : C.querySelectorAll("script"), D = active_effect;
	for (let F of E) {
		let E = document.createElement("script");
		for (var O of F.attributes) E.setAttribute(O.name, O.value);
		E.textContent = F.textContent, (T ? C.firstChild === F : C === F) && (D.nodes_start = E), (T ? C.lastChild === F : C === F) && (D.nodes_end = E), F.replaceWith(E);
	}
	return C;
}
function text(C = "") {
	if (!hydrating) {
		var T = create_text(C + "");
		return assign_nodes(T, T), T;
	}
	var E = hydrate_node;
	return E.nodeType !== 3 && (E.before(E = create_text()), set_hydrate_node(E)), assign_nodes(E, E), E;
}
function comment() {
	if (hydrating) return assign_nodes(hydrate_node, null), hydrate_node;
	var C = document.createDocumentFragment(), T = document.createComment(""), E = create_text();
	return C.append(T, E), assign_nodes(T, E), C;
}
function append(C, T) {
	if (hydrating) {
		var E = active_effect;
		(!(E.f & 32768) || E.nodes_end === null) && (E.nodes_end = hydrate_node), hydrate_next();
		return;
	}
	C !== null && C.before(T);
}
function is_capture_event(C) {
	return C.endsWith("capture") && C !== "gotpointercapture" && C !== "lostpointercapture";
}
var DELEGATED_EVENTS = [
	"beforeinput",
	"click",
	"change",
	"dblclick",
	"contextmenu",
	"focusin",
	"focusout",
	"input",
	"keydown",
	"keyup",
	"mousedown",
	"mousemove",
	"mouseout",
	"mouseover",
	"mouseup",
	"pointerdown",
	"pointermove",
	"pointerout",
	"pointerover",
	"pointerup",
	"touchend",
	"touchmove",
	"touchstart"
];
function can_delegate_event(C) {
	return DELEGATED_EVENTS.includes(C);
}
var DOM_BOOLEAN_ATTRIBUTES = /* @__PURE__ */ "allowfullscreen.async.autofocus.autoplay.checked.controls.default.disabled.formnovalidate.indeterminate.inert.ismap.loop.multiple.muted.nomodule.novalidate.open.playsinline.readonly.required.reversed.seamless.selected.webkitdirectory.defer.disablepictureinpicture.disableremoteplayback".split("."), ATTRIBUTE_ALIASES = {
	formnovalidate: "formNoValidate",
	ismap: "isMap",
	nomodule: "noModule",
	playsinline: "playsInline",
	readonly: "readOnly",
	defaultvalue: "defaultValue",
	defaultchecked: "defaultChecked",
	srcobject: "srcObject",
	novalidate: "noValidate",
	allowfullscreen: "allowFullscreen",
	disablepictureinpicture: "disablePictureInPicture",
	disableremoteplayback: "disableRemotePlayback"
};
function normalize_attribute(C) {
	var T;
	return C = C.toLowerCase(), (T = ATTRIBUTE_ALIASES[C]) == null ? C : T;
}
[...DOM_BOOLEAN_ATTRIBUTES];
var PASSIVE_EVENTS = ["touchstart", "touchmove"];
function is_passive_event(C) {
	return PASSIVE_EVENTS.includes(C);
}
var RAW_TEXT_ELEMENTS = [
	"textarea",
	"script",
	"style",
	"title"
];
function is_raw_text_element(C) {
	return RAW_TEXT_ELEMENTS.includes(C);
}
let should_intro = !0;
function set_should_intro(C) {
	should_intro = C;
}
function set_text(C, T) {
	var E, D = T == null ? "" : typeof T == "object" ? T + "" : T;
	D !== ((E = C.__t) == null ? C.__t = C.nodeValue : E) && (C.__t = D, C.nodeValue = D + "");
}
function mount(C, T) {
	return _mount(C, T);
}
function hydrate(C, E) {
	var D;
	init_operations(), E.intro = (D = E.intro) == null ? !1 : D;
	let O = E.target, F = hydrating, L = hydrate_node;
	try {
		for (var z = /* @__PURE__ */ get_first_child(O); z && (z.nodeType !== 8 || z.data !== "[");) z = /* @__PURE__ */ get_next_sibling(z);
		if (!z) throw HYDRATION_ERROR;
		set_hydrating(!0), set_hydrate_node(z);
		let D = _mount(C, _objectSpread2(_objectSpread2({}, E), {}, { anchor: z }));
		return set_hydrating(!1), D;
	} catch (T) {
		if (T instanceof Error && T.message.split("\n").some((C) => C.startsWith("https://svelte.dev/e/"))) throw T;
		return T !== HYDRATION_ERROR && console.warn("Failed to hydrate: ", T), E.recover === !1 && hydration_failed(), init_operations(), clear_text_content(O), set_hydrating(!1), mount(C, E);
	} finally {
		set_hydrating(F), set_hydrate_node(L);
	}
}
var document_listeners = /* @__PURE__ */ new Map();
function _mount(C, { target: T, anchor: E, props: D = {}, events: O, context: F, intro: L = !0 }) {
	init_operations();
	var z = /* @__PURE__ */ new Set(), B = (C) => {
		for (var E = 0; E < C.length; E++) {
			var D = C[E];
			if (!z.has(D)) {
				z.add(D);
				var O = is_passive_event(D);
				T.addEventListener(D, handle_event_propagation, { passive: O });
				var F = document_listeners.get(D);
				F === void 0 ? (document.addEventListener(D, handle_event_propagation, { passive: O }), document_listeners.set(D, 1)) : document_listeners.set(D, F + 1);
			}
		}
	};
	B(array_from(all_registered_events)), root_event_handles.add(B);
	var U = void 0, W = component_root(() => {
		var V = E == null ? T.appendChild(create_text()) : E;
		return boundary(V, { pending: () => {} }, (T) => {
			if (F) {
				push({});
				var E = component_context;
				E.c = F;
			}
			if (O && (D.$$events = O), hydrating && assign_nodes(T, null), should_intro = L, U = C(T, D) || {}, should_intro = !0, hydrating && (active_effect.nodes_end = hydrate_node, hydrate_node === null || hydrate_node.nodeType !== 8 || hydrate_node.data !== "]")) throw hydration_mismatch(), HYDRATION_ERROR;
			F && pop();
		}), () => {
			for (var C of z) {
				T.removeEventListener(C, handle_event_propagation);
				var D = document_listeners.get(C);
				--D === 0 ? (document.removeEventListener(C, handle_event_propagation), document_listeners.delete(C)) : document_listeners.set(C, D);
			}
			if (root_event_handles.delete(B), V !== E) {
				var O;
				(O = V.parentNode) == null || O.removeChild(V);
			}
		};
	});
	return mounted_components.set(U, W), U;
}
var mounted_components = /* @__PURE__ */ new WeakMap();
function unmount(C, T) {
	let E = mounted_components.get(C);
	return E ? (mounted_components.delete(C), E(T)) : Promise.resolve();
}
var _batches = /* @__PURE__ */ new WeakMap(), _onscreen = /* @__PURE__ */ new WeakMap(), _offscreen = /* @__PURE__ */ new WeakMap(), _transition = /* @__PURE__ */ new WeakMap(), _commit = /* @__PURE__ */ new WeakMap(), _discard = /* @__PURE__ */ new WeakMap(), BranchManager = class {
	constructor(T, E = !0) {
		_defineProperty(this, "anchor", void 0), _classPrivateFieldInitSpec(this, _batches, /* @__PURE__ */ new Map()), _classPrivateFieldInitSpec(this, _onscreen, /* @__PURE__ */ new Map()), _classPrivateFieldInitSpec(this, _offscreen, /* @__PURE__ */ new Map()), _classPrivateFieldInitSpec(this, _transition, !0), _classPrivateFieldInitSpec(this, _commit, () => {
			var C = current_batch;
			if (_classPrivateFieldGet2(_batches, this).has(C)) {
				var T = _classPrivateFieldGet2(_batches, this).get(C), E = _classPrivateFieldGet2(_onscreen, this).get(T);
				if (E) resume_effect(E);
				else {
					var D = _classPrivateFieldGet2(_offscreen, this).get(T);
					D && (_classPrivateFieldGet2(_onscreen, this).set(T, D.effect), _classPrivateFieldGet2(_offscreen, this).delete(T), D.fragment.lastChild.remove(), this.anchor.before(D.fragment), E = D.effect);
				}
				for (let [T, E] of _classPrivateFieldGet2(_batches, this)) {
					if (_classPrivateFieldGet2(_batches, this).delete(T), T === C) break;
					let D = _classPrivateFieldGet2(_offscreen, this).get(E);
					D && (destroy_effect(D.effect), _classPrivateFieldGet2(_offscreen, this).delete(E));
				}
				for (let [C, D] of _classPrivateFieldGet2(_onscreen, this)) {
					if (C === T) continue;
					let O = () => {
						if (Array.from(_classPrivateFieldGet2(_batches, this).values()).includes(C)) {
							var T = document.createDocumentFragment();
							move_effect(D, T), T.append(create_text()), _classPrivateFieldGet2(_offscreen, this).set(C, {
								effect: D,
								fragment: T
							});
						} else destroy_effect(D);
						_classPrivateFieldGet2(_onscreen, this).delete(C);
					};
					_classPrivateFieldGet2(_transition, this) || !E ? pause_effect(D, O, !1) : O();
				}
			}
		}), _classPrivateFieldInitSpec(this, _discard, (C) => {
			_classPrivateFieldGet2(_batches, this).delete(C);
			let T = Array.from(_classPrivateFieldGet2(_batches, this).values());
			for (let [C, E] of _classPrivateFieldGet2(_offscreen, this)) T.includes(C) || (destroy_effect(E.effect), _classPrivateFieldGet2(_offscreen, this).delete(C));
		}), this.anchor = T, _classPrivateFieldSet2(_transition, this, E);
	}
	ensure(C, T) {
		var E = current_batch, D = should_defer_append();
		if (T && !_classPrivateFieldGet2(_onscreen, this).has(C) && !_classPrivateFieldGet2(_offscreen, this).has(C)) if (D) {
			var O = document.createDocumentFragment(), F = create_text();
			O.append(F), _classPrivateFieldGet2(_offscreen, this).set(C, {
				effect: branch(() => T(F)),
				fragment: O
			});
		} else _classPrivateFieldGet2(_onscreen, this).set(C, branch(() => T(this.anchor)));
		if (_classPrivateFieldGet2(_batches, this).set(E, C), D) {
			for (let [T, D] of _classPrivateFieldGet2(_onscreen, this)) T === C ? E.skipped_effects.delete(D) : E.skipped_effects.add(D);
			for (let [T, D] of _classPrivateFieldGet2(_offscreen, this)) T === C ? E.skipped_effects.delete(D.effect) : E.skipped_effects.add(D.effect);
			E.oncommit(_classPrivateFieldGet2(_commit, this)), E.ondiscard(_classPrivateFieldGet2(_discard, this));
		} else hydrating && (this.anchor = hydrate_node), _classPrivateFieldGet2(_commit, this).call(this);
	}
};
function snippet(C, T, ...E) {
	var D = new BranchManager(C);
	block(() => {
		var C;
		let O = (C = T()) == null ? null : C;
		D.ensure(O, O && ((C) => O(C, ...E)));
	}, EFFECT_TRANSPARENT);
}
function onMount(C) {
	component_context === null && lifecycle_outside_component("onMount"), legacy_mode_flag && component_context.l !== null ? init_update_callbacks(component_context).m.push(C) : user_effect(() => {
		let T = untrack(C);
		if (typeof T == "function") return T;
	});
}
function onDestroy(C) {
	component_context === null && lifecycle_outside_component("onDestroy"), onMount(() => () => untrack(C));
}
function init_update_callbacks(C) {
	var T, E = C.l;
	return (T = E.u) == null ? E.u = {
		a: [],
		b: [],
		m: []
	} : T;
}
function if_block(C, T, E = !1) {
	hydrating && hydrate_next();
	var D = new BranchManager(C), O = E ? EFFECT_TRANSPARENT : 0;
	function F(T, E) {
		if (hydrating && T === (read_hydration_instruction(C) === "[!")) {
			var O = skip_nodes();
			set_hydrate_node(O), D.anchor = O, set_hydrating(!1), D.ensure(T, E), set_hydrating(!0);
			return;
		}
		D.ensure(T, E);
	}
	block(() => {
		var C = !1;
		T((T, E = !0) => {
			C = !0, F(E, T);
		}), C || F(!1, null);
	}, O);
}
function key(C, T, E) {
	hydrating && hydrate_next();
	var D = new BranchManager(C), O = !is_runes();
	block(() => {
		var C = T();
		O && typeof C == "object" && C && (C = {}), D.ensure(C, E);
	});
}
let current_each_item = null;
function set_current_each_item(C) {
	current_each_item = C;
}
function index(C, T) {
	return T;
}
function pause_effects(C, T, E) {
	for (var D = C.items, O = [], F = T.length, I = 0; I < F; I++) pause_children(T[I].e, O, !0);
	var L = F > 0 && O.length === 0 && E !== null;
	if (L) {
		var z = E.parentNode;
		clear_text_content(z), z.append(E), D.clear(), link(C, T[0].prev, T[F - 1].next);
	}
	run_out_transitions(O, () => {
		for (var E = 0; E < F; E++) {
			var O = T[E];
			L || (D.delete(O.k), link(C, O.prev, O.next)), destroy_effect(O.e, !L);
		}
	});
}
function each(C, T, E, D, O, F = null) {
	var I = C, L = {
		flags: T,
		items: /* @__PURE__ */ new Map(),
		first: null
	};
	if (T & 4) {
		var B = C;
		I = hydrating ? set_hydrate_node(/* @__PURE__ */ get_first_child(B)) : B.appendChild(create_text());
	}
	hydrating && hydrate_next();
	var U = null, W = !1, G = /* @__PURE__ */ new Map(), K = /* @__PURE__ */ derived_safe_equal(() => {
		var C = E();
		return is_array(C) ? C : C == null ? [] : array_from(C);
	}), J, Y;
	function X() {
		reconcile(Y, J, L, G, I, O, T, D, E), F !== null && (J.length === 0 ? U ? resume_effect(U) : U = branch(() => F(I)) : U !== null && pause_effect(U, () => {
			U = null;
		}));
	}
	block(() => {
		Y != null || (Y = active_effect), J = get(K);
		var C = J.length;
		if (W && C === 0) return;
		W = C === 0;
		let z = !1;
		if (hydrating && read_hydration_instruction(I) === "[!" != (C === 0) && (I = skip_nodes(), set_hydrate_node(I), set_hydrating(!1), z = !0), hydrating) {
			for (var B = null, V, Z = 0; Z < C; Z++) {
				if (hydrate_node.nodeType === 8 && hydrate_node.data === "]") {
					I = hydrate_node, z = !0, set_hydrating(!1);
					break;
				}
				var Q = J[Z], NL = D(Q, Z);
				V = create_item(hydrate_node, L, B, null, Q, NL, Z, O, T, E), L.items.set(NL, V), B = V;
			}
			C > 0 && set_hydrate_node(skip_nodes());
		}
		if (hydrating) C === 0 && F && (U = branch(() => F(I)));
		else if (should_defer_append()) {
			var PL = /* @__PURE__ */ new Set(), FL = current_batch;
			for (Z = 0; Z < C; Z += 1) {
				var IL;
				Q = J[Z], NL = D(Q, Z);
				var LL = (IL = L.items.get(NL)) == null ? G.get(NL) : IL;
				LL ? T & 3 && update_item(LL, Q, Z, T) : (V = create_item(null, L, null, null, Q, NL, Z, O, T, E, !0), G.set(NL, V)), PL.add(NL);
			}
			for (let [C, T] of L.items) PL.has(C) || FL.skipped_effects.add(T.e);
			FL.oncommit(X);
		} else X();
		z && set_hydrating(!0), get(K);
	}), hydrating && (I = hydrate_node);
}
function reconcile(C, T, E, D, O, F, I, L, z) {
	var B = (I & 8) != 0, U = (I & 3) != 0, W = T.length, G = E.items, K = E.first, J, Y = null, X, Z = [], Q = [], NL, PL, FL, IL;
	if (B) {
		for (IL = 0; IL < W; IL += 1) if (NL = T[IL], PL = L(NL, IL), FL = G.get(PL), FL !== void 0) {
			var LL, RL;
			(LL = FL.a) == null || LL.measure(), ((RL = X) == null ? X = /* @__PURE__ */ new Set() : RL).add(FL);
		}
	}
	for (IL = 0; IL < W; IL += 1) {
		if (NL = T[IL], PL = L(NL, IL), FL = G.get(PL), FL === void 0) {
			var zL = D.get(PL);
			if (zL !== void 0) {
				D.delete(PL), G.set(PL, zL);
				var BL = Y ? Y.next : K;
				link(E, Y, zL), link(E, zL, BL), move(zL, BL, O), Y = zL;
			} else Y = create_item(K ? K.e.nodes_start : O, E, Y, Y === null ? E.first : Y.next, NL, PL, IL, F, I, z);
			G.set(PL, Y), Z = [], Q = [], K = Y.next;
			continue;
		}
		if (U && update_item(FL, NL, IL, I), FL.e.f & 8192 && (resume_effect(FL.e), B)) {
			var VL, HL;
			(VL = FL.a) == null || VL.unfix(), ((HL = X) == null ? X = /* @__PURE__ */ new Set() : HL).delete(FL);
		}
		if (FL !== K) {
			if (J !== void 0 && J.has(FL)) {
				if (Z.length < Q.length) {
					var UL = Q[0], WL;
					Y = UL.prev;
					var GL = Z[0], KL = Z[Z.length - 1];
					for (WL = 0; WL < Z.length; WL += 1) move(Z[WL], UL, O);
					for (WL = 0; WL < Q.length; WL += 1) J.delete(Q[WL]);
					link(E, GL.prev, KL.next), link(E, Y, GL), link(E, KL, UL), K = UL, Y = KL, --IL, Z = [], Q = [];
				} else J.delete(FL), move(FL, K, O), link(E, FL.prev, FL.next), link(E, FL, Y === null ? E.first : Y.next), link(E, Y, FL), Y = FL;
				continue;
			}
			for (Z = [], Q = []; K !== null && K.k !== PL;) {
				if (!(K.e.f & 8192)) {
					var qL;
					((qL = J) == null ? J = /* @__PURE__ */ new Set() : qL).add(K);
				}
				Q.push(K), K = K.next;
			}
			if (K === null) continue;
			FL = K;
		}
		Z.push(FL), Y = FL, K = FL.next;
	}
	if (K !== null || J !== void 0) {
		for (var JL = J === void 0 ? [] : array_from(J); K !== null;) K.e.f & 8192 || JL.push(K), K = K.next;
		var YL = JL.length;
		if (YL > 0) {
			var XL = I & 4 && W === 0 ? O : null;
			if (B) {
				for (IL = 0; IL < YL; IL += 1) {
					var ZL;
					(ZL = JL[IL].a) == null || ZL.measure();
				}
				for (IL = 0; IL < YL; IL += 1) {
					var QL;
					(QL = JL[IL].a) == null || QL.fix();
				}
			}
			pause_effects(E, JL, XL);
		}
	}
	B && queue_micro_task(() => {
		if (X !== void 0) for (FL of X) {
			var C;
			(C = FL.a) == null || C.apply();
		}
	}), C.first = E.first && E.first.e, C.last = Y && Y.e;
	for (var $L of D.values()) destroy_effect($L.e);
	D.clear();
}
function update_item(C, T, E, D) {
	D & 1 && internal_set(C.v, T), D & 2 ? internal_set(C.i, E) : C.i = E;
}
function create_item(C, T, E, D, O, F, I, L, z, B, V) {
	var U = current_each_item, W = (z & 1) != 0, G = (z & 16) == 0, K = W ? G ? /* @__PURE__ */ mutable_source(O, !1, !1) : source(O) : O, J = z & 2 ? source(I) : I, Y = {
		i: J,
		v: K,
		k: F,
		a: null,
		e: null,
		prev: E,
		next: D
	};
	current_each_item = Y;
	try {
		return C === null && document.createDocumentFragment().append(C = create_text()), Y.e = branch(() => L(C, K, J, B), hydrating), Y.e.prev = E && E.e, Y.e.next = D && D.e, E === null ? V || (T.first = Y) : (E.next = Y, E.e.next = Y.e), D !== null && (D.prev = Y, D.e.prev = Y.e), Y;
	} finally {
		current_each_item = U;
	}
}
function move(C, T, E) {
	for (var D = C.next ? C.next.e.nodes_start : E, O = T ? T.e.nodes_start : E, F = C.e.nodes_start; F !== null && F !== D;) {
		var I = /* @__PURE__ */ get_next_sibling(F);
		O.before(F), F = I;
	}
}
function link(C, T, E) {
	T === null ? C.first = E : (T.next = E, T.e.next = E && E.e), E !== null && (E.prev = T, E.e.prev = T && T.e);
}
function html(C, T, E = !1, D = !1, O = !1) {
	var F = C, L = "";
	template_effect(() => {
		var C, O = active_effect;
		if (L === (L = (C = T()) == null ? "" : C)) {
			hydrating && hydrate_next();
			return;
		}
		if (O.nodes_start !== null && (remove_effect_dom(O.nodes_start, O.nodes_end), O.nodes_start = O.nodes_end = null), L !== "") {
			if (hydrating) {
				for (var z = hydrate_node.data, B = hydrate_next(), V = B; B !== null && (B.nodeType !== 8 || B.data !== "");) V = B, B = /* @__PURE__ */ get_next_sibling(B);
				if (B === null) throw hydration_mismatch(), HYDRATION_ERROR;
				assign_nodes(hydrate_node, V), F = set_hydrate_node(B);
				return;
			}
			var U = L + "";
			E ? U = `<svg>${U}</svg>` : D && (U = `<math>${U}</math>`);
			var W = create_fragment_from_html(U);
			if ((E || D) && (W = /* @__PURE__ */ get_first_child(W)), assign_nodes(/* @__PURE__ */ get_first_child(W), W.lastChild), E || D) for (; /* @__PURE__ */ get_first_child(W);) F.before(/* @__PURE__ */ get_first_child(W));
			else F.before(W);
		}
	});
}
function slot(C, T, E, D, O) {
	var F;
	hydrating && hydrate_next();
	var I = (F = T.$$slots) == null ? void 0 : F[E], L = !1;
	I === !0 && (I = T[E === "default" ? "children" : E], L = !0), I === void 0 ? O !== null && O(C) : I(C, L ? () => D : D);
}
function component(C, T, E) {
	hydrating && hydrate_next();
	var D = new BranchManager(C);
	block(() => {
		var C, O = (C = T()) == null ? null : C;
		D.ensure(O, O && ((C) => E(C, O)));
	}, EFFECT_TRANSPARENT);
}
function element(C, T, E, D, O, F) {
	let I = hydrating;
	hydrating && hydrate_next();
	var L = null;
	hydrating && hydrate_node.nodeType === 1 && (L = hydrate_node, hydrate_next());
	var z = hydrating ? hydrate_node : C, B = current_each_item, V = new BranchManager(z, !1);
	block(() => {
		let C = T() || null;
		var F = O ? O() : E || C === "svg" ? "http://www.w3.org/2000/svg" : null;
		if (C === null) {
			V.ensure(null, null), set_should_intro(!0);
			return;
		}
		return V.ensure(C, (T) => {
			var E = current_each_item;
			if (set_current_each_item(B), C) {
				if (L = hydrating ? L : F ? document.createElementNS(F, C) : document.createElement(C), assign_nodes(L, L), D) {
					hydrating && is_raw_text_element(C) && L.append(document.createComment(""));
					var O = hydrating ? /* @__PURE__ */ get_first_child(L) : L.appendChild(create_text());
					hydrating && (O === null ? set_hydrating(!1) : set_hydrate_node(O)), D(L, O);
				}
				active_effect.nodes_end = L, T.before(L);
			}
			set_current_each_item(E), hydrating && set_hydrate_node(T);
		}), set_should_intro(!0), () => {
			C && set_should_intro(!1);
		};
	}, EFFECT_TRANSPARENT), teardown(() => {
		set_should_intro(!0);
	}), I && (set_hydrating(!0), set_hydrate_node(z));
}
function head(C, T) {
	let E = null, D = hydrating;
	var O;
	if (hydrating) {
		E = hydrate_node;
		for (var F = /* @__PURE__ */ get_first_child(document.head); F !== null && (F.nodeType !== 8 || F.data !== C);) F = /* @__PURE__ */ get_next_sibling(F);
		if (F === null) set_hydrating(!1);
		else {
			var I = /* @__PURE__ */ get_next_sibling(F);
			F.remove(), set_hydrate_node(I);
		}
	}
	hydrating || (O = document.head.appendChild(create_text()));
	try {
		block(() => T(O), 262144);
	} finally {
		D && (set_hydrating(!0), set_hydrate_node(E));
	}
}
function append_styles(C, T) {
	effect(() => {
		var E, D = C.getRootNode(), O = D.host ? D : (E = D.head) == null ? D.ownerDocument.head : E;
		if (!O.querySelector("#" + T.hash)) {
			let C = document.createElement("style");
			C.id = T.hash, C.textContent = T.code, O.appendChild(C);
		}
	});
}
function action(C, T, E) {
	effect(() => {
		var D = untrack(() => T(C, E == null ? void 0 : E()) || {});
		if (E && D != null && D.update) {
			var O = !1, F = {};
			render_effect(() => {
				var C = E();
				deep_read_state(C), O && safe_not_equal(F, C) && (F = C, D.update(C));
			}), O = !0;
		}
		if (D != null && D.destroy) return () => D.destroy();
	});
}
function attach(C, T) {
	var E = void 0, D;
	block(() => {
		E !== (E = T()) && (D && (destroy_effect(D), D = null), E && (D = branch(() => {
			effect(() => E(C));
		})));
	});
}
function r$1(C) {
	var T, E, D = "";
	if (typeof C == "string" || typeof C == "number") D += C;
	else if (typeof C == "object") if (Array.isArray(C)) {
		var O = C.length;
		for (T = 0; T < O; T++) C[T] && (E = r$1(C[T])) && (D && (D += " "), D += E);
	} else for (E in C) C[E] && (D && (D += " "), D += E);
	return D;
}
function clsx() {
	for (var C, T, E = 0, D = "", O = arguments.length; E < O; E++) (C = arguments[E]) && (T = r$1(C)) && (D && (D += " "), D += T);
	return D;
}
var clsx_default = clsx;
function clsx$1(C) {
	return typeof C == "object" ? clsx(C) : C == null ? "" : C;
}
var whitespace = [..." 	\n\r\f\xA0\v"];
function to_class(C, T, E) {
	var D = C == null ? "" : "" + C;
	if (T && (D = D ? D + " " + T : T), E) {
		for (var O in E) if (E[O]) D = D ? D + " " + O : O;
		else if (D.length) for (var F = O.length, I = 0; (I = D.indexOf(O, I)) >= 0;) {
			var L = I + F;
			(I === 0 || whitespace.includes(D[I - 1])) && (L === D.length || whitespace.includes(D[L])) ? D = (I === 0 ? "" : D.substring(0, I)) + D.substring(L + 1) : I = L;
		}
	}
	return D === "" ? null : D;
}
function append_styles$1(C, T = !1) {
	var E = T ? " !important;" : ";", D = "";
	for (var O in C) {
		var F = C[O];
		F != null && F !== "" && (D += " " + O + ": " + F + E);
	}
	return D;
}
function to_css_name(C) {
	return C[0] !== "-" || C[1] !== "-" ? C.toLowerCase() : C;
}
function to_style(C, T) {
	if (T) {
		var E = "", D, O;
		if (Array.isArray(T) ? (D = T[0], O = T[1]) : D = T, C) {
			C = String(C).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
			var F = !1, I = 0, L = !1, z = [];
			D && z.push(...Object.keys(D).map(to_css_name)), O && z.push(...Object.keys(O).map(to_css_name));
			var B = 0, V = -1;
			let T = C.length;
			for (var U = 0; U < T; U++) {
				var W = C[U];
				if (L ? W === "/" && C[U - 1] === "*" && (L = !1) : F ? F === W && (F = !1) : W === "/" && C[U + 1] === "*" ? L = !0 : W === "\"" || W === "'" ? F = W : W === "(" ? I++ : W === ")" && I--, !L && F === !1 && I === 0) {
					if (W === ":" && V === -1) V = U;
					else if (W === ";" || U === T - 1) {
						if (V !== -1) {
							var G = to_css_name(C.substring(B, V).trim());
							if (!z.includes(G)) {
								W !== ";" && U++;
								var K = C.substring(B, U).trim();
								E += " " + K + ";";
							}
						}
						B = U + 1, V = -1;
					}
				}
			}
		}
		return D && (E += append_styles$1(D)), O && (E += append_styles$1(O, !0)), E = E.trim(), E === "" ? null : E;
	}
	return C == null ? null : String(C);
}
function set_class(C, T, E, D, O, F) {
	var I = C.__className;
	if (hydrating || I !== E || I === void 0) {
		var L = to_class(E, D, F);
		(!hydrating || L !== C.getAttribute("class")) && (L == null ? C.removeAttribute("class") : T ? C.className = L : C.setAttribute("class", L)), C.__className = E;
	} else if (F && O !== F) for (var z in F) {
		var B = !!F[z];
		(O == null || B !== !!O[z]) && C.classList.toggle(z, B);
	}
	return F;
}
function update_styles(C, T = {}, E, D) {
	for (var O in E) {
		var F = E[O];
		T[O] !== F && (E[O] == null ? C.style.removeProperty(O) : C.style.setProperty(O, F, D));
	}
}
function set_style(C, T, E, D) {
	var O = C.__style;
	if (hydrating || O !== T) {
		var F = to_style(T, D);
		(!hydrating || F !== C.getAttribute("style")) && (F == null ? C.removeAttribute("style") : C.style.cssText = F), C.__style = T;
	} else D && (Array.isArray(D) ? (update_styles(C, E == null ? void 0 : E[0], D[0]), update_styles(C, E == null ? void 0 : E[1], D[1], "important")) : update_styles(C, E, D));
	return D;
}
function select_option(C, T, E = !1) {
	if (C.multiple) {
		if (T == null) return;
		if (!is_array(T)) return select_multiple_invalid_value();
		for (var D of C.options) D.selected = T.includes(get_option_value(D));
		return;
	}
	for (D of C.options) if (is(get_option_value(D), T)) {
		D.selected = !0;
		return;
	}
	(!E || T !== void 0) && (C.selectedIndex = -1);
}
function init_select(C) {
	var T = new MutationObserver(() => {
		select_option(C, C.__value);
	});
	T.observe(C, {
		childList: !0,
		subtree: !0,
		attributes: !0,
		attributeFilter: ["value"]
	}), teardown(() => {
		T.disconnect();
	});
}
function bind_select_value(C, T, E = T) {
	var D = /* @__PURE__ */ new WeakSet(), O = !0;
	listen_to_event_and_reset_event(C, "change", (T) => {
		var O = T ? "[selected]" : ":checked", F;
		if (C.multiple) F = [].map.call(C.querySelectorAll(O), get_option_value);
		else {
			var I, L = (I = C.querySelector(O)) == null ? C.querySelector("option:not([disabled])") : I;
			F = L && get_option_value(L);
		}
		E(F), current_batch !== null && D.add(current_batch);
	}), effect(() => {
		var F = T();
		if (C === document.activeElement) {
			var I = previous_batch == null ? current_batch : previous_batch;
			if (D.has(I)) return;
		}
		if (select_option(C, F, O), O && F === void 0) {
			var L = C.querySelector(":checked");
			L !== null && (F = get_option_value(L), E(F));
		}
		C.__value = F, O = !1;
	}), init_select(C);
}
function get_option_value(C) {
	return "__value" in C ? C.__value : C.value;
}
const CLASS = Symbol("class"), STYLE = Symbol("style");
var IS_CUSTOM_ELEMENT = Symbol("is custom element"), IS_HTML = Symbol("is html");
function remove_input_defaults(C) {
	if (hydrating) {
		var T = !1, E = () => {
			if (!T) {
				if (T = !0, C.hasAttribute("value")) {
					var E = C.value;
					set_attribute(C, "value", null), C.value = E;
				}
				if (C.hasAttribute("checked")) {
					var D = C.checked;
					set_attribute(C, "checked", null), C.checked = D;
				}
			}
		};
		C.__on_r = E, queue_micro_task(E), add_form_reset_listener();
	}
}
function set_value(C, T) {
	var E = get_attributes(C);
	E.value === (E.value = T == null ? void 0 : T) || C.value === T && (T !== 0 || C.nodeName !== "PROGRESS") || (C.value = T == null ? "" : T);
}
function set_selected(C, T) {
	T ? C.hasAttribute("selected") || C.setAttribute("selected", "") : C.removeAttribute("selected");
}
function set_attribute(C, T, E, D) {
	var O = get_attributes(C);
	hydrating && (O[T] = C.getAttribute(T), T === "src" || T === "srcset" || T === "href" && C.nodeName === "LINK") || O[T] !== (O[T] = E) && (T === "loading" && (C[LOADING_ATTR_SYMBOL] = E), E == null ? C.removeAttribute(T) : typeof E != "string" && get_setters(C).includes(T) ? C[T] = E : C.setAttribute(T, E));
}
function set_custom_element_data(C, T, E) {
	var D = active_reaction, O = active_effect;
	let F = hydrating;
	hydrating && set_hydrating(!1), set_active_reaction(null), set_active_effect(null);
	try {
		T !== "style" && (setters_cache.has(C.getAttribute("is") || C.nodeName) || !customElements || customElements.get(C.getAttribute("is") || C.tagName.toLowerCase()) ? get_setters(C).includes(T) : E && typeof E == "object") ? C[T] = E : set_attribute(C, T, E == null ? E : String(E));
	} finally {
		set_active_reaction(D), set_active_effect(O), F && set_hydrating(!0);
	}
}
function set_attributes(C, T, E, D, O = !1, F = !1) {
	if (hydrating && O && C.tagName === "INPUT") {
		var I = C;
		(I.type === "checkbox" ? "defaultChecked" : "defaultValue") in E || remove_input_defaults(I);
	}
	var z = get_attributes(C), B = z[IS_CUSTOM_ELEMENT], V = !z[IS_HTML];
	let U = hydrating && B;
	U && set_hydrating(!1);
	var W = T || {}, G = C.tagName === "OPTION";
	for (var K in T) K in E || (E[K] = null);
	E.class ? E.class = clsx$1(E.class) : (D || E[CLASS]) && (E.class = null), E[STYLE] && (E.style != null || (E.style = null));
	var J = get_setters(C);
	for (let O in E) {
		let I = E[O];
		if (G && O === "value" && I == null) {
			C.value = C.__value = "", W[O] = I;
			continue;
		}
		if (O === "class") {
			set_class(C, C.namespaceURI === "http://www.w3.org/1999/xhtml", I, D, T == null ? void 0 : T[CLASS], E[CLASS]), W[O] = I, W[CLASS] = E[CLASS];
			continue;
		}
		if (O === "style") {
			set_style(C, I, T == null ? void 0 : T[STYLE], E[STYLE]), W[O] = I, W[STYLE] = E[STYLE];
			continue;
		}
		var Y = W[O];
		if (!(I === Y && !(I === void 0 && C.hasAttribute(O)))) {
			W[O] = I;
			var X = O[0] + O[1];
			if (X !== "$$") if (X === "on") {
				let T = {}, E = "$$" + O, D = O.slice(2);
				var Z = can_delegate_event(D);
				if (is_capture_event(D) && (D = D.slice(0, -7), T.capture = !0), !Z && Y) {
					if (I != null) continue;
					C.removeEventListener(D, W[E], T), W[E] = null;
				}
				if (I != null) if (Z) C[`__${D}`] = I, delegate([D]);
				else {
					function F(C) {
						W[O].call(this, C);
					}
					W[E] = create_event(D, C, F, T);
				}
				else Z && (C[`__${D}`] = void 0);
			} else if (O === "style") set_attribute(C, O, I);
			else if (O === "autofocus") autofocus(C, !!I);
			else if (!B && (O === "__value" || O === "value" && I != null)) C.value = C.__value = I;
			else if (O === "selected" && G) set_selected(C, I);
			else {
				var Q = O;
				V || (Q = normalize_attribute(Q));
				var NL = Q === "defaultValue" || Q === "defaultChecked";
				if (I == null && !B && !NL) if (z[O] = null, Q === "value" || Q === "checked") {
					let E = C, D = T === void 0;
					if (Q === "value") {
						let C = E.defaultValue;
						E.removeAttribute(Q), E.defaultValue = C, E.value = E.__value = D ? C : null;
					} else {
						let C = E.defaultChecked;
						E.removeAttribute(Q), E.defaultChecked = C, E.checked = D ? C : !1;
					}
				} else C.removeAttribute(O);
				else NL || J.includes(Q) && (B || typeof I != "string") ? (C[Q] = I, Q in z && (z[Q] = UNINITIALIZED)) : typeof I != "function" && set_attribute(C, Q, I, F);
			}
		}
	}
	return U && set_hydrating(!0), W;
}
function attribute_effect(C, T, E = [], D = [], O = [], F, I = !1, L = !1) {
	flatten(O, E, D, (E) => {
		var D = void 0, O = {}, z = C.nodeName === "SELECT", B = !1;
		if (block(() => {
			var V = T(...E.map(get)), U = set_attributes(C, D, V, F, I, L);
			B && z && "value" in V && select_option(C, V.value);
			for (let C of Object.getOwnPropertySymbols(O)) V[C] || destroy_effect(O[C]);
			for (let T of Object.getOwnPropertySymbols(V)) {
				var W = V[T];
				T.description === "@attach" && (!D || W !== D[T]) && (O[T] && destroy_effect(O[T]), O[T] = branch(() => attach(C, () => W))), U[T] = W;
			}
			D = U;
		}), z) {
			var V = C;
			effect(() => {
				select_option(V, D.value, !0), init_select(V);
			});
		}
		B = !0;
	});
}
function get_attributes(C) {
	var T;
	return (T = C.__attributes) == null ? C.__attributes = {
		[IS_CUSTOM_ELEMENT]: C.nodeName.includes("-"),
		[IS_HTML]: C.namespaceURI === "http://www.w3.org/1999/xhtml"
	} : T;
}
var setters_cache = /* @__PURE__ */ new Map();
function get_setters(C) {
	var T = C.getAttribute("is") || C.nodeName, E = setters_cache.get(T);
	if (E) return E;
	setters_cache.set(T, E = []);
	for (var D, O = C, F = Element.prototype; F !== O;) {
		for (var I in D = get_descriptors(O), D) D[I].set && E.push(I);
		O = get_prototype_of(O);
	}
	return E;
}
var now = () => performance.now();
const raf = {
	tick: (C) => requestAnimationFrame(C),
	now: () => now(),
	tasks: /* @__PURE__ */ new Set()
};
function run_tasks() {
	let C = raf.now();
	raf.tasks.forEach((T) => {
		T.c(C) || (raf.tasks.delete(T), T.f());
	}), raf.tasks.size !== 0 && raf.tick(run_tasks);
}
function loop(C) {
	let T;
	return raf.tasks.size === 0 && raf.tick(run_tasks), {
		promise: new Promise((E) => {
			raf.tasks.add(T = {
				c: C,
				f: E
			});
		}),
		abort() {
			raf.tasks.delete(T);
		}
	};
}
function dispatch_event(C, T) {
	without_reactive_context(() => {
		C.dispatchEvent(new CustomEvent(T));
	});
}
function css_property_to_camelcase(C) {
	if (C === "float") return "cssFloat";
	if (C === "offset") return "cssOffset";
	if (C.startsWith("--")) return C;
	let T = C.split("-");
	return T.length === 1 ? T[0] : T[0] + T.slice(1).map((C) => C[0].toUpperCase() + C.slice(1)).join("");
}
function css_to_keyframe(C) {
	let T = {}, E = C.split(";");
	for (let C of E) {
		let [E, D] = C.split(":");
		if (!E || D === void 0) break;
		let O = css_property_to_camelcase(E.trim());
		T[O] = D.trim();
	}
	return T;
}
var linear$2 = (C) => C;
function transition(C, T, E, D) {
	var O, F = (C & 1) != 0, I = (C & 2) != 0, L = F && I, z = (C & 4) != 0, B = L ? "both" : F ? "in" : "out", V, U = T.inert, W = T.style.overflow, G, K;
	function J() {
		return without_reactive_context(() => {
			var C, O;
			return (C = V) == null ? V = E()(T, (O = D == null ? void 0 : D()) == null ? {} : O, { direction: B }) : C;
		});
	}
	var Y = {
		is_global: z,
		in() {
			if (T.inert = U, !F) {
				var C;
				K == null || K.abort(), K == null || (C = K.reset) == null || C.call(K);
				return;
			}
			I || G == null || G.abort(), dispatch_event(T, "introstart"), G = animate(T, J(), K, 1, () => {
				dispatch_event(T, "introend"), G == null || G.abort(), G = V = void 0, T.style.overflow = W;
			});
		},
		out(C) {
			if (!I) {
				C == null || C(), V = void 0;
				return;
			}
			T.inert = !0, dispatch_event(T, "outrostart"), K = animate(T, J(), G, 0, () => {
				dispatch_event(T, "outroend"), C == null || C();
			});
		},
		stop: () => {
			G == null || G.abort(), K == null || K.abort();
		}
	}, X = active_effect;
	if (((O = X.transitions) == null ? X.transitions = [] : O).push(Y), F && should_intro) {
		var Z = z;
		if (!Z) {
			for (var Q = X.parent; Q && Q.f & 65536;) for (; (Q = Q.parent) && !(Q.f & 16););
			Z = !Q || (Q.f & 32768) != 0;
		}
		Z && effect(() => {
			untrack(() => Y.in());
		});
	}
}
function animate(C, T, E, D, O) {
	var F = D === 1;
	if (is_function(T)) {
		var I, L = !1;
		return queue_micro_task(() => {
			L || (I = animate(C, T({ direction: F ? "in" : "out" }), E, D, O));
		}), {
			abort: () => {
				L = !0, I == null || I.abort();
			},
			deactivate: () => I.deactivate(),
			reset: () => I.reset(),
			t: () => I.t()
		};
	}
	if (E == null || E.deactivate(), !(T != null && T.duration)) return O(), {
		abort: noop,
		deactivate: noop,
		reset: noop,
		t: () => D
	};
	let { delay: z = 0, css: B, tick: V, easing: U = linear$2 } = T;
	var W = [];
	if (F && E === void 0 && (V && V(0, 1), B)) {
		var G = css_to_keyframe(B(0, 1));
		W.push(G, G);
	}
	var K = () => 1 - D, J = C.animate(W, {
		duration: z,
		fill: "forwards"
	});
	return J.onfinish = () => {
		var F;
		J.cancel();
		var I = (F = E == null ? void 0 : E.t()) == null ? 1 - D : F;
		E == null || E.abort();
		var L = D - I, z = T.duration * Math.abs(L), W = [];
		if (z > 0) {
			var G = !1;
			if (B) for (var Y = Math.ceil(z / (1e3 / 60)), X = 0; X <= Y; X += 1) {
				var Z = I + L * U(X / Y), Q = css_to_keyframe(B(Z, 1 - Z));
				W.push(Q), G || (G = Q.overflow === "hidden");
			}
			G && (C.style.overflow = "hidden"), K = () => {
				var C = J.currentTime;
				return I + L * U(C / z);
			}, V && loop(() => {
				if (J.playState !== "running") return !1;
				var C = K();
				return V(C, 1 - C), !0;
			});
		}
		J = C.animate(W, {
			duration: z,
			fill: "forwards"
		}), J.onfinish = () => {
			K = () => D, V == null || V(D, 1 - D), O();
		};
	}, {
		abort: () => {
			J && (J.cancel(), J.effect = null, J.onfinish = noop);
		},
		deactivate: () => {
			O = noop;
		},
		reset: () => {
			D === 0 && (V == null || V(1, 0));
		},
		t: () => K()
	};
}
function bind_value(C, T, E = T) {
	var D = /* @__PURE__ */ new WeakSet();
	listen_to_event_and_reset_event(C, "input", function() {
		var O = _asyncToGenerator(function* (O) {
			var F = O ? C.defaultValue : C.value;
			if (F = is_numberlike_input(C) ? to_number(F) : F, E(F), current_batch !== null && D.add(current_batch), yield tick(), F !== (F = T())) {
				var I, L = C.selectionStart, z = C.selectionEnd, B = C.value.length;
				if (C.value = (I = F) == null ? "" : I, z !== null) {
					var V = C.value.length;
					L === z && z === B && V > B ? (C.selectionStart = V, C.selectionEnd = V) : (C.selectionStart = L, C.selectionEnd = Math.min(z, V));
				}
			}
		});
		return function(C) {
			return O.apply(this, arguments);
		};
	}()), (hydrating && C.defaultValue !== C.value || untrack(T) == null && C.value) && (E(is_numberlike_input(C) ? to_number(C.value) : C.value), current_batch !== null && D.add(current_batch)), render_effect(() => {
		var E = T();
		if (C === document.activeElement) {
			var O = previous_batch == null ? current_batch : previous_batch;
			if (D.has(O)) return;
		}
		is_numberlike_input(C) && E === to_number(C.value) || C.type === "date" && !E && !C.value || E !== C.value && (C.value = E == null ? "" : E);
	});
}
var pending = /* @__PURE__ */ new Set();
function bind_group(C, T, E, D, O = D) {
	var F = E.getAttribute("type") === "checkbox", I = C;
	let L = !1;
	if (T !== null) for (var z of T) {
		var B, V;
		I = (V = (B = I)[z]) == null ? B[z] = [] : V;
	}
	I.push(E), listen_to_event_and_reset_event(E, "change", () => {
		var C = E.__value;
		F && (C = get_binding_group_value(I, C, E.checked)), O(C);
	}, () => O(F ? [] : null)), render_effect(() => {
		var C = D();
		if (hydrating && E.defaultChecked !== E.checked) {
			L = !0;
			return;
		}
		F ? (C = C || [], E.checked = C.includes(E.__value)) : E.checked = is(E.__value, C);
	}), teardown(() => {
		var C = I.indexOf(E);
		C !== -1 && I.splice(C, 1);
	}), pending.has(I) || (pending.add(I), queue_micro_task(() => {
		I.sort((C, T) => C.compareDocumentPosition(T) === 4 ? -1 : 1), pending.delete(I);
	})), queue_micro_task(() => {
		if (L) {
			var C;
			if (F) C = get_binding_group_value(I, C, E.checked);
			else {
				var T = I.find((C) => C.checked);
				C = T == null ? void 0 : T.__value;
			}
			O(C);
		}
	});
}
function bind_checked(C, T, E = T) {
	listen_to_event_and_reset_event(C, "change", (T) => {
		E(T ? C.defaultChecked : C.checked);
	}), (hydrating && C.defaultChecked !== C.checked || untrack(T) == null) && E(C.checked), render_effect(() => {
		C.checked = !!T();
	});
}
function get_binding_group_value(C, T, E) {
	for (var D = /* @__PURE__ */ new Set(), O = 0; O < C.length; O += 1) C[O].checked && D.add(C[O].__value);
	return E || D.delete(T), Array.from(D);
}
function is_numberlike_input(C) {
	var T = C.type;
	return T === "number" || T === "range";
}
function to_number(C) {
	return C === "" ? null : +C;
}
function bind_files(C, T, E = T) {
	listen_to_event_and_reset_event(C, "change", () => {
		E(C.files);
	}), hydrating && C.files && E(C.files), render_effect(() => {
		C.files = T();
	});
}
var _ResizeObserverSingleton, _listeners = /* @__PURE__ */ new WeakMap(), _observer = /* @__PURE__ */ new WeakMap(), _options = /* @__PURE__ */ new WeakMap(), _ResizeObserverSingleton_brand = /* @__PURE__ */ new WeakSet(), ResizeObserverSingleton = class {
	constructor(C) {
		_classPrivateMethodInitSpec(this, _ResizeObserverSingleton_brand), _classPrivateFieldInitSpec(this, _listeners, /* @__PURE__ */ new WeakMap()), _classPrivateFieldInitSpec(this, _observer, void 0), _classPrivateFieldInitSpec(this, _options, void 0), _classPrivateFieldSet2(_options, this, C);
	}
	observe(C, T) {
		var E = _classPrivateFieldGet2(_listeners, this).get(C) || /* @__PURE__ */ new Set();
		return E.add(T), _classPrivateFieldGet2(_listeners, this).set(C, E), _assertClassBrand(_ResizeObserverSingleton_brand, this, _getObserver).call(this).observe(C, _classPrivateFieldGet2(_options, this)), () => {
			var E = _classPrivateFieldGet2(_listeners, this).get(C);
			E.delete(T), E.size === 0 && (_classPrivateFieldGet2(_listeners, this).delete(C), _classPrivateFieldGet2(_observer, this).unobserve(C));
		};
	}
};
_ResizeObserverSingleton = ResizeObserverSingleton;
function _getObserver() {
	var C;
	return (C = _classPrivateFieldGet2(_observer, this)) == null ? _classPrivateFieldSet2(_observer, this, new ResizeObserver((C) => {
		for (var T of C) {
			_ResizeObserverSingleton.entries.set(T.target, T);
			for (var E of _classPrivateFieldGet2(_listeners, this).get(T.target) || []) E(T);
		}
	})) : C;
}
_defineProperty(ResizeObserverSingleton, "entries", /* @__PURE__ */ new WeakMap());
function is_bound_this(C, T) {
	return C === T || (C == null ? void 0 : C[STATE_SYMBOL]) === T;
}
function bind_this(C = {}, T, E, D) {
	return effect(() => {
		var O, F;
		return render_effect(() => {
			O = F, F = (D == null ? void 0 : D()) || [], untrack(() => {
				C !== E(...F) && (T(C, ...F), O && is_bound_this(E(...O), C) && T(null, ...O));
			});
		}), () => {
			queue_micro_task(() => {
				F && is_bound_this(E(...F), C) && T(null, ...F);
			});
		};
	}), C;
}
function bind_window_size(C, T) {
	listen(window, ["resize"], () => without_reactive_context(() => T(window[C])));
}
function init(C = !1) {
	let T = component_context, E = T.l.u;
	if (!E) return;
	let D = () => deep_read_state(T.s);
	if (C) {
		let C = 0, E = {}, O = /* @__PURE__ */ derived$1(() => {
			let D = !1, O = T.s;
			for (let C in O) O[C] !== E[C] && (E[C] = O[C], D = !0);
			return D && C++, C;
		});
		D = () => get(O);
	}
	E.b.length && user_pre_effect(() => {
		observe_all(T, D), run_all(E.b);
	}), user_effect(() => {
		let C = untrack(() => E.m.map(run));
		return () => {
			for (let T of C) typeof T == "function" && T();
		};
	}), E.a.length && user_effect(() => {
		observe_all(T, D), run_all(E.a);
	});
}
function observe_all(C, T) {
	if (C.l.s) for (let T of C.l.s) get(T);
	T();
}
function subscribe_to_store(C, T, E) {
	if (C == null) return T(void 0), E && E(void 0), noop;
	let D = untrack(() => C.subscribe(T, E));
	return D.unsubscribe ? () => D.unsubscribe() : D;
}
var subscriber_queue = [];
function writable(C, T = noop) {
	let E = null, D = /* @__PURE__ */ new Set();
	function O(T) {
		if (safe_not_equal(C, T) && (C = T, E)) {
			let T = !subscriber_queue.length;
			for (let T of D) T[1](), subscriber_queue.push(T, C);
			if (T) {
				for (let C = 0; C < subscriber_queue.length; C += 2) subscriber_queue[C][0](subscriber_queue[C + 1]);
				subscriber_queue.length = 0;
			}
		}
	}
	function F(T) {
		O(T(C));
	}
	function I(I, L = noop) {
		let z = [I, L];
		return D.add(z), D.size === 1 && (E = T(O, F) || noop), I(C), () => {
			D.delete(z), D.size === 0 && E && (E(), E = null);
		};
	}
	return {
		set: O,
		update: F,
		subscribe: I
	};
}
function get$1(C) {
	let T;
	return subscribe_to_store(C, (C) => T = C)(), T;
}
var is_store_binding = !1, IS_UNMOUNTED = Symbol();
function store_get(C, T, E) {
	var D;
	let O = (D = E[T]) == null ? E[T] = {
		store: null,
		source: /* @__PURE__ */ mutable_source(void 0),
		unsubscribe: noop
	} : D;
	if (O.store !== C && !(IS_UNMOUNTED in E)) if (O.unsubscribe(), O.store = C == null ? null : C, C == null) O.source.v = void 0, O.unsubscribe = noop;
	else {
		var F = !0;
		O.unsubscribe = subscribe_to_store(C, (C) => {
			F ? O.source.v = C : set(O.source, C);
		}), F = !1;
	}
	return C && IS_UNMOUNTED in E ? get$1(C) : get(O.source);
}
function store_set(C, T) {
	return C.set(T), T;
}
function setup_stores() {
	let C = {};
	function T() {
		teardown(() => {
			for (var T in C) C[T].unsubscribe();
			define_property(C, IS_UNMOUNTED, {
				enumerable: !1,
				value: !0
			});
		});
	}
	return [C, T];
}
function capture_store_binding(C) {
	var T = is_store_binding;
	try {
		return is_store_binding = !1, [C(), is_store_binding];
	} finally {
		is_store_binding = T;
	}
}
var rest_props_handler = {
	get(C, T) {
		if (!C.exclude.includes(T)) return C.props[T];
	},
	set(C, T) {
		return !1;
	},
	getOwnPropertyDescriptor(C, T) {
		if (!C.exclude.includes(T) && T in C.props) return {
			enumerable: !0,
			configurable: !0,
			value: C.props[T]
		};
	},
	has(C, T) {
		return C.exclude.includes(T) ? !1 : T in C.props;
	},
	ownKeys(C) {
		return Reflect.ownKeys(C.props).filter((T) => !C.exclude.includes(T));
	}
};
/* @__NO_SIDE_EFFECTS__ */
function rest_props(C, T, E) {
	return new Proxy({
		props: C,
		exclude: T
	}, rest_props_handler);
}
var spread_props_handler = {
	get(C, T) {
		let E = C.props.length;
		for (; E--;) {
			let D = C.props[E];
			if (is_function(D) && (D = D()), typeof D == "object" && D && T in D) return D[T];
		}
	},
	set(C, T, E) {
		let D = C.props.length;
		for (; D--;) {
			let O = C.props[D];
			is_function(O) && (O = O());
			let F = get_descriptor(O, T);
			if (F && F.set) return F.set(E), !0;
		}
		return !1;
	},
	getOwnPropertyDescriptor(C, T) {
		let E = C.props.length;
		for (; E--;) {
			let D = C.props[E];
			if (is_function(D) && (D = D()), typeof D == "object" && D && T in D) {
				let C = get_descriptor(D, T);
				return C && !C.configurable && (C.configurable = !0), C;
			}
		}
	},
	has(C, T) {
		if (T === STATE_SYMBOL || T === LEGACY_PROPS) return !1;
		for (let E of C.props) if (is_function(E) && (E = E()), E != null && T in E) return !0;
		return !1;
	},
	ownKeys(C) {
		let T = [];
		for (let E of C.props) if (is_function(E) && (E = E()), E) {
			for (let C in E) T.includes(C) || T.push(C);
			for (let C of Object.getOwnPropertySymbols(E)) T.includes(C) || T.push(C);
		}
		return T;
	}
};
function spread_props(...C) {
	return new Proxy({ props: C }, spread_props_handler);
}
function prop(C, T, E, D) {
	var O = !legacy_mode_flag || (E & 2) != 0, F = (E & 8) != 0, I = (E & 16) != 0, L = D, z = !0, B = () => (z && (z = !1, L = I ? untrack(D) : D), L), V;
	if (F) {
		var U, W, K = STATE_SYMBOL in C || LEGACY_PROPS in C;
		V = (U = (W = get_descriptor(C, T)) == null ? void 0 : W.set) == null ? K && T in C ? (E) => C[T] = E : void 0 : U;
	}
	var J, Y = !1;
	F ? [J, Y] = capture_store_binding(() => C[T]) : J = C[T], J === void 0 && D !== void 0 && (J = B(), V && (O && props_invalid_value(T), V(J)));
	var X = O ? () => {
		var E = C[T];
		return E === void 0 ? B() : (z = !0, E);
	} : () => {
		var E = C[T];
		return E !== void 0 && (L = void 0), E === void 0 ? L : E;
	};
	if (O && !(E & 4)) return X;
	if (V) {
		var Z = C.$$legacy;
		return (function(C, T) {
			return arguments.length > 0 ? ((!O || !T || Z || Y) && V(T ? X() : C), C) : X();
		});
	}
	var Q = !1, NL = (E & 1 ? derived$1 : derived_safe_equal)(() => (Q = !1, X()));
	F && get(NL);
	var PL = active_effect;
	return (function(C, T) {
		if (arguments.length > 0) {
			let E = T ? get(NL) : O && F ? proxy(C) : C;
			return set(NL, E), Q = !0, L !== void 0 && (L = E), C;
		}
		return is_destroying_effect && Q || PL.f & 16384 ? NL.v : get(NL);
	});
}
function createClassComponent(C) {
	return new Svelte4Component(C);
}
var _events = /* @__PURE__ */ new WeakMap(), _instance = /* @__PURE__ */ new WeakMap(), Svelte4Component = class {
	constructor(C) {
		var E, D;
		_classPrivateFieldInitSpec(this, _events, void 0), _classPrivateFieldInitSpec(this, _instance, void 0);
		var O = /* @__PURE__ */ new Map(), F = (C, T) => {
			var E = /* @__PURE__ */ mutable_source(T, !1, !1);
			return O.set(C, E), E;
		};
		let I = new Proxy(_objectSpread2(_objectSpread2({}, C.props || {}), {}, { $$events: {} }), {
			get(C, T) {
				var E;
				return get((E = O.get(T)) == null ? F(T, Reflect.get(C, T)) : E);
			},
			has(C, T) {
				var E;
				return T === LEGACY_PROPS ? !0 : (get((E = O.get(T)) == null ? F(T, Reflect.get(C, T)) : E), Reflect.has(C, T));
			},
			set(C, T, E) {
				var D;
				return set((D = O.get(T)) == null ? F(T, E) : D, E), Reflect.set(C, T, E);
			}
		});
		_classPrivateFieldSet2(_instance, this, (C.hydrate ? hydrate : mount)(C.component, {
			target: C.target,
			anchor: C.anchor,
			props: I,
			context: C.context,
			intro: (E = C.intro) == null ? !1 : E,
			recover: C.recover
		})), (!(!(C == null || (D = C.props) == null) && D.$$host) || C.sync === !1) && flushSync(), _classPrivateFieldSet2(_events, this, I.$$events);
		for (let C of Object.keys(_classPrivateFieldGet2(_instance, this))) C === "$set" || C === "$destroy" || C === "$on" || define_property(this, C, {
			get() {
				return _classPrivateFieldGet2(_instance, this)[C];
			},
			set(T) {
				_classPrivateFieldGet2(_instance, this)[C] = T;
			},
			enumerable: !0
		});
		_classPrivateFieldGet2(_instance, this).$set = (C) => {
			Object.assign(I, C);
		}, _classPrivateFieldGet2(_instance, this).$destroy = () => {
			unmount(_classPrivateFieldGet2(_instance, this));
		};
	}
	$set(C) {
		_classPrivateFieldGet2(_instance, this).$set(C);
	}
	$on(C, T) {
		_classPrivateFieldGet2(_events, this)[C] = _classPrivateFieldGet2(_events, this)[C] || [];
		let E = (...C) => T.call(this, ...C);
		return _classPrivateFieldGet2(_events, this)[C].push(E), () => {
			_classPrivateFieldGet2(_events, this)[C] = _classPrivateFieldGet2(_events, this)[C].filter((C) => C !== E);
		};
	}
	$destroy() {
		_classPrivateFieldGet2(_instance, this).$destroy();
	}
}, SvelteElement;
typeof HTMLElement == "function" && (SvelteElement = class extends HTMLElement {
	constructor(T, E, D) {
		super(), _defineProperty(this, "$$ctor", void 0), _defineProperty(this, "$$s", void 0), _defineProperty(this, "$$c", void 0), _defineProperty(this, "$$cn", !1), _defineProperty(this, "$$d", {}), _defineProperty(this, "$$r", !1), _defineProperty(this, "$$p_d", {}), _defineProperty(this, "$$l", {}), _defineProperty(this, "$$l_u", /* @__PURE__ */ new Map()), _defineProperty(this, "$$me", void 0), this.$$ctor = T, this.$$s = E, D && this.attachShadow({ mode: "open" });
	}
	addEventListener(C, T, E) {
		if (this.$$l[C] = this.$$l[C] || [], this.$$l[C].push(T), this.$$c) {
			let E = this.$$c.$on(C, T);
			this.$$l_u.set(T, E);
		}
		super.addEventListener(C, T, E);
	}
	removeEventListener(C, T, E) {
		if (super.removeEventListener(C, T, E), this.$$c) {
			let C = this.$$l_u.get(T);
			C && (C(), this.$$l_u.delete(T));
		}
	}
	connectedCallback() {
		var C = this;
		return _asyncToGenerator(function* () {
			if (C.$$cn = !0, !C.$$c) {
				if (yield Promise.resolve(), !C.$$cn || C.$$c) return;
				function E(C) {
					return (T) => {
						let E = document.createElement("slot");
						C !== "default" && (E.name = C), append(T, E);
					};
				}
				let D = {}, O = get_custom_elements_slots(C);
				for (let T of C.$$s) T in O && (T === "default" && !C.$$d.children ? (C.$$d.children = E(T), D.default = !0) : D[T] = E(T));
				for (let T of C.attributes) {
					let E = C.$$g_p(T.name);
					E in C.$$d || (C.$$d[E] = get_custom_element_value(E, T.value, C.$$p_d, "toProp"));
				}
				for (let T in C.$$p_d) !(T in C.$$d) && C[T] !== void 0 && (C.$$d[T] = C[T], delete C[T]);
				for (let E in C.$$c = createClassComponent({
					component: C.$$ctor,
					target: C.shadowRoot || C,
					props: _objectSpread2(_objectSpread2({}, C.$$d), {}, {
						$$slots: D,
						$$host: C
					})
				}), C.$$me = effect_root(() => {
					render_effect(() => {
						C.$$r = !0;
						for (let E of object_keys(C.$$c)) {
							var T;
							if (!((T = C.$$p_d[E]) != null && T.reflect)) continue;
							C.$$d[E] = C.$$c[E];
							let D = get_custom_element_value(E, C.$$d[E], C.$$p_d, "toAttribute");
							D == null ? C.removeAttribute(C.$$p_d[E].attribute || E) : C.setAttribute(C.$$p_d[E].attribute || E, D);
						}
						C.$$r = !1;
					});
				}), C.$$l) for (let T of C.$$l[E]) {
					let D = C.$$c.$on(E, T);
					C.$$l_u.set(T, D);
				}
				C.$$l = {};
			}
		})();
	}
	attributeChangedCallback(C, T, E) {
		var D;
		this.$$r || (C = this.$$g_p(C), this.$$d[C] = get_custom_element_value(C, E, this.$$p_d, "toProp"), (D = this.$$c) == null || D.$set({ [C]: this.$$d[C] }));
	}
	disconnectedCallback() {
		this.$$cn = !1, Promise.resolve().then(() => {
			!this.$$cn && this.$$c && (this.$$c.$destroy(), this.$$me(), this.$$c = void 0);
		});
	}
	$$g_p(C) {
		return object_keys(this.$$p_d).find((T) => this.$$p_d[T].attribute === C || !this.$$p_d[T].attribute && T.toLowerCase() === C) || C;
	}
});
function get_custom_element_value(C, T, E, D) {
	var O;
	let F = (O = E[C]) == null ? void 0 : O.type;
	if (T = F === "Boolean" && typeof T != "boolean" ? T != null : T, !D || !E[C]) return T;
	if (D === "toAttribute") switch (F) {
		case "Object":
		case "Array": return T == null ? null : JSON.stringify(T);
		case "Boolean": return T ? "" : null;
		case "Number": return T == null ? null : T;
		default: return T;
	}
	else switch (F) {
		case "Object":
		case "Array": return T && JSON.parse(T);
		case "Boolean": return T;
		case "Number": return T == null ? T : +T;
		default: return T;
	}
}
function get_custom_elements_slots(C) {
	let T = {};
	return C.childNodes.forEach((C) => {
		T[C.slot || "default"] = !0;
	}), T;
}
function create_custom_element(C, T, E, D, O, F) {
	let I = class extends SvelteElement {
		constructor() {
			super(C, E, O), this.$$p_d = T;
		}
		static get observedAttributes() {
			return object_keys(T).map((C) => (T[C].attribute || C).toLowerCase());
		}
	};
	return object_keys(T).forEach((C) => {
		define_property(I.prototype, C, {
			get() {
				return this.$$c && C in this.$$c ? this.$$c[C] : this.$$d[C];
			},
			set(E) {
				E = get_custom_element_value(C, E, T), this.$$d[C] = E;
				var D = this.$$c;
				if (D) {
					var O;
					(O = get_descriptor(D, C)) != null && O.get ? D[C] = E : D.$set({ [C]: E });
				}
			}
		});
	}), D.forEach((C) => {
		define_property(I.prototype, C, { get() {
			var T;
			return (T = this.$$c) == null ? void 0 : T[C];
		} });
	}), F && (I = F(I)), C.element = I, I;
}
function uiHelpers() {
	let C = /* @__PURE__ */ state(!1);
	function T() {
		set(C, !get(C));
	}
	function E() {
		set(C, !1);
	}
	function D() {
		set(C, !0);
	}
	return {
		get isOpen() {
			return get(C);
		},
		set isOpen(T) {
			set(C, T, !0);
		},
		toggle: T,
		close: E,
		open: D
	};
}
function clickOutside(C, T) {
	let E = (E) => {
		if (typeof T == "function") {
			let D = E.target;
			C.contains(D) || T(E);
		} else console.error("Callback function is not a function");
	};
	return C.ownerDocument.body.addEventListener("click", E), {
		update(C) {
			typeof C == "function" ? T = C : console.error("New callback function is not a function");
		},
		destroy() {
			C.ownerDocument.body.removeEventListener("click", E);
		}
	};
}
var root$134 = /* @__PURE__ */ from_html("<div><!></div>");
function Accordion(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "flush", 7), F = prop(E, "activeClass", 7), I = prop(E, "inactiveClass", 7), L = prop(E, "isSingle", 7, !1), z = prop(E, "class", 7), B = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"flush",
		"activeClass",
		"inactiveClass",
		"isSingle",
		"class"
	]);
	setContext("ctx", {
		flush: O(),
		activeClass: F(),
		inactiveClass: I(),
		isSingle: L()
	});
	let V = /* @__PURE__ */ user_derived(() => accordion({
		flush: O(),
		className: z()
	}));
	var U = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get flush() {
			return O();
		},
		set flush(C) {
			O(C), flushSync();
		},
		get activeClass() {
			return F();
		},
		set activeClass(C) {
			F(C), flushSync();
		},
		get inactiveClass() {
			return I();
		},
		set inactiveClass(C) {
			I(C), flushSync();
		},
		get isSingle() {
			return L();
		},
		set isSingle(C = !1) {
			L(C), flushSync();
		},
		get class() {
			return z();
		},
		set class(C) {
			z(C), flushSync();
		}
	}, W = root$134();
	return attribute_effect(W, () => _objectSpread2(_objectSpread2({}, B), {}, { class: get(V) })), snippet(child(W), D), reset(W), append(C, W), pop(U);
}
create_custom_element(Accordion, {
	children: {},
	flush: {},
	activeClass: {},
	inactiveClass: {},
	isSingle: {},
	class: {}
}, [], [], !0);
var concatArrays = (C, T) => {
	let E = Array(C.length + T.length);
	for (let T = 0; T < C.length; T++) E[T] = C[T];
	for (let D = 0; D < T.length; D++) E[C.length + D] = T[D];
	return E;
}, createClassValidatorObject = (C, T) => ({
	classGroupId: C,
	validator: T
}), createClassPartObject = (C = /* @__PURE__ */ new Map(), T = null, E) => ({
	nextPart: C,
	validators: T,
	classGroupId: E
}), CLASS_PART_SEPARATOR$1 = "-", EMPTY_CONFLICTS = [], ARBITRARY_PROPERTY_PREFIX = "arbitrary..", createClassGroupUtils$1 = (C) => {
	let T = createClassMap$1(C), { conflictingClassGroups: E, conflictingClassGroupModifiers: D } = C;
	return {
		getClassGroupId: (C) => {
			if (C.startsWith("[") && C.endsWith("]")) return getGroupIdForArbitraryProperty$1(C);
			let E = C.split(CLASS_PART_SEPARATOR$1);
			return getGroupRecursive$1(E, E[0] === "" && E.length > 1 ? 1 : 0, T);
		},
		getConflictingClassGroupIds: (C, T) => {
			if (T) {
				let T = D[C], O = E[C];
				return T ? O ? concatArrays(O, T) : T : O || EMPTY_CONFLICTS;
			}
			return E[C] || EMPTY_CONFLICTS;
		}
	};
}, getGroupRecursive$1 = (C, T, E) => {
	if (C.length - T === 0) return E.classGroupId;
	let D = C[T], O = E.nextPart.get(D);
	if (O) {
		let E = getGroupRecursive$1(C, T + 1, O);
		if (E) return E;
	}
	let F = E.validators;
	if (F === null) return;
	let I = T === 0 ? C.join(CLASS_PART_SEPARATOR$1) : C.slice(T).join(CLASS_PART_SEPARATOR$1), L = F.length;
	for (let C = 0; C < L; C++) {
		let T = F[C];
		if (T.validator(I)) return T.classGroupId;
	}
}, getGroupIdForArbitraryProperty$1 = (C) => C.slice(1, -1).indexOf(":") === -1 ? void 0 : (() => {
	let T = C.slice(1, -1), E = T.indexOf(":"), D = T.slice(0, E);
	return D ? ARBITRARY_PROPERTY_PREFIX + D : void 0;
})(), createClassMap$1 = (C) => {
	let { theme: T, classGroups: E } = C;
	return processClassGroups(E, T);
}, processClassGroups = (C, T) => {
	let E = createClassPartObject();
	for (let D in C) {
		let O = C[D];
		processClassesRecursively$1(O, E, D, T);
	}
	return E;
}, processClassesRecursively$1 = (C, T, E, D) => {
	let O = C.length;
	for (let F = 0; F < O; F++) {
		let O = C[F];
		processClassDefinition(O, T, E, D);
	}
}, processClassDefinition = (C, T, E, D) => {
	if (typeof C == "string") {
		processStringDefinition(C, T, E);
		return;
	}
	if (typeof C == "function") {
		processFunctionDefinition(C, T, E, D);
		return;
	}
	processObjectDefinition(C, T, E, D);
}, processStringDefinition = (C, T, E) => {
	let D = C === "" ? T : getPart$1(T, C);
	D.classGroupId = E;
}, processFunctionDefinition = (C, T, E, D) => {
	if (isThemeGetter$1(C)) {
		processClassesRecursively$1(C(D), T, E, D);
		return;
	}
	T.validators === null && (T.validators = []), T.validators.push(createClassValidatorObject(E, C));
}, processObjectDefinition = (C, T, E, D) => {
	let O = Object.entries(C), F = O.length;
	for (let C = 0; C < F; C++) {
		let [F, I] = O[C];
		processClassesRecursively$1(I, getPart$1(T, F), E, D);
	}
}, getPart$1 = (C, T) => {
	let E = C, D = T.split(CLASS_PART_SEPARATOR$1), O = D.length;
	for (let C = 0; C < O; C++) {
		let T = D[C], O = E.nextPart.get(T);
		O || (O = createClassPartObject(), E.nextPart.set(T, O)), E = O;
	}
	return E;
}, isThemeGetter$1 = (C) => "isThemeGetter" in C && C.isThemeGetter === !0, createLruCache$1 = (C) => {
	if (C < 1) return {
		get: () => void 0,
		set: () => {}
	};
	let T = 0, E = Object.create(null), D = Object.create(null), O = (O, F) => {
		E[O] = F, T++, T > C && (T = 0, D = E, E = Object.create(null));
	};
	return {
		get(C) {
			let T = E[C];
			if (T !== void 0) return T;
			if ((T = D[C]) !== void 0) return O(C, T), T;
		},
		set(C, T) {
			C in E ? E[C] = T : O(C, T);
		}
	};
}, IMPORTANT_MODIFIER$1 = "!", MODIFIER_SEPARATOR$1 = ":", EMPTY_MODIFIERS = [], createResultObject = (C, T, E, D, O) => ({
	modifiers: C,
	hasImportantModifier: T,
	baseClassName: E,
	maybePostfixModifierPosition: D,
	isExternal: O
}), createParseClassName$1 = (C) => {
	let { prefix: T, experimentalParseClassName: E } = C, D = (C) => {
		let T = [], E = 0, D = 0, O = 0, F, I = C.length;
		for (let L = 0; L < I; L++) {
			let I = C[L];
			if (E === 0 && D === 0) {
				if (I === MODIFIER_SEPARATOR$1) {
					T.push(C.slice(O, L)), O = L + 1;
					continue;
				}
				if (I === "/") {
					F = L;
					continue;
				}
			}
			I === "[" ? E++ : I === "]" ? E-- : I === "(" ? D++ : I === ")" && D--;
		}
		let L = T.length === 0 ? C : C.slice(O), z = L, B = !1;
		L.endsWith(IMPORTANT_MODIFIER$1) ? (z = L.slice(0, -1), B = !0) : L.startsWith(IMPORTANT_MODIFIER$1) && (z = L.slice(1), B = !0);
		let V = F && F > O ? F - O : void 0;
		return createResultObject(T, B, z, V);
	};
	if (T) {
		let C = T + MODIFIER_SEPARATOR$1, E = D;
		D = (T) => T.startsWith(C) ? E(T.slice(C.length)) : createResultObject(EMPTY_MODIFIERS, !1, T, void 0, !0);
	}
	if (E) {
		let C = D;
		D = (T) => E({
			className: T,
			parseClassName: C
		});
	}
	return D;
}, createSortModifiers$1 = (C) => {
	let T = /* @__PURE__ */ new Map();
	return C.orderSensitiveModifiers.forEach((C, E) => {
		T.set(C, 1e6 + E);
	}), (C) => {
		let E = [], D = [];
		for (let O = 0; O < C.length; O++) {
			let F = C[O], I = F[0] === "[", L = T.has(F);
			I || L ? (D.length > 0 && (D.sort(), E.push(...D), D = []), E.push(F)) : D.push(F);
		}
		return D.length > 0 && (D.sort(), E.push(...D)), E;
	};
}, createConfigUtils$1 = (C) => _objectSpread2({
	cache: createLruCache$1(C.cacheSize),
	parseClassName: createParseClassName$1(C),
	sortModifiers: createSortModifiers$1(C)
}, createClassGroupUtils$1(C)), SPLIT_CLASSES_REGEX$1 = /\s+/, mergeClassList$1 = (C, T) => {
	let { parseClassName: E, getClassGroupId: D, getConflictingClassGroupIds: O, sortModifiers: F } = T, I = [], L = C.trim().split(SPLIT_CLASSES_REGEX$1), z = "";
	for (let C = L.length - 1; C >= 0; --C) {
		let T = L[C], { isExternal: B, modifiers: V, hasImportantModifier: U, baseClassName: W, maybePostfixModifierPosition: G } = E(T);
		if (B) {
			z = T + (z.length > 0 ? " " + z : z);
			continue;
		}
		let K = !!G, J = D(K ? W.substring(0, G) : W);
		if (!J) {
			if (!K) {
				z = T + (z.length > 0 ? " " + z : z);
				continue;
			}
			if (J = D(W), !J) {
				z = T + (z.length > 0 ? " " + z : z);
				continue;
			}
			K = !1;
		}
		let Y = V.length === 0 ? "" : V.length === 1 ? V[0] : F(V).join(":"), X = U ? Y + IMPORTANT_MODIFIER$1 : Y, Z = X + J;
		if (I.indexOf(Z) > -1) continue;
		I.push(Z);
		let Q = O(J, K);
		for (let C = 0; C < Q.length; ++C) {
			let T = Q[C];
			I.push(X + T);
		}
		z = T + (z.length > 0 ? " " + z : z);
	}
	return z;
}, twJoin$1 = (...C) => {
	let T = 0, E, D, O = "";
	for (; T < C.length;) (E = C[T++]) && (D = toValue$1(E)) && (O && (O += " "), O += D);
	return O;
}, toValue$1 = (C) => {
	if (typeof C == "string") return C;
	let T, E = "";
	for (let D = 0; D < C.length; D++) C[D] && (T = toValue$1(C[D])) && (E && (E += " "), E += T);
	return E;
}, createTailwindMerge$1 = (C, ...T) => {
	let E, D, O, F, I = (I) => (E = createConfigUtils$1(T.reduce((C, T) => T(C), C())), D = E.cache.get, O = E.cache.set, F = L, L(I)), L = (C) => {
		let T = D(C);
		if (T) return T;
		let F = mergeClassList$1(C, E);
		return O(C, F), F;
	};
	return F = I, (...C) => F(twJoin$1(...C));
}, fallbackThemeArr = [], fromTheme$1 = (C) => {
	let T = (T) => T[C] || fallbackThemeArr;
	return T.isThemeGetter = !0, T;
}, arbitraryValueRegex$1 = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, arbitraryVariableRegex$1 = /^\((?:(\w[\w-]*):)?(.+)\)$/i, fractionRegex$1 = /^\d+\/\d+$/, tshirtUnitRegex$1 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, lengthUnitRegex$1 = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, colorFunctionRegex$1 = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, shadowRegex$1 = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, imageRegex$1 = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, isFraction$1 = (C) => fractionRegex$1.test(C), isNumber$1 = (C) => !!C && !Number.isNaN(Number(C)), isInteger$1 = (C) => !!C && Number.isInteger(Number(C)), isPercent$1 = (C) => C.endsWith("%") && isNumber$1(C.slice(0, -1)), isTshirtSize$1 = (C) => tshirtUnitRegex$1.test(C), isAny$1 = () => !0, isLengthOnly$1 = (C) => lengthUnitRegex$1.test(C) && !colorFunctionRegex$1.test(C), isNever$1 = () => !1, isShadow$1 = (C) => shadowRegex$1.test(C), isImage$1 = (C) => imageRegex$1.test(C), isAnyNonArbitrary$1 = (C) => !isArbitraryValue$1(C) && !isArbitraryVariable$1(C), isArbitrarySize$1 = (C) => getIsArbitraryValue$1(C, isLabelSize$1, isNever$1), isArbitraryValue$1 = (C) => arbitraryValueRegex$1.test(C), isArbitraryLength$1 = (C) => getIsArbitraryValue$1(C, isLabelLength$1, isLengthOnly$1), isArbitraryNumber$1 = (C) => getIsArbitraryValue$1(C, isLabelNumber$1, isNumber$1), isArbitraryPosition$1 = (C) => getIsArbitraryValue$1(C, isLabelPosition$1, isNever$1), isArbitraryImage$1 = (C) => getIsArbitraryValue$1(C, isLabelImage$1, isImage$1), isArbitraryShadow$1 = (C) => getIsArbitraryValue$1(C, isLabelShadow$1, isShadow$1), isArbitraryVariable$1 = (C) => arbitraryVariableRegex$1.test(C), isArbitraryVariableLength$1 = (C) => getIsArbitraryVariable$1(C, isLabelLength$1), isArbitraryVariableFamilyName$1 = (C) => getIsArbitraryVariable$1(C, isLabelFamilyName$1), isArbitraryVariablePosition$1 = (C) => getIsArbitraryVariable$1(C, isLabelPosition$1), isArbitraryVariableSize$1 = (C) => getIsArbitraryVariable$1(C, isLabelSize$1), isArbitraryVariableImage$1 = (C) => getIsArbitraryVariable$1(C, isLabelImage$1), isArbitraryVariableShadow$1 = (C) => getIsArbitraryVariable$1(C, isLabelShadow$1, !0), getIsArbitraryValue$1 = (C, T, E) => {
	let D = arbitraryValueRegex$1.exec(C);
	return D ? D[1] ? T(D[1]) : E(D[2]) : !1;
}, getIsArbitraryVariable$1 = (C, T, E = !1) => {
	let D = arbitraryVariableRegex$1.exec(C);
	return D ? D[1] ? T(D[1]) : E : !1;
}, isLabelPosition$1 = (C) => C === "position" || C === "percentage", isLabelImage$1 = (C) => C === "image" || C === "url", isLabelSize$1 = (C) => C === "length" || C === "size" || C === "bg-size", isLabelLength$1 = (C) => C === "length", isLabelNumber$1 = (C) => C === "number", isLabelFamilyName$1 = (C) => C === "family-name", isLabelShadow$1 = (C) => C === "shadow", twMerge = /* @__PURE__ */ createTailwindMerge$1(() => {
	let C = fromTheme$1("color"), T = fromTheme$1("font"), E = fromTheme$1("text"), D = fromTheme$1("font-weight"), O = fromTheme$1("tracking"), F = fromTheme$1("leading"), I = fromTheme$1("breakpoint"), L = fromTheme$1("container"), z = fromTheme$1("spacing"), B = fromTheme$1("radius"), V = fromTheme$1("shadow"), U = fromTheme$1("inset-shadow"), W = fromTheme$1("text-shadow"), G = fromTheme$1("drop-shadow"), K = fromTheme$1("blur"), J = fromTheme$1("perspective"), Y = fromTheme$1("aspect"), X = fromTheme$1("ease"), Z = fromTheme$1("animate"), Q = () => [
		"auto",
		"avoid",
		"all",
		"avoid-page",
		"page",
		"left",
		"right",
		"column"
	], NL = () => [
		"center",
		"top",
		"bottom",
		"left",
		"right",
		"top-left",
		"left-top",
		"top-right",
		"right-top",
		"bottom-right",
		"right-bottom",
		"bottom-left",
		"left-bottom"
	], PL = () => [
		...NL(),
		isArbitraryVariable$1,
		isArbitraryValue$1
	], FL = () => [
		"auto",
		"hidden",
		"clip",
		"visible",
		"scroll"
	], IL = () => [
		"auto",
		"contain",
		"none"
	], LL = () => [
		isArbitraryVariable$1,
		isArbitraryValue$1,
		z
	], RL = () => [
		isFraction$1,
		"full",
		"auto",
		...LL()
	], zL = () => [
		isInteger$1,
		"none",
		"subgrid",
		isArbitraryVariable$1,
		isArbitraryValue$1
	], BL = () => [
		"auto",
		{ span: [
			"full",
			isInteger$1,
			isArbitraryVariable$1,
			isArbitraryValue$1
		] },
		isInteger$1,
		isArbitraryVariable$1,
		isArbitraryValue$1
	], VL = () => [
		isInteger$1,
		"auto",
		isArbitraryVariable$1,
		isArbitraryValue$1
	], HL = () => [
		"auto",
		"min",
		"max",
		"fr",
		isArbitraryVariable$1,
		isArbitraryValue$1
	], UL = () => [
		"start",
		"end",
		"center",
		"between",
		"around",
		"evenly",
		"stretch",
		"baseline",
		"center-safe",
		"end-safe"
	], WL = () => [
		"start",
		"end",
		"center",
		"stretch",
		"center-safe",
		"end-safe"
	], GL = () => ["auto", ...LL()], KL = () => [
		isFraction$1,
		"auto",
		"full",
		"dvw",
		"dvh",
		"lvw",
		"lvh",
		"svw",
		"svh",
		"min",
		"max",
		"fit",
		...LL()
	], qL = () => [
		C,
		isArbitraryVariable$1,
		isArbitraryValue$1
	], JL = () => [
		...NL(),
		isArbitraryVariablePosition$1,
		isArbitraryPosition$1,
		{ position: [isArbitraryVariable$1, isArbitraryValue$1] }
	], YL = () => ["no-repeat", { repeat: [
		"",
		"x",
		"y",
		"space",
		"round"
	] }], XL = () => [
		"auto",
		"cover",
		"contain",
		isArbitraryVariableSize$1,
		isArbitrarySize$1,
		{ size: [isArbitraryVariable$1, isArbitraryValue$1] }
	], ZL = () => [
		isPercent$1,
		isArbitraryVariableLength$1,
		isArbitraryLength$1
	], QL = () => [
		"",
		"none",
		"full",
		B,
		isArbitraryVariable$1,
		isArbitraryValue$1
	], $L = () => [
		"",
		isNumber$1,
		isArbitraryVariableLength$1,
		isArbitraryLength$1
	], eR = () => [
		"solid",
		"dashed",
		"dotted",
		"double"
	], tR = () => [
		"normal",
		"multiply",
		"screen",
		"overlay",
		"darken",
		"lighten",
		"color-dodge",
		"color-burn",
		"hard-light",
		"soft-light",
		"difference",
		"exclusion",
		"hue",
		"saturation",
		"color",
		"luminosity"
	], nR = () => [
		isNumber$1,
		isPercent$1,
		isArbitraryVariablePosition$1,
		isArbitraryPosition$1
	], rR = () => [
		"",
		"none",
		K,
		isArbitraryVariable$1,
		isArbitraryValue$1
	], iR = () => [
		"none",
		isNumber$1,
		isArbitraryVariable$1,
		isArbitraryValue$1
	], aR = () => [
		"none",
		isNumber$1,
		isArbitraryVariable$1,
		isArbitraryValue$1
	], oR = () => [
		isNumber$1,
		isArbitraryVariable$1,
		isArbitraryValue$1
	], sR = () => [
		isFraction$1,
		"full",
		...LL()
	];
	return {
		cacheSize: 500,
		theme: {
			animate: [
				"spin",
				"ping",
				"pulse",
				"bounce"
			],
			aspect: ["video"],
			blur: [isTshirtSize$1],
			breakpoint: [isTshirtSize$1],
			color: [isAny$1],
			container: [isTshirtSize$1],
			"drop-shadow": [isTshirtSize$1],
			ease: [
				"in",
				"out",
				"in-out"
			],
			font: [isAnyNonArbitrary$1],
			"font-weight": [
				"thin",
				"extralight",
				"light",
				"normal",
				"medium",
				"semibold",
				"bold",
				"extrabold",
				"black"
			],
			"inset-shadow": [isTshirtSize$1],
			leading: [
				"none",
				"tight",
				"snug",
				"normal",
				"relaxed",
				"loose"
			],
			perspective: [
				"dramatic",
				"near",
				"normal",
				"midrange",
				"distant",
				"none"
			],
			radius: [isTshirtSize$1],
			shadow: [isTshirtSize$1],
			spacing: ["px", isNumber$1],
			text: [isTshirtSize$1],
			"text-shadow": [isTshirtSize$1],
			tracking: [
				"tighter",
				"tight",
				"normal",
				"wide",
				"wider",
				"widest"
			]
		},
		classGroups: {
			aspect: [{ aspect: [
				"auto",
				"square",
				isFraction$1,
				isArbitraryValue$1,
				isArbitraryVariable$1,
				Y
			] }],
			container: ["container"],
			columns: [{ columns: [
				isNumber$1,
				isArbitraryValue$1,
				isArbitraryVariable$1,
				L
			] }],
			"break-after": [{ "break-after": Q() }],
			"break-before": [{ "break-before": Q() }],
			"break-inside": [{ "break-inside": [
				"auto",
				"avoid",
				"avoid-page",
				"avoid-column"
			] }],
			"box-decoration": [{ "box-decoration": ["slice", "clone"] }],
			box: [{ box: ["border", "content"] }],
			display: [
				"block",
				"inline-block",
				"inline",
				"flex",
				"inline-flex",
				"table",
				"inline-table",
				"table-caption",
				"table-cell",
				"table-column",
				"table-column-group",
				"table-footer-group",
				"table-header-group",
				"table-row-group",
				"table-row",
				"flow-root",
				"grid",
				"inline-grid",
				"contents",
				"list-item",
				"hidden"
			],
			sr: ["sr-only", "not-sr-only"],
			float: [{ float: [
				"right",
				"left",
				"none",
				"start",
				"end"
			] }],
			clear: [{ clear: [
				"left",
				"right",
				"both",
				"none",
				"start",
				"end"
			] }],
			isolation: ["isolate", "isolation-auto"],
			"object-fit": [{ object: [
				"contain",
				"cover",
				"fill",
				"none",
				"scale-down"
			] }],
			"object-position": [{ object: PL() }],
			overflow: [{ overflow: FL() }],
			"overflow-x": [{ "overflow-x": FL() }],
			"overflow-y": [{ "overflow-y": FL() }],
			overscroll: [{ overscroll: IL() }],
			"overscroll-x": [{ "overscroll-x": IL() }],
			"overscroll-y": [{ "overscroll-y": IL() }],
			position: [
				"static",
				"fixed",
				"absolute",
				"relative",
				"sticky"
			],
			inset: [{ inset: RL() }],
			"inset-x": [{ "inset-x": RL() }],
			"inset-y": [{ "inset-y": RL() }],
			start: [{ start: RL() }],
			end: [{ end: RL() }],
			top: [{ top: RL() }],
			right: [{ right: RL() }],
			bottom: [{ bottom: RL() }],
			left: [{ left: RL() }],
			visibility: [
				"visible",
				"invisible",
				"collapse"
			],
			z: [{ z: [
				isInteger$1,
				"auto",
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			basis: [{ basis: [
				isFraction$1,
				"full",
				"auto",
				L,
				...LL()
			] }],
			"flex-direction": [{ flex: [
				"row",
				"row-reverse",
				"col",
				"col-reverse"
			] }],
			"flex-wrap": [{ flex: [
				"nowrap",
				"wrap",
				"wrap-reverse"
			] }],
			flex: [{ flex: [
				isNumber$1,
				isFraction$1,
				"auto",
				"initial",
				"none",
				isArbitraryValue$1
			] }],
			grow: [{ grow: [
				"",
				isNumber$1,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			shrink: [{ shrink: [
				"",
				isNumber$1,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			order: [{ order: [
				isInteger$1,
				"first",
				"last",
				"none",
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"grid-cols": [{ "grid-cols": zL() }],
			"col-start-end": [{ col: BL() }],
			"col-start": [{ "col-start": VL() }],
			"col-end": [{ "col-end": VL() }],
			"grid-rows": [{ "grid-rows": zL() }],
			"row-start-end": [{ row: BL() }],
			"row-start": [{ "row-start": VL() }],
			"row-end": [{ "row-end": VL() }],
			"grid-flow": [{ "grid-flow": [
				"row",
				"col",
				"dense",
				"row-dense",
				"col-dense"
			] }],
			"auto-cols": [{ "auto-cols": HL() }],
			"auto-rows": [{ "auto-rows": HL() }],
			gap: [{ gap: LL() }],
			"gap-x": [{ "gap-x": LL() }],
			"gap-y": [{ "gap-y": LL() }],
			"justify-content": [{ justify: [...UL(), "normal"] }],
			"justify-items": [{ "justify-items": [...WL(), "normal"] }],
			"justify-self": [{ "justify-self": ["auto", ...WL()] }],
			"align-content": [{ content: ["normal", ...UL()] }],
			"align-items": [{ items: [...WL(), { baseline: ["", "last"] }] }],
			"align-self": [{ self: [
				"auto",
				...WL(),
				{ baseline: ["", "last"] }
			] }],
			"place-content": [{ "place-content": UL() }],
			"place-items": [{ "place-items": [...WL(), "baseline"] }],
			"place-self": [{ "place-self": ["auto", ...WL()] }],
			p: [{ p: LL() }],
			px: [{ px: LL() }],
			py: [{ py: LL() }],
			ps: [{ ps: LL() }],
			pe: [{ pe: LL() }],
			pt: [{ pt: LL() }],
			pr: [{ pr: LL() }],
			pb: [{ pb: LL() }],
			pl: [{ pl: LL() }],
			m: [{ m: GL() }],
			mx: [{ mx: GL() }],
			my: [{ my: GL() }],
			ms: [{ ms: GL() }],
			me: [{ me: GL() }],
			mt: [{ mt: GL() }],
			mr: [{ mr: GL() }],
			mb: [{ mb: GL() }],
			ml: [{ ml: GL() }],
			"space-x": [{ "space-x": LL() }],
			"space-x-reverse": ["space-x-reverse"],
			"space-y": [{ "space-y": LL() }],
			"space-y-reverse": ["space-y-reverse"],
			size: [{ size: KL() }],
			w: [{ w: [
				L,
				"screen",
				...KL()
			] }],
			"min-w": [{ "min-w": [
				L,
				"screen",
				"none",
				...KL()
			] }],
			"max-w": [{ "max-w": [
				L,
				"screen",
				"none",
				"prose",
				{ screen: [I] },
				...KL()
			] }],
			h: [{ h: [
				"screen",
				"lh",
				...KL()
			] }],
			"min-h": [{ "min-h": [
				"screen",
				"lh",
				"none",
				...KL()
			] }],
			"max-h": [{ "max-h": [
				"screen",
				"lh",
				...KL()
			] }],
			"font-size": [{ text: [
				"base",
				E,
				isArbitraryVariableLength$1,
				isArbitraryLength$1
			] }],
			"font-smoothing": ["antialiased", "subpixel-antialiased"],
			"font-style": ["italic", "not-italic"],
			"font-weight": [{ font: [
				D,
				isArbitraryVariable$1,
				isArbitraryNumber$1
			] }],
			"font-stretch": [{ "font-stretch": [
				"ultra-condensed",
				"extra-condensed",
				"condensed",
				"semi-condensed",
				"normal",
				"semi-expanded",
				"expanded",
				"extra-expanded",
				"ultra-expanded",
				isPercent$1,
				isArbitraryValue$1
			] }],
			"font-family": [{ font: [
				isArbitraryVariableFamilyName$1,
				isArbitraryValue$1,
				T
			] }],
			"fvn-normal": ["normal-nums"],
			"fvn-ordinal": ["ordinal"],
			"fvn-slashed-zero": ["slashed-zero"],
			"fvn-figure": ["lining-nums", "oldstyle-nums"],
			"fvn-spacing": ["proportional-nums", "tabular-nums"],
			"fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
			tracking: [{ tracking: [
				O,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"line-clamp": [{ "line-clamp": [
				isNumber$1,
				"none",
				isArbitraryVariable$1,
				isArbitraryNumber$1
			] }],
			leading: [{ leading: [F, ...LL()] }],
			"list-image": [{ "list-image": [
				"none",
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"list-style-position": [{ list: ["inside", "outside"] }],
			"list-style-type": [{ list: [
				"disc",
				"decimal",
				"none",
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"text-alignment": [{ text: [
				"left",
				"center",
				"right",
				"justify",
				"start",
				"end"
			] }],
			"placeholder-color": [{ placeholder: qL() }],
			"text-color": [{ text: qL() }],
			"text-decoration": [
				"underline",
				"overline",
				"line-through",
				"no-underline"
			],
			"text-decoration-style": [{ decoration: [...eR(), "wavy"] }],
			"text-decoration-thickness": [{ decoration: [
				isNumber$1,
				"from-font",
				"auto",
				isArbitraryVariable$1,
				isArbitraryLength$1
			] }],
			"text-decoration-color": [{ decoration: qL() }],
			"underline-offset": [{ "underline-offset": [
				isNumber$1,
				"auto",
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"text-transform": [
				"uppercase",
				"lowercase",
				"capitalize",
				"normal-case"
			],
			"text-overflow": [
				"truncate",
				"text-ellipsis",
				"text-clip"
			],
			"text-wrap": [{ text: [
				"wrap",
				"nowrap",
				"balance",
				"pretty"
			] }],
			indent: [{ indent: LL() }],
			"vertical-align": [{ align: [
				"baseline",
				"top",
				"middle",
				"bottom",
				"text-top",
				"text-bottom",
				"sub",
				"super",
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			whitespace: [{ whitespace: [
				"normal",
				"nowrap",
				"pre",
				"pre-line",
				"pre-wrap",
				"break-spaces"
			] }],
			break: [{ break: [
				"normal",
				"words",
				"all",
				"keep"
			] }],
			wrap: [{ wrap: [
				"break-word",
				"anywhere",
				"normal"
			] }],
			hyphens: [{ hyphens: [
				"none",
				"manual",
				"auto"
			] }],
			content: [{ content: [
				"none",
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"bg-attachment": [{ bg: [
				"fixed",
				"local",
				"scroll"
			] }],
			"bg-clip": [{ "bg-clip": [
				"border",
				"padding",
				"content",
				"text"
			] }],
			"bg-origin": [{ "bg-origin": [
				"border",
				"padding",
				"content"
			] }],
			"bg-position": [{ bg: JL() }],
			"bg-repeat": [{ bg: YL() }],
			"bg-size": [{ bg: XL() }],
			"bg-image": [{ bg: [
				"none",
				{
					linear: [
						{ to: [
							"t",
							"tr",
							"r",
							"br",
							"b",
							"bl",
							"l",
							"tl"
						] },
						isInteger$1,
						isArbitraryVariable$1,
						isArbitraryValue$1
					],
					radial: [
						"",
						isArbitraryVariable$1,
						isArbitraryValue$1
					],
					conic: [
						isInteger$1,
						isArbitraryVariable$1,
						isArbitraryValue$1
					]
				},
				isArbitraryVariableImage$1,
				isArbitraryImage$1
			] }],
			"bg-color": [{ bg: qL() }],
			"gradient-from-pos": [{ from: ZL() }],
			"gradient-via-pos": [{ via: ZL() }],
			"gradient-to-pos": [{ to: ZL() }],
			"gradient-from": [{ from: qL() }],
			"gradient-via": [{ via: qL() }],
			"gradient-to": [{ to: qL() }],
			rounded: [{ rounded: QL() }],
			"rounded-s": [{ "rounded-s": QL() }],
			"rounded-e": [{ "rounded-e": QL() }],
			"rounded-t": [{ "rounded-t": QL() }],
			"rounded-r": [{ "rounded-r": QL() }],
			"rounded-b": [{ "rounded-b": QL() }],
			"rounded-l": [{ "rounded-l": QL() }],
			"rounded-ss": [{ "rounded-ss": QL() }],
			"rounded-se": [{ "rounded-se": QL() }],
			"rounded-ee": [{ "rounded-ee": QL() }],
			"rounded-es": [{ "rounded-es": QL() }],
			"rounded-tl": [{ "rounded-tl": QL() }],
			"rounded-tr": [{ "rounded-tr": QL() }],
			"rounded-br": [{ "rounded-br": QL() }],
			"rounded-bl": [{ "rounded-bl": QL() }],
			"border-w": [{ border: $L() }],
			"border-w-x": [{ "border-x": $L() }],
			"border-w-y": [{ "border-y": $L() }],
			"border-w-s": [{ "border-s": $L() }],
			"border-w-e": [{ "border-e": $L() }],
			"border-w-t": [{ "border-t": $L() }],
			"border-w-r": [{ "border-r": $L() }],
			"border-w-b": [{ "border-b": $L() }],
			"border-w-l": [{ "border-l": $L() }],
			"divide-x": [{ "divide-x": $L() }],
			"divide-x-reverse": ["divide-x-reverse"],
			"divide-y": [{ "divide-y": $L() }],
			"divide-y-reverse": ["divide-y-reverse"],
			"border-style": [{ border: [
				...eR(),
				"hidden",
				"none"
			] }],
			"divide-style": [{ divide: [
				...eR(),
				"hidden",
				"none"
			] }],
			"border-color": [{ border: qL() }],
			"border-color-x": [{ "border-x": qL() }],
			"border-color-y": [{ "border-y": qL() }],
			"border-color-s": [{ "border-s": qL() }],
			"border-color-e": [{ "border-e": qL() }],
			"border-color-t": [{ "border-t": qL() }],
			"border-color-r": [{ "border-r": qL() }],
			"border-color-b": [{ "border-b": qL() }],
			"border-color-l": [{ "border-l": qL() }],
			"divide-color": [{ divide: qL() }],
			"outline-style": [{ outline: [
				...eR(),
				"none",
				"hidden"
			] }],
			"outline-offset": [{ "outline-offset": [
				isNumber$1,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"outline-w": [{ outline: [
				"",
				isNumber$1,
				isArbitraryVariableLength$1,
				isArbitraryLength$1
			] }],
			"outline-color": [{ outline: qL() }],
			shadow: [{ shadow: [
				"",
				"none",
				V,
				isArbitraryVariableShadow$1,
				isArbitraryShadow$1
			] }],
			"shadow-color": [{ shadow: qL() }],
			"inset-shadow": [{ "inset-shadow": [
				"none",
				U,
				isArbitraryVariableShadow$1,
				isArbitraryShadow$1
			] }],
			"inset-shadow-color": [{ "inset-shadow": qL() }],
			"ring-w": [{ ring: $L() }],
			"ring-w-inset": ["ring-inset"],
			"ring-color": [{ ring: qL() }],
			"ring-offset-w": [{ "ring-offset": [isNumber$1, isArbitraryLength$1] }],
			"ring-offset-color": [{ "ring-offset": qL() }],
			"inset-ring-w": [{ "inset-ring": $L() }],
			"inset-ring-color": [{ "inset-ring": qL() }],
			"text-shadow": [{ "text-shadow": [
				"none",
				W,
				isArbitraryVariableShadow$1,
				isArbitraryShadow$1
			] }],
			"text-shadow-color": [{ "text-shadow": qL() }],
			opacity: [{ opacity: [
				isNumber$1,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"mix-blend": [{ "mix-blend": [
				...tR(),
				"plus-darker",
				"plus-lighter"
			] }],
			"bg-blend": [{ "bg-blend": tR() }],
			"mask-clip": [{ "mask-clip": [
				"border",
				"padding",
				"content",
				"fill",
				"stroke",
				"view"
			] }, "mask-no-clip"],
			"mask-composite": [{ mask: [
				"add",
				"subtract",
				"intersect",
				"exclude"
			] }],
			"mask-image-linear-pos": [{ "mask-linear": [isNumber$1] }],
			"mask-image-linear-from-pos": [{ "mask-linear-from": nR() }],
			"mask-image-linear-to-pos": [{ "mask-linear-to": nR() }],
			"mask-image-linear-from-color": [{ "mask-linear-from": qL() }],
			"mask-image-linear-to-color": [{ "mask-linear-to": qL() }],
			"mask-image-t-from-pos": [{ "mask-t-from": nR() }],
			"mask-image-t-to-pos": [{ "mask-t-to": nR() }],
			"mask-image-t-from-color": [{ "mask-t-from": qL() }],
			"mask-image-t-to-color": [{ "mask-t-to": qL() }],
			"mask-image-r-from-pos": [{ "mask-r-from": nR() }],
			"mask-image-r-to-pos": [{ "mask-r-to": nR() }],
			"mask-image-r-from-color": [{ "mask-r-from": qL() }],
			"mask-image-r-to-color": [{ "mask-r-to": qL() }],
			"mask-image-b-from-pos": [{ "mask-b-from": nR() }],
			"mask-image-b-to-pos": [{ "mask-b-to": nR() }],
			"mask-image-b-from-color": [{ "mask-b-from": qL() }],
			"mask-image-b-to-color": [{ "mask-b-to": qL() }],
			"mask-image-l-from-pos": [{ "mask-l-from": nR() }],
			"mask-image-l-to-pos": [{ "mask-l-to": nR() }],
			"mask-image-l-from-color": [{ "mask-l-from": qL() }],
			"mask-image-l-to-color": [{ "mask-l-to": qL() }],
			"mask-image-x-from-pos": [{ "mask-x-from": nR() }],
			"mask-image-x-to-pos": [{ "mask-x-to": nR() }],
			"mask-image-x-from-color": [{ "mask-x-from": qL() }],
			"mask-image-x-to-color": [{ "mask-x-to": qL() }],
			"mask-image-y-from-pos": [{ "mask-y-from": nR() }],
			"mask-image-y-to-pos": [{ "mask-y-to": nR() }],
			"mask-image-y-from-color": [{ "mask-y-from": qL() }],
			"mask-image-y-to-color": [{ "mask-y-to": qL() }],
			"mask-image-radial": [{ "mask-radial": [isArbitraryVariable$1, isArbitraryValue$1] }],
			"mask-image-radial-from-pos": [{ "mask-radial-from": nR() }],
			"mask-image-radial-to-pos": [{ "mask-radial-to": nR() }],
			"mask-image-radial-from-color": [{ "mask-radial-from": qL() }],
			"mask-image-radial-to-color": [{ "mask-radial-to": qL() }],
			"mask-image-radial-shape": [{ "mask-radial": ["circle", "ellipse"] }],
			"mask-image-radial-size": [{ "mask-radial": [{
				closest: ["side", "corner"],
				farthest: ["side", "corner"]
			}] }],
			"mask-image-radial-pos": [{ "mask-radial-at": NL() }],
			"mask-image-conic-pos": [{ "mask-conic": [isNumber$1] }],
			"mask-image-conic-from-pos": [{ "mask-conic-from": nR() }],
			"mask-image-conic-to-pos": [{ "mask-conic-to": nR() }],
			"mask-image-conic-from-color": [{ "mask-conic-from": qL() }],
			"mask-image-conic-to-color": [{ "mask-conic-to": qL() }],
			"mask-mode": [{ mask: [
				"alpha",
				"luminance",
				"match"
			] }],
			"mask-origin": [{ "mask-origin": [
				"border",
				"padding",
				"content",
				"fill",
				"stroke",
				"view"
			] }],
			"mask-position": [{ mask: JL() }],
			"mask-repeat": [{ mask: YL() }],
			"mask-size": [{ mask: XL() }],
			"mask-type": [{ "mask-type": ["alpha", "luminance"] }],
			"mask-image": [{ mask: [
				"none",
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			filter: [{ filter: [
				"",
				"none",
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			blur: [{ blur: rR() }],
			brightness: [{ brightness: [
				isNumber$1,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			contrast: [{ contrast: [
				isNumber$1,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"drop-shadow": [{ "drop-shadow": [
				"",
				"none",
				G,
				isArbitraryVariableShadow$1,
				isArbitraryShadow$1
			] }],
			"drop-shadow-color": [{ "drop-shadow": qL() }],
			grayscale: [{ grayscale: [
				"",
				isNumber$1,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"hue-rotate": [{ "hue-rotate": [
				isNumber$1,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			invert: [{ invert: [
				"",
				isNumber$1,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			saturate: [{ saturate: [
				isNumber$1,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			sepia: [{ sepia: [
				"",
				isNumber$1,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"backdrop-filter": [{ "backdrop-filter": [
				"",
				"none",
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"backdrop-blur": [{ "backdrop-blur": rR() }],
			"backdrop-brightness": [{ "backdrop-brightness": [
				isNumber$1,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"backdrop-contrast": [{ "backdrop-contrast": [
				isNumber$1,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"backdrop-grayscale": [{ "backdrop-grayscale": [
				"",
				isNumber$1,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"backdrop-hue-rotate": [{ "backdrop-hue-rotate": [
				isNumber$1,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"backdrop-invert": [{ "backdrop-invert": [
				"",
				isNumber$1,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"backdrop-opacity": [{ "backdrop-opacity": [
				isNumber$1,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"backdrop-saturate": [{ "backdrop-saturate": [
				isNumber$1,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"backdrop-sepia": [{ "backdrop-sepia": [
				"",
				isNumber$1,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"border-collapse": [{ border: ["collapse", "separate"] }],
			"border-spacing": [{ "border-spacing": LL() }],
			"border-spacing-x": [{ "border-spacing-x": LL() }],
			"border-spacing-y": [{ "border-spacing-y": LL() }],
			"table-layout": [{ table: ["auto", "fixed"] }],
			caption: [{ caption: ["top", "bottom"] }],
			transition: [{ transition: [
				"",
				"all",
				"colors",
				"opacity",
				"shadow",
				"transform",
				"none",
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"transition-behavior": [{ transition: ["normal", "discrete"] }],
			duration: [{ duration: [
				isNumber$1,
				"initial",
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			ease: [{ ease: [
				"linear",
				"initial",
				X,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			delay: [{ delay: [
				isNumber$1,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			animate: [{ animate: [
				"none",
				Z,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			backface: [{ backface: ["hidden", "visible"] }],
			perspective: [{ perspective: [
				J,
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"perspective-origin": [{ "perspective-origin": PL() }],
			rotate: [{ rotate: iR() }],
			"rotate-x": [{ "rotate-x": iR() }],
			"rotate-y": [{ "rotate-y": iR() }],
			"rotate-z": [{ "rotate-z": iR() }],
			scale: [{ scale: aR() }],
			"scale-x": [{ "scale-x": aR() }],
			"scale-y": [{ "scale-y": aR() }],
			"scale-z": [{ "scale-z": aR() }],
			"scale-3d": ["scale-3d"],
			skew: [{ skew: oR() }],
			"skew-x": [{ "skew-x": oR() }],
			"skew-y": [{ "skew-y": oR() }],
			transform: [{ transform: [
				isArbitraryVariable$1,
				isArbitraryValue$1,
				"",
				"none",
				"gpu",
				"cpu"
			] }],
			"transform-origin": [{ origin: PL() }],
			"transform-style": [{ transform: ["3d", "flat"] }],
			translate: [{ translate: sR() }],
			"translate-x": [{ "translate-x": sR() }],
			"translate-y": [{ "translate-y": sR() }],
			"translate-z": [{ "translate-z": sR() }],
			"translate-none": ["translate-none"],
			accent: [{ accent: qL() }],
			appearance: [{ appearance: ["none", "auto"] }],
			"caret-color": [{ caret: qL() }],
			"color-scheme": [{ scheme: [
				"normal",
				"dark",
				"light",
				"light-dark",
				"only-dark",
				"only-light"
			] }],
			cursor: [{ cursor: [
				"auto",
				"default",
				"pointer",
				"wait",
				"text",
				"move",
				"help",
				"not-allowed",
				"none",
				"context-menu",
				"progress",
				"cell",
				"crosshair",
				"vertical-text",
				"alias",
				"copy",
				"no-drop",
				"grab",
				"grabbing",
				"all-scroll",
				"col-resize",
				"row-resize",
				"n-resize",
				"e-resize",
				"s-resize",
				"w-resize",
				"ne-resize",
				"nw-resize",
				"se-resize",
				"sw-resize",
				"ew-resize",
				"ns-resize",
				"nesw-resize",
				"nwse-resize",
				"zoom-in",
				"zoom-out",
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			"field-sizing": [{ "field-sizing": ["fixed", "content"] }],
			"pointer-events": [{ "pointer-events": ["auto", "none"] }],
			resize: [{ resize: [
				"none",
				"",
				"y",
				"x"
			] }],
			"scroll-behavior": [{ scroll: ["auto", "smooth"] }],
			"scroll-m": [{ "scroll-m": LL() }],
			"scroll-mx": [{ "scroll-mx": LL() }],
			"scroll-my": [{ "scroll-my": LL() }],
			"scroll-ms": [{ "scroll-ms": LL() }],
			"scroll-me": [{ "scroll-me": LL() }],
			"scroll-mt": [{ "scroll-mt": LL() }],
			"scroll-mr": [{ "scroll-mr": LL() }],
			"scroll-mb": [{ "scroll-mb": LL() }],
			"scroll-ml": [{ "scroll-ml": LL() }],
			"scroll-p": [{ "scroll-p": LL() }],
			"scroll-px": [{ "scroll-px": LL() }],
			"scroll-py": [{ "scroll-py": LL() }],
			"scroll-ps": [{ "scroll-ps": LL() }],
			"scroll-pe": [{ "scroll-pe": LL() }],
			"scroll-pt": [{ "scroll-pt": LL() }],
			"scroll-pr": [{ "scroll-pr": LL() }],
			"scroll-pb": [{ "scroll-pb": LL() }],
			"scroll-pl": [{ "scroll-pl": LL() }],
			"snap-align": [{ snap: [
				"start",
				"end",
				"center",
				"align-none"
			] }],
			"snap-stop": [{ snap: ["normal", "always"] }],
			"snap-type": [{ snap: [
				"none",
				"x",
				"y",
				"both"
			] }],
			"snap-strictness": [{ snap: ["mandatory", "proximity"] }],
			touch: [{ touch: [
				"auto",
				"none",
				"manipulation"
			] }],
			"touch-x": [{ "touch-pan": [
				"x",
				"left",
				"right"
			] }],
			"touch-y": [{ "touch-pan": [
				"y",
				"up",
				"down"
			] }],
			"touch-pz": ["touch-pinch-zoom"],
			select: [{ select: [
				"none",
				"text",
				"all",
				"auto"
			] }],
			"will-change": [{ "will-change": [
				"auto",
				"scroll",
				"contents",
				"transform",
				isArbitraryVariable$1,
				isArbitraryValue$1
			] }],
			fill: [{ fill: ["none", ...qL()] }],
			"stroke-w": [{ stroke: [
				isNumber$1,
				isArbitraryVariableLength$1,
				isArbitraryLength$1,
				isArbitraryNumber$1
			] }],
			stroke: [{ stroke: ["none", ...qL()] }],
			"forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }]
		},
		conflictingClassGroups: {
			overflow: ["overflow-x", "overflow-y"],
			overscroll: ["overscroll-x", "overscroll-y"],
			inset: [
				"inset-x",
				"inset-y",
				"start",
				"end",
				"top",
				"right",
				"bottom",
				"left"
			],
			"inset-x": ["right", "left"],
			"inset-y": ["top", "bottom"],
			flex: [
				"basis",
				"grow",
				"shrink"
			],
			gap: ["gap-x", "gap-y"],
			p: [
				"px",
				"py",
				"ps",
				"pe",
				"pt",
				"pr",
				"pb",
				"pl"
			],
			px: ["pr", "pl"],
			py: ["pt", "pb"],
			m: [
				"mx",
				"my",
				"ms",
				"me",
				"mt",
				"mr",
				"mb",
				"ml"
			],
			mx: ["mr", "ml"],
			my: ["mt", "mb"],
			size: ["w", "h"],
			"font-size": ["leading"],
			"fvn-normal": [
				"fvn-ordinal",
				"fvn-slashed-zero",
				"fvn-figure",
				"fvn-spacing",
				"fvn-fraction"
			],
			"fvn-ordinal": ["fvn-normal"],
			"fvn-slashed-zero": ["fvn-normal"],
			"fvn-figure": ["fvn-normal"],
			"fvn-spacing": ["fvn-normal"],
			"fvn-fraction": ["fvn-normal"],
			"line-clamp": ["display", "overflow"],
			rounded: [
				"rounded-s",
				"rounded-e",
				"rounded-t",
				"rounded-r",
				"rounded-b",
				"rounded-l",
				"rounded-ss",
				"rounded-se",
				"rounded-ee",
				"rounded-es",
				"rounded-tl",
				"rounded-tr",
				"rounded-br",
				"rounded-bl"
			],
			"rounded-s": ["rounded-ss", "rounded-es"],
			"rounded-e": ["rounded-se", "rounded-ee"],
			"rounded-t": ["rounded-tl", "rounded-tr"],
			"rounded-r": ["rounded-tr", "rounded-br"],
			"rounded-b": ["rounded-br", "rounded-bl"],
			"rounded-l": ["rounded-tl", "rounded-bl"],
			"border-spacing": ["border-spacing-x", "border-spacing-y"],
			"border-w": [
				"border-w-x",
				"border-w-y",
				"border-w-s",
				"border-w-e",
				"border-w-t",
				"border-w-r",
				"border-w-b",
				"border-w-l"
			],
			"border-w-x": ["border-w-r", "border-w-l"],
			"border-w-y": ["border-w-t", "border-w-b"],
			"border-color": [
				"border-color-x",
				"border-color-y",
				"border-color-s",
				"border-color-e",
				"border-color-t",
				"border-color-r",
				"border-color-b",
				"border-color-l"
			],
			"border-color-x": ["border-color-r", "border-color-l"],
			"border-color-y": ["border-color-t", "border-color-b"],
			translate: [
				"translate-x",
				"translate-y",
				"translate-none"
			],
			"translate-none": [
				"translate",
				"translate-x",
				"translate-y",
				"translate-z"
			],
			"scroll-m": [
				"scroll-mx",
				"scroll-my",
				"scroll-ms",
				"scroll-me",
				"scroll-mt",
				"scroll-mr",
				"scroll-mb",
				"scroll-ml"
			],
			"scroll-mx": ["scroll-mr", "scroll-ml"],
			"scroll-my": ["scroll-mt", "scroll-mb"],
			"scroll-p": [
				"scroll-px",
				"scroll-py",
				"scroll-ps",
				"scroll-pe",
				"scroll-pt",
				"scroll-pr",
				"scroll-pb",
				"scroll-pl"
			],
			"scroll-px": ["scroll-pr", "scroll-pl"],
			"scroll-py": ["scroll-pt", "scroll-pb"],
			touch: [
				"touch-x",
				"touch-y",
				"touch-pz"
			],
			"touch-x": ["touch"],
			"touch-y": ["touch"],
			"touch-pz": ["touch"]
		},
		conflictingClassGroupModifiers: { "font-size": ["leading"] },
		orderSensitiveModifiers: [
			"*",
			"**",
			"after",
			"backdrop",
			"before",
			"details-content",
			"file",
			"first-letter",
			"first-line",
			"marker",
			"placeholder",
			"selection"
		]
	};
});
function _objectWithoutPropertiesLoose(C, T) {
	if (C == null) return {};
	var E = {};
	for (var D in C) if ({}.hasOwnProperty.call(C, D)) {
		if (T.includes(D)) continue;
		E[D] = C[D];
	}
	return E;
}
function _objectWithoutProperties(C, T) {
	if (C == null) return {};
	var E, D, O = _objectWithoutPropertiesLoose(C, T);
	if (Object.getOwnPropertySymbols) {
		var F = Object.getOwnPropertySymbols(C);
		for (D = 0; D < F.length; D++) E = F[D], T.includes(E) || {}.propertyIsEnumerable.call(C, E) && (O[E] = C[E]);
	}
	return O;
}
var linear$1 = (C) => C;
function cubic_out(C) {
	let T = C - 1;
	return T * T * T + 1;
}
function split_css_unit(C) {
	let T = typeof C == "string" && C.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
	return T ? [parseFloat(T[1]), T[2] || "px"] : [C, "px"];
}
function fade(C, { delay: T = 0, duration: E = 400, easing: D = linear$1 } = {}) {
	let O = +getComputedStyle(C).opacity;
	return {
		delay: T,
		duration: E,
		easing: D,
		css: (C) => `opacity: ${C * O}`
	};
}
function fly(C, { delay: T = 0, duration: E = 400, easing: D = cubic_out, x: O = 0, y: F = 0, opacity: I = 0 } = {}) {
	let L = getComputedStyle(C), z = +L.opacity, B = L.transform === "none" ? "" : L.transform, V = z * (1 - I), [U, W] = split_css_unit(O), [G, K] = split_css_unit(F);
	return {
		delay: T,
		duration: E,
		easing: D,
		css: (C, T) => `
			transform: ${B} translate(${(1 - C) * U}${W}, ${(1 - C) * G}${K});
			opacity: ${z - V * T}`
	};
}
function slide(C, { delay: T = 0, duration: E = 400, easing: D = cubic_out, axis: O = "y" } = {}) {
	let F = getComputedStyle(C), I = +F.opacity, L = O === "y" ? "height" : "width", z = parseFloat(F[L]), B = O === "y" ? ["top", "bottom"] : ["left", "right"], V = B.map((C) => `${C[0].toUpperCase()}${C.slice(1)}`), U = parseFloat(F[`padding${V[0]}`]), W = parseFloat(F[`padding${V[1]}`]), G = parseFloat(F[`margin${V[0]}`]), K = parseFloat(F[`margin${V[1]}`]), J = parseFloat(F[`border${V[0]}Width`]), Y = parseFloat(F[`border${V[1]}Width`]);
	return {
		delay: T,
		duration: E,
		easing: D,
		css: (C) => `overflow: hidden;opacity: ${Math.min(C * 20, 1) * I};${L}: ${C * z}px;padding-${B[0]}: ${C * U}px;padding-${B[1]}: ${C * W}px;margin-${B[0]}: ${C * G}px;margin-${B[1]}: ${C * K}px;border-${B[0]}-width: ${C * J}px;border-${B[1]}-width: ${C * Y}px;min-${L}: 0`
	};
}
var root_4$34 = /* @__PURE__ */ from_svg("<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 10 6\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9 5 5 1 1 5\"></path></svg>"), root_7$16 = /* @__PURE__ */ from_svg("<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 10 6\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"m1 1 4 4 4-4\"></path></svg>"), root_1$110 = /* @__PURE__ */ from_html("<!> <!>", 1), root_9$10 = /* @__PURE__ */ from_html("<div><div><!></div></div>"), root$133 = /* @__PURE__ */ from_html("<h2><button><!></button></h2> <!>", 1);
function AccordionItem(C, T) {
	var E;
	push(T, !0);
	let D = prop(T, "children", 7), O = prop(T, "header", 7), F = prop(T, "arrowup", 7), I = prop(T, "arrowdown", 7), L = prop(T, "open", 15, !1), z = prop(T, "activeClass", 7), B = prop(T, "inactiveClass", 7), V = prop(T, "transition", 7, slide), U = prop(T, "params", 7), W = prop(T, "class", 7), G = prop(T, "arrowColor", 7), K = prop(T, "isArrowShow", 7, !0), J = (E = getContext("ctx")) == null ? {} : E;
	J.selected || (J.selected = writable());
	let Y = {}, X = J.isSingle ? J.selected : writable();
	L() && X.set(Y), X.subscribe((C) => L(C === Y));
	let Z = () => X.set(L() ? {} : Y), { base: Q, button: NL, content: PL, active: FL, inactive: IL } = accordionitem({
		flush: J.flush,
		open: L()
	}), LL = /* @__PURE__ */ user_derived(() => twMerge(NL(), L() && !J.flush && (z() || J.activeClass || FL()), !L() && !J.flush && (B() || J.inactiveClass || IL()), W())), RL = /* @__PURE__ */ user_derived(() => twMerge("h-3 w-3 dark:text-white", G()));
	var zL = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get header() {
			return O();
		},
		set header(C) {
			O(C), flushSync();
		},
		get arrowup() {
			return F();
		},
		set arrowup(C) {
			F(C), flushSync();
		},
		get arrowdown() {
			return I();
		},
		set arrowdown(C) {
			I(C), flushSync();
		},
		get open() {
			return L();
		},
		set open(C = !1) {
			L(C), flushSync();
		},
		get activeClass() {
			return z();
		},
		set activeClass(C) {
			z(C), flushSync();
		},
		get inactiveClass() {
			return B();
		},
		set inactiveClass(C) {
			B(C), flushSync();
		},
		get transition() {
			return V();
		},
		set transition(C = slide) {
			V(C), flushSync();
		},
		get params() {
			return U();
		},
		set params(C) {
			U(C), flushSync();
		},
		get class() {
			return W();
		},
		set class(C) {
			W(C), flushSync();
		},
		get arrowColor() {
			return G();
		},
		set arrowColor(C) {
			G(C), flushSync();
		},
		get isArrowShow() {
			return K();
		},
		set isArrowShow(C = !0) {
			K(C), flushSync();
		}
	}, BL = root$133(), VL = first_child(BL), HL = child(VL);
	HL.__click = Z;
	var UL = child(HL), WL = (C) => {
		var T = root_1$110(), E = first_child(T);
		snippet(E, O);
		var D = sibling(E, 2), z = (C) => {
			var T = comment(), E = first_child(T), D = (C) => {
				var T = comment(), E = first_child(T), D = (C) => {
					var T = root_4$34();
					template_effect(() => set_class(T, 0, clsx$1(get(RL)))), append(C, T);
				}, O = (C) => {
					var T = comment();
					snippet(first_child(T), F), append(C, T);
				};
				if_block(E, (C) => {
					F() ? C(O, !1) : C(D);
				}), append(C, T);
			}, O = (C) => {
				var T = comment(), E = first_child(T), D = (C) => {
					var T = root_7$16();
					template_effect(() => set_class(T, 0, clsx$1(get(RL)))), append(C, T);
				}, O = (C) => {
					var T = comment();
					snippet(first_child(T), I), append(C, T);
				};
				if_block(E, (C) => {
					I() ? C(O, !1) : C(D);
				}, !0), append(C, T);
			};
			if_block(E, (C) => {
				L() ? C(D) : C(O, !1);
			}), append(C, T);
		};
		if_block(D, (C) => {
			K() && C(z);
		}), append(C, T);
	};
	if_block(UL, (C) => {
		O() && C(WL);
	}), reset(HL), reset(VL);
	var GL = sibling(VL, 2), KL = (C) => {
		var T = root_9$10(), E = child(T);
		snippet(child(E), D), reset(E), reset(T), template_effect((C) => set_class(E, 1, C), [() => clsx$1(PL())]), transition(3, T, V, U), append(C, T);
	};
	return if_block(GL, (C) => {
		L() && C(KL);
	}), template_effect((C) => {
		set_class(VL, 1, C), set_class(HL, 1, clsx$1(get(LL))), set_attribute(HL, "aria-expanded", L());
	}, [() => clsx$1(Q())]), append(C, BL), pop(zL);
}
delegate(["click"]), create_custom_element(AccordionItem, {
	children: {},
	header: {},
	arrowup: {},
	arrowdown: {},
	open: {},
	activeClass: {},
	inactiveClass: {},
	transition: {},
	params: {},
	class: {},
	arrowColor: {},
	isArrowShow: {}
}, [], [], !0);
var l$1 = (C) => typeof C == "boolean" ? `${C}` : C === 0 ? "0" : C, u$1 = (C) => !C || typeof C != "object" || Object.keys(C).length === 0, x$1 = (C, T) => JSON.stringify(C) === JSON.stringify(T);
function i$1(C, T) {
	C.forEach(function(C) {
		Array.isArray(C) ? i$1(C, T) : T.push(C);
	});
}
function y$1(C) {
	let T = [];
	return i$1(C, T), T;
}
var a$1 = (...C) => y$1(C).filter(Boolean), p$1 = (C, T) => {
	let E = {}, D = Object.keys(C), O = Object.keys(T);
	for (let F of D) if (O.includes(F)) {
		let D = C[F], O = T[F];
		Array.isArray(D) || Array.isArray(O) ? E[F] = a$1(O, D) : typeof D == "object" && typeof O == "object" ? E[F] = p$1(D, O) : E[F] = O + " " + D;
	} else E[F] = C[F];
	for (let C of O) D.includes(C) || (E[C] = T[C]);
	return E;
}, g$1 = (C) => !C || typeof C != "string" ? C : C.replace(/\s+/g, " ").trim(), CLASS_PART_SEPARATOR = "-", createClassGroupUtils = (C) => {
	let T = createClassMap(C), { conflictingClassGroups: E, conflictingClassGroupModifiers: D } = C;
	return {
		getClassGroupId: (C) => {
			let E = C.split(CLASS_PART_SEPARATOR);
			return E[0] === "" && E.length !== 1 && E.shift(), getGroupRecursive(E, T) || getGroupIdForArbitraryProperty(C);
		},
		getConflictingClassGroupIds: (C, T) => {
			let O = E[C] || [];
			return T && D[C] ? [...O, ...D[C]] : O;
		}
	};
}, getGroupRecursive = (C, T) => {
	var E;
	if (C.length === 0) return T.classGroupId;
	let D = C[0], O = T.nextPart.get(D), F = O ? getGroupRecursive(C.slice(1), O) : void 0;
	if (F) return F;
	if (T.validators.length === 0) return;
	let I = C.join(CLASS_PART_SEPARATOR);
	return (E = T.validators.find(({ validator: C }) => C(I))) == null ? void 0 : E.classGroupId;
}, arbitraryPropertyRegex = /^\[(.+)\]$/, getGroupIdForArbitraryProperty = (C) => {
	if (arbitraryPropertyRegex.test(C)) {
		let T = arbitraryPropertyRegex.exec(C)[1], E = T == null ? void 0 : T.substring(0, T.indexOf(":"));
		if (E) return "arbitrary.." + E;
	}
}, createClassMap = (C) => {
	let { theme: T, classGroups: E } = C, D = {
		nextPart: /* @__PURE__ */ new Map(),
		validators: []
	};
	for (let C in E) processClassesRecursively(E[C], D, C, T);
	return D;
}, processClassesRecursively = (C, T, E, D) => {
	C.forEach((C) => {
		if (typeof C == "string") {
			let D = C === "" ? T : getPart(T, C);
			D.classGroupId = E;
			return;
		}
		if (typeof C == "function") {
			if (isThemeGetter(C)) {
				processClassesRecursively(C(D), T, E, D);
				return;
			}
			T.validators.push({
				validator: C,
				classGroupId: E
			});
			return;
		}
		Object.entries(C).forEach(([C, O]) => {
			processClassesRecursively(O, getPart(T, C), E, D);
		});
	});
}, getPart = (C, T) => {
	let E = C;
	return T.split(CLASS_PART_SEPARATOR).forEach((C) => {
		E.nextPart.has(C) || E.nextPart.set(C, {
			nextPart: /* @__PURE__ */ new Map(),
			validators: []
		}), E = E.nextPart.get(C);
	}), E;
}, isThemeGetter = (C) => C.isThemeGetter, createLruCache = (C) => {
	if (C < 1) return {
		get: () => void 0,
		set: () => {}
	};
	let T = 0, E = /* @__PURE__ */ new Map(), D = /* @__PURE__ */ new Map(), O = (O, F) => {
		E.set(O, F), T++, T > C && (T = 0, D = E, E = /* @__PURE__ */ new Map());
	};
	return {
		get(C) {
			let T = E.get(C);
			if (T !== void 0) return T;
			if ((T = D.get(C)) !== void 0) return O(C, T), T;
		},
		set(C, T) {
			E.has(C) ? E.set(C, T) : O(C, T);
		}
	};
}, IMPORTANT_MODIFIER = "!", MODIFIER_SEPARATOR = ":", MODIFIER_SEPARATOR_LENGTH = 1, createParseClassName = (C) => {
	let { prefix: T, experimentalParseClassName: E } = C, D = (C) => {
		let T = [], E = 0, D = 0, O = 0, F;
		for (let I = 0; I < C.length; I++) {
			let L = C[I];
			if (E === 0 && D === 0) {
				if (L === MODIFIER_SEPARATOR) {
					T.push(C.slice(O, I)), O = I + MODIFIER_SEPARATOR_LENGTH;
					continue;
				}
				if (L === "/") {
					F = I;
					continue;
				}
			}
			L === "[" ? E++ : L === "]" ? E-- : L === "(" ? D++ : L === ")" && D--;
		}
		let I = T.length === 0 ? C : C.substring(O), L = stripImportantModifier(I);
		return {
			modifiers: T,
			hasImportantModifier: L !== I,
			baseClassName: L,
			maybePostfixModifierPosition: F && F > O ? F - O : void 0
		};
	};
	if (T) {
		let C = T + MODIFIER_SEPARATOR, E = D;
		D = (T) => T.startsWith(C) ? E(T.substring(C.length)) : {
			isExternal: !0,
			modifiers: [],
			hasImportantModifier: !1,
			baseClassName: T,
			maybePostfixModifierPosition: void 0
		};
	}
	if (E) {
		let C = D;
		D = (T) => E({
			className: T,
			parseClassName: C
		});
	}
	return D;
}, stripImportantModifier = (C) => C.endsWith(IMPORTANT_MODIFIER) ? C.substring(0, C.length - 1) : C.startsWith(IMPORTANT_MODIFIER) ? C.substring(1) : C, createSortModifiers = (C) => {
	let T = Object.fromEntries(C.orderSensitiveModifiers.map((C) => [C, !0]));
	return (C) => {
		if (C.length <= 1) return C;
		let E = [], D = [];
		return C.forEach((C) => {
			C[0] === "[" || T[C] ? (E.push(...D.sort(), C), D = []) : D.push(C);
		}), E.push(...D.sort()), E;
	};
}, createConfigUtils = (C) => _objectSpread2({
	cache: createLruCache(C.cacheSize),
	parseClassName: createParseClassName(C),
	sortModifiers: createSortModifiers(C)
}, createClassGroupUtils(C)), SPLIT_CLASSES_REGEX = /\s+/, mergeClassList = (C, T) => {
	let { parseClassName: E, getClassGroupId: D, getConflictingClassGroupIds: O, sortModifiers: F } = T, I = [], L = C.trim().split(SPLIT_CLASSES_REGEX), z = "";
	for (let C = L.length - 1; C >= 0; --C) {
		let T = L[C], { isExternal: B, modifiers: V, hasImportantModifier: U, baseClassName: W, maybePostfixModifierPosition: G } = E(T);
		if (B) {
			z = T + (z.length > 0 ? " " + z : z);
			continue;
		}
		let K = !!G, J = D(K ? W.substring(0, G) : W);
		if (!J) {
			if (!K) {
				z = T + (z.length > 0 ? " " + z : z);
				continue;
			}
			if (J = D(W), !J) {
				z = T + (z.length > 0 ? " " + z : z);
				continue;
			}
			K = !1;
		}
		let Y = F(V).join(":"), X = U ? Y + IMPORTANT_MODIFIER : Y, Z = X + J;
		if (I.includes(Z)) continue;
		I.push(Z);
		let Q = O(J, K);
		for (let C = 0; C < Q.length; ++C) {
			let T = Q[C];
			I.push(X + T);
		}
		z = T + (z.length > 0 ? " " + z : z);
	}
	return z;
};
function twJoin() {
	let C = 0, T, E, D = "";
	for (; C < arguments.length;) (T = arguments[C++]) && (E = toValue(T)) && (D && (D += " "), D += E);
	return D;
}
var toValue = (C) => {
	if (typeof C == "string") return C;
	let T, E = "";
	for (let D = 0; D < C.length; D++) C[D] && (T = toValue(C[D])) && (E && (E += " "), E += T);
	return E;
};
function createTailwindMerge(C, ...T) {
	let E, D, O, F = I;
	function I(I) {
		return E = createConfigUtils(T.reduce((C, T) => T(C), C())), D = E.cache.get, O = E.cache.set, F = L, L(I);
	}
	function L(C) {
		let T = D(C);
		if (T) return T;
		let F = mergeClassList(C, E);
		return O(C, F), F;
	}
	return function() {
		return F(twJoin.apply(null, arguments));
	};
}
var fromTheme = (C) => {
	let T = (T) => T[C] || [];
	return T.isThemeGetter = !0, T;
}, arbitraryValueRegex = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, arbitraryVariableRegex = /^\((?:(\w[\w-]*):)?(.+)\)$/i, fractionRegex = /^\d+\/\d+$/, tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, isFraction = (C) => fractionRegex.test(C), isNumber = (C) => !!C && !Number.isNaN(Number(C)), isInteger = (C) => !!C && Number.isInteger(Number(C)), isPercent = (C) => C.endsWith("%") && isNumber(C.slice(0, -1)), isTshirtSize = (C) => tshirtUnitRegex.test(C), isAny = () => !0, isLengthOnly = (C) => lengthUnitRegex.test(C) && !colorFunctionRegex.test(C), isNever = () => !1, isShadow = (C) => shadowRegex.test(C), isImage = (C) => imageRegex.test(C), isAnyNonArbitrary = (C) => !isArbitraryValue(C) && !isArbitraryVariable(C), isArbitrarySize = (C) => getIsArbitraryValue(C, isLabelSize, isNever), isArbitraryValue = (C) => arbitraryValueRegex.test(C), isArbitraryLength = (C) => getIsArbitraryValue(C, isLabelLength, isLengthOnly), isArbitraryNumber = (C) => getIsArbitraryValue(C, isLabelNumber, isNumber), isArbitraryPosition = (C) => getIsArbitraryValue(C, isLabelPosition, isNever), isArbitraryImage = (C) => getIsArbitraryValue(C, isLabelImage, isImage), isArbitraryShadow = (C) => getIsArbitraryValue(C, isNever, isShadow), isArbitraryVariable = (C) => arbitraryVariableRegex.test(C), isArbitraryVariableLength = (C) => getIsArbitraryVariable(C, isLabelLength), isArbitraryVariableFamilyName = (C) => getIsArbitraryVariable(C, isLabelFamilyName), isArbitraryVariablePosition = (C) => getIsArbitraryVariable(C, isLabelPosition), isArbitraryVariableSize = (C) => getIsArbitraryVariable(C, isLabelSize), isArbitraryVariableImage = (C) => getIsArbitraryVariable(C, isLabelImage), isArbitraryVariableShadow = (C) => getIsArbitraryVariable(C, isLabelShadow, !0), getIsArbitraryValue = (C, T, E) => {
	let D = arbitraryValueRegex.exec(C);
	return D ? D[1] ? T(D[1]) : E(D[2]) : !1;
}, getIsArbitraryVariable = (C, T, E = !1) => {
	let D = arbitraryVariableRegex.exec(C);
	return D ? D[1] ? T(D[1]) : E : !1;
}, isLabelPosition = (C) => C === "position", imageLabels = /* @__PURE__ */ new Set(["image", "url"]), isLabelImage = (C) => imageLabels.has(C), sizeLabels = /* @__PURE__ */ new Set([
	"length",
	"size",
	"percentage"
]), isLabelSize = (C) => sizeLabels.has(C), isLabelLength = (C) => C === "length", isLabelNumber = (C) => C === "number", isLabelFamilyName = (C) => C === "family-name", isLabelShadow = (C) => C === "shadow", getDefaultConfig = () => {
	let C = fromTheme("color"), T = fromTheme("font"), E = fromTheme("text"), D = fromTheme("font-weight"), O = fromTheme("tracking"), F = fromTheme("leading"), I = fromTheme("breakpoint"), L = fromTheme("container"), z = fromTheme("spacing"), B = fromTheme("radius"), V = fromTheme("shadow"), U = fromTheme("inset-shadow"), W = fromTheme("drop-shadow"), G = fromTheme("blur"), K = fromTheme("perspective"), J = fromTheme("aspect"), Y = fromTheme("ease"), X = fromTheme("animate"), Z = () => [
		"auto",
		"avoid",
		"all",
		"avoid-page",
		"page",
		"left",
		"right",
		"column"
	], Q = () => [
		"bottom",
		"center",
		"left",
		"left-bottom",
		"left-top",
		"right",
		"right-bottom",
		"right-top",
		"top"
	], NL = () => [
		"auto",
		"hidden",
		"clip",
		"visible",
		"scroll"
	], PL = () => [
		"auto",
		"contain",
		"none"
	], FL = () => [
		isArbitraryVariable,
		isArbitraryValue,
		z
	], IL = () => [
		isFraction,
		"full",
		"auto",
		...FL()
	], LL = () => [
		isInteger,
		"none",
		"subgrid",
		isArbitraryVariable,
		isArbitraryValue
	], RL = () => [
		"auto",
		{ span: [
			"full",
			isInteger,
			isArbitraryVariable,
			isArbitraryValue
		] },
		isArbitraryVariable,
		isArbitraryValue
	], zL = () => [
		isInteger,
		"auto",
		isArbitraryVariable,
		isArbitraryValue
	], BL = () => [
		"auto",
		"min",
		"max",
		"fr",
		isArbitraryVariable,
		isArbitraryValue
	], VL = () => [
		"start",
		"end",
		"center",
		"between",
		"around",
		"evenly",
		"stretch",
		"baseline"
	], HL = () => [
		"start",
		"end",
		"center",
		"stretch"
	], UL = () => ["auto", ...FL()], WL = () => [
		isFraction,
		"auto",
		"full",
		"dvw",
		"dvh",
		"lvw",
		"lvh",
		"svw",
		"svh",
		"min",
		"max",
		"fit",
		...FL()
	], GL = () => [
		C,
		isArbitraryVariable,
		isArbitraryValue
	], KL = () => [isPercent, isArbitraryLength], qL = () => [
		"",
		"none",
		"full",
		B,
		isArbitraryVariable,
		isArbitraryValue
	], JL = () => [
		"",
		isNumber,
		isArbitraryVariableLength,
		isArbitraryLength
	], YL = () => [
		"solid",
		"dashed",
		"dotted",
		"double"
	], XL = () => [
		"normal",
		"multiply",
		"screen",
		"overlay",
		"darken",
		"lighten",
		"color-dodge",
		"color-burn",
		"hard-light",
		"soft-light",
		"difference",
		"exclusion",
		"hue",
		"saturation",
		"color",
		"luminosity"
	], ZL = () => [
		"",
		"none",
		G,
		isArbitraryVariable,
		isArbitraryValue
	], QL = () => [
		"center",
		"top",
		"top-right",
		"right",
		"bottom-right",
		"bottom",
		"bottom-left",
		"left",
		"top-left",
		isArbitraryVariable,
		isArbitraryValue
	], $L = () => [
		"none",
		isNumber,
		isArbitraryVariable,
		isArbitraryValue
	], eR = () => [
		"none",
		isNumber,
		isArbitraryVariable,
		isArbitraryValue
	], tR = () => [
		isNumber,
		isArbitraryVariable,
		isArbitraryValue
	], nR = () => [
		isFraction,
		"full",
		...FL()
	];
	return {
		cacheSize: 500,
		theme: {
			animate: [
				"spin",
				"ping",
				"pulse",
				"bounce"
			],
			aspect: ["video"],
			blur: [isTshirtSize],
			breakpoint: [isTshirtSize],
			color: [isAny],
			container: [isTshirtSize],
			"drop-shadow": [isTshirtSize],
			ease: [
				"in",
				"out",
				"in-out"
			],
			font: [isAnyNonArbitrary],
			"font-weight": [
				"thin",
				"extralight",
				"light",
				"normal",
				"medium",
				"semibold",
				"bold",
				"extrabold",
				"black"
			],
			"inset-shadow": [isTshirtSize],
			leading: [
				"none",
				"tight",
				"snug",
				"normal",
				"relaxed",
				"loose"
			],
			perspective: [
				"dramatic",
				"near",
				"normal",
				"midrange",
				"distant",
				"none"
			],
			radius: [isTshirtSize],
			shadow: [isTshirtSize],
			spacing: ["px", isNumber],
			text: [isTshirtSize],
			tracking: [
				"tighter",
				"tight",
				"normal",
				"wide",
				"wider",
				"widest"
			]
		},
		classGroups: {
			aspect: [{ aspect: [
				"auto",
				"square",
				isFraction,
				isArbitraryValue,
				isArbitraryVariable,
				J
			] }],
			container: ["container"],
			columns: [{ columns: [
				isNumber,
				isArbitraryValue,
				isArbitraryVariable,
				L
			] }],
			"break-after": [{ "break-after": Z() }],
			"break-before": [{ "break-before": Z() }],
			"break-inside": [{ "break-inside": [
				"auto",
				"avoid",
				"avoid-page",
				"avoid-column"
			] }],
			"box-decoration": [{ "box-decoration": ["slice", "clone"] }],
			box: [{ box: ["border", "content"] }],
			display: [
				"block",
				"inline-block",
				"inline",
				"flex",
				"inline-flex",
				"table",
				"inline-table",
				"table-caption",
				"table-cell",
				"table-column",
				"table-column-group",
				"table-footer-group",
				"table-header-group",
				"table-row-group",
				"table-row",
				"flow-root",
				"grid",
				"inline-grid",
				"contents",
				"list-item",
				"hidden"
			],
			sr: ["sr-only", "not-sr-only"],
			float: [{ float: [
				"right",
				"left",
				"none",
				"start",
				"end"
			] }],
			clear: [{ clear: [
				"left",
				"right",
				"both",
				"none",
				"start",
				"end"
			] }],
			isolation: ["isolate", "isolation-auto"],
			"object-fit": [{ object: [
				"contain",
				"cover",
				"fill",
				"none",
				"scale-down"
			] }],
			"object-position": [{ object: [
				...Q(),
				isArbitraryValue,
				isArbitraryVariable
			] }],
			overflow: [{ overflow: NL() }],
			"overflow-x": [{ "overflow-x": NL() }],
			"overflow-y": [{ "overflow-y": NL() }],
			overscroll: [{ overscroll: PL() }],
			"overscroll-x": [{ "overscroll-x": PL() }],
			"overscroll-y": [{ "overscroll-y": PL() }],
			position: [
				"static",
				"fixed",
				"absolute",
				"relative",
				"sticky"
			],
			inset: [{ inset: IL() }],
			"inset-x": [{ "inset-x": IL() }],
			"inset-y": [{ "inset-y": IL() }],
			start: [{ start: IL() }],
			end: [{ end: IL() }],
			top: [{ top: IL() }],
			right: [{ right: IL() }],
			bottom: [{ bottom: IL() }],
			left: [{ left: IL() }],
			visibility: [
				"visible",
				"invisible",
				"collapse"
			],
			z: [{ z: [
				isInteger,
				"auto",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			basis: [{ basis: [
				isFraction,
				"full",
				"auto",
				L,
				...FL()
			] }],
			"flex-direction": [{ flex: [
				"row",
				"row-reverse",
				"col",
				"col-reverse"
			] }],
			"flex-wrap": [{ flex: [
				"nowrap",
				"wrap",
				"wrap-reverse"
			] }],
			flex: [{ flex: [
				isNumber,
				isFraction,
				"auto",
				"initial",
				"none",
				isArbitraryValue
			] }],
			grow: [{ grow: [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			shrink: [{ shrink: [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			order: [{ order: [
				isInteger,
				"first",
				"last",
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"grid-cols": [{ "grid-cols": LL() }],
			"col-start-end": [{ col: RL() }],
			"col-start": [{ "col-start": zL() }],
			"col-end": [{ "col-end": zL() }],
			"grid-rows": [{ "grid-rows": LL() }],
			"row-start-end": [{ row: RL() }],
			"row-start": [{ "row-start": zL() }],
			"row-end": [{ "row-end": zL() }],
			"grid-flow": [{ "grid-flow": [
				"row",
				"col",
				"dense",
				"row-dense",
				"col-dense"
			] }],
			"auto-cols": [{ "auto-cols": BL() }],
			"auto-rows": [{ "auto-rows": BL() }],
			gap: [{ gap: FL() }],
			"gap-x": [{ "gap-x": FL() }],
			"gap-y": [{ "gap-y": FL() }],
			"justify-content": [{ justify: [...VL(), "normal"] }],
			"justify-items": [{ "justify-items": [...HL(), "normal"] }],
			"justify-self": [{ "justify-self": ["auto", ...HL()] }],
			"align-content": [{ content: ["normal", ...VL()] }],
			"align-items": [{ items: [...HL(), "baseline"] }],
			"align-self": [{ self: [
				"auto",
				...HL(),
				"baseline"
			] }],
			"place-content": [{ "place-content": VL() }],
			"place-items": [{ "place-items": [...HL(), "baseline"] }],
			"place-self": [{ "place-self": ["auto", ...HL()] }],
			p: [{ p: FL() }],
			px: [{ px: FL() }],
			py: [{ py: FL() }],
			ps: [{ ps: FL() }],
			pe: [{ pe: FL() }],
			pt: [{ pt: FL() }],
			pr: [{ pr: FL() }],
			pb: [{ pb: FL() }],
			pl: [{ pl: FL() }],
			m: [{ m: UL() }],
			mx: [{ mx: UL() }],
			my: [{ my: UL() }],
			ms: [{ ms: UL() }],
			me: [{ me: UL() }],
			mt: [{ mt: UL() }],
			mr: [{ mr: UL() }],
			mb: [{ mb: UL() }],
			ml: [{ ml: UL() }],
			"space-x": [{ "space-x": FL() }],
			"space-x-reverse": ["space-x-reverse"],
			"space-y": [{ "space-y": FL() }],
			"space-y-reverse": ["space-y-reverse"],
			size: [{ size: WL() }],
			w: [{ w: [
				L,
				"screen",
				...WL()
			] }],
			"min-w": [{ "min-w": [
				L,
				"screen",
				"none",
				...WL()
			] }],
			"max-w": [{ "max-w": [
				L,
				"screen",
				"none",
				"prose",
				{ screen: [I] },
				...WL()
			] }],
			h: [{ h: ["screen", ...WL()] }],
			"min-h": [{ "min-h": [
				"screen",
				"none",
				...WL()
			] }],
			"max-h": [{ "max-h": ["screen", ...WL()] }],
			"font-size": [{ text: [
				"base",
				E,
				isArbitraryVariableLength,
				isArbitraryLength
			] }],
			"font-smoothing": ["antialiased", "subpixel-antialiased"],
			"font-style": ["italic", "not-italic"],
			"font-weight": [{ font: [
				D,
				isArbitraryVariable,
				isArbitraryNumber
			] }],
			"font-stretch": [{ "font-stretch": [
				"ultra-condensed",
				"extra-condensed",
				"condensed",
				"semi-condensed",
				"normal",
				"semi-expanded",
				"expanded",
				"extra-expanded",
				"ultra-expanded",
				isPercent,
				isArbitraryValue
			] }],
			"font-family": [{ font: [
				isArbitraryVariableFamilyName,
				isArbitraryValue,
				T
			] }],
			"fvn-normal": ["normal-nums"],
			"fvn-ordinal": ["ordinal"],
			"fvn-slashed-zero": ["slashed-zero"],
			"fvn-figure": ["lining-nums", "oldstyle-nums"],
			"fvn-spacing": ["proportional-nums", "tabular-nums"],
			"fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
			tracking: [{ tracking: [
				O,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"line-clamp": [{ "line-clamp": [
				isNumber,
				"none",
				isArbitraryVariable,
				isArbitraryNumber
			] }],
			leading: [{ leading: [F, ...FL()] }],
			"list-image": [{ "list-image": [
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"list-style-position": [{ list: ["inside", "outside"] }],
			"list-style-type": [{ list: [
				"disc",
				"decimal",
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"text-alignment": [{ text: [
				"left",
				"center",
				"right",
				"justify",
				"start",
				"end"
			] }],
			"placeholder-color": [{ placeholder: GL() }],
			"text-color": [{ text: GL() }],
			"text-decoration": [
				"underline",
				"overline",
				"line-through",
				"no-underline"
			],
			"text-decoration-style": [{ decoration: [...YL(), "wavy"] }],
			"text-decoration-thickness": [{ decoration: [
				isNumber,
				"from-font",
				"auto",
				isArbitraryVariable,
				isArbitraryLength
			] }],
			"text-decoration-color": [{ decoration: GL() }],
			"underline-offset": [{ "underline-offset": [
				isNumber,
				"auto",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"text-transform": [
				"uppercase",
				"lowercase",
				"capitalize",
				"normal-case"
			],
			"text-overflow": [
				"truncate",
				"text-ellipsis",
				"text-clip"
			],
			"text-wrap": [{ text: [
				"wrap",
				"nowrap",
				"balance",
				"pretty"
			] }],
			indent: [{ indent: FL() }],
			"vertical-align": [{ align: [
				"baseline",
				"top",
				"middle",
				"bottom",
				"text-top",
				"text-bottom",
				"sub",
				"super",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			whitespace: [{ whitespace: [
				"normal",
				"nowrap",
				"pre",
				"pre-line",
				"pre-wrap",
				"break-spaces"
			] }],
			break: [{ break: [
				"normal",
				"words",
				"all",
				"keep"
			] }],
			hyphens: [{ hyphens: [
				"none",
				"manual",
				"auto"
			] }],
			content: [{ content: [
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"bg-attachment": [{ bg: [
				"fixed",
				"local",
				"scroll"
			] }],
			"bg-clip": [{ "bg-clip": [
				"border",
				"padding",
				"content",
				"text"
			] }],
			"bg-origin": [{ "bg-origin": [
				"border",
				"padding",
				"content"
			] }],
			"bg-position": [{ bg: [
				...Q(),
				isArbitraryVariablePosition,
				isArbitraryPosition
			] }],
			"bg-repeat": [{ bg: ["no-repeat", { repeat: [
				"",
				"x",
				"y",
				"space",
				"round"
			] }] }],
			"bg-size": [{ bg: [
				"auto",
				"cover",
				"contain",
				isArbitraryVariableSize,
				isArbitrarySize
			] }],
			"bg-image": [{ bg: [
				"none",
				{
					linear: [
						{ to: [
							"t",
							"tr",
							"r",
							"br",
							"b",
							"bl",
							"l",
							"tl"
						] },
						isInteger,
						isArbitraryVariable,
						isArbitraryValue
					],
					radial: [
						"",
						isArbitraryVariable,
						isArbitraryValue
					],
					conic: [
						isInteger,
						isArbitraryVariable,
						isArbitraryValue
					]
				},
				isArbitraryVariableImage,
				isArbitraryImage
			] }],
			"bg-color": [{ bg: GL() }],
			"gradient-from-pos": [{ from: KL() }],
			"gradient-via-pos": [{ via: KL() }],
			"gradient-to-pos": [{ to: KL() }],
			"gradient-from": [{ from: GL() }],
			"gradient-via": [{ via: GL() }],
			"gradient-to": [{ to: GL() }],
			rounded: [{ rounded: qL() }],
			"rounded-s": [{ "rounded-s": qL() }],
			"rounded-e": [{ "rounded-e": qL() }],
			"rounded-t": [{ "rounded-t": qL() }],
			"rounded-r": [{ "rounded-r": qL() }],
			"rounded-b": [{ "rounded-b": qL() }],
			"rounded-l": [{ "rounded-l": qL() }],
			"rounded-ss": [{ "rounded-ss": qL() }],
			"rounded-se": [{ "rounded-se": qL() }],
			"rounded-ee": [{ "rounded-ee": qL() }],
			"rounded-es": [{ "rounded-es": qL() }],
			"rounded-tl": [{ "rounded-tl": qL() }],
			"rounded-tr": [{ "rounded-tr": qL() }],
			"rounded-br": [{ "rounded-br": qL() }],
			"rounded-bl": [{ "rounded-bl": qL() }],
			"border-w": [{ border: JL() }],
			"border-w-x": [{ "border-x": JL() }],
			"border-w-y": [{ "border-y": JL() }],
			"border-w-s": [{ "border-s": JL() }],
			"border-w-e": [{ "border-e": JL() }],
			"border-w-t": [{ "border-t": JL() }],
			"border-w-r": [{ "border-r": JL() }],
			"border-w-b": [{ "border-b": JL() }],
			"border-w-l": [{ "border-l": JL() }],
			"divide-x": [{ "divide-x": JL() }],
			"divide-x-reverse": ["divide-x-reverse"],
			"divide-y": [{ "divide-y": JL() }],
			"divide-y-reverse": ["divide-y-reverse"],
			"border-style": [{ border: [
				...YL(),
				"hidden",
				"none"
			] }],
			"divide-style": [{ divide: [
				...YL(),
				"hidden",
				"none"
			] }],
			"border-color": [{ border: GL() }],
			"border-color-x": [{ "border-x": GL() }],
			"border-color-y": [{ "border-y": GL() }],
			"border-color-s": [{ "border-s": GL() }],
			"border-color-e": [{ "border-e": GL() }],
			"border-color-t": [{ "border-t": GL() }],
			"border-color-r": [{ "border-r": GL() }],
			"border-color-b": [{ "border-b": GL() }],
			"border-color-l": [{ "border-l": GL() }],
			"divide-color": [{ divide: GL() }],
			"outline-style": [{ outline: [
				...YL(),
				"none",
				"hidden"
			] }],
			"outline-offset": [{ "outline-offset": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"outline-w": [{ outline: [
				"",
				isNumber,
				isArbitraryVariableLength,
				isArbitraryLength
			] }],
			"outline-color": [{ outline: [C] }],
			shadow: [{ shadow: [
				"",
				"none",
				V,
				isArbitraryVariableShadow,
				isArbitraryShadow
			] }],
			"shadow-color": [{ shadow: GL() }],
			"inset-shadow": [{ "inset-shadow": [
				"none",
				isArbitraryVariable,
				isArbitraryValue,
				U
			] }],
			"inset-shadow-color": [{ "inset-shadow": GL() }],
			"ring-w": [{ ring: JL() }],
			"ring-w-inset": ["ring-inset"],
			"ring-color": [{ ring: GL() }],
			"ring-offset-w": [{ "ring-offset": [isNumber, isArbitraryLength] }],
			"ring-offset-color": [{ "ring-offset": GL() }],
			"inset-ring-w": [{ "inset-ring": JL() }],
			"inset-ring-color": [{ "inset-ring": GL() }],
			opacity: [{ opacity: [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"mix-blend": [{ "mix-blend": [
				...XL(),
				"plus-darker",
				"plus-lighter"
			] }],
			"bg-blend": [{ "bg-blend": XL() }],
			filter: [{ filter: [
				"",
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			blur: [{ blur: ZL() }],
			brightness: [{ brightness: [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			contrast: [{ contrast: [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"drop-shadow": [{ "drop-shadow": [
				"",
				"none",
				W,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			grayscale: [{ grayscale: [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"hue-rotate": [{ "hue-rotate": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			invert: [{ invert: [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			saturate: [{ saturate: [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			sepia: [{ sepia: [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-filter": [{ "backdrop-filter": [
				"",
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-blur": [{ "backdrop-blur": ZL() }],
			"backdrop-brightness": [{ "backdrop-brightness": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-contrast": [{ "backdrop-contrast": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-grayscale": [{ "backdrop-grayscale": [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-hue-rotate": [{ "backdrop-hue-rotate": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-invert": [{ "backdrop-invert": [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-opacity": [{ "backdrop-opacity": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-saturate": [{ "backdrop-saturate": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-sepia": [{ "backdrop-sepia": [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"border-collapse": [{ border: ["collapse", "separate"] }],
			"border-spacing": [{ "border-spacing": FL() }],
			"border-spacing-x": [{ "border-spacing-x": FL() }],
			"border-spacing-y": [{ "border-spacing-y": FL() }],
			"table-layout": [{ table: ["auto", "fixed"] }],
			caption: [{ caption: ["top", "bottom"] }],
			transition: [{ transition: [
				"",
				"all",
				"colors",
				"opacity",
				"shadow",
				"transform",
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"transition-behavior": [{ transition: ["normal", "discrete"] }],
			duration: [{ duration: [
				isNumber,
				"initial",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			ease: [{ ease: [
				"linear",
				"initial",
				Y,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			delay: [{ delay: [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			animate: [{ animate: [
				"none",
				X,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			backface: [{ backface: ["hidden", "visible"] }],
			perspective: [{ perspective: [
				K,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"perspective-origin": [{ "perspective-origin": QL() }],
			rotate: [{ rotate: $L() }],
			"rotate-x": [{ "rotate-x": $L() }],
			"rotate-y": [{ "rotate-y": $L() }],
			"rotate-z": [{ "rotate-z": $L() }],
			scale: [{ scale: eR() }],
			"scale-x": [{ "scale-x": eR() }],
			"scale-y": [{ "scale-y": eR() }],
			"scale-z": [{ "scale-z": eR() }],
			"scale-3d": ["scale-3d"],
			skew: [{ skew: tR() }],
			"skew-x": [{ "skew-x": tR() }],
			"skew-y": [{ "skew-y": tR() }],
			transform: [{ transform: [
				isArbitraryVariable,
				isArbitraryValue,
				"",
				"none",
				"gpu",
				"cpu"
			] }],
			"transform-origin": [{ origin: QL() }],
			"transform-style": [{ transform: ["3d", "flat"] }],
			translate: [{ translate: nR() }],
			"translate-x": [{ "translate-x": nR() }],
			"translate-y": [{ "translate-y": nR() }],
			"translate-z": [{ "translate-z": nR() }],
			"translate-none": ["translate-none"],
			accent: [{ accent: GL() }],
			appearance: [{ appearance: ["none", "auto"] }],
			"caret-color": [{ caret: GL() }],
			"color-scheme": [{ scheme: [
				"normal",
				"dark",
				"light",
				"light-dark",
				"only-dark",
				"only-light"
			] }],
			cursor: [{ cursor: [
				"auto",
				"default",
				"pointer",
				"wait",
				"text",
				"move",
				"help",
				"not-allowed",
				"none",
				"context-menu",
				"progress",
				"cell",
				"crosshair",
				"vertical-text",
				"alias",
				"copy",
				"no-drop",
				"grab",
				"grabbing",
				"all-scroll",
				"col-resize",
				"row-resize",
				"n-resize",
				"e-resize",
				"s-resize",
				"w-resize",
				"ne-resize",
				"nw-resize",
				"se-resize",
				"sw-resize",
				"ew-resize",
				"ns-resize",
				"nesw-resize",
				"nwse-resize",
				"zoom-in",
				"zoom-out",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"field-sizing": [{ "field-sizing": ["fixed", "content"] }],
			"pointer-events": [{ "pointer-events": ["auto", "none"] }],
			resize: [{ resize: [
				"none",
				"",
				"y",
				"x"
			] }],
			"scroll-behavior": [{ scroll: ["auto", "smooth"] }],
			"scroll-m": [{ "scroll-m": FL() }],
			"scroll-mx": [{ "scroll-mx": FL() }],
			"scroll-my": [{ "scroll-my": FL() }],
			"scroll-ms": [{ "scroll-ms": FL() }],
			"scroll-me": [{ "scroll-me": FL() }],
			"scroll-mt": [{ "scroll-mt": FL() }],
			"scroll-mr": [{ "scroll-mr": FL() }],
			"scroll-mb": [{ "scroll-mb": FL() }],
			"scroll-ml": [{ "scroll-ml": FL() }],
			"scroll-p": [{ "scroll-p": FL() }],
			"scroll-px": [{ "scroll-px": FL() }],
			"scroll-py": [{ "scroll-py": FL() }],
			"scroll-ps": [{ "scroll-ps": FL() }],
			"scroll-pe": [{ "scroll-pe": FL() }],
			"scroll-pt": [{ "scroll-pt": FL() }],
			"scroll-pr": [{ "scroll-pr": FL() }],
			"scroll-pb": [{ "scroll-pb": FL() }],
			"scroll-pl": [{ "scroll-pl": FL() }],
			"snap-align": [{ snap: [
				"start",
				"end",
				"center",
				"align-none"
			] }],
			"snap-stop": [{ snap: ["normal", "always"] }],
			"snap-type": [{ snap: [
				"none",
				"x",
				"y",
				"both"
			] }],
			"snap-strictness": [{ snap: ["mandatory", "proximity"] }],
			touch: [{ touch: [
				"auto",
				"none",
				"manipulation"
			] }],
			"touch-x": [{ "touch-pan": [
				"x",
				"left",
				"right"
			] }],
			"touch-y": [{ "touch-pan": [
				"y",
				"up",
				"down"
			] }],
			"touch-pz": ["touch-pinch-zoom"],
			select: [{ select: [
				"none",
				"text",
				"all",
				"auto"
			] }],
			"will-change": [{ "will-change": [
				"auto",
				"scroll",
				"contents",
				"transform",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			fill: [{ fill: ["none", ...GL()] }],
			"stroke-w": [{ stroke: [
				isNumber,
				isArbitraryVariableLength,
				isArbitraryLength,
				isArbitraryNumber
			] }],
			stroke: [{ stroke: ["none", ...GL()] }],
			"forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }]
		},
		conflictingClassGroups: {
			overflow: ["overflow-x", "overflow-y"],
			overscroll: ["overscroll-x", "overscroll-y"],
			inset: [
				"inset-x",
				"inset-y",
				"start",
				"end",
				"top",
				"right",
				"bottom",
				"left"
			],
			"inset-x": ["right", "left"],
			"inset-y": ["top", "bottom"],
			flex: [
				"basis",
				"grow",
				"shrink"
			],
			gap: ["gap-x", "gap-y"],
			p: [
				"px",
				"py",
				"ps",
				"pe",
				"pt",
				"pr",
				"pb",
				"pl"
			],
			px: ["pr", "pl"],
			py: ["pt", "pb"],
			m: [
				"mx",
				"my",
				"ms",
				"me",
				"mt",
				"mr",
				"mb",
				"ml"
			],
			mx: ["mr", "ml"],
			my: ["mt", "mb"],
			size: ["w", "h"],
			"font-size": ["leading"],
			"fvn-normal": [
				"fvn-ordinal",
				"fvn-slashed-zero",
				"fvn-figure",
				"fvn-spacing",
				"fvn-fraction"
			],
			"fvn-ordinal": ["fvn-normal"],
			"fvn-slashed-zero": ["fvn-normal"],
			"fvn-figure": ["fvn-normal"],
			"fvn-spacing": ["fvn-normal"],
			"fvn-fraction": ["fvn-normal"],
			"line-clamp": ["display", "overflow"],
			rounded: [
				"rounded-s",
				"rounded-e",
				"rounded-t",
				"rounded-r",
				"rounded-b",
				"rounded-l",
				"rounded-ss",
				"rounded-se",
				"rounded-ee",
				"rounded-es",
				"rounded-tl",
				"rounded-tr",
				"rounded-br",
				"rounded-bl"
			],
			"rounded-s": ["rounded-ss", "rounded-es"],
			"rounded-e": ["rounded-se", "rounded-ee"],
			"rounded-t": ["rounded-tl", "rounded-tr"],
			"rounded-r": ["rounded-tr", "rounded-br"],
			"rounded-b": ["rounded-br", "rounded-bl"],
			"rounded-l": ["rounded-tl", "rounded-bl"],
			"border-spacing": ["border-spacing-x", "border-spacing-y"],
			"border-w": [
				"border-w-s",
				"border-w-e",
				"border-w-t",
				"border-w-r",
				"border-w-b",
				"border-w-l"
			],
			"border-w-x": ["border-w-r", "border-w-l"],
			"border-w-y": ["border-w-t", "border-w-b"],
			"border-color": [
				"border-color-s",
				"border-color-e",
				"border-color-t",
				"border-color-r",
				"border-color-b",
				"border-color-l"
			],
			"border-color-x": ["border-color-r", "border-color-l"],
			"border-color-y": ["border-color-t", "border-color-b"],
			translate: [
				"translate-x",
				"translate-y",
				"translate-none"
			],
			"translate-none": [
				"translate",
				"translate-x",
				"translate-y",
				"translate-z"
			],
			"scroll-m": [
				"scroll-mx",
				"scroll-my",
				"scroll-ms",
				"scroll-me",
				"scroll-mt",
				"scroll-mr",
				"scroll-mb",
				"scroll-ml"
			],
			"scroll-mx": ["scroll-mr", "scroll-ml"],
			"scroll-my": ["scroll-mt", "scroll-mb"],
			"scroll-p": [
				"scroll-px",
				"scroll-py",
				"scroll-ps",
				"scroll-pe",
				"scroll-pt",
				"scroll-pr",
				"scroll-pb",
				"scroll-pl"
			],
			"scroll-px": ["scroll-pr", "scroll-pl"],
			"scroll-py": ["scroll-pt", "scroll-pb"],
			touch: [
				"touch-x",
				"touch-y",
				"touch-pz"
			],
			"touch-x": ["touch"],
			"touch-y": ["touch"],
			"touch-pz": ["touch"]
		},
		conflictingClassGroupModifiers: { "font-size": ["leading"] },
		orderSensitiveModifiers: [
			"before",
			"after",
			"placeholder",
			"file",
			"marker",
			"selection",
			"first-line",
			"first-letter",
			"backdrop",
			"*",
			"**"
		]
	};
}, mergeConfigs = (C, { cacheSize: T, prefix: E, experimentalParseClassName: D, extend: O = {}, override: F = {} }) => (overrideProperty(C, "cacheSize", T), overrideProperty(C, "prefix", E), overrideProperty(C, "experimentalParseClassName", D), overrideConfigProperties(C.theme, F.theme), overrideConfigProperties(C.classGroups, F.classGroups), overrideConfigProperties(C.conflictingClassGroups, F.conflictingClassGroups), overrideConfigProperties(C.conflictingClassGroupModifiers, F.conflictingClassGroupModifiers), overrideProperty(C, "orderSensitiveModifiers", F.orderSensitiveModifiers), mergeConfigProperties(C.theme, O.theme), mergeConfigProperties(C.classGroups, O.classGroups), mergeConfigProperties(C.conflictingClassGroups, O.conflictingClassGroups), mergeConfigProperties(C.conflictingClassGroupModifiers, O.conflictingClassGroupModifiers), mergeArrayProperties(C, O, "orderSensitiveModifiers"), C), overrideProperty = (C, T, E) => {
	E !== void 0 && (C[T] = E);
}, overrideConfigProperties = (C, T) => {
	if (T) for (let E in T) overrideProperty(C, E, T[E]);
}, mergeConfigProperties = (C, T) => {
	if (T) for (let E in T) mergeArrayProperties(C, T, E);
}, mergeArrayProperties = (C, T, E) => {
	let D = T[E];
	D !== void 0 && (C[E] = C[E] ? C[E].concat(D) : D);
}, extendTailwindMerge = (C, ...T) => typeof C == "function" ? createTailwindMerge(getDefaultConfig, C, ...T) : createTailwindMerge(() => mergeConfigs(getDefaultConfig(), C), ...T), twMerge$1 = /* @__PURE__ */ createTailwindMerge(getDefaultConfig), _excluded$1 = ["class", "className"], _excluded2$1 = [
	"slots",
	"class",
	"className"
], ie = {
	twMerge: !0,
	twMergeConfig: {},
	responsiveVariants: !1
}, x$2 = (C) => C || void 0, N$1 = (...C) => x$2(y$1(C).filter(Boolean).join(" ")), R = null, v$1 = {}, q = !1, M$1 = (...C) => (E) => E.twMerge ? ((!R || q) && (q = !1, R = u$1(v$1) ? twMerge$1 : extendTailwindMerge(_objectSpread2(_objectSpread2({}, v$1), {}, { extend: _objectSpread2({
	theme: v$1.theme,
	classGroups: v$1.classGroups,
	conflictingClassGroupModifiers: v$1.conflictingClassGroupModifiers,
	conflictingClassGroups: v$1.conflictingClassGroups
}, v$1.extend) }))), x$2(R(N$1(C)))) : N$1(C), _ = (C, T) => {
	for (let E in T) C.hasOwnProperty(E) ? C[E] = N$1(C[E], T[E]) : C[E] = T[E];
	return C;
}, ce = (C, E) => {
	let { extend: D = null, slots: O = {}, variants: F = {}, compoundVariants: I = [], compoundSlots: L = [], defaultVariants: z = {} } = C, B = _objectSpread2(_objectSpread2({}, ie), E), V = D != null && D.base ? N$1(D.base, C == null ? void 0 : C.base) : C == null ? void 0 : C.base, U = D != null && D.variants && !u$1(D.variants) ? p$1(F, D.variants) : F, W = D != null && D.defaultVariants && !u$1(D.defaultVariants) ? _objectSpread2(_objectSpread2({}, D.defaultVariants), z) : z;
	!u$1(B.twMergeConfig) && !x$1(B.twMergeConfig, v$1) && (q = !0, v$1 = B.twMergeConfig);
	let G = u$1(D == null ? void 0 : D.slots), K = u$1(O) ? {} : _objectSpread2({ base: N$1(C == null ? void 0 : C.base, G && (D == null ? void 0 : D.base)) }, O), J = G ? K : _(_objectSpread2({}, D == null ? void 0 : D.slots), u$1(K) ? { base: C == null ? void 0 : C.base } : K), Y = u$1(D == null ? void 0 : D.compoundVariants) ? I : a$1(D == null ? void 0 : D.compoundVariants, I), X = (C) => {
		if (u$1(U) && u$1(O) && G) return M$1(V, C == null ? void 0 : C.class, C == null ? void 0 : C.className)(B);
		if (Y && !Array.isArray(Y)) throw TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof Y}`);
		if (L && !Array.isArray(L)) throw TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof L}`);
		let E = (C, T, E = [], D) => {
			let O = E;
			if (typeof T == "string") O = O.concat(g$1(T).split(" ").map((T) => `${C}:${T}`));
			else if (Array.isArray(T)) O = O.concat(T.reduce((T, E) => T.concat(`${C}:${E}`), []));
			else if (typeof T == "object" && typeof D == "string") {
				for (let E in T) if (T.hasOwnProperty(E) && E === D) {
					let F = T[E];
					if (F && typeof F == "string") {
						let T = g$1(F);
						O[D] ? O[D] = O[D].concat(T.split(" ").map((T) => `${C}:${T}`)) : O[D] = T.split(" ").map((T) => `${C}:${T}`);
					} else Array.isArray(F) && F.length > 0 && (O[D] = F.reduce((T, E) => T.concat(`${C}:${E}`), []));
				}
			}
			return O;
		}, D = (T, D = U, O = null, F = null) => {
			var I;
			let L = D[T];
			if (!L || u$1(L)) return null;
			let z = (I = F == null ? void 0 : F[T]) == null ? C == null ? void 0 : C[T] : I;
			if (z === null) return null;
			let V = l$1(z), G = Array.isArray(B.responsiveVariants) && B.responsiveVariants.length > 0 || B.responsiveVariants === !0, K = W == null ? void 0 : W[T], J = [];
			if (typeof V == "object" && G) for (let [C, T] of Object.entries(V)) {
				let D = L[T];
				if (C === "initial") {
					K = T;
					continue;
				}
				Array.isArray(B.responsiveVariants) && !B.responsiveVariants.includes(C) || (J = E(C, D, J, O));
			}
			let Y = L[(V != null && typeof V != "object" ? V : l$1(K)) || "false"];
			return typeof J == "object" && typeof O == "string" && J[O] ? _(J, Y) : J.length > 0 ? (J.push(Y), O === "base" ? J.join(" ") : J) : Y;
		}, F = () => U ? Object.keys(U).map((C) => D(C, U)) : null, I = (C, T) => {
			if (!U || typeof U != "object") return null;
			let E = [];
			for (let O in U) {
				let F = D(O, U, C, T), I = C === "base" && typeof F == "string" ? F : F && F[C];
				I && (E[E.length] = I);
			}
			return E;
		}, z = {};
		for (let T in C) C[T] !== void 0 && (z[T] = C[T]);
		let K = (E, D) => {
			var O;
			let F = typeof (C == null ? void 0 : C[E]) == "object" ? { [E]: (O = C[E]) == null ? void 0 : O.initial } : {};
			return _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, W), z), F), D);
		}, X = (C = [], T) => {
			let E = [];
			for (let D of C) {
				let { class: C, className: O } = D, F = _objectWithoutProperties(D, _excluded$1), I = !0;
				for (let [C, E] of Object.entries(F)) {
					let D = K(C, T)[C];
					if (Array.isArray(E)) {
						if (!E.includes(D)) {
							I = !1;
							break;
						}
					} else {
						let C = (C) => C == null || C === !1;
						if (C(E) && C(D)) continue;
						if (D !== E) {
							I = !1;
							break;
						}
					}
				}
				I && (C && E.push(C), O && E.push(O));
			}
			return E;
		}, Z = (C) => {
			let T = X(Y, C);
			if (!Array.isArray(T)) return T;
			let E = {};
			for (let C of T) if (typeof C == "string" && (E.base = M$1(E.base, C)(B)), typeof C == "object") for (let [T, D] of Object.entries(C)) E[T] = M$1(E[T], D)(B);
			return E;
		}, Q = (C) => {
			if (L.length < 1) return null;
			let T = {};
			for (let E of L) {
				let { slots: D = [], class: O, className: F } = E, I = _objectWithoutProperties(E, _excluded2$1);
				if (!u$1(I)) {
					let T = !0;
					for (let E of Object.keys(I)) {
						let D = K(E, C)[E];
						if (D === void 0 || (Array.isArray(I[E]) ? !I[E].includes(D) : I[E] !== D)) {
							T = !1;
							break;
						}
					}
					if (!T) continue;
				}
				for (let C of D) T[C] = T[C] || [], T[C].push([O, F]);
			}
			return T;
		};
		if (!u$1(O) || !G) {
			let C = {};
			if (typeof J == "object" && !u$1(J)) for (let T of Object.keys(J)) C[T] = (C) => {
				var E, D;
				return M$1(J[T], I(T, C), ((E = Z(C)) == null ? [] : E)[T], ((D = Q(C)) == null ? [] : D)[T], C == null ? void 0 : C.class, C == null ? void 0 : C.className)(B);
			};
			return C;
		}
		return M$1(V, F(), X(Y), C == null ? void 0 : C.class, C == null ? void 0 : C.className)(B);
	};
	return X.variantKeys = (() => {
		if (!(!U || typeof U != "object")) return Object.keys(U);
	})(), X.extend = D, X.base = V, X.slots = J, X.variants = U, X.defaultVariants = W, X.compoundSlots = L, X.compoundVariants = Y, X;
};
const accordion = ce({
	base: "w-full text-gray-500 dark:text-gray-400",
	variants: { flush: {
		true: "",
		false: " dark:border-gray-700 rounded-t-xl"
	} }
}), accordionitem = ce({
	slots: {
		base: "group",
		button: " flex items-center justify-between w-full font-medium text-sm ffont-sans text-left border-gray-200 dark:border-gray-700 ",
		content: "border-b border-gray-200 dark:border-gray-700",
		active: "bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-white focus:ring-4 focus:ring-gray-200 dark:focus:ring-gray-800",
		inactive: "text-gray-300 dark:text-gray-400 hover:bg-gray-800 hover:dark:bg-gray-800"
	},
	variants: {
		flush: {
			true: {
				button: "p-2 pl-3",
				content: "p-1"
			},
			false: {
				button: "p-2  pl-3",
				content: "p-1 "
			}
		},
		open: {
			true: {},
			false: {}
		}
	},
	compoundVariants: [{
		flush: !0,
		open: !0,
		class: { button: "text-gray-900 dark:text-white" }
	}, {
		flush: !0,
		open: !1,
		class: { button: "text-gray-500 dark:text-gray-400" }
	}],
	defaultVariants: {
		flush: !1,
		open: !1
	}
});
var root_3$51 = /* @__PURE__ */ from_html("<div><!></div>"), root_6$16 = /* @__PURE__ */ from_html("<button type=\"button\" class=\"m-0.5 -me-1.5 ms-1.5 whitespace-normal rounded p-0.5 text-primary-500 hover:bg-primary-200 focus:outline-none focus:ring-1 focus:ring-primary-400 dark:hover:bg-primary-800 dark:hover:text-primary-300\" aria-label=\"Remove badge\"><span class=\"sr-only\">Remove alert</span> <!></button>"), root_1$109 = /* @__PURE__ */ from_html("<div><!> <!> <!></div>");
function Alert(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "icon", 7), F = prop(E, "alertStatus", 15, !0), I = prop(E, "closeIcon", 7), L = prop(E, "color", 7, "primary"), z = prop(E, "rounded", 7, !0), B = prop(E, "border", 7), V = prop(E, "class", 7), U = prop(E, "dismissable", 7), W = prop(E, "transition", 7, fade), G = prop(E, "params", 7), K = prop(E, "onclick", 7), J = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"icon",
		"alertStatus",
		"closeIcon",
		"color",
		"rounded",
		"border",
		"class",
		"dismissable",
		"transition",
		"params",
		"onclick"
	]), Y = /* @__PURE__ */ user_derived(() => alert({
		color: L(),
		rounded: z(),
		border: B(),
		icon: !!O(),
		dismissable: U(),
		className: V()
	}));
	var X = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get icon() {
			return O();
		},
		set icon(C) {
			O(C), flushSync();
		},
		get alertStatus() {
			return F();
		},
		set alertStatus(C = !0) {
			F(C), flushSync();
		},
		get closeIcon() {
			return I();
		},
		set closeIcon(C) {
			I(C), flushSync();
		},
		get color() {
			return L();
		},
		set color(C = "primary") {
			L(C), flushSync();
		},
		get rounded() {
			return z();
		},
		set rounded(C = !0) {
			z(C), flushSync();
		},
		get border() {
			return B();
		},
		set border(C) {
			B(C), flushSync();
		},
		get class() {
			return V();
		},
		set class(C) {
			V(C), flushSync();
		},
		get dismissable() {
			return U();
		},
		set dismissable(C) {
			U(C), flushSync();
		},
		get transition() {
			return W();
		},
		set transition(C = fade) {
			W(C), flushSync();
		},
		get params() {
			return G();
		},
		set params(C) {
			G(C), flushSync();
		},
		get onclick() {
			return K();
		},
		set onclick(C) {
			K(C), flushSync();
		}
	}, Z = comment(), Q = first_child(Z), NL = (C) => {
		var E = root_1$109();
		attribute_effect(E, () => _objectSpread2(_objectSpread2({ role: "alert" }, J), {}, { class: get(Y) }));
		var z = child(E), B = (C) => {
			var T = comment();
			snippet(first_child(T), O), append(C, T);
		};
		if_block(z, (C) => {
			O() && C(B);
		});
		var V = sibling(z, 2), X = (C) => {
			var T = root_3$51();
			snippet(child(T), D), reset(T), append(C, T);
		}, Z = (C) => {
			var T = comment();
			snippet(first_child(T), D), append(C, T);
		};
		if_block(V, (C) => {
			O() || U() ? C(X) : C(Z, !1);
		});
		var Q = sibling(V, 2), NL = (C) => {
			var T = comment(), E = first_child(T), D = (C) => {
				var T = root_6$16();
				T.__click = () => {
					F(!1);
				};
				var E = sibling(child(T), 2), D = (C) => {
					var T = comment();
					snippet(first_child(T), O), append(C, T);
				};
				if_block(E, (C) => {
					O() && C(D);
				}), reset(T), append(C, T);
			}, z = (C) => {
				var T = comment(), E = first_child(T), D = (C) => {
					CloseButton(C, {
						class: "-my-1.5 -me-1.5 ms-auto dark:hover:bg-gray-700",
						get color() {
							return L();
						},
						ariaLabel: "Remove badge",
						get onclick() {
							return K();
						}
					});
				}, O = (C) => {
					CloseButton(C, {
						class: "-my-1.5 -me-1.5 ms-auto dark:hover:bg-gray-700",
						get color() {
							return L();
						},
						ariaLabel: "Remove alert",
						onclick: () => {
							F(!1);
						}
					});
				};
				if_block(E, (C) => {
					K() ? C(D) : C(O, !1);
				}, !0), append(C, T);
			};
			if_block(E, (C) => {
				I() ? C(D) : C(z, !1);
			}), append(C, T);
		};
		if_block(Q, (C) => {
			U() && C(NL);
		}), reset(E), transition(3, E, W, G), append(C, E);
	};
	return if_block(Q, (C) => {
		F() && C(NL);
	}), append(C, Z), pop(X);
}
delegate(["click"]), create_custom_element(Alert, {
	children: {},
	icon: {},
	alertStatus: {},
	closeIcon: {},
	color: {},
	rounded: {},
	border: {},
	class: {},
	dismissable: {},
	transition: {},
	params: {},
	onclick: {}
}, [], [], !0);
var alert = ce({
	base: "p-4 gap-3 text-sm",
	variants: {
		color: {
			primary: "bg-primary-50 dark:bg-gray-800 text-primary-800 dark:text-primary-400",
			secondary: "bg-secondary-50 dark:bg-secondary-800 text-secondary-800 dark:text-secondary-400",
			gray: "bg-gray-100 text-gray-500 hover:bg-gray-200 focus:ring-gray-400 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-800 dark:hover:text-white",
			red: "bg-red-100 text-red-500 hover:bg-red-200 focus:ring-red-400 dark:bg-red-200 dark:text-red-600 dark:hover:bg-red-300",
			orange: "bg-orange-100 text-orange-500 hover:bg-orange-200 focus:ring-orange-400 dark:bg-orange-200 dark:text-orange-600 dark:hover:bg-orange-300",
			amber: "bg-amber-100 text-amber-500 hover:bg-amber-200 focus:ring-amber-400 dark:bg-amber-200 dark:text-amber-600 dark:hover:bg-amber-300",
			yellow: "bg-yellow-100 text-yellow-500 hover:bg-yellow-200 focus:ring-yellow-400 dark:bg-yellow-200 dark:text-yellow-600 dark:hover:bg-yellow-300",
			lime: "bg-lime-100 text-lime-500 hover:bg-lime-200 focus:ring-lime-400 dark:bg-lime-200 dark:text-lime-600 dark:hover:bg-lime-300",
			green: "bg-green-100 text-green-500 hover:bg-green-200 focus:ring-green-400 dark:bg-green-200 dark:text-green-600 dark:hover:bg-green-300",
			emerald: "bg-emerald-100 text-emerald-500 hover:bg-emerald-200 focus:ring-emerald-400 dark:bg-emerald-200 dark:text-emerald-600 dark:hover:bg-emerald-300",
			teal: "bg-teal-100 text-teal-500 hover:bg-teal-200 focus:ring-teal-400 dark:bg-teal-200 dark:text-teal-600 dark:hover:bg-teal-300",
			cyan: "bg-cyan-100 text-cyan-500 hover:bg-cyan-200 focus:ring-cyan-400 dark:bg-cyan-200 dark:text-cyan-600 dark:hover:bg-cyan-300",
			sky: "bg-sky-100 text-sky-500 hover:bg-sky-200 focus:ring-sky-400 dark:bg-sky-200 dark:text-sky-600 dark:hover:bg-sky-300",
			blue: "bg-blue-100 text-blue-500 hover:bg-blue-200 focus:ring-blue-400 dark:bg-blue-200 dark:text-blue-600 dark:hover:bg-blue-300",
			indigo: "bg-indigo-100 text-indigo-500 hover:bg-indigo-200 focus:ring-indigo-400 dark:bg-indigo-200 dark:text-indigo-600 dark:hover:bg-indigo-300",
			violet: "bg-violet-100 text-violet-500 hover:bg-violet-200 focus:ring-violet-400 dark:bg-violet-200 dark:text-violet-600 dark:hover:bg-violet-300",
			purple: "bg-purple-100 text-purple-500 hover:bg-purple-200 focus:ring-purple-400 dark:bg-purple-200 dark:text-purple-600 dark:hover:bg-purple-300",
			fuchsia: "bg-fuchsia-100 text-fuchsia-500 hover:bg-fuchsia-200 focus:ring-fuchsia-400 dark:bg-fuchsia-200 dark:text-fuchsia-600 dark:hover:bg-fuchsia-300",
			pink: "bg-pink-100 text-pink-500 hover:bg-pink-200 focus:ring-pink-400 dark:bg-pink-200 dark:text-pink-600 dark:hover:bg-pink-300",
			rose: "bg-rose-100 text-rose-500 hover:bg-rose-200 focus:ring-rose-400 dark:bg-rose-200 dark:text-rose-600 dark:hover:bg-rose-300"
		},
		rounded: { true: "rounded-lg" },
		border: { true: "border" },
		icon: { true: "flex items-center" },
		dismissable: { true: "flex items-center" }
	},
	compoundVariants: [
		{
			border: !0,
			color: "primary",
			class: "border-primary-500 dark:border-primary-200 divide-primary-500 dark:divide-primary-200"
		},
		{
			border: !0,
			color: "secondary",
			class: "border-secondary-500 dark:border-secondary-200 divide-secondary-500 dark:divide-secondary-200"
		},
		{
			border: !0,
			color: "gray",
			class: "border-gray-300 dark:border-gray-800 divide-gray-300 dark:divide-gray-800"
		},
		{
			border: !0,
			color: "red",
			class: "border-red-300 dark:border-red-800 divide-red-300 dark:divide-red-800"
		},
		{
			border: !0,
			color: "orange",
			class: "border-orange-300 dark:border-orange-800 divide-orange-300 dark:divide-orange-800"
		},
		{
			border: !0,
			color: "amber",
			class: "border-amber-300 dark:border-amber-800 divide-amber-300 dark:divide-amber-800"
		},
		{
			border: !0,
			color: "yellow",
			class: "border-yellow-300 dark:border-yellow-800 divide-yellow-300 dark:divide-yellow-800"
		},
		{
			border: !0,
			color: "lime",
			class: "border-lime-300 dark:border-lime-800 divide-lime-300 dark:divide-lime-800"
		},
		{
			border: !0,
			color: "green",
			class: "border-green-300 dark:border-green-800 divide-green-300 dark:divide-green-800"
		},
		{
			border: !0,
			color: "emerald",
			class: "border-emerald-300 dark:border-emerald-800 divide-emerald-300 dark:divide-emerald-800"
		},
		{
			border: !0,
			color: "teal",
			class: "border-teal-300 dark:border-teal-800 divide-teal-300 dark:divide-teal-800"
		},
		{
			border: !0,
			color: "cyan",
			class: "border-cyan-300 dark:border-cyan-800 divide-cyan-300 dark:divide-cyan-800"
		},
		{
			border: !0,
			color: "sky",
			class: "border-sky-300 dark:border-sky-800 divide-sky-300 dark:divide-sky-800"
		},
		{
			border: !0,
			color: "blue",
			class: "border-blue-300 dark:border-blue-800 divide-blue-300 dark:divide-blue-800"
		},
		{
			border: !0,
			color: "indigo",
			class: "border-indigo-300 dark:border-indigo-800 divide-indigo-300 dark:divide-indigo-800"
		},
		{
			border: !0,
			color: "violet",
			class: "border-violet-300 dark:border-violet-800 divide-violet-300 dark:divide-violet-800"
		},
		{
			border: !0,
			color: "purple",
			class: "border-purple-300 dark:border-purple-800 divide-purple-300 dark:divide-purple-800"
		},
		{
			border: !0,
			color: "fuchsia",
			class: "border-fuchsia-300 dark:border-fuchsia-800 divide-fuchsia-300 dark:divide-fuchsia-800"
		},
		{
			border: !0,
			color: "pink",
			class: "border-pink-300 dark:border-pink-800 divide-pink-300 dark:divide-pink-800"
		},
		{
			border: !0,
			color: "rose",
			class: "border-rose-300 dark:border-rose-800 divide-rose-300 dark:divide-rose-800"
		}
	],
	defaultVariants: {
		color: "primary",
		rounded: !0
	}
}), root_3$50 = /* @__PURE__ */ from_html("<img/>"), root_6$15 = /* @__PURE__ */ from_svg("<svg fill=\"currentColor\" viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" d=\"M8 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z\" clip-rule=\"evenodd\"></path></svg>"), root_2$58 = /* @__PURE__ */ from_html("<!> <!>", 1), root_8$13 = /* @__PURE__ */ from_html("<img/>");
function Avatar(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "src", 7), F = prop(E, "href", 7), I = prop(E, "target", 7), L = prop(E, "cornerStyle", 7, "circular"), z = prop(E, "border", 7, !1), B = prop(E, "stacked", 7, !1), V = prop(E, "dot", 7), U = prop(E, "class", 7), W = prop(E, "alt", 7), G = prop(E, "size", 7, "md"), K = prop(E, "onclick", 7), J = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"src",
		"href",
		"target",
		"cornerStyle",
		"border",
		"stacked",
		"dot",
		"class",
		"alt",
		"size",
		"onclick"
	]);
	V(V() && _objectSpread2({
		placement: "top-right",
		color: "gray",
		size: "lg"
	}, V()));
	let Y = /* @__PURE__ */ user_derived(() => avatar({
		cornerStyle: L(),
		border: z(),
		stacked: B(),
		size: G(),
		className: U()
	}));
	var X = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get src() {
			return O();
		},
		set src(C) {
			O(C), flushSync();
		},
		get href() {
			return F();
		},
		set href(C) {
			F(C), flushSync();
		},
		get target() {
			return I();
		},
		set target(C) {
			I(C), flushSync();
		},
		get cornerStyle() {
			return L();
		},
		set cornerStyle(C = "circular") {
			L(C), flushSync();
		},
		get border() {
			return z();
		},
		set border(C = !1) {
			z(C), flushSync();
		},
		get stacked() {
			return B();
		},
		set stacked(C = !1) {
			B(C), flushSync();
		},
		get dot() {
			return V();
		},
		set dot(C) {
			V(C), flushSync();
		},
		get class() {
			return U();
		},
		set class(C) {
			U(C), flushSync();
		},
		get alt() {
			return W();
		},
		set alt(C) {
			W(C), flushSync();
		},
		get size() {
			return G();
		},
		set size(C = "md") {
			G(C), flushSync();
		},
		get onclick() {
			return K();
		},
		set onclick(C) {
			K(C), flushSync();
		}
	}, Z = comment(), Q = first_child(Z), NL = (C) => {
		var E = comment();
		element(first_child(E), () => F() ? "a" : "div", !1, (C, E) => {
			attribute_effect(C, () => _objectSpread2(_objectSpread2({
				role: F() ? void 0 : "button",
				onclick: K(),
				href: F(),
				target: I()
			}, J), {}, { class: get(Y) }));
			var z = root_2$58(), B = first_child(z), U = (C) => {
				var T = root_3$50();
				template_effect(() => {
					set_attribute(T, "alt", W()), set_attribute(T, "src", O()), set_class(T, 1, clsx$1(L() === "circular" ? "rounded-full" : "rounded"));
				}), append(C, T);
			}, G = (C) => {
				var T = comment(), E = first_child(T), O = (C) => {
					var T = comment();
					snippet(first_child(T), D), append(C, T);
				}, F = (C) => {
					var T = root_6$15();
					template_effect(() => set_class(T, 0, `h-full w-full ${L() === "circular" ? "rounded-full" : "rounded"}`)), append(C, T);
				};
				if_block(E, (C) => {
					D() ? C(O) : C(F, !1);
				}, !0), append(C, T);
			};
			if_block(B, (C) => {
				O() ? C(U) : C(G, !1);
			});
			var X = sibling(B, 2), Z = (C) => {
				{
					let T = /* @__PURE__ */ user_derived(() => L() === "circular");
					Indicator(C, spread_props({
						border: !0,
						get offset() {
							return get(T);
						}
					}, V));
				}
			};
			if_block(X, (C) => {
				V() && C(Z);
			}), append(E, z);
		}), append(C, E);
	}, PL = (C) => {
		var E = root_8$13();
		attribute_effect(E, () => _objectSpread2(_objectSpread2({
			alt: W(),
			src: O()
		}, J), {}, { class: get(Y) })), replay_events(E), append(C, E);
	};
	return if_block(Q, (C) => {
		!O() || F() || D() || V() ? C(NL) : C(PL, !1);
	}), append(C, Z), pop(X);
}
create_custom_element(Avatar, {
	children: {},
	src: {},
	href: {},
	target: {},
	cornerStyle: {},
	border: {},
	stacked: {},
	dot: {},
	class: {},
	alt: {},
	size: {},
	onclick: {}
}, [], [], !0);
var avatar = ce({
	base: "relative flex items-center justify-center bg-gray-100 dark:bg-gray-600 text-gray-600 dark:text-gray-300",
	variants: {
		cornerStyle: {
			rounded: "rounded",
			circular: "rounded-full"
		},
		border: {
			true: "p-1 ring-2 ring-gray-300 dark:ring-gray-500",
			false: ""
		},
		stacked: {
			true: "border-2 -ms-4 border-white dark:border-gray-800",
			false: ""
		},
		size: {
			xs: "w-6 h-6",
			sm: "w-8 h-8",
			md: "w-10 h-10",
			lg: "w-20 h-20",
			xl: "w-36 h-36"
		}
	},
	defaultVariants: {
		cornerStyle: "circular",
		border: !1,
		stacked: !1,
		size: "md"
	}
}), root_2$57 = /* @__PURE__ */ from_html("<a><!></a>"), root_5$25 = /* @__PURE__ */ from_html("<button type=\"button\" class=\"m-0.5 -me-1.5 ms-1.5 whitespace-normal rounded p-0.5 text-primary-500 hover:bg-primary-200 focus:outline-none focus:ring-1 focus:ring-primary-400 dark:hover:bg-primary-800 dark:hover:text-primary-300\" aria-label=\"Remove badge\"><span class=\"sr-only\">Remove badge</span> <!></button>"), root_1$108 = /* @__PURE__ */ from_html("<div><!> <!></div>");
function Badge(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "icon", 7), F = prop(E, "badgeStatus", 15, !0), I = prop(E, "color", 7, "primary"), L = prop(E, "large", 7, !1), z = prop(E, "dismissable", 7, !1), B = prop(E, "class", 7), V = prop(E, "border", 7), U = prop(E, "href", 7), W = prop(E, "target", 7), G = prop(E, "rounded", 7), K = prop(E, "transition", 7, fade), J = prop(E, "params", 7), Y = prop(E, "aClass", 7), X = prop(E, "onclick", 7), Z = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"icon",
		"badgeStatus",
		"color",
		"large",
		"dismissable",
		"class",
		"border",
		"href",
		"target",
		"rounded",
		"transition",
		"params",
		"aClass",
		"onclick"
	]), Q = /* @__PURE__ */ user_derived(() => badge({
		color: I(),
		size: L() ? "large" : "small",
		border: V(),
		rounded: G()
	})), NL = /* @__PURE__ */ user_derived(() => get(Q).base), PL = /* @__PURE__ */ user_derived(() => get(Q).hrefClass);
	var FL = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get icon() {
			return O();
		},
		set icon(C) {
			O(C), flushSync();
		},
		get badgeStatus() {
			return F();
		},
		set badgeStatus(C = !0) {
			F(C), flushSync();
		},
		get color() {
			return I();
		},
		set color(C = "primary") {
			I(C), flushSync();
		},
		get large() {
			return L();
		},
		set large(C = !1) {
			L(C), flushSync();
		},
		get dismissable() {
			return z();
		},
		set dismissable(C = !1) {
			z(C), flushSync();
		},
		get class() {
			return B();
		},
		set class(C) {
			B(C), flushSync();
		},
		get border() {
			return V();
		},
		set border(C) {
			V(C), flushSync();
		},
		get href() {
			return U();
		},
		set href(C) {
			U(C), flushSync();
		},
		get target() {
			return W();
		},
		set target(C) {
			W(C), flushSync();
		},
		get rounded() {
			return G();
		},
		set rounded(C) {
			G(C), flushSync();
		},
		get transition() {
			return K();
		},
		set transition(C = fade) {
			K(C), flushSync();
		},
		get params() {
			return J();
		},
		set params(C) {
			J(C), flushSync();
		},
		get aClass() {
			return Y();
		},
		set aClass(C) {
			Y(C), flushSync();
		},
		get onclick() {
			return X();
		},
		set onclick(C) {
			X(C), flushSync();
		}
	}, IL = comment(), LL = first_child(IL), RL = (C) => {
		var E = root_1$108();
		attribute_effect(E, (C) => _objectSpread2(_objectSpread2({}, Z), {}, { class: C }), [() => get(NL)({ className: B() })]);
		var V = child(E), G = (C) => {
			var T = root_2$57();
			snippet(child(T), D), reset(T), template_effect((C) => {
				set_attribute(T, "href", U()), set_attribute(T, "target", W()), set_class(T, 1, C);
			}, [() => clsx$1(get(PL)({ class: Y() }))]), append(C, T);
		}, Q = (C) => {
			var T = comment();
			snippet(first_child(T), D), append(C, T);
		};
		if_block(V, (C) => {
			U() ? C(G) : C(Q, !1);
		});
		var FL = sibling(V, 2), IL = (C) => {
			var T = comment(), E = first_child(T), D = (C) => {
				var T = root_5$25();
				T.__click = () => {
					F(!1);
				}, snippet(sibling(child(T), 2), O), reset(T), append(C, T);
			}, z = (C) => {
				var T = comment(), E = first_child(T), D = (C) => {
					{
						let T = /* @__PURE__ */ user_derived(() => L() ? "sm" : "xs");
						CloseButton(C, {
							class: "-me-1.5 ms-1.5",
							get color() {
								return I();
							},
							get size() {
								return get(T);
							},
							ariaLabel: "Remove badge",
							get onclick() {
								return X();
							}
						});
					}
				}, O = (C) => {
					{
						let T = /* @__PURE__ */ user_derived(() => L() ? "sm" : "xs");
						CloseButton(C, {
							class: "-me-1.5 ms-1.5",
							get color() {
								return I();
							},
							get size() {
								return get(T);
							},
							ariaLabel: "Remove badge",
							onclick: () => {
								F(!1);
							}
						});
					}
				};
				if_block(E, (C) => {
					X() ? C(D) : C(O, !1);
				}, !0), append(C, T);
			};
			if_block(E, (C) => {
				O() ? C(D) : C(z, !1);
			}), append(C, T);
		};
		if_block(FL, (C) => {
			z() && C(IL);
		}), reset(E), transition(3, E, K, J), append(C, E);
	};
	return if_block(LL, (C) => {
		F() && C(RL);
	}), append(C, IL), pop(FL);
}
delegate(["click"]), create_custom_element(Badge, {
	children: {},
	icon: {},
	badgeStatus: {},
	color: {},
	large: {},
	dismissable: {},
	class: {},
	border: {},
	href: {},
	target: {},
	rounded: {},
	transition: {},
	params: {},
	aClass: {},
	onclick: {}
}, [], [], !0);
var badge = ce({
	slots: {
		hrefClass: "flex align-middle",
		base: "font-medium inline-flex items-center justify-center px-2.5 py-0.5"
	},
	variants: {
		color: {
			primary: { base: "bg-primary-100 text-primary-800 dark:bg-primary-900 dark:text-primary-300" },
			secondary: { base: "bg-secondary-100 text-secondary-800 dark:bg-secondary-900 dark:text-secondary-300" },
			gray: { base: "bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-300" },
			red: { base: "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300" },
			orange: { base: "bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-300" },
			amber: { base: "bg-amber-100 text-amber-800 dark:bg-amber-900 dark:text-amber-300" },
			yellow: { base: "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-300" },
			lime: { base: "bg-lime-100 text-lime-800 dark:bg-lime-900 dark:text-lime-300" },
			green: { base: "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300" },
			emerald: { base: "bg-emerald-100 text-emerald-800 dark:bg-emerald-900 dark:text-emerald-300" },
			teal: { base: "bg-teal-100 text-teal-800 dark:bg-teal-900 dark:text-teal-300" },
			cyan: { base: "bg-cyan-100 text-cyan-800 dark:bg-cyan-900 dark:text-cyan-300" },
			sky: { base: "bg-sky-100 text-sky-800 dark:bg-sky-900 dark:text-sky-300" },
			blue: { base: "bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300" },
			indigo: { base: "bg-indigo-100 text-indigo-800 dark:bg-indigo-900 dark:text-indigo-300" },
			violet: { base: "bg-violet-100 text-violet-800 dark:bg-violet-900 dark:text-violet-300" },
			fuchsia: { base: "bg-fuchsia-100 text-fuchsia-800 dark:bg-fuchsia-900 dark:text-fuchsia-300" },
			purple: { base: "bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-300" },
			pink: { base: "bg-pink-100 text-pink-800 dark:bg-pink-900 dark:text-pink-300" },
			rose: { base: "bg-rose-100 text-rose-800 dark:bg-rose-900 dark:text-rose-300" }
		},
		size: {
			small: "text-xs",
			large: "text-sm"
		},
		border: { true: "border" },
		rounded: {
			true: "rounded-full",
			false: "rounded"
		}
	},
	compoundVariants: [
		{
			border: !0,
			color: "primary",
			class: "bg-primary-100 text-primary-800 dark:bg-primary-700/50 dark:text-primary-400 border-primary-400 dark:border-primary-400"
		},
		{
			border: !0,
			color: "secondary",
			class: "bg-secondary-100 text-secondary-800 dark:bg-secondary-700/50 dark:text-secondary-400 border-secondary-400 dark:border-secondary-400"
		},
		{
			border: !0,
			color: "gray",
			class: "bg-gray-100 text-gray-800 dark:bg-gray-700/50 dark:text-gray-400 border-gray-400 dark:border-gray-400"
		},
		{
			border: !0,
			color: "red",
			class: "bg-red-100 text-red-800 dark:bg-red-700/50 dark:text-red-400 border-red-400 dark:border-red-400"
		},
		{
			border: !0,
			color: "orange",
			class: "bg-orange-100 text-orange-800 dark:bg-orange-700/50 dark:text-orange-400 border-orange-400 dark:border-orange-400"
		},
		{
			border: !0,
			color: "amber",
			class: "bg-amber-100 text-amber-800 dark:bg-amber-700/50 dark:text-amber-400 border-amber-400 dark:border-amber-400"
		},
		{
			border: !0,
			color: "yellow",
			class: "bg-yellow-100 text-yellow-800 dark:bg-yellow-700/50 dark:text-yellow-300 border-yellow-300 dark:border-yellow-300"
		},
		{
			border: !0,
			color: "lime",
			class: "bg-lime-100 text-lime-800 dark:bg-lime-700/50 dark:text-lime-400 border-lime-400 dark:border-lime-400"
		},
		{
			border: !0,
			color: "green",
			class: "bg-green-100 text-green-800 dark:bg-green-700/50 dark:text-green-400 border-green-400 dark:border-green-400"
		},
		{
			border: !0,
			color: "emerald",
			class: "bg-emerald-100 text-emerald-800 dark:bg-emerald-700/50 dark:text-emerald-400 border-emerald-400 dark:border-emerald-400"
		},
		{
			border: !0,
			color: "teal",
			class: "bg-teal-100 text-teal-800 dark:bg-teal-700/50 dark:text-teal-400 border-teal-400 dark:border-teal-400"
		},
		{
			border: !0,
			color: "cyan",
			class: "bg-cyan-100 text-cyan-800 dark:bg-cyan-700/50 dark:text-cyan-400 border-cyan-400 dark:border-cyan-400"
		},
		{
			border: !0,
			color: "sky",
			class: "bg-sky-100 text-sky-800 dark:bg-sky-700/50 dark:text-sky-400 border-sky-400 dark:border-sky-400"
		},
		{
			border: !0,
			color: "blue",
			class: "bg-blue-100 text-blue-800 dark:bg-blue-700/50 dark:text-blue-400 border-blue-400 dark:border-blue-400"
		},
		{
			border: !0,
			color: "indigo",
			class: "bg-indigo-100 text-indigo-800 dark:bg-indigo-700/50 dark:text-indigo-400 border-indigo-400 dark:border-indigo-400"
		},
		{
			border: !0,
			color: "violet",
			class: "bg-violet-100 text-violet-800 dark:bg-violet-700/50 dark:text-violet-400 border-violet-400 dark:border-violet-400"
		},
		{
			border: !0,
			color: "purple",
			class: "bg-purple-100 text-purple-800 dark:bg-purple-700/50 dark:text-purple-400 border-purple-400 dark:border-purple-400"
		},
		{
			border: !0,
			color: "fuchsia",
			class: "bg-fuchsia-100 text-fuchsia-800 dark:bg-fuchsia-700/50 dark:text-fuchsia-400 border-fuchsia-400 dark:border-fuchsia-400"
		},
		{
			border: !0,
			color: "pink",
			class: "bg-pink-100 text-pink-800 dark:bg-pink-700/50 dark:text-pink-400 border-pink-400 dark:border-pink-400"
		},
		{
			border: !0,
			color: "rose",
			class: "bg-rose-100 text-rose-800 dark:bg-rose-700/50 dark:text-rose-400 border-rose-400 dark:border-rose-400"
		},
		{
			href: !0,
			color: "primary",
			class: "hover:bg-primary-200"
		},
		{
			href: !0,
			color: "secondary",
			class: "hover:bg-secondary-200"
		},
		{
			href: !0,
			color: "gray",
			class: "hover:bg-gray-200"
		},
		{
			href: !0,
			color: "red",
			class: "hover:bg-red-200"
		},
		{
			href: !0,
			color: "orange",
			class: "hover:bg-orange-200"
		},
		{
			href: !0,
			color: "amber",
			class: "hover:bg-amber-200"
		},
		{
			href: !0,
			color: "yellow",
			class: "hover:bg-yellow-200"
		},
		{
			href: !0,
			color: "lime",
			class: "hover:bg-lime-200"
		},
		{
			href: !0,
			color: "green",
			class: "hover:bg-green-200"
		},
		{
			href: !0,
			color: "emerald",
			class: "hover:bg-emerald-200"
		},
		{
			href: !0,
			color: "teal",
			class: "hover:bg-teal-200"
		},
		{
			href: !0,
			color: "cyan",
			class: "hover:bg-cyan-200"
		},
		{
			href: !0,
			color: "sky",
			class: "hover:bg-sky-200"
		},
		{
			href: !0,
			color: "blue",
			class: "hover:bg-blue-200"
		},
		{
			href: !0,
			color: "indigo",
			class: "hover:bg-indigo-200"
		},
		{
			href: !0,
			color: "violet",
			class: "hover:bg-violet-200"
		},
		{
			href: !0,
			color: "purple",
			class: "hover:bg-purple-200"
		},
		{
			href: !0,
			color: "fuchsia",
			class: "hover:bg-fuchsia-200"
		},
		{
			href: !0,
			color: "pink",
			class: "hover:bg-pink-200"
		},
		{
			href: !0,
			color: "rose",
			class: "hover:bg-rose-200"
		}
	],
	defaultVariants: {
		color: "primary",
		size: "small",
		rounded: !1
	}
}), root_3$49 = /* @__PURE__ */ from_html("<div class=\"flex items-center\"><!></div>"), root_1$107 = /* @__PURE__ */ from_html("<div><!> <div><!></div> <!></div>");
function Banner(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "header", 7), F = prop(E, "bannerStatus", 15, !0), I = prop(E, "position", 7, "sticky"), L = prop(E, "dismissable", 7, !0), z = prop(E, "color", 7, "gray"), B = prop(E, "bannerType", 7, "default"), V = prop(E, "class", 7), U = prop(E, "innerClass", 7), W = prop(E, "transition", 7, fade), G = prop(E, "params", 7), K = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"header",
		"bannerStatus",
		"position",
		"dismissable",
		"color",
		"bannerType",
		"class",
		"innerClass",
		"transition",
		"params"
	]), { base: J, insideDiv: Y } = banner({
		bannerType: B(),
		color: z()
	}), X = /* @__PURE__ */ user_derived(() => J({
		position: I(),
		bannerType: B(),
		color: z(),
		className: V()
	})), Z = /* @__PURE__ */ user_derived(() => Y({
		bannerType: B(),
		class: U()
	}));
	var Q = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get header() {
			return O();
		},
		set header(C) {
			O(C), flushSync();
		},
		get bannerStatus() {
			return F();
		},
		set bannerStatus(C = !0) {
			F(C), flushSync();
		},
		get position() {
			return I();
		},
		set position(C = "sticky") {
			I(C), flushSync();
		},
		get dismissable() {
			return L();
		},
		set dismissable(C = !0) {
			L(C), flushSync();
		},
		get color() {
			return z();
		},
		set color(C = "gray") {
			z(C), flushSync();
		},
		get bannerType() {
			return B();
		},
		set bannerType(C = "default") {
			B(C), flushSync();
		},
		get class() {
			return V();
		},
		set class(C) {
			V(C), flushSync();
		},
		get innerClass() {
			return U();
		},
		set innerClass(C) {
			U(C), flushSync();
		},
		get transition() {
			return W();
		},
		set transition(C = fade) {
			W(C), flushSync();
		},
		get params() {
			return G();
		},
		set params(C) {
			G(C), flushSync();
		}
	}, NL = comment(), PL = first_child(NL), FL = (C) => {
		var E = root_1$107();
		attribute_effect(E, () => _objectSpread2({
			tabindex: "-1",
			class: get(X)
		}, K));
		var I = child(E), B = (C) => {
			var T = comment();
			snippet(first_child(T), O), append(C, T);
		};
		if_block(I, (C) => {
			O() && C(B);
		});
		var V = sibling(I, 2);
		snippet(child(V), D), reset(V);
		var U = sibling(V, 2), J = (C) => {
			var T = root_3$49();
			CloseButton(child(T), {
				class: "-mx-1.5 -my-1.5",
				get color() {
					return z();
				},
				ariaLabel: "Remove badge",
				onclick: () => {
					F(!1);
				}
			}), reset(T), append(C, T);
		};
		if_block(U, (C) => {
			L() && C(J);
		}), reset(E), template_effect(() => set_class(V, 1, clsx$1(get(Z)))), transition(3, E, W, G), append(C, E);
	};
	return if_block(PL, (C) => {
		F() && C(FL);
	}), append(C, NL), pop(Q);
}
create_custom_element(Banner, {
	children: {},
	header: {},
	bannerStatus: {},
	position: {},
	dismissable: {},
	color: {},
	bannerType: {},
	class: {},
	innerClass: {},
	transition: {},
	params: {}
}, [], [], !0);
var banner = ce({
	slots: {
		base: "z-10 flex justify-between p-4 dark:bg-gray-700 dark:border-gray-600",
		insideDiv: "flex items-center"
	},
	variants: {
		position: {
			static: { base: "static" },
			fixed: { base: "fixed" },
			absolute: { base: "absolute" },
			relative: { base: "relative" },
			sticky: { base: "sticky" }
		},
		bannerType: {
			default: {
				base: "top-0 start-0 w-full border-b border-gray-200 bg-gray-50",
				insideDiv: "mx-auto"
			},
			bottom: {
				base: "bottom-0 start-0 w-full border-t border-gray-200 bg-gray-50",
				insideDiv: "mx-auto"
			},
			cta: {
				base: "flex-col md:flex-row w-[calc(100%-2rem)] -translate-x-1/2 rtl:translate-x-1/2 bg-white border border-gray-100 rounded-lg shadow-sm lg:max-w-7xl start-1/2 top-6",
				insideDiv: "flex-col items-start mb-3 me-4 md:items-center md:flex-row md:mb-0"
			},
			signup: {
				base: "top-0 start-0 w-full border-b border-gray-200 bg-gray-50",
				insideDiv: "flex-shrink-0 w-full mx-auto sm:w-auto"
			},
			info: {
				base: "top-0 start-0 flex-col w-full border-b border-gray-200 md:flex-row bg-gray-50",
				insideDiv: "flex-shrink-0"
			}
		},
		color: {
			primary: { base: "bg-primary-50 dark:bg-primary-900" },
			secondary: { base: "bg-secondary-50 dark:bg-secondary-900" },
			gray: { base: "bg-gray-50 dark:bg-gray-700" },
			red: { base: "bg-red-50 dark:bg-red-900" },
			orange: { base: "bg-orange-50 dark:bg-orange-900" },
			amber: { base: "bg-amber-50 dark:bg-amber-900" },
			yellow: { base: "bg-yellow-50 dark:bg-yellow-900" },
			lime: { base: "bg-lime-50 dark:bg-lime-900" },
			green: { base: "bg-green-50 dark:bg-green-900" },
			emerald: { base: "bg-emerald-50 dark:bg-emerald-900" },
			teal: { base: "bg-teal-50 dark:bg-teal-900" },
			cyan: { base: "bg-cyan-50 dark:bg-cyan-900" },
			sky: { base: "bg-sky-50 dark:bg-sky-900" },
			blue: { base: "bg-blue-50 dark:bg-blue-900" },
			indigo: { base: "bg-indigo-50 dark:bg-indigo-900" },
			violet: { base: "bg-violet-50 dark:bg-violet-900" },
			purple: { base: "bg-purple-50 dark:bg-purple-900" },
			fuchsia: { base: "bg-fuchsia-50 dark:bg-fuchsia-900" },
			pink: { base: "bg-pink-50 dark:bg-pink-900" },
			rose: { base: "bg-rose-50 dark:bg-rose-900" }
		}
	},
	defaultVariants: {
		position: "sticky",
		bannerType: "default"
	}
}), root$132 = /* @__PURE__ */ from_html("<div><!> <div><!></div></div>");
function BottomNav(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "header", 7), F = prop(E, "position", 7, "fixed"), I = prop(E, "navType", 7, "default"), L = prop(E, "outerClass", 7), z = prop(E, "innerClass", 7), B = prop(E, "activeClass", 7), V = prop(E, "activeUrl", 7, ""), U = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"header",
		"position",
		"navType",
		"outerClass",
		"innerClass",
		"activeClass",
		"activeUrl"
	]), W = twMerge("text-primary-700 dark:text-primary-700 hover:text-primary-900 dark:hover:text-primary-900", B()), G = writable("");
	setContext("activeUrl", G), setContext("navType", I()), setContext("bottomNavType", { activeClass: W });
	let { outer: K, inner: J } = bottomNav({
		position: F(),
		navType: I()
	}), Y = /* @__PURE__ */ user_derived(() => K({ class: L() })), X = /* @__PURE__ */ user_derived(() => J({ class: z() }));
	user_effect(() => {
		G.set(V());
	});
	var Z = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get header() {
			return O();
		},
		set header(C) {
			O(C), flushSync();
		},
		get position() {
			return F();
		},
		set position(C = "fixed") {
			F(C), flushSync();
		},
		get navType() {
			return I();
		},
		set navType(C = "default") {
			I(C), flushSync();
		},
		get outerClass() {
			return L();
		},
		set outerClass(C) {
			L(C), flushSync();
		},
		get innerClass() {
			return z();
		},
		set innerClass(C) {
			z(C), flushSync();
		},
		get activeClass() {
			return B();
		},
		set activeClass(C) {
			B(C), flushSync();
		},
		get activeUrl() {
			return V();
		},
		set activeUrl(C = "") {
			V(C), flushSync();
		}
	}, Q = root$132();
	attribute_effect(Q, () => _objectSpread2(_objectSpread2({}, U), {}, { class: get(Y) }));
	var NL = child(Q), PL = (C) => {
		var T = comment();
		snippet(first_child(T), O), append(C, T);
	};
	if_block(NL, (C) => {
		O() && C(PL);
	});
	var FL = sibling(NL, 2);
	return snippet(child(FL), D), reset(FL), reset(Q), template_effect(() => set_class(FL, 1, clsx$1(get(X)))), append(C, Q), pop(Z);
}
create_custom_element(BottomNav, {
	children: {},
	header: {},
	position: {},
	navType: {},
	outerClass: {},
	innerClass: {},
	activeClass: {},
	activeUrl: {}
}, [], [], !0);
var root_1$106 = /* @__PURE__ */ from_html("<a><!> <span> </span></a>"), root_2$56 = /* @__PURE__ */ from_html("<button><!> <span> </span></button>");
function BottomNavItem(C, E) {
	var D;
	push(E, !0);
	let O = prop(E, "children", 7), F = prop(E, "btnName", 7), I = prop(E, "appBtnPosition", 7, "middle"), L = prop(E, "target", 7), z = prop(E, "activeClass", 7), B = prop(E, "href", 7, ""), V = prop(E, "btnClass", 7), U = prop(E, "spanClass", 7), W = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"btnName",
		"appBtnPosition",
		"target",
		"activeClass",
		"href",
		"btnClass",
		"spanClass"
	]), G = getContext("navType"), K = (D = getContext("bottomNavType")) == null ? {} : D, J = /* @__PURE__ */ state(!1), Y = getContext("activeUrl"), X = /* @__PURE__ */ state("");
	Y.subscribe((C) => {
		set(X, C, !0);
	});
	let { base: Z, span: Q } = bottomNavItem({
		navType: G,
		appBtnPosition: I()
	});
	user_effect(() => {
		set(J, get(X) ? B() === get(X) : get(X) ? get(X).startsWith(B()) : !1, !0);
	});
	function NL() {
		var C;
		return twMerge(Z({ class: V() }), get(J) && ((C = z()) == null ? K.activeClass : C));
	}
	function PL() {
		var C;
		return twMerge(Q({ class: U() }), get(J) && ((C = z()) == null ? K.activeClass : C));
	}
	let FL = /* @__PURE__ */ user_derived(() => _objectSpread2({
		"aria-label": F(),
		class: NL()
	}, W)), IL = /* @__PURE__ */ user_derived(() => _objectSpread2(_objectSpread2({}, get(FL)), {}, {
		href: B(),
		target: L()
	})), LL = /* @__PURE__ */ user_derived(() => _objectSpread2(_objectSpread2({}, get(FL)), {}, { type: "button" }));
	user_effect(() => {
		console.log("commonProps: ", get(FL));
	});
	var RL = {
		get children() {
			return O();
		},
		set children(C) {
			O(C), flushSync();
		},
		get btnName() {
			return F();
		},
		set btnName(C) {
			F(C), flushSync();
		},
		get appBtnPosition() {
			return I();
		},
		set appBtnPosition(C = "middle") {
			I(C), flushSync();
		},
		get target() {
			return L();
		},
		set target(C) {
			L(C), flushSync();
		},
		get activeClass() {
			return z();
		},
		set activeClass(C) {
			z(C), flushSync();
		},
		get href() {
			return B();
		},
		set href(C = "") {
			B(C), flushSync();
		},
		get btnClass() {
			return V();
		},
		set btnClass(C) {
			V(C), flushSync();
		},
		get spanClass() {
			return U();
		},
		set spanClass(C) {
			U(C), flushSync();
		}
	}, zL = comment(), BL = first_child(zL), VL = (C) => {
		var E = root_1$106();
		attribute_effect(E, () => _objectSpread2({}, get(IL)));
		var D = child(E);
		snippet(D, O);
		var I = sibling(D, 2), L = child(I, !0);
		reset(I), reset(E), template_effect((C) => {
			set_class(I, 1, C), set_text(L, F());
		}, [() => clsx$1(PL())]), append(C, E);
	}, HL = (C) => {
		var E = root_2$56();
		attribute_effect(E, () => _objectSpread2({}, get(LL)));
		var D = child(E);
		snippet(D, O);
		var I = sibling(D, 2), L = child(I, !0);
		reset(I), reset(E), template_effect((C) => {
			set_class(I, 1, C), set_text(L, F());
		}, [() => clsx$1(PL())]), append(C, E);
	};
	return if_block(BL, (C) => {
		B() ? C(VL) : C(HL, !1);
	}), append(C, zL), pop(RL);
}
create_custom_element(BottomNavItem, {
	children: {},
	btnName: {},
	appBtnPosition: {},
	target: {},
	activeClass: {},
	href: {},
	btnClass: {},
	spanClass: {}
}, [], [], !0);
var root$131 = /* @__PURE__ */ from_html("<button> </button>");
function BottomNavHeaderItem(C, E) {
	push(E, !0);
	let D = prop(E, "itemName", 7), O = prop(E, "active", 7), F = prop(E, "class", 7), I = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"itemName",
		"active",
		"class"
	]), L = /* @__PURE__ */ user_derived(() => bottomnavheaderitem({
		active: O(),
		className: F()
	}));
	var z = {
		get itemName() {
			return D();
		},
		set itemName(C) {
			D(C), flushSync();
		},
		get active() {
			return O();
		},
		set active(C) {
			O(C), flushSync();
		},
		get class() {
			return F();
		},
		set class(C) {
			F(C), flushSync();
		}
	}, B = root$131();
	attribute_effect(B, () => _objectSpread2(_objectSpread2({}, I), {}, { class: get(L) }));
	var V = child(B, !0);
	return reset(B), template_effect(() => set_text(V, D())), append(C, B), pop(z);
}
create_custom_element(BottomNavHeaderItem, {
	itemName: {},
	active: {},
	class: {}
}, [], [], !0);
var root$130 = /* @__PURE__ */ from_html("<div><div role=\"group\"><!></div></div>");
function BottomNavHeader(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "outerClass", 7), F = prop(E, "innerClass", 7), I = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"outerClass",
		"innerClass"
	]), L = /* @__PURE__ */ user_derived(bottomnavheader), z = /* @__PURE__ */ user_derived(() => get(L).innerDiv), B = /* @__PURE__ */ user_derived(() => get(L).outerDiv);
	var V = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get outerClass() {
			return O();
		},
		set outerClass(C) {
			O(C), flushSync();
		},
		get innerClass() {
			return F();
		},
		set innerClass(C) {
			F(C), flushSync();
		}
	}, U = root$130();
	attribute_effect(U, (C) => _objectSpread2(_objectSpread2({}, I), {}, { class: C }), [() => get(B)({ class: O() })]);
	var W = child(U);
	return snippet(child(W), D), reset(W), reset(U), template_effect((C) => set_class(W, 1, C), [() => clsx$1(get(z)({ class: F() }))]), append(C, U), pop(V);
}
create_custom_element(BottomNavHeader, {
	children: {},
	outerClass: {},
	innerClass: {}
}, [], [], !0);
const bottomNav = ce({
	slots: {
		outer: "w-full z-30 border-gray-200 dark:bg-gray-700 dark:border-gray-600",
		inner: "grid h-full max-w-lg mx-auto"
	},
	variants: {
		position: {
			static: { outer: "static" },
			fixed: { outer: "fixed" },
			absolute: { outer: "absolute" },
			relative: { outer: "relative" },
			sticky: { outer: "sticky" }
		},
		navType: {
			default: { outer: "bottom-0 start-0 h-16 bg-white border-t" },
			border: { outer: "bottom-0 start-0 h-16 bg-white border-t" },
			application: { outer: "h-16 max-w-lg -translate-x-1/2 rtl:translate-x-1/2 bg-white border rounded-full bottom-4 start-1/2" },
			pagination: { outer: "bottom-0 h-16 -translate-x-1/2 rtl:translate-x-1/2 bg-white border-t start-1/2" },
			group: { outer: "bottom-0 -translate-x-1/2 rtl:translate-x-1/2 bg-white border-t start-1/2" },
			card: { outer: "bottom-0 start-0 h-16 bg-white border-t" },
			meeting: {
				outer: "bottom-0 start-0 grid h-16 grid-cols-1 px-8 bg-white border-t md:grid-cols-3",
				inner: "flex items-center justify-center mx-auto"
			},
			video: {
				outer: "bottom-0 start-0 grid h-24 grid-cols-1 px-8 bg-white border-t md:grid-cols-3",
				inner: "flex items-center w-full"
			}
		}
	},
	defaultVariants: {
		position: "fixed",
		navType: "default"
	}
}), bottomNavItem = ce({
	slots: {
		base: "inline-flex flex-col items-center justify-center",
		span: "text-sm"
	},
	variants: {
		navType: {
			default: {
				base: "px-5 hover:bg-gray-50 dark:hover:bg-gray-800 group",
				span: "text-gray-500 dark:text-gray-400 group-hover:text-primary-600 dark:group-hover:text-primary-500"
			},
			border: {
				base: "px-5 border-gray-200 border-x hover:bg-gray-50 dark:hover:bg-gray-800 group dark:border-gray-600",
				span: "text-gray-500 dark:text-gray-400 group-hover:text-primary-600 dark:group-hover:text-primary-500"
			},
			application: {
				base: "",
				span: "sr-only"
			},
			pagination: {
				base: "px-5 hover:bg-gray-50 dark:hover:bg-gray-800 group",
				span: "sr-only"
			},
			group: {
				base: "p-4 hover:bg-gray-50 dark:hover:bg-gray-800 group",
				span: "sr-only"
			},
			card: {
				base: "px-5 hover:bg-gray-50 dark:hover:bg-gray-800 group",
				span: "text-gray-500 dark:text-gray-400 group-hover:text-primary-600 dark:group-hover:text-primary-500"
			},
			meeting: {
				base: "",
				span: ""
			},
			video: {
				base: "",
				span: ""
			}
		},
		appBtnPosition: {
			left: { base: "px-5 rounded-s-full hover:bg-gray-50 dark:hover:bg-gray-800 group" },
			middle: { base: "px-5 hover:bg-gray-50 dark:hover:bg-gray-800 group" },
			right: { base: "px-5 rounded-e-full hover:bg-gray-50 dark:hover:bg-gray-800 group" }
		}
	},
	defaultVariants: {
		navType: "default",
		appBtnPosition: "middle",
		active: !1
	}
}), bottomnavheader = ce({ slots: {
	innerDiv: "grid max-w-xs grid-cols-3 gap-1 p-1 mx-auto my-2 bg-gray-100 rounded-lg dark:bg-gray-600",
	outerDiv: "w-full"
} }), bottomnavheaderitem = ce({
	base: "px-5 py-1.5 text-xs font-medium rounded-lg",
	variants: { active: {
		true: "text-white bg-gray-900 dark:bg-gray-300 dark:text-gray-900",
		false: "text-gray-900 hover:bg-gray-200 dark:text-white dark:hover:bg-gray-700"
	} }
});
var root$129 = /* @__PURE__ */ from_html("<nav><ol><!></ol></nav>");
function Breadcrumb(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "solid", 7, !1), F = prop(E, "navClass", 7), I = prop(E, "olClass", 7), L = prop(E, "ariaLabel", 7, "Breadcrumb"), z = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"solid",
		"navClass",
		"olClass",
		"ariaLabel"
	]), B = getContext("themeConfig"), { nav: V, list: U } = ((B == null ? void 0 : B.breadcrumb) || breadcrumb)({ solid: O() }), W = /* @__PURE__ */ user_derived(() => V({ class: F() })), G = /* @__PURE__ */ user_derived(() => U({ class: I() }));
	var K = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get solid() {
			return O();
		},
		set solid(C = !1) {
			O(C), flushSync();
		},
		get navClass() {
			return F();
		},
		set navClass(C) {
			F(C), flushSync();
		},
		get olClass() {
			return I();
		},
		set olClass(C) {
			I(C), flushSync();
		},
		get ariaLabel() {
			return L();
		},
		set ariaLabel(C = "Breadcrumb") {
			L(C), flushSync();
		}
	}, J = root$129();
	attribute_effect(J, () => _objectSpread2(_objectSpread2({ "aria-label": L() }, z), {}, { class: get(W) }));
	var Y = child(J);
	return snippet(child(Y), D), reset(Y), reset(J), template_effect(() => set_class(Y, 1, clsx$1(get(G)))), append(C, J), pop(K);
}
create_custom_element(Breadcrumb, {
	children: {},
	solid: {},
	navClass: {},
	olClass: {},
	ariaLabel: {}
}, [], [], !0);
var root_3$48 = /* @__PURE__ */ from_svg("<svg class=\"me-2 h-4 w-4\" fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z\"></path></svg>"), root_1$105 = /* @__PURE__ */ from_html("<a><!> <!></a>"), root_6$14 = /* @__PURE__ */ from_svg("<svg fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" d=\"M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z\" clip-rule=\"evenodd\"></path></svg>"), root_7$15 = /* @__PURE__ */ from_html("<a><!></a>"), root_8$12 = /* @__PURE__ */ from_html("<span><!></span>"), root_4$33 = /* @__PURE__ */ from_html("<!> <!>", 1), root$128 = /* @__PURE__ */ from_html("<li><!></li>");
function BreadcrumbItem(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "icon", 7), F = prop(E, "home", 7, !1), I = prop(E, "href", 7), L = prop(E, "linkClass", 7), z = prop(E, "spanClass", 7), B = prop(E, "homeClass", 7), V = prop(E, "class", 7), U = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"icon",
		"home",
		"href",
		"linkClass",
		"spanClass",
		"homeClass",
		"class"
	]), { item: W, icon: G } = breadcrumb({
		home: F(),
		hasHref: !!I(),
		class: V()
	});
	var K = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get icon() {
			return O();
		},
		set icon(C) {
			O(C), flushSync();
		},
		get home() {
			return F();
		},
		set home(C = !1) {
			F(C), flushSync();
		},
		get href() {
			return I();
		},
		set href(C) {
			I(C), flushSync();
		},
		get linkClass() {
			return L();
		},
		set linkClass(C) {
			L(C), flushSync();
		},
		get spanClass() {
			return z();
		},
		set spanClass(C) {
			z(C), flushSync();
		},
		get homeClass() {
			return B();
		},
		set homeClass(C) {
			B(C), flushSync();
		},
		get class() {
			return V();
		},
		set class(C) {
			V(C), flushSync();
		}
	}, J = root$128();
	attribute_effect(J, (C) => _objectSpread2(_objectSpread2({}, U), {}, { class: C }), [W]);
	var Y = child(J), X = (C) => {
		var T = root_1$105(), E = child(T), F = (C) => {
			var T = comment();
			snippet(first_child(T), O), append(C, T);
		}, L = (C) => {
			append(C, root_3$48());
		};
		if_block(E, (C) => {
			O() ? C(F) : C(L, !1);
		}), snippet(sibling(E, 2), D), reset(T), template_effect((C) => {
			set_class(T, 1, C), set_attribute(T, "href", I());
		}, [() => clsx$1(W({
			home: !0,
			class: B()
		}))]), append(C, T);
	}, Z = (C) => {
		var T = root_4$33(), E = first_child(T), F = (C) => {
			var T = comment();
			snippet(first_child(T), O), append(C, T);
		}, B = (C) => {
			var T = root_6$14();
			template_effect((C) => set_class(T, 0, C), [() => clsx$1(G())]), append(C, T);
		};
		if_block(E, (C) => {
			O() ? C(F) : C(B, !1);
		});
		var V = sibling(E, 2), U = (C) => {
			var T = root_7$15();
			snippet(child(T), D), reset(T), template_effect((C) => {
				set_class(T, 1, C), set_attribute(T, "href", I());
			}, [() => clsx$1(twMerge(W({
				home: !1,
				hasHref: !0
			}), L()))]), append(C, T);
		}, K = (C) => {
			var T = root_8$12();
			snippet(child(T), D), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(twMerge(W({
				home: !1,
				hasHref: !1
			}), z()))]), append(C, T);
		};
		if_block(V, (C) => {
			I() ? C(U) : C(K, !1);
		}), append(C, T);
	};
	return if_block(Y, (C) => {
		F() ? C(X) : C(Z, !1);
	}), reset(J), append(C, J), pop(K);
}
create_custom_element(BreadcrumbItem, {
	children: {},
	icon: {},
	home: {},
	href: {},
	linkClass: {},
	spanClass: {},
	homeClass: {},
	class: {}
}, [], [], !0);
const breadcrumb = ce({
	slots: {
		nav: "flex",
		list: "inline-flex items-center space-x-1 rtl:space-x-reverse md:space-x-3 rtl:space-x-reverse",
		item: "inline-flex items-center",
		icon: "h-6 w-6 text-gray-400 rtl:-scale-x-100"
	},
	variants: {
		solid: {
			true: { nav: "px-5 py-3 text-gray-700 border border-gray-200 rounded-lg bg-gray-50 dark:bg-gray-800 dark:border-gray-700" },
			false: ""
		},
		home: {
			true: "",
			false: ""
		},
		hasHref: {
			true: "",
			false: ""
		}
	},
	compoundVariants: [
		{
			home: !0,
			class: {
				item: "inline-flex items-center text-sm font-medium text-gray-700 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white",
				icon: "me-2 h-4 w-4"
			}
		},
		{
			home: !1,
			hasHref: !0,
			class: { item: "ms-1 text-sm font-medium text-gray-700 hover:text-gray-900 md:ms-2 dark:text-gray-400 dark:hover:text-white" }
		},
		{
			home: !1,
			hasHref: !1,
			class: { item: "ms-1 text-sm font-medium text-gray-500 md:ms-2 dark:text-gray-400" }
		}
	],
	defaultVariants: { solid: !1 }
}), buttonGroup = ce({
	base: "inline-flex rounded-lg shadow-xs",
	variants: { size: {
		sm: "scale-90",
		md: "scale-100",
		lg: "scale-110"
	} },
	defaultVariants: { size: "md" }
});
function getTheme(C) {
	let T = getContext("theme");
	return T == null ? void 0 : T[C];
}
var root$127 = /* @__PURE__ */ from_html("<div><!></div>");
function ButtonGroup(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "size", 7, "md"), F = prop(E, "disabled", 7), I = prop(E, "class", 7), L = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"size",
		"disabled",
		"class"
	]), z = getTheme("buttonGroup"), B = /* @__PURE__ */ user_derived(() => buttonGroup({
		size: O(),
		class: clsx_default(z, I())
	}));
	setContext("group", O()), setContext("disabled", F());
	var V = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get size() {
			return O();
		},
		set size(C = "md") {
			O(C), flushSync();
		},
		get disabled() {
			return F();
		},
		set disabled(C) {
			F(C), flushSync();
		},
		get class() {
			return I();
		},
		set class(C) {
			I(C), flushSync();
		}
	}, U = root$127();
	return attribute_effect(U, () => _objectSpread2(_objectSpread2({}, L), {}, {
		class: get(B),
		role: "group"
	})), snippet(child(U), D), reset(U), append(C, U), pop(V);
}
create_custom_element(ButtonGroup, {
	children: {},
	size: {},
	disabled: {},
	class: {}
}, [], [], !0);
const button = ce({
	slots: {
		base: "text-center font-medium inline-flex items-center justify-center",
		outline: "bg-transparent border hover:text-white dark:bg-transparent dark:hover-text-white",
		shadow: "shadow-lg"
	},
	variants: {
		color: {
			primary: {
				base: "text-white bg-primary-700 hover:bg-primary-800 dark:bg-primary-600 dark:hover:bg-primary-700 focus-within:ring-primary-300 dark:focus-within:ring-primary-800",
				outline: "text-primary-700 border-primary-700 hover:bg-primary-800 dark:border-primary-500 dark:text-primary-500 dark:hover:bg-primary-600",
				shadow: "shadow-primary-500/50 dark:shadow-primary-800/80"
			},
			dark: {
				base: "text-white bg-gray-800 hover:bg-gray-900 dark:bg-gray-800 dark:hover:bg-gray-700 focus-within:ring-gray-300 dark:focus-within:ring-gray-700",
				outline: "text-gray-900 border-gray-800 hover:bg-gray-900 dark:border-gray-600 dark:text-gray-400 dark:hover:bg-gray-600",
				shadow: "shadow-gray-500/50 gray:shadow-gray-800/80"
			},
			alternative: {
				base: "text-gray-900 bg-transparent border border-gray-200 dark:border-gray-600 hover:bg-gray-100 dark:bg-gray-800 dark:text-gray-400 hover:text-primary-700 focus-within:text-primary-700 dark:focus-within:text-white dark:hover:text-white dark:hover:bg-gray-700 focus-within:ring-gray-200 dark:focus-within:ring-gray-700",
				outline: "text-gray-700 border-gray-700 hover:bg-gray-800 dark:border-gray-400 dark:text-gray-400 dark:hover:bg-gray-500",
				shadow: "_shadow-gray-500/50 dark:shadow-gray-800/80"
			},
			light: {
				base: "text-gray-900 bg-white border border-gray-300 hover:bg-gray-100 dark:bg-gray-800 dark:text-white dark:border-gray-600 dark:hover:bg-gray-700 dark:hover:border-gray-600 focus-within:ring-gray-200 dark:focus-within:ring-gray-700",
				outline: "text-gray-700 border-gray-700 hover:bg-gray-800 dark:border-gray-400 dark:text-gray-400 dark:hover:bg-gray-500",
				shadow: "shadow-gray-500/50 dark:shadow-gray-800/80"
			},
			secondary: {
				base: "text-white bg-secondary-700 hover:bg-secondary-800 dark:bg-secondary-600 dark:hover:bg-secondary-700 focus-within:ring-secondary-300 dark:focus-within:ring-secondary-800",
				outline: "text-secondary-700 border-secondary-700 hover:bg-secondary-800 dark:border-secondary-400 dark:text-secondary-400 dark:hover:bg-secondary-500",
				shadow: "shadow-secondary-500/50 dark:shadow-secondary-800/80"
			},
			gray: {
				base: "text-white bg-gray-700 hover:bg-gray-800 dark:bg-gray-600 dark:hover:bg-gray-700 focus-within:ring-gray-300 dark:focus-within:ring-gray-800",
				outline: "text-gray-700 border-gray-700 hover:bg-gray-800 dark:border-gray-400 dark:text-gray-400 dark:hover:bg-gray-500",
				shadow: "shadow-gray-500/50 dark:shadow-gray-800/80"
			},
			red: {
				base: "text-white bg-red-700 hover:bg-red-800 dark:bg-red-600 dark:hover:bg-red-700 focus-within:ring-red-300 dark:focus-within:ring-red-900",
				outline: "text-red-700 border-red-700 hover:bg-red-800 dark:border-red-500 dark:text-red-500 dark:hover:bg-red-600",
				shadow: "shadow-red-500/50 dark:shadow-red-800/80"
			},
			orange: {
				base: "text-white bg-orange-700 hover:bg-orange-800 dark:bg-orange-600 dark:hover:bg-orange-700 focus-within:ring-orange-300 dark:focus-within:ring-orange-900",
				outline: "text-orange-700 border-orange-700 hover:bg-orange-800 dark:border-orange-400 dark:text-orange-400 dark:hover:bg-orange-500",
				shadow: "shadow-orange-500/50 dark:shadow-orange-800/80"
			},
			amber: {
				base: "text-white bg-amber-700 hover:bg-amber-800 dark:bg-amber-600 dark:hover:bg-amber-700 focus-within:ring-amber-300 dark:focus-within:ring-amber-900",
				outline: "text-amber-700 border-amber-700 hover:bg-amber-800 dark:border-amber-400 dark:text-amber-400 dark:hover:bg-amber-500",
				shadow: "shadow-amber-500/50 dark:shadow-amber-800/80"
			},
			yellow: {
				base: "text-white bg-yellow-400 hover:bg-yellow-500 focus-within:ring-yellow-300 dark:focus-within:ring-yellow-900",
				outline: "text-yellow-400 border-yellow-400 hover:bg-yellow-500 dark:border-yellow-300 dark:text-yellow-300 dark:hover:bg-yellow-400",
				shadow: "shadow-yellow-500/50 dark:shadow-yellow-800/80"
			},
			lime: {
				base: "text-white bg-lime-700 hover:bg-lime-800 dark:bg-lime-600 dark:hover:bg-lime-700 focus-within:ring-lime-300 dark:focus-within:ring-lime-800",
				outline: "text-lime-700 border-lime-700 hover:bg-lime-800 dark:border-lime-400 dark:text-lime-400 dark:hover:bg-lime-500",
				shadow: "shadow-lime-500/50 dark:shadow-lime-800/80"
			},
			green: {
				base: "text-white bg-green-700 hover:bg-green-800 dark:bg-green-600 dark:hover:bg-green-700 focus-within:ring-green-300 dark:focus-within:ring-green-800",
				outline: "text-green-700 border-green-700 hover:bg-green-800 dark:border-green-500 dark:text-green-500 dark:hover:bg-green-600",
				shadow: "shadow-green-500/50 dark:shadow-green-800/80"
			},
			emerald: {
				base: "text-white bg-emerald-700 hover:bg-emerald-800 dark:bg-emerald-600 dark:hover:bg-emerald-700 focus-within:ring-emerald-300 dark:focus-within:ring-emerald-800",
				outline: "text-emerald-700 border-emerald-700 hover:bg-emerald-800 dark:border-emerald-400 dark:text-emerald-400 dark:hover:bg-emerald-500",
				shadow: "shadow-emerald-500/50 dark:shadow-emerald-800/80"
			},
			teal: {
				base: "text-white bg-teal-700 hover:bg-teal-800 dark:bg-teal-600 dark:hover:bg-teal-700 focus-within:ring-teal-300 dark:focus-within:ring-teal-800",
				outline: "text-teal-700 border-teal-700 hover:bg-teal-800 dark:border-teal-400 dark:text-teal-400 dark:hover:bg-teal-500",
				shadow: "shadow-teal-500/50 dark:shadow-teal-800/80"
			},
			cyan: {
				base: "text-white bg-cyan-700 hover:bg-cyan-800 dark:bg-cyan-600 dark:hover:bg-cyan-700 focus-within:ring-cyan-300 dark:focus-within:ring-cyan-800",
				outline: "text-cyan-700 border-cyan-700 hover:bg-cyan-800 dark:border-cyan-400 dark:text-cyan-400 dark:hover:bg-cyan-500",
				shadow: "shadow-cyan-500/50 dark:shadow-cyan-800/80"
			},
			sky: {
				base: "text-white bg-sky-700 hover:bg-sky-800 dark:bg-sky-600 dark:hover:bg-sky-700 focus-within:ring-sky-300 dark:focus-within:ring-sky-800",
				outline: "text-sky-700 border-sky-700 hover:bg-sky-800 dark:border-sky-400 dark:text-sky-400 dark:hover:bg-sky-500",
				shadow: "shadow-sky-500/50 dark:shadow-sky-800/80"
			},
			blue: {
				base: "text-white bg-blue-700 hover:bg-blue-800 dark:bg-blue-600 dark:hover:bg-blue-700 focus-within:ring-blue-300 dark:focus-within:ring-blue-800",
				outline: "text-blue-700 border-blue-700 hover:bg-blue-800 dark:border-blue-500 dark:text-blue-500 dark:hover:bg-blue-500",
				shadow: "shadow-blue-500/50 dark:shadow-blue-800/80"
			},
			indigo: {
				base: "text-white bg-indigo-700 hover:bg-indigo-800 dark:bg-indigo-600 dark:hover:bg-indigo-700 focus-within:ring-indigo-300 dark:focus-within:ring-indigo-800",
				outline: "text-indigo-700 border-indigo-700 hover:bg-indigo-800 dark:border-indigo-400 dark:text-indigo-400 dark:hover:bg-indigo-500",
				shadow: "shadow-indigo-500/50 dark:shadow-indigo-800/80"
			},
			violet: {
				base: "text-white bg-violet-700 hover:bg-violet-800 dark:bg-violet-600 dark:hover:bg-violet-700 focus-within:ring-violet-300 dark:focus-within:ring-violet-800",
				outline: "text-violet-700 border-violet-700 hover:bg-violet-800 dark:border-violet-400 dark:text-violet-400 dark:hover:bg-violet-500",
				shadow: "shadow-violet-500/50 dark:shadow-violet-800/80"
			},
			purple: {
				base: "text-white bg-purple-700 hover:bg-purple-800 dark:bg-purple-600 dark:hover:bg-purple-700",
				outline: "text-purple-700 border-purple-700 hover:bg-purple-800 dark:border-purple-400 dark:text-purple-400 dark:hover:bg-purple-500",
				shadow: "shadow-purple-500/50 dark:shadow-purple-800/80"
			},
			fuchsia: {
				base: "text-white bg-fuchsia-700 hover:bg-fuchsia-800 dark:bg-fuchsia-600 dark:hover:bg-fuchsia-700",
				outline: "text-fuchsia-700 border-fuchsia-700 hover:bg-fuchsia-800 dark:border-fuchsia-400 dark:text-fuchsia-400 dark:hover:bg-fuchsia-500",
				shadow: "shadow-fuchsia-500/50 dark:shadow-fuchsia-800/80"
			},
			pink: {
				base: "text-white bg-pink-700 hover:bg-pink-800 dark:bg-pink-600 dark:hover:bg-pink-700",
				outline: "text-pink-700 border-pink-700 hover:bg-pink-800 dark:border-pink-400 dark:text-pink-400 dark:hover:bg-pink-500",
				shadow: "shadow-pink-500/50 dark:shadow-pink-800/80"
			},
			rose: {
				base: "text-white bg-rose-700 hover:bg-rose-800 dark:bg-rose-600 dark:hover:bg-rose-700",
				outline: "text-rose-700 border-rose-700 hover:bg-rose-800 dark:border-rose-400 dark:text-rose-400 dark:hover:bg-rose-500",
				shadow: "shadow-rose-500/50 dark:shadow-rose-800/80"
			}
		},
		size: {
			xs: "px-3 py-2 text-xs",
			sm: "px-4 py-2 text-sm",
			md: "px-5 py-2.5 text-sm",
			lg: "px-5 py-3 text-base",
			xl: "px-6 py-3.5 text-base"
		},
		group: {
			true: "focus-within:ring-2 focus-within:z-10 [&:not(:first-child)]:rounded-s-none [&:not(:last-child)]:rounded-e-none [&:not(:last-child)]:border-e-0",
			false: "focus-within:ring-4 focus-within:outline-hidden"
		},
		disabled: {
			true: "cursor-not-allowed opacity-50",
			false: ""
		},
		pill: {
			true: "rounded-full",
			false: "rounded-lg"
		},
		checked: {
			true: "",
			false: ""
		}
	},
	compoundVariants: [],
	defaultVariants: { pill: !1 }
}), gradientButton = ce({
	slots: {
		base: "inline-flex items-center justify-center transition-all duration-75 ease-in text-white bg-linear-to-r ",
		outlineWrapper: "inline-flex items-center justify-center w-full border-0!"
	},
	variants: {
		color: {
			blue: { base: "from-blue-500 via-blue-600 to-blue-700 hover:bg-linear-to-br focus:ring-blue-300 dark:focus:ring-blue-800" },
			green: { base: "from-green-400 via-green-500 to-green-600 hover:bg-linear-to-br focus:ring-green-300 dark:focus:ring-green-800" },
			cyan: { base: "text-white bg-linear-to-r from-cyan-400 via-cyan-500 to-cyan-600 hover:bg-linear-to-br focus:ring-cyan-300 dark:focus:ring-cyan-800" },
			teal: { base: "text-white bg-linear-to-r from-teal-400 via-teal-500 to-teal-600 hover:bg-linear-to-br focus:ring-teal-300 dark:focus:ring-teal-800" },
			lime: { base: "text-gray-900 bg-linear-to-r from-lime-200 via-lime-400 to-lime-500 hover:bg-linear-to-br focus:ring-lime-300 dark:focus:ring-lime-800" },
			red: { base: "text-white bg-linear-to-r from-red-400 via-red-500 to-red-600 hover:bg-linear-to-br focus:ring-red-300 dark:focus:ring-red-800" },
			pink: { base: "text-white bg-linear-to-r from-pink-400 via-pink-500 to-pink-600 hover:bg-linear-to-br focus:ring-pink-300 dark:focus:ring-pink-800" },
			purple: { base: "text-white bg-linear-to-r from-purple-500 via-purple-600 to-purple-700 hover:bg-linear-to-br focus:ring-purple-300 dark:focus:ring-purple-800" },
			purpleToBlue: { base: "text-white bg-linear-to-br from-purple-600 to-blue-500 hover:bg-linear-to-bl focus:ring-blue-300 dark:focus:ring-blue-800" },
			cyanToBlue: { base: "text-white bg-linear-to-r from-cyan-500 to-blue-500 hover:bg-linear-to-bl focus:ring-cyan-300 dark:focus:ring-cyan-800" },
			greenToBlue: { base: "text-white bg-linear-to-br from-green-400 to-blue-600 hover:bg-linear-to-bl focus:ring-green-200 dark:focus:ring-green-800" },
			purpleToPink: { base: "text-white bg-linear-to-r from-purple-500 to-pink-500 hover:bg-linear-to-l focus:ring-purple-200 dark:focus:ring-purple-800" },
			pinkToOrange: { base: "text-white bg-linear-to-br from-pink-500 to-orange-400 hover:bg-linear-to-bl focus:ring-pink-200 dark:focus:ring-pink-800" },
			tealToLime: { base: "text-gray-900 bg-linear-to-r from-teal-200 to-lime-200 hover:bg-linear-to-l focus:ring-lime-200 dark:focus:ring-teal-700" },
			redToYellow: { base: "text-gray-900 bg-linear-to-r from-red-200 via-red-300 to-yellow-200 hover:bg-linear-to-bl focus:ring-red-100 dark:focus:ring-red-400" }
		},
		outline: { true: {
			base: "p-0.5",
			outlineWrapper: "bg-white text-gray-900! dark:bg-gray-900 dark:text-white! hover:bg-transparent hover:text-inherit! group-hover:opacity-0! group-hover:text-inherit!"
		} },
		pill: {
			true: {
				base: "rounded-full",
				outlineWrapper: "rounded-full"
			},
			false: {
				base: "rounded-lg",
				outlineWrapper: "rounded-lg"
			}
		},
		size: {
			xs: "px-3 py-2 text-xs",
			sm: "px-4 py-2 text-sm",
			md: "px-5 py-2.5 text-sm",
			lg: "px-5 py-3 text-base",
			xl: "px-6 py-3.5 text-base"
		},
		shadow: { true: { base: "shadow-lg" } },
		group: {
			true: "rounded-none",
			false: ""
		},
		disabled: { true: { base: "opacity-50 cursor-not-allowed" } }
	},
	compoundVariants: [
		{
			shadow: !0,
			color: "blue",
			class: { base: "shadow-blue-500/50 dark:shadow-blue-800/80" }
		},
		{
			shadow: !0,
			color: "green",
			class: { base: "shadow-green-500/50 dark:shadow-green-800/80" }
		},
		{
			shadow: !0,
			color: "cyan",
			class: { base: "shadow-cyan-500/50 dark:shadow-cyan-800/80" }
		},
		{
			shadow: !0,
			color: "teal",
			class: { base: "shadow-teal-500/50 dark:shadow-teal-800/80" }
		},
		{
			shadow: !0,
			color: "lime",
			class: { base: "shadow-lime-500/50 dark:shadow-lime-800/80" }
		},
		{
			shadow: !0,
			color: "red",
			class: { base: "shadow-red-500/50 dark:shadow-red-800/80" }
		},
		{
			shadow: !0,
			color: "pink",
			class: { base: "shadow-pink-500/50 dark:shadow-pink-800/80" }
		},
		{
			shadow: !0,
			color: "purple",
			class: { base: "shadow-purple-500/50 dark:shadow-purple-800/80" }
		},
		{
			shadow: !0,
			color: "purpleToBlue",
			class: { base: "shadow-blue-500/50 dark:shadow-blue-800/80" }
		},
		{
			shadow: !0,
			color: "cyanToBlue",
			class: { base: "shadow-cyan-500/50 dark:shadow-cyan-800/80" }
		},
		{
			shadow: !0,
			color: "greenToBlue",
			class: { base: "shadow-green-500/50 dark:shadow-green-800/80" }
		},
		{
			shadow: !0,
			color: "purpleToPink",
			class: { base: "shadow-purple-500/50 dark:shadow-purple-800/80" }
		},
		{
			shadow: !0,
			color: "pinkToOrange",
			class: { base: "shadow-pink-500/50 dark:shadow-pink-800/80" }
		},
		{
			shadow: !0,
			color: "tealToLime",
			class: { base: "shadow-lime-500/50 dark:shadow-teal-800/80" }
		},
		{
			shadow: !0,
			color: "redToYellow",
			class: { base: "shadow-red-500/50 dark:shadow-red-800/80" }
		},
		{
			group: !0,
			pill: !0,
			class: "first:rounded-s-full last:rounded-e-full"
		},
		{
			group: !0,
			pill: !1,
			class: "first:rounded-s-lg last:rounded-e-lg"
		}
	]
});
var root_1$104 = /* @__PURE__ */ from_html("<a><!></a>"), root_4$32 = /* @__PURE__ */ from_svg("<svg class=\"ml-2 h-4 w-4 animate-spin text-white\" fill=\"none\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\" aria-hidden=\"true\"><circle class=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" stroke-width=\"4\"></circle><path class=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z\"></path></svg>"), root_3$47 = /* @__PURE__ */ from_html("<button><!> <!></button>");
function Button(C, E) {
	push(E, !0);
	let D = getContext("group"), O = getContext("disabled"), F = prop(E, "children", 7), I = prop(E, "pill", 7), L = prop(E, "outline", 7, !1), z = prop(E, "size", 7, "md"), B = prop(E, "color", 7), V = prop(E, "shadow", 7, !1), U = prop(E, "tag", 7, "button"), W = prop(E, "disabled", 7), G = prop(E, "loading", 7, !1), K = prop(E, "class", 7), J = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"pill",
		"outline",
		"size",
		"color",
		"shadow",
		"tag",
		"disabled",
		"loading",
		"class"
	]), Y = getTheme("button"), X = /* @__PURE__ */ user_derived(() => D ? "sm" : z()), Z = /* @__PURE__ */ user_derived(() => {
		var C;
		return (C = B()) == null ? D ? L() ? "dark" : "alternative" : "primary" : C;
	}), Q = /* @__PURE__ */ user_derived(() => !!O || !!W() || G()), PL = /* @__PURE__ */ user_derived(() => button({
		color: get(Z),
		size: get(X),
		disabled: get(Q),
		pill: I(),
		group: !!D
	})), FL = /* @__PURE__ */ user_derived(() => get(PL).base), IL = /* @__PURE__ */ user_derived(() => get(PL).outline), LL = /* @__PURE__ */ user_derived(() => get(PL).shadow), RL = /* @__PURE__ */ user_derived(() => get(FL)({ class: clsx_default(L() && get(IL)(), V() && get(LL)(), Y == null ? void 0 : Y.base, K()) }));
	var zL = {
		get children() {
			return F();
		},
		set children(C) {
			F(C), flushSync();
		},
		get pill() {
			return I();
		},
		set pill(C) {
			I(C), flushSync();
		},
		get outline() {
			return L();
		},
		set outline(C = !1) {
			L(C), flushSync();
		},
		get size() {
			return z();
		},
		set size(C = "md") {
			z(C), flushSync();
		},
		get color() {
			return B();
		},
		set color(C) {
			B(C), flushSync();
		},
		get shadow() {
			return V();
		},
		set shadow(C = !1) {
			V(C), flushSync();
		},
		get tag() {
			return U();
		},
		set tag(C = "button") {
			U(C), flushSync();
		},
		get disabled() {
			return W();
		},
		set disabled(C) {
			W(C), flushSync();
		},
		get loading() {
			return G();
		},
		set loading(C = !1) {
			G(C), flushSync();
		},
		get class() {
			return K();
		},
		set class(C) {
			K(C), flushSync();
		}
	}, BL = comment(), VL = first_child(BL), HL = (C) => {
		var E = root_1$104();
		attribute_effect(E, () => _objectSpread2(_objectSpread2({}, J), {}, { class: get(RL) })), snippet(child(E), () => {
			var C;
			return (C = F()) == null ? noop : C;
		}), reset(E), append(C, E);
	}, UL = (C) => {
		var E = comment(), D = first_child(E), O = (C) => {
			var E = root_3$47();
			attribute_effect(E, () => _objectSpread2(_objectSpread2({ type: "button" }, J), {}, {
				class: get(RL),
				disabled: get(Q)
			}));
			var D = child(E);
			snippet(D, () => {
				var C;
				return (C = F()) == null ? noop : C;
			});
			var O = sibling(D, 2), I = (C) => {
				append(C, root_4$32());
			};
			if_block(O, (C) => {
				G() && C(I);
			}), reset(E), append(C, E);
		}, I = (C) => {
			var E = comment();
			element(first_child(E), U, !1, (C, E) => {
				attribute_effect(C, () => _objectSpread2(_objectSpread2({}, J), {}, { class: get(RL) }));
				var D = comment();
				snippet(first_child(D), () => {
					var C;
					return (C = F()) == null ? noop : C;
				}), append(E, D);
			}), append(C, E);
		};
		if_block(D, (C) => {
			U() === "button" ? C(O) : C(I, !1);
		}, !0), append(C, E);
	};
	return if_block(VL, (C) => {
		E.href === void 0 ? C(UL, !1) : C(HL);
	}), append(C, BL), pop(zL);
}
create_custom_element(Button, {
	children: {},
	pill: {},
	outline: {},
	size: {},
	color: {},
	shadow: {},
	tag: {},
	disabled: {},
	loading: {},
	class: {}
}, [], [], !0);
var root_1$103 = /* @__PURE__ */ from_html("<div><!></div>");
function GradientButton(C, T) {
	push(T, !0);
	let E = getContext("group"), D = prop(T, "children", 7), O = prop(T, "outline", 7), F = prop(T, "pill", 7), I = prop(T, "color", 7, "blue"), L = prop(T, "shadow", 7), z = prop(T, "class", 7), B = prop(T, "href", 7), V = prop(T, "disabled", 7), U = prop(T, "size", 7), W = prop(T, "btnClass", 7), G = /* @__PURE__ */ rest_props(T, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"outline",
		"pill",
		"color",
		"shadow",
		"class",
		"href",
		"disabled",
		"size",
		"btnClass"
	]), K = getTheme("gradientButton"), J = /* @__PURE__ */ user_derived(() => gradientButton({
		color: I(),
		outline: O(),
		pill: F(),
		shadow: L(),
		disabled: V(),
		size: U(),
		group: !!E
	})), Y = /* @__PURE__ */ user_derived(() => get(J).base), X = /* @__PURE__ */ user_derived(() => get(J).outlineWrapper);
	var Z = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get outline() {
			return O();
		},
		set outline(C) {
			O(C), flushSync();
		},
		get pill() {
			return F();
		},
		set pill(C) {
			F(C), flushSync();
		},
		get color() {
			return I();
		},
		set color(C = "blue") {
			I(C), flushSync();
		},
		get shadow() {
			return L();
		},
		set shadow(C) {
			L(C), flushSync();
		},
		get class() {
			return z();
		},
		set class(C) {
			z(C), flushSync();
		},
		get href() {
			return B();
		},
		set href(C) {
			B(C), flushSync();
		},
		get disabled() {
			return V();
		},
		set disabled(C) {
			V(C), flushSync();
		},
		get size() {
			return U();
		},
		set size(C) {
			U(C), flushSync();
		},
		get btnClass() {
			return W();
		},
		set btnClass(C) {
			W(C), flushSync();
		}
	}, Q = comment(), PL = first_child(Q), FL = (C) => {
		var T = root_1$103(), E = child(T);
		{
			let C = /* @__PURE__ */ user_derived(() => get(X)({ class: clsx_default(K == null ? void 0 : K.outlineWrapper, W()) }));
			Button(E, spread_props(() => G, {
				get class() {
					return get(C);
				},
				get disabled() {
					return V();
				},
				get href() {
					return B();
				},
				get size() {
					return U();
				},
				children: (C, T) => {
					var E = comment();
					snippet(first_child(E), () => {
						var C;
						return (C = D()) == null ? noop : C;
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}));
		}
		reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(Y)({ class: clsx_default(K == null ? void 0 : K.base, z()) }))]), append(C, T);
	}, IL = (C) => {
		{
			let T = /* @__PURE__ */ user_derived(() => get(Y)({ class: clsx_default(K == null ? void 0 : K.base, z()) }));
			Button(C, spread_props(() => G, {
				get class() {
					return get(T);
				},
				get disabled() {
					return V();
				},
				get href() {
					return B();
				},
				get size() {
					return U();
				},
				children: (C, T) => {
					var E = comment();
					snippet(first_child(E), () => {
						var C;
						return (C = D()) == null ? noop : C;
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}));
		}
	};
	return if_block(PL, (C) => {
		O() ? C(FL) : C(IL, !1);
	}), append(C, Q), pop(Z);
}
create_custom_element(GradientButton, {
	children: {},
	outline: {},
	pill: {},
	color: {},
	shadow: {},
	class: {},
	href: {},
	disabled: {},
	size: {},
	btnClass: {}
}, [], [], !0);
var root_2$55 = /* @__PURE__ */ from_html("<img/> <div><!></div>", 1), root_3$46 = /* @__PURE__ */ from_html("<div><!></div>"), root_4$31 = /* @__PURE__ */ from_html("<a><!></a>"), root_5$24 = /* @__PURE__ */ from_html("<div><!></div>");
function Card(C, E) {
	push(E, !0);
	let D = (C) => {
		var T = comment(), E = first_child(T), D = (C) => {
			var T = root_2$55(), E = first_child(T), D = sibling(E, 2);
			snippet(child(D), O), reset(D), template_effect((C, T) => {
				set_class(E, 1, C), set_attribute(E, "src", V().src), set_attribute(E, "alt", V().alt), set_class(D, 1, T);
			}, [() => clsx$1(get(Q)({ class: K() })), () => clsx$1(get(NL)({ class: J() }))]), append(C, T);
		}, F = (C) => {
			var T = root_3$46();
			snippet(child(T), O), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(NL)({ class: J() }))]), append(C, T);
		};
		if_block(E, (C) => {
			V() ? C(D) : C(F, !1);
		}), append(C, T);
	}, O = prop(E, "children", 7), F = prop(E, "href", 7), I = prop(E, "color", 7, "gray"), L = prop(E, "horizontal", 7, !1), z = prop(E, "shadow", 7, "md"), B = prop(E, "reverse", 7, !1), V = prop(E, "img", 7), U = prop(E, "padding", 7, "lg"), W = prop(E, "size", 7, "sm"), G = prop(E, "class", 7), K = prop(E, "imgClass", 7), J = prop(E, "contentClass", 7), Y = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"href",
		"color",
		"horizontal",
		"shadow",
		"reverse",
		"img",
		"padding",
		"size",
		"class",
		"imgClass",
		"contentClass"
	]), X = /* @__PURE__ */ user_derived(() => card({
		size: W(),
		color: I(),
		shadow: z(),
		padding: U(),
		horizontal: L(),
		reverse: B(),
		href: !!F()
	})), Z = /* @__PURE__ */ user_derived(() => get(X).base), Q = /* @__PURE__ */ user_derived(() => get(X).image), NL = /* @__PURE__ */ user_derived(() => get(X).content), PL = /* @__PURE__ */ user_derived(() => _objectSpread2({ class: get(Z)({ class: G() }) }, Y)), FL = /* @__PURE__ */ user_derived(() => _objectSpread2(_objectSpread2({}, get(PL)), {}, { href: F() })), IL = /* @__PURE__ */ user_derived(() => _objectSpread2({}, get(PL)));
	var LL = {
		get children() {
			return O();
		},
		set children(C) {
			O(C), flushSync();
		},
		get href() {
			return F();
		},
		set href(C) {
			F(C), flushSync();
		},
		get color() {
			return I();
		},
		set color(C = "gray") {
			I(C), flushSync();
		},
		get horizontal() {
			return L();
		},
		set horizontal(C = !1) {
			L(C), flushSync();
		},
		get shadow() {
			return z();
		},
		set shadow(C = "md") {
			z(C), flushSync();
		},
		get reverse() {
			return B();
		},
		set reverse(C = !1) {
			B(C), flushSync();
		},
		get img() {
			return V();
		},
		set img(C) {
			V(C), flushSync();
		},
		get padding() {
			return U();
		},
		set padding(C = "lg") {
			U(C), flushSync();
		},
		get size() {
			return W();
		},
		set size(C = "sm") {
			W(C), flushSync();
		},
		get class() {
			return G();
		},
		set class(C) {
			G(C), flushSync();
		},
		get imgClass() {
			return K();
		},
		set imgClass(C) {
			K(C), flushSync();
		},
		get contentClass() {
			return J();
		},
		set contentClass(C) {
			J(C), flushSync();
		}
	}, RL = comment(), zL = first_child(RL), BL = (C) => {
		var E = root_4$31();
		attribute_effect(E, () => _objectSpread2({}, get(FL))), D(child(E)), reset(E), append(C, E);
	}, VL = (C) => {
		var E = root_5$24();
		attribute_effect(E, () => _objectSpread2({}, get(IL))), D(child(E)), reset(E), append(C, E);
	};
	return if_block(zL, (C) => {
		F() ? C(BL) : C(VL, !1);
	}), append(C, RL), pop(LL);
}
create_custom_element(Card, {
	children: {},
	href: {},
	color: {},
	horizontal: {},
	shadow: {},
	reverse: {},
	img: {},
	padding: {},
	size: {},
	class: {},
	imgClass: {},
	contentClass: {}
}, [], [], !0);
const card = ce({
	slots: {
		base: "w-full flex max-w-sm bg-white border border-gray-200 rounded-lg dark:bg-gray-800 dark:border-gray-700",
		image: "rounded-t-lg",
		content: ""
	},
	variants: {
		size: {
			xs: { base: "max-w-xs" },
			sm: { base: "max-w-sm" },
			md: { base: "max-w-lg" },
			lg: { base: "max-w-2xl" },
			xl: { base: "max-w-screen-xl" }
		},
		color: {
			gray: { base: "border-gray-200 dark:bg-gray-800 dark:border-gray-700" },
			primary: { base: "border-primary-200 bg-primary-400 dark:bg-primary-800 dark:border-primary-700" },
			secondary: { base: "border-secondary-200 bg-secondary-400 dark:bg-secondary-800 dark:border-secondary-700" },
			red: { base: "border-red-200 bg-red-400 dark:bg-red-800 dark:border-red-700" },
			orange: { base: "border-orange-200 bg-orange-400 dark:bg-orange-800 dark:border-orange-700" },
			amber: { base: "border-amber-200 bg-amber-400 dark:bg-amber-800 dark:border-amber-700" },
			yellow: { base: "border-yellow-200 bg-yellow-400 dark:bg-yellow-800 dark:border-yellow-700" },
			lime: { base: "border-lime-200 bg-lime-400 dark:bg-lime-800 dark:border-lime-700" },
			green: { base: "border-green-200 bg-green-400 dark:bg-green-800 dark:border-green-700" },
			emerald: { base: "border-emerald-200 bg-emerald-400 dark:bg-emerald-800 dark:border-emerald-700" },
			teal: { base: "border-teal-200 bg-teal-400 dark:bg-teal-800 dark:border-teal-700" },
			cyan: { base: "border-cyan-200 bg-cyan-400 dark:bg-cyan-800 dark:border-cyan-700" },
			sky: { base: "border-sky-200 bg-sky-400 dark:bg-sky-800 dark:border-sky-700" },
			blue: { base: "border-blue-200 bg-blue-400 dark:bg-blue-800 dark:border-blue-700" },
			indigo: { base: "border-indigo-200 bg-indigo-400 dark:bg-indigo-800 dark:border-indigo-700" },
			violet: { base: "border-violet-200 bg-violet-400 dark:bg-violet-800 dark:border-violet-700" },
			purple: { base: "border-purple-200 bg-purple-400 dark:bg-purple-800 dark:border-purple-700" },
			fuchsia: { base: "border-fuchsia-200 bg-fuchsia-400 dark:bg-fuchsia-800 dark:border-fuchsia-700" },
			pink: { base: "border-pink-200 bg-pink-400 dark:bg-pink-800 dark:border-pink-700" },
			rose: { base: "border-rose-200 bg-rose-400 dark:bg-rose-800 dark:border-rose-700" }
		},
		shadow: {
			sm: { base: "shadow-md" },
			normal: { base: "shadow" },
			md: { base: "shadow-md" },
			lg: { base: "shadow-lg" },
			xl: { base: "shadow-xl" },
			"2xl": { base: "shadow-2xl" },
			inner: { base: "shadow-inner" }
		},
		padding: {
			xs: { content: "p-2" },
			sm: { content: "p-4 md:p-6" },
			md: { content: "p-4 sm:p-5 md:p-7" },
			lg: { content: "p-4 sm:p-6 md:p-8" },
			xl: { content: "p-4 sm:p-8 md:p-10" },
			none: { content: "p-0" }
		},
		horizontal: { true: {
			base: "md:flex-row",
			image: "object-cover w-full h-96 md:h-auto md:w-48 md:rounded-none"
		} },
		reverse: {
			true: {
				base: "flex-col-reverse",
				image: "rounded-b-lg rounded-tl-none"
			},
			false: {
				base: "flex-col",
				image: "rounded-t-lg"
			}
		},
		href: {
			true: "",
			false: ""
		},
		hasImage: {
			true: "",
			false: ""
		}
	},
	compoundVariants: [
		{
			horizontal: !0,
			reverse: !0,
			class: {
				base: "md:flex-row-reverse",
				image: "md:rounded-e-lg"
			}
		},
		{
			horizontal: !0,
			reverse: !1,
			class: {
				base: "md:flex-row",
				image: "md:rounded-s-lg"
			}
		},
		{
			href: !0,
			color: "gray",
			class: { base: "cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700" }
		},
		{
			href: !0,
			color: "primary",
			class: { base: "cursor-pointer hover:bg-primary-500 dark:hover:bg-primary-700" }
		},
		{
			href: !0,
			color: "secondary",
			class: { base: "cursor-pointer hover:bg-secondary-500 dark:hover:bg-secondary-700" }
		},
		{
			href: !0,
			color: "red",
			class: { base: "cursor-pointer hover:bg-red-500 dark:hover:bg-red-700" }
		},
		{
			href: !0,
			color: "orange",
			class: { base: "cursor-pointer hover:bg-orange-500 dark:hover:bg-orange-700" }
		},
		{
			href: !0,
			color: "amber",
			class: { base: "cursor-pointer hover:bg-amber-500 dark:hover:bg-amber-700" }
		},
		{
			href: !0,
			color: "yellow",
			class: { base: "cursor-pointer hover:bg-yellow-500 dark:hover:bg-yellow-700" }
		},
		{
			href: !0,
			color: "lime",
			class: { base: "cursor-pointer hover:bg-lime-500 dark:hover:bg-lime-700" }
		},
		{
			href: !0,
			color: "green",
			class: { base: "cursor-pointer hover:bg-green-500 dark:hover:bg-green-700" }
		},
		{
			href: !0,
			color: "emerald",
			class: { base: "cursor-pointer hover:bg-emerald-500 dark:hover:bg-emerald-700" }
		},
		{
			href: !0,
			color: "teal",
			class: { base: "cursor-pointer hover:bg-teal-500 dark:hover:bg-teal-700" }
		},
		{
			href: !0,
			color: "cyan",
			class: { base: "cursor-pointer hover:bg-cyan-500 dark:hover:bg-cyan-700" }
		},
		{
			href: !0,
			color: "sky",
			class: { base: "cursor-pointer hover:bg-sky-500 dark:hover:bg-sky-700" }
		},
		{
			href: !0,
			color: "blue",
			class: { base: "cursor-pointer hover:bg-blue-500 dark:hover:bg-blue-700" }
		},
		{
			href: !0,
			color: "indigo",
			class: { base: "cursor-pointer hover:bg-indigo-500 dark:hover:bg-indigo-700" }
		},
		{
			href: !0,
			color: "violet",
			class: { base: "cursor-pointer hover:bg-violet-500 dark:hover:bg-violet-700" }
		},
		{
			href: !0,
			color: "purple",
			class: { base: "cursor-pointer hover:bg-purple-500 dark:hover:bg-purple-700" }
		},
		{
			href: !0,
			color: "fuchsia",
			class: { base: "cursor-pointer hover:bg-fuchsia-500 dark:hover:bg-fuchsia-700" }
		},
		{
			href: !0,
			color: "pink",
			class: { base: "cursor-pointer hover:bg-pink-500 dark:hover:bg-pink-700" }
		},
		{
			href: !0,
			color: "rose",
			class: { base: "cursor-pointer hover:bg-rose-500 dark:hover:bg-rose-700" }
		}
	],
	defaultVariants: {
		size: "sm",
		shadow: "normal",
		padding: "lg",
		horizontal: !1,
		reverse: !1
	}
});
var root$126 = /* @__PURE__ */ from_html("<div></div>");
function Chart$1(C, T) {
	push(T, !0);
	let E = prop(T, "options", 7), D = prop(T, "class", 7);
	function O(C, T) {
		let E;
		function D() {
			return O.apply(this, arguments);
		}
		function O() {
			return O = _asyncToGenerator(function* () {
				let D = (yield import("./apexcharts.esm-BrifJtrm.js")).default;
				E = new D(C, T), E.render();
			}), O.apply(this, arguments);
		}
		return D(), {
			update(C) {
				E && E.updateOptions(C);
			},
			destroy() {
				E && E.destroy();
			}
		};
	}
	var F = {
		get options() {
			return E();
		},
		set options(C) {
			E(C), flushSync();
		},
		get class() {
			return D();
		},
		set class(C) {
			D(C), flushSync();
		}
	}, I = root$126();
	return action(I, (C, T) => O == null ? void 0 : O(C, T), E), template_effect(() => set_class(I, 1, clsx$1(D()))), append(C, I), pop(F);
}
create_custom_element(Chart$1, {
	options: {},
	class: {}
}, [], [], !0);
var root_1$102 = with_script(/* @__PURE__ */ from_html("<script>\n    if (\"THEME_PREFERENCE_KEY\" in localStorage) {\n      localStorage.getItem(\"THEME_PREFERENCE_KEY\") === \"dark\" ? window.document.documentElement.classList.add(\"dark\") : window.document.documentElement.classList.remove(\"dark\");\n    } else {\n      if (window.matchMedia(\"(prefers-color-scheme: dark)\").matches) window.document.documentElement.classList.add(\"dark\");\n    }\n  <\/script><!>", 1)), root_3$45 = /* @__PURE__ */ from_svg("<svg role=\"img\" aria-label=\"Light mode\" fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1\n    0 100-2H3a1 1 0 000 2h1z\" fill-rule=\"evenodd\" clip-rule=\"evenodd\"></path></svg>"), root_5$23 = /* @__PURE__ */ from_svg("<svg role=\"img\" aria-label=\"Dark mode\" fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z\"></path></svg>"), root$125 = /* @__PURE__ */ from_html("<button><span class=\"hidden dark:block\"><!></span> <span class=\"block dark:hidden\"><!></span></button>");
function Darkmode(C, E) {
	push(E, !0);
	let D = prop(E, "class", 7), O = prop(E, "lightIcon", 7), F = prop(E, "darkIcon", 7), I = prop(E, "size", 7, "md"), L = prop(E, "ariaLabel", 7, "Dark mode"), z = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"class",
		"lightIcon",
		"darkIcon",
		"size",
		"ariaLabel"
	]), B = darkmode({ class: D() }), V = {
		sm: "w-4 h-4",
		md: "w-5 h-5",
		lg: "w-6 h-6"
	}, U = (C) => {
		let T = C.target, E = T.ownerDocument.documentElement.classList.toggle("dark");
		T.ownerDocument === document && localStorage.setItem("THEME_PREFERENCE_KEY", E ? "dark" : "light");
	};
	var W = {
		get class() {
			return D();
		},
		set class(C) {
			D(C), flushSync();
		},
		get lightIcon() {
			return O();
		},
		set lightIcon(C) {
			O(C), flushSync();
		},
		get darkIcon() {
			return F();
		},
		set darkIcon(C) {
			F(C), flushSync();
		},
		get size() {
			return I();
		},
		set size(C = "md") {
			I(C), flushSync();
		},
		get ariaLabel() {
			return L();
		},
		set ariaLabel(C = "Dark mode") {
			L(C), flushSync();
		}
	}, G = root$125();
	head("19tyieb", (C) => {
		var T = root_1$102();
		sibling(first_child(T)), append(C, T);
	}), attribute_effect(G, () => _objectSpread2(_objectSpread2({
		onclick: U,
		"aria-label": L(),
		type: "button"
	}, z), {}, {
		class: B,
		tabindex: 0
	}));
	var K = child(G), J = child(K), Y = (C) => {
		var T = comment();
		snippet(first_child(T), O), append(C, T);
	}, X = (C) => {
		var T = root_3$45();
		template_effect(() => set_class(T, 0, clsx$1(V[I()]))), append(C, T);
	};
	if_block(J, (C) => {
		O() ? C(Y) : C(X, !1);
	}), reset(K);
	var Z = sibling(K, 2), Q = child(Z), NL = (C) => {
		var T = comment();
		snippet(first_child(T), F), append(C, T);
	}, PL = (C) => {
		var T = root_5$23();
		template_effect(() => set_class(T, 0, clsx$1(V[I()]))), append(C, T);
	};
	return if_block(Q, (C) => {
		F() ? C(NL) : C(PL, !1);
	}), reset(Z), reset(G), append(C, G), pop(W);
}
create_custom_element(Darkmode, {
	class: {},
	lightIcon: {},
	darkIcon: {},
	size: {},
	ariaLabel: {}
}, [], [], !0);
const darkmode = ce({ base: "text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 focus:outline-none rounded-lg text-sm p-2.5 focus:ring-1" });
var root$124 = /* @__PURE__ */ from_html("<div><div></div> <div></div> <div></div> <div></div> <div></div> <div><!></div></div>");
function Android(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "divClass", 7), F = prop(E, "div2Class", 7), I = prop(E, "div3Class", 7), L = prop(E, "div4Class", 7), z = prop(E, "div5Class", 7), B = prop(E, "div6Class", 7), V = prop(E, "div7Class", 7), U = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"divClass",
		"div2Class",
		"div3Class",
		"div4Class",
		"div5Class",
		"div6Class",
		"div7Class"
	]), { div: W, slot: G, top: K, leftTop: J, leftMid: Y, leftBot: X, right: Z } = android();
	var Q = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get divClass() {
			return O();
		},
		set divClass(C) {
			O(C), flushSync();
		},
		get div2Class() {
			return F();
		},
		set div2Class(C) {
			F(C), flushSync();
		},
		get div3Class() {
			return I();
		},
		set div3Class(C) {
			I(C), flushSync();
		},
		get div4Class() {
			return L();
		},
		set div4Class(C) {
			L(C), flushSync();
		},
		get div5Class() {
			return z();
		},
		set div5Class(C) {
			z(C), flushSync();
		},
		get div6Class() {
			return B();
		},
		set div6Class(C) {
			B(C), flushSync();
		},
		get div7Class() {
			return V();
		},
		set div7Class(C) {
			V(C), flushSync();
		}
	}, NL = root$124();
	attribute_effect(NL, (C) => _objectSpread2(_objectSpread2({}, U), {}, { class: C }), [() => W({ class: O() })]);
	var PL = child(NL), FL = sibling(PL, 2), IL = sibling(FL, 2), LL = sibling(IL, 2), RL = sibling(LL, 2), zL = sibling(RL, 2), BL = child(zL), VL = (C) => {
		var T = comment();
		snippet(first_child(T), D), append(C, T);
	};
	return if_block(BL, (C) => {
		D() && C(VL);
	}), reset(zL), reset(NL), template_effect((C, T, E, D, O, F) => {
		set_class(PL, 1, C), set_class(FL, 1, T), set_class(IL, 1, E), set_class(LL, 1, D), set_class(RL, 1, O), set_class(zL, 1, F);
	}, [
		() => clsx$1(K({ class: F() })),
		() => clsx$1(J({ class: I() })),
		() => clsx$1(Y({ class: L() })),
		() => clsx$1(X({ class: z() })),
		() => clsx$1(Z({ class: B() })),
		() => clsx$1(G({ class: V() }))
	]), append(C, NL), pop(Q);
}
create_custom_element(Android, {
	children: {},
	divClass: {},
	div2Class: {},
	div3Class: {},
	div4Class: {},
	div5Class: {},
	div6Class: {},
	div7Class: {}
}, [], [], !0);
var root$123 = /* @__PURE__ */ from_html("<div><div></div> <div></div> <div></div> <div></div> <div><!></div></div>");
function DefaultMockup(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "divClass", 7), F = prop(E, "div2Class", 7), I = prop(E, "div3Class", 7), L = prop(E, "div4Class", 7), z = prop(E, "div5Class", 7), B = prop(E, "div6Class", 7), V = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"divClass",
		"div2Class",
		"div3Class",
		"div4Class",
		"div5Class",
		"div6Class"
	]), { div: U, slot: W, top: G, leftTop: K, leftBot: J, right: Y } = defaultMockup();
	var X = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get divClass() {
			return O();
		},
		set divClass(C) {
			O(C), flushSync();
		},
		get div2Class() {
			return F();
		},
		set div2Class(C) {
			F(C), flushSync();
		},
		get div3Class() {
			return I();
		},
		set div3Class(C) {
			I(C), flushSync();
		},
		get div4Class() {
			return L();
		},
		set div4Class(C) {
			L(C), flushSync();
		},
		get div5Class() {
			return z();
		},
		set div5Class(C) {
			z(C), flushSync();
		},
		get div6Class() {
			return B();
		},
		set div6Class(C) {
			B(C), flushSync();
		}
	}, Z = root$123();
	attribute_effect(Z, (C) => _objectSpread2(_objectSpread2({}, V), {}, { class: C }), [() => U({ class: O() })]);
	var Q = child(Z), NL = sibling(Q, 2), PL = sibling(NL, 2), FL = sibling(PL, 2), IL = sibling(FL, 2), LL = child(IL), RL = (C) => {
		var T = comment();
		snippet(first_child(T), D), append(C, T);
	};
	return if_block(LL, (C) => {
		D() && C(RL);
	}), reset(IL), reset(Z), template_effect((C, T, E, D, O) => {
		set_class(Q, 1, C), set_class(NL, 1, T), set_class(PL, 1, E), set_class(FL, 1, D), set_class(IL, 1, O);
	}, [
		() => clsx$1(G({ class: F() })),
		() => clsx$1(K({ class: I() })),
		() => clsx$1(J({ class: L() })),
		() => clsx$1(Y({ class: z() })),
		() => clsx$1(W({ class: B() }))
	]), append(C, Z), pop(X);
}
create_custom_element(DefaultMockup, {
	children: {},
	divClass: {},
	div2Class: {},
	div3Class: {},
	div4Class: {},
	div5Class: {},
	div6Class: {}
}, [], [], !0);
var root$122 = /* @__PURE__ */ from_html("<div><div><!></div></div> <div></div> <div></div>", 1);
function Desktop(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "divClass", 7), F = prop(E, "div2Class", 7), I = prop(E, "div3Class", 7), L = prop(E, "div4Class", 7), z = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"divClass",
		"div2Class",
		"div3Class",
		"div4Class"
	]), { div: B, inner: V, bot: U, botUnder: W } = desktop();
	var G = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get divClass() {
			return O();
		},
		set divClass(C) {
			O(C), flushSync();
		},
		get div2Class() {
			return F();
		},
		set div2Class(C) {
			F(C), flushSync();
		},
		get div3Class() {
			return I();
		},
		set div3Class(C) {
			I(C), flushSync();
		},
		get div4Class() {
			return L();
		},
		set div4Class(C) {
			L(C), flushSync();
		}
	}, K = root$122(), J = first_child(K);
	attribute_effect(J, (C) => _objectSpread2(_objectSpread2({}, z), {}, { class: C }), [() => B({ class: O() })]);
	var Y = child(J), X = child(Y), Z = (C) => {
		var T = comment();
		snippet(first_child(T), D), append(C, T);
	};
	if_block(X, (C) => {
		D() && C(Z);
	}), reset(Y), reset(J);
	var Q = sibling(J, 2), NL = sibling(Q, 2);
	return template_effect((C, T, E) => {
		set_class(Y, 1, C), set_class(Q, 1, T), set_class(NL, 1, E);
	}, [
		() => clsx$1(V({ class: F() })),
		() => clsx$1(U({ class: I() })),
		() => clsx$1(W({ class: L() }))
	]), append(C, K), pop(G);
}
create_custom_element(Desktop, {
	children: {},
	divClass: {},
	div2Class: {},
	div3Class: {},
	div4Class: {}
}, [], [], !0);
var root$121 = /* @__PURE__ */ from_html("<div><div></div> <div></div> <div></div> <div></div> <div><!></div></div>");
function Ios(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "divClass", 7), F = prop(E, "div2Class", 7), I = prop(E, "div3Class", 7), L = prop(E, "div4Class", 7), z = prop(E, "div5Class", 7), B = prop(E, "div6Class", 7), V = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"divClass",
		"div2Class",
		"div3Class",
		"div4Class",
		"div5Class",
		"div6Class"
	]), { div: U, slot: W, top: G, leftTop: K, leftBot: J, right: Y } = ios();
	var X = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get divClass() {
			return O();
		},
		set divClass(C) {
			O(C), flushSync();
		},
		get div2Class() {
			return F();
		},
		set div2Class(C) {
			F(C), flushSync();
		},
		get div3Class() {
			return I();
		},
		set div3Class(C) {
			I(C), flushSync();
		},
		get div4Class() {
			return L();
		},
		set div4Class(C) {
			L(C), flushSync();
		},
		get div5Class() {
			return z();
		},
		set div5Class(C) {
			z(C), flushSync();
		},
		get div6Class() {
			return B();
		},
		set div6Class(C) {
			B(C), flushSync();
		}
	}, Z = root$121();
	attribute_effect(Z, (C) => _objectSpread2(_objectSpread2({}, V), {}, { class: C }), [() => U({ class: O() })]);
	var Q = child(Z), NL = sibling(Q, 2), PL = sibling(NL, 2), FL = sibling(PL, 2), IL = sibling(FL, 2), LL = child(IL), RL = (C) => {
		var T = comment();
		snippet(first_child(T), D), append(C, T);
	};
	return if_block(LL, (C) => {
		D() && C(RL);
	}), reset(IL), reset(Z), template_effect((C, T, E, D, O) => {
		set_class(Q, 1, C), set_class(NL, 1, T), set_class(PL, 1, E), set_class(FL, 1, D), set_class(IL, 1, O);
	}, [
		() => clsx$1(G({ class: F() })),
		() => clsx$1(K({ class: I() })),
		() => clsx$1(J({ class: L() })),
		() => clsx$1(Y({ class: z() })),
		() => clsx$1(W({ class: B() }))
	]), append(C, Z), pop(X);
}
create_custom_element(Ios, {
	children: {},
	divClass: {},
	div2Class: {},
	div3Class: {},
	div4Class: {},
	div5Class: {},
	div6Class: {}
}, [], [], !0);
var root$120 = /* @__PURE__ */ from_html("<div><div><div><!></div></div> <div><div></div></div></div>");
function Laptop(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "divClass", 7), F = prop(E, "div2Class", 7), I = prop(E, "div3Class", 7), L = prop(E, "div4Class", 7), z = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"divClass",
		"div2Class",
		"div3Class",
		"div4Class"
	]), { div: B, inner: V, bot: U, botCen: W } = laptop();
	var G = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get divClass() {
			return O();
		},
		set divClass(C) {
			O(C), flushSync();
		},
		get div2Class() {
			return F();
		},
		set div2Class(C) {
			F(C), flushSync();
		},
		get div3Class() {
			return I();
		},
		set div3Class(C) {
			I(C), flushSync();
		},
		get div4Class() {
			return L();
		},
		set div4Class(C) {
			L(C), flushSync();
		}
	}, K = root$120();
	attribute_effect(K, () => _objectSpread2({}, z));
	var J = child(K), Y = child(J), X = child(Y), Z = (C) => {
		var T = comment();
		snippet(first_child(T), D), append(C, T);
	};
	if_block(X, (C) => {
		D() && C(Z);
	}), reset(Y), reset(J);
	var Q = sibling(J, 2), NL = child(Q);
	return reset(Q), reset(K), template_effect((C, T, E, D) => {
		set_class(J, 1, C), set_class(Y, 1, T), set_class(Q, 1, E), set_class(NL, 1, D);
	}, [
		() => clsx$1(B({ class: O() })),
		() => clsx$1(V({ class: F() })),
		() => clsx$1(U({ class: I() })),
		() => clsx$1(W({ class: L() }))
	]), append(C, K), pop(G);
}
create_custom_element(Laptop, {
	children: {},
	divClass: {},
	div2Class: {},
	div3Class: {},
	div4Class: {}
}, [], [], !0);
var root$119 = /* @__PURE__ */ from_html("<div><div></div> <div><div></div> <div></div> <div><!></div></div> <div></div></div>");
function Smartwatch(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "divClass", 7), F = prop(E, "div2Class", 7), I = prop(E, "div3Class", 7), L = prop(E, "div4Class", 7), z = prop(E, "div5Class", 7), B = prop(E, "div6Class", 7), V = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"divClass",
		"div2Class",
		"div3Class",
		"div4Class",
		"div5Class",
		"div6Class"
	]), { div: U, top: W, rightTop: G, rightBot: K, bot: J, slot: Y } = smartwatch();
	var X = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get divClass() {
			return O();
		},
		set divClass(C) {
			O(C), flushSync();
		},
		get div2Class() {
			return F();
		},
		set div2Class(C) {
			F(C), flushSync();
		},
		get div3Class() {
			return I();
		},
		set div3Class(C) {
			I(C), flushSync();
		},
		get div4Class() {
			return L();
		},
		set div4Class(C) {
			L(C), flushSync();
		},
		get div5Class() {
			return z();
		},
		set div5Class(C) {
			z(C), flushSync();
		},
		get div6Class() {
			return B();
		},
		set div6Class(C) {
			B(C), flushSync();
		}
	}, Z = root$119();
	attribute_effect(Z, () => _objectSpread2({}, V));
	var Q = child(Z), NL = sibling(Q, 2), PL = child(NL), FL = sibling(PL, 2), IL = sibling(FL, 2), LL = child(IL), RL = (C) => {
		var T = comment();
		snippet(first_child(T), D), append(C, T);
	};
	if_block(LL, (C) => {
		D() && C(RL);
	}), reset(IL), reset(NL);
	var zL = sibling(NL, 2);
	return reset(Z), template_effect((C, T, E, D, O, F) => {
		set_class(Q, 1, C), set_class(NL, 1, T), set_class(PL, 1, E), set_class(FL, 1, D), set_class(IL, 1, O), set_class(zL, 1, F);
	}, [
		() => clsx$1(U({ class: O() })),
		() => clsx$1(W({ class: F() })),
		() => clsx$1(G({ class: I() })),
		() => clsx$1(K({ class: L() })),
		() => clsx$1(Y({ class: z() })),
		() => clsx$1(J({ class: B() }))
	]), append(C, Z), pop(X);
}
create_custom_element(Smartwatch, {
	children: {},
	divClass: {},
	div2Class: {},
	div3Class: {},
	div4Class: {},
	div5Class: {},
	div6Class: {}
}, [], [], !0);
var root$118 = /* @__PURE__ */ from_html("<div><div></div> <div></div> <div></div> <div></div> <div><!></div></div>");
function Tablet(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "divClass", 7), F = prop(E, "div2Class", 7), I = prop(E, "div3Class", 7), L = prop(E, "div4Class", 7), z = prop(E, "div5Class", 7), B = prop(E, "div6Class", 7), V = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"divClass",
		"div2Class",
		"div3Class",
		"div4Class",
		"div5Class",
		"div6Class"
	]), { div: U, leftTop: W, leftMid: G, leftBot: K, right: J, slot: Y } = tablet();
	var X = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get divClass() {
			return O();
		},
		set divClass(C) {
			O(C), flushSync();
		},
		get div2Class() {
			return F();
		},
		set div2Class(C) {
			F(C), flushSync();
		},
		get div3Class() {
			return I();
		},
		set div3Class(C) {
			I(C), flushSync();
		},
		get div4Class() {
			return L();
		},
		set div4Class(C) {
			L(C), flushSync();
		},
		get div5Class() {
			return z();
		},
		set div5Class(C) {
			z(C), flushSync();
		},
		get div6Class() {
			return B();
		},
		set div6Class(C) {
			B(C), flushSync();
		}
	}, Z = root$118();
	attribute_effect(Z, (C) => _objectSpread2(_objectSpread2({}, V), {}, { class: C }), [() => U({ class: O() })]);
	var Q = child(Z), NL = sibling(Q, 2), PL = sibling(NL, 2), FL = sibling(PL, 2), IL = sibling(FL, 2), LL = child(IL), RL = (C) => {
		var T = comment();
		snippet(first_child(T), D), append(C, T);
	};
	return if_block(LL, (C) => {
		D() && C(RL);
	}), reset(IL), reset(Z), template_effect((C, T, E, D, O) => {
		set_class(Q, 1, C), set_class(NL, 1, T), set_class(PL, 1, E), set_class(FL, 1, D), set_class(IL, 1, O);
	}, [
		() => clsx$1(W({ class: F() })),
		() => clsx$1(G({ class: I() })),
		() => clsx$1(K({ class: L() })),
		() => clsx$1(J({ class: z() })),
		() => clsx$1(Y({ class: B() }))
	]), append(C, Z), pop(X);
}
create_custom_element(Tablet, {
	children: {},
	divClass: {},
	div2Class: {},
	div3Class: {},
	div4Class: {},
	div5Class: {},
	div6Class: {}
}, [], [], !0);
function DeviceMockup(C, T) {
	push(T, !0);
	let E = prop(T, "children", 7), D = prop(T, "device", 7, "default"), O = {
		android: Android,
		ios: Ios,
		tablet: Tablet,
		default: DefaultMockup,
		smartwatch: Smartwatch,
		laptop: Laptop,
		desktop: Desktop
	}, F = /* @__PURE__ */ user_derived(() => O[D()]);
	var I = {
		get children() {
			return E();
		},
		set children(C) {
			E(C), flushSync();
		},
		get device() {
			return D();
		},
		set device(C = "default") {
			D(C), flushSync();
		}
	}, L = comment();
	return component(first_child(L), () => get(F), (C, T) => {
		T(C, {
			children: (C, T) => {
				var D = comment();
				snippet(first_child(D), E), append(C, D);
			},
			$$slots: { default: !0 }
		});
	}), append(C, L), pop(I);
}
create_custom_element(DeviceMockup, {
	children: {},
	device: {}
}, [], [], !0);
var android = ce({ slots: {
	div: "relative mx-auto border-gray-800 dark:border-gray-800 bg-gray-800 border-[14px] rounded-xl h-[600px] w-[300px] shadow-xl",
	slot: "rounded-xl overflow-hidden w-[272px] h-[572px] bg-white dark:bg-gray-800",
	top: "w-[148px] h-[18px] bg-gray-800 top-0 rounded-b-[1rem] left-1/2 -translate-x-1/2 absolute",
	leftTop: "h-[32px] w-[3px] bg-gray-800 absolute -left-[17px] top-[72px] rounded-l-lg",
	leftMid: "h-[46px] w-[3px] bg-gray-800 absolute -left-[17px] top-[124px] rounded-l-lg",
	leftBot: "h-[46px] w-[3px] bg-gray-800 absolute -left-[17px] top-[178px] rounded-l-lg",
	right: "h-[64px] w-[3px] bg-gray-800 absolute -right-[17px] top-[142px] rounded-r-lg"
} }), defaultMockup = ce({ slots: {
	div: "relative mx-auto border-gray-800 dark:border-gray-800 bg-gray-800 border-[14px] rounded-[2.5rem] h-[600px] w-[300px]",
	slot: "rounded-[2rem] overflow-hidden w-[272px] h-[572px] bg-white dark:bg-gray-800",
	top: "h-[32px] w-[3px] bg-gray-800 dark:bg-gray-800 absolute -left-[17px] top-[72px] rounded-l-lg",
	leftTop: "h-[46px] w-[3px] bg-gray-800 dark:bg-gray-800 absolute -left-[17px] top-[124px] rounded-l-lg",
	leftBot: "h-[46px] w-[3px] bg-gray-800 dark:bg-gray-800 absolute -left-[17px] top-[178px] rounded-l-lg",
	right: "h-[64px] w-[3px] bg-gray-800 dark:bg-gray-800 absolute -right-[17px] top-[142px] rounded-r-lg"
} }), desktop = ce({ slots: {
	inner: "rounded-xl overflow-hidden h-[140px] md:h-[262px]",
	bot: "relative mx-auto bg-gray-900 dark:bg-gray-700 rounded-b-xl h-[24px] max-w-[301px] md:h-[42px] md:max-w-[512px]",
	botUnder: "relative mx-auto bg-gray-800 rounded-b-xl h-[55px] max-w-[83px] md:h-[95px] md:max-w-[142px]",
	div: "relative mx-auto border-gray-800 dark:border-gray-800 bg-gray-800 border-[16px] rounded-t-xl h-[172px] max-w-[301px] md:h-[294px] md:max-w-[512px]"
} }), ios = ce({ slots: {
	div: "relative mx-auto border-gray-800 dark:border-gray-800 bg-gray-800 border-[14px] rounded-[2.5rem] h-[600px] w-[300px] shadow-xl",
	slot: "rounded-[2rem] overflow-hidden w-[272px] h-[572px] bg-white dark:bg-gray-800",
	top: "w-[148px] h-[18px] bg-gray-800 top-0 rounded-b-[1rem] left-1/2 -translate-x-1/2 absolute",
	leftTop: "h-[46px] w-[3px] bg-gray-800 absolute -left-[17px] top-[124px] rounded-l-lg",
	leftBot: "h-[46px] w-[3px] bg-gray-800 absolute -left-[17px] top-[178px] rounded-l-lg",
	right: "h-[64px] w-[3px] bg-gray-800 absolute -right-[17px] top-[142px] rounded-r-lg"
} }), laptop = ce({ slots: {
	div: "relative mx-auto border-gray-800 dark:border-gray-800 bg-gray-800 border-[8px] rounded-t-xl h-[172px] max-w-[301px] md:h-[294px] md:max-w-[512px]",
	inner: "rounded-lg overflow-hidden h-[156px] md:h-[278px] bg-white dark:bg-gray-800",
	bot: "relative mx-auto bg-gray-900 dark:bg-gray-700 rounded-b-xl rounded-t-sm h-[17px] max-w-[351px] md:h-[21px] md:max-w-[597px]",
	botCen: "absolute left-1/2 top-0 -translate-x-1/2 rounded-b-xl w-[56px] h-[5px] md:w-[96px] md:h-[8px] bg-gray-800"
} }), smartwatch = ce({ slots: {
	div: "relative mx-auto bg-gray-800 dark:bg-gray-700 rounded-t-[2.5rem] h-[63px] max-w-[133px]",
	slot: "rounded-[2rem] overflow-hidden h-[193px] w-[188px]",
	rightTop: "h-[41px] w-[6px] bg-gray-800 dark:bg-gray-800 absolute -right-[16px] top-[40px] rounded-r-lg",
	rightBot: "h-[32px] w-[6px] bg-gray-800 dark:bg-gray-800 absolute -right-[16px] top-[88px] rounded-r-lg",
	top: "relative mx-auto border-gray-900 dark:bg-gray-800 dark:border-gray-800 border-[10px] rounded-[2.5rem] h-[213px] w-[208px]",
	bot: "relative mx-auto bg-gray-800 dark:bg-gray-700 rounded-b-[2.5rem] h-[63px] max-w-[133px]"
} }), tablet = ce({ slots: {
	div: "relative mx-auto border-gray-800 dark:border-gray-800 bg-gray-800 border-[14px] rounded-[2.5rem] h-[454px] max-w-[341px] md:h-[682px] md:max-w-[512px]",
	slot: "rounded-[2rem] overflow-hidden h-[426px] md:h-[654px] bg-white dark:bg-gray-800",
	leftTop: "h-[32px] w-[3px] bg-gray-800 dark:bg-gray-800 absolute -left-[17px] top-[72px] rounded-l-lg",
	leftMid: "h-[46px] w-[3px] bg-gray-800 dark:bg-gray-800 absolute -left-[17px] top-[124px] rounded-l-lg",
	leftBot: "h-[46px] w-[3px] bg-gray-800 dark:bg-gray-800 absolute -left-[17px] top-[178px] rounded-l-lg",
	right: "h-[64px] w-[3px] bg-gray-800 dark:bg-gray-800 absolute -right-[17px] top-[142px] rounded-r-lg"
} });
const dropdown = ce({ base: "mt-2 divide-y divide-gray-300 dark:divide-gray-500 overflow-hidden rounded-lg bg-white shadow-sm dark:bg-gray-700" }), dropdownDivider = ce({ base: "my-1 h-px bg-gray-100 dark:bg-gray-500" }), dropdownHeader = ce({ base: "px-4 py-3 text-sm text-gray-900 dark:text-white" }), dropdownItem = ce({ slots: {
	base: "block px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-600 dark:hover:text-white",
	active: "block px-4 py-2 text-primary-700 dark:text-primary-600 hover:bg-gray-100 dark:hover:bg-gray-600 dark:hover:text-white",
	li: ""
} }), dropdownGroup = ce({ base: "py-2 text-sm text-gray-700 dark:text-gray-200" });
function Dropdown$1(C, T) {
	push(T, !0);
	let E = prop(T, "children", 7), D = prop(T, "simple", 7, !1), O = prop(T, "placement", 7, "bottom"), F = prop(T, "offset", 7, 2), I = prop(T, "class", 7), L = prop(T, "activeUrl", 7, ""), z = prop(T, "isOpen", 15, !1), B = /* @__PURE__ */ rest_props(T, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"simple",
		"placement",
		"offset",
		"class",
		"activeUrl",
		"isOpen"
	]), V = getTheme("dropdown"), U = /* @__PURE__ */ user_derived(() => dropdown({ class: clsx_default(V, I()) })), W = /* @__PURE__ */ state(proxy({ value: "" }));
	return setContext("activeUrl", get(W)), user_effect(() => {
		var C;
		get(W).value = (C = L()) == null ? "" : C;
	}), Popper(C, spread_props(() => B, {
		get placement() {
			return O();
		},
		get offset() {
			return F();
		},
		get class() {
			return get(U);
		},
		get isOpen() {
			return z();
		},
		set isOpen(C) {
			z(C);
		},
		children: (C, T) => {
			var O = comment(), F = first_child(O), I = (C) => {
				DropdownGroup(C, {
					children: (C, T) => {
						var D = comment();
						snippet(first_child(D), E), append(C, D);
					},
					$$slots: { default: !0 }
				});
			}, L = (C) => {
				var T = comment();
				snippet(first_child(T), E), append(C, T);
			};
			if_block(F, (C) => {
				D() ? C(I) : C(L, !1);
			}), append(C, O);
		},
		$$slots: { default: !0 }
	})), pop({
		get children() {
			return E();
		},
		set children(C) {
			E(C), flushSync();
		},
		get simple() {
			return D();
		},
		set simple(C = !1) {
			D(C), flushSync();
		},
		get placement() {
			return O();
		},
		set placement(C = "bottom") {
			O(C), flushSync();
		},
		get offset() {
			return F();
		},
		set offset(C = 2) {
			F(C), flushSync();
		},
		get class() {
			return I();
		},
		set class(C) {
			I(C), flushSync();
		},
		get activeUrl() {
			return L();
		},
		set activeUrl(C = "") {
			L(C), flushSync();
		},
		get isOpen() {
			return z();
		},
		set isOpen(C = !1) {
			z(C), flushSync();
		}
	});
}
create_custom_element(Dropdown$1, {
	children: {},
	simple: {},
	placement: {},
	offset: {},
	class: {},
	activeUrl: {},
	isOpen: {}
}, [], [], !0);
var root$117 = /* @__PURE__ */ from_html("<div></div>");
function DropdownDivider(C, E) {
	push(E, !0);
	let D = prop(E, "class", 7), O = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"class"
	]), F = getTheme("dropdownDivider");
	var I = {
		get class() {
			return D();
		},
		set class(C) {
			D(C), flushSync();
		}
	}, L = root$117();
	return attribute_effect(L, (C) => _objectSpread2(_objectSpread2({}, O), {}, { class: C }), [() => dropdownDivider({ class: clsx_default(F, D()) })]), append(C, L), pop(I);
}
create_custom_element(DropdownDivider, { class: {} }, [], [], !0);
var root$116 = /* @__PURE__ */ from_html("<ul><!></ul>");
function DropdownGroup(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "class", 7), F = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"class"
	]), I = getTheme("dropdownGroup");
	var L = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get class() {
			return O();
		},
		set class(C) {
			O(C), flushSync();
		}
	}, z = root$116();
	return attribute_effect(z, (C) => _objectSpread2(_objectSpread2({}, F), {}, { class: C }), [() => dropdownGroup({ class: clsx_default(I, O()) })]), snippet(child(z), D), reset(z), append(C, z), pop(L);
}
create_custom_element(DropdownGroup, {
	children: {},
	class: {}
}, [], [], !0);
var root$115 = /* @__PURE__ */ from_html("<div><!></div>");
function DropdownHeader(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "class", 7), F = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"class"
	]), I = getTheme("dropdownHeader");
	var L = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get class() {
			return O();
		},
		set class(C) {
			O(C), flushSync();
		}
	}, z = root$115();
	return attribute_effect(z, (C) => _objectSpread2(_objectSpread2({}, F), {}, { class: C }), [() => dropdownHeader({ class: clsx_default(I, O()) })]), snippet(child(z), D), reset(z), append(C, z), pop(L);
}
create_custom_element(DropdownHeader, {
	children: {},
	class: {}
}, [], [], !0);
var root_1$101 = /* @__PURE__ */ from_html("<div><!></div>"), root_3$44 = /* @__PURE__ */ from_html("<button><!></button>"), root_4$30 = /* @__PURE__ */ from_html("<a><!></a>"), root$114 = /* @__PURE__ */ from_html("<li><!></li>");
function DropdownItem(C, E) {
	push(E, !0);
	let D = prop(E, "aClass", 7), O = prop(E, "children", 7), F = prop(E, "activeClass", 7), I = prop(E, "liClass", 7), L = prop(E, "classes", 7), z = prop(E, "class", 7), B = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"aClass",
		"children",
		"activeClass",
		"liClass",
		"classes",
		"class"
	]);
	D(), F(), I();
	let V = /* @__PURE__ */ user_derived(() => {
		var C;
		return (C = L()) == null ? {
			active: F(),
			li: I()
		} : C;
	}), U = getTheme("dropdownItem"), W = getContext("activeUrl"), G = /* @__PURE__ */ user_derived(() => W != null && W.value ? E.href === W.value : !1), { base: K, active: J, li: Y } = dropdownItem(), X = /* @__PURE__ */ user_derived(() => [get(G) ? J({ class: clsx_default(U == null ? void 0 : U.active, get(V).active) }) : K({ class: clsx_default(U == null ? void 0 : U.base, z()) })]);
	var Z = {
		get aClass() {
			return D();
		},
		set aClass(C) {
			D(C), flushSync();
		},
		get children() {
			return O();
		},
		set children(C) {
			O(C), flushSync();
		},
		get activeClass() {
			return F();
		},
		set activeClass(C) {
			F(C), flushSync();
		},
		get liClass() {
			return I();
		},
		set liClass(C) {
			I(C), flushSync();
		},
		get classes() {
			return L();
		},
		set classes(C) {
			L(C), flushSync();
		},
		get class() {
			return z();
		},
		set class(C) {
			z(C), flushSync();
		}
	}, Q = root$114(), NL = child(Q), PL = (C) => {
		var E = root_1$101();
		attribute_effect(E, () => _objectSpread2(_objectSpread2({}, B), {}, { class: get(X) })), snippet(child(E), O), reset(E), append(C, E);
	}, FL = (C) => {
		var D = comment(), F = first_child(D), I = (C) => {
			var E = root_3$44();
			attribute_effect(E, () => _objectSpread2(_objectSpread2({ type: "button" }, B), {}, { class: get(X) })), snippet(child(E), O), reset(E), append(C, E);
		}, L = (C) => {
			var E = root_4$30();
			attribute_effect(E, () => _objectSpread2(_objectSpread2({}, B), {}, { class: get(X) })), snippet(child(E), O), reset(E), append(C, E);
		};
		if_block(F, (C) => {
			E.href === void 0 ? C(I) : C(L, !1);
		}, !0), append(C, D);
	};
	return if_block(NL, (C) => {
		E.href === void 0 && E.onclick === void 0 ? C(PL) : C(FL, !1);
	}), reset(Q), template_effect((C) => set_class(Q, 1, C), [() => clsx$1(Y({ class: clsx_default(get(V).li) }))]), append(C, Q), pop(Z);
}
create_custom_element(DropdownItem, {
	aClass: {},
	children: {},
	activeClass: {},
	liClass: {},
	classes: {},
	class: {}
}, [], [], !0);
function linear(C) {
	return C;
}
function cubicOut(C) {
	let T = C - 1;
	return T * T * T + 1;
}
function quintOut(C) {
	return --C * C * C * C * C + 1;
}
function sineIn(C) {
	let T = Math.cos(C * Math.PI * .5);
	return Math.abs(T) < 1e-14 ? 1 : 1 - T;
}
var root_2$54 = /* @__PURE__ */ from_html("<div role=\"presentation\"></div>"), root_4$29 = /* @__PURE__ */ from_html("<div role=\"presentation\"></div>"), root_6$13 = /* @__PURE__ */ from_html("<div role=\"presentation\" class=\"fixed start-0 top-0 z-50 h-full w-full\"></div>"), root_1$100 = /* @__PURE__ */ from_html("<!> <div><!></div>", 1);
function Drawer(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "drawerStatus", 7), F = prop(E, "closeDrawer", 7), I = prop(E, "activateClickOutside", 7, !0), L = prop(E, "position", 7), z = prop(E, "width", 7), B = prop(E, "backdrop", 7, !0), V = prop(E, "backdropClass", 7), U = prop(E, "placement", 7, "left"), W = prop(E, "class", 7), G = prop(E, "params", 23, () => ({
		x: -320,
		duration: 200,
		easing: sineIn
	})), K = prop(E, "transition", 7, fly), J = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"drawerStatus",
		"closeDrawer",
		"activateClickOutside",
		"position",
		"width",
		"backdrop",
		"backdropClass",
		"placement",
		"class",
		"params",
		"transition"
	]), Y = /* @__PURE__ */ user_derived(() => drawer({
		position: L(),
		placement: U(),
		width: z(),
		backdrop: B()
	})), X = /* @__PURE__ */ user_derived(() => get(Y).base), Z = /* @__PURE__ */ user_derived(() => get(Y).backdrop);
	var Q = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get drawerStatus() {
			return O();
		},
		set drawerStatus(C) {
			O(C), flushSync();
		},
		get closeDrawer() {
			return F();
		},
		set closeDrawer(C) {
			F(C), flushSync();
		},
		get activateClickOutside() {
			return I();
		},
		set activateClickOutside(C = !0) {
			I(C), flushSync();
		},
		get position() {
			return L();
		},
		set position(C) {
			L(C), flushSync();
		},
		get width() {
			return z();
		},
		set width(C) {
			z(C), flushSync();
		},
		get backdrop() {
			return B();
		},
		set backdrop(C = !0) {
			B(C), flushSync();
		},
		get backdropClass() {
			return V();
		},
		set backdropClass(C) {
			V(C), flushSync();
		},
		get placement() {
			return U();
		},
		set placement(C = "left") {
			U(C), flushSync();
		},
		get class() {
			return W();
		},
		set class(C) {
			W(C), flushSync();
		},
		get params() {
			return G();
		},
		set params(C = {
			x: -320,
			duration: 200,
			easing: sineIn
		}) {
			G(C), flushSync();
		},
		get transition() {
			return K();
		},
		set transition(C = fly) {
			K(C), flushSync();
		}
	}, NL = comment(), PL = first_child(NL), FL = (C) => {
		var E = root_1$100(), O = first_child(E), L = (C) => {
			var T = root_2$54();
			T.__click = function(...C) {
				var T;
				(T = F()) == null || T.apply(this, C);
			}, template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(Z)({ class: V() }))]), append(C, T);
		}, z = (C) => {
			var T = comment(), E = first_child(T), D = (C) => {
				var T = root_4$29();
				template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(Z)({ class: V() }))]), append(C, T);
			}, O = (C) => {
				var T = comment(), E = first_child(T), D = (C) => {
					var T = root_6$13();
					T.__click = function(...C) {
						var T;
						(T = F()) == null || T.apply(this, C);
					}, append(C, T);
				};
				if_block(E, (C) => {
					!B() && I() && C(D);
				}, !0), append(C, T);
			};
			if_block(E, (C) => {
				B() && !I() ? C(D) : C(O, !1);
			}, !0), append(C, T);
		};
		if_block(O, (C) => {
			B() && I() ? C(L) : C(z, !1);
		});
		var U = sibling(O, 2);
		attribute_effect(U, (C) => _objectSpread2(_objectSpread2({}, J), {}, {
			class: C,
			tabindex: "-1"
		}), [() => get(X)({ className: W() })]), snippet(child(U), D), reset(U), transition(3, U, K, G), append(C, E);
	};
	return if_block(PL, (C) => {
		O() && C(FL);
	}), append(C, NL), pop(Q);
}
delegate(["click"]), create_custom_element(Drawer, {
	children: {},
	drawerStatus: {},
	closeDrawer: {},
	activateClickOutside: {},
	position: {},
	width: {},
	backdrop: {},
	backdropClass: {},
	placement: {},
	class: {},
	params: {},
	transition: {}
}, [], [], !0);
var root_3$43 = /* @__PURE__ */ from_html("<button><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 14 14\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"m1 1 6 6m0 0 6 6M7 7l6-6M7 7l-6 6\"></path></svg> <span class=\"sr-only\">Close drawer</span></button>"), root$113 = /* @__PURE__ */ from_html("<div><!> <!></div>");
function Drawerhead(C, E) {
	push(E, !0);
	let D = prop(E, "closeIcon", 7), O = prop(E, "children", 7), F = prop(E, "buttonClass", 7), I = prop(E, "svgClass", 7), L = prop(E, "class", 7), z = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"closeIcon",
		"children",
		"buttonClass",
		"svgClass",
		"class"
	]), B = /* @__PURE__ */ user_derived(drawerhead), V = /* @__PURE__ */ user_derived(() => get(B).base), U = /* @__PURE__ */ user_derived(() => get(B).button), W = /* @__PURE__ */ user_derived(() => get(B).svg);
	var G = {
		get closeIcon() {
			return D();
		},
		set closeIcon(C) {
			D(C), flushSync();
		},
		get children() {
			return O();
		},
		set children(C) {
			O(C), flushSync();
		},
		get buttonClass() {
			return F();
		},
		set buttonClass(C) {
			F(C), flushSync();
		},
		get svgClass() {
			return I();
		},
		set svgClass(C) {
			I(C), flushSync();
		},
		get class() {
			return L();
		},
		set class(C) {
			L(C), flushSync();
		}
	}, K = root$113(), J = child(K), Y = (C) => {
		var T = comment();
		snippet(first_child(T), O), append(C, T);
	};
	if_block(J, (C) => {
		O() && C(Y);
	});
	var X = sibling(J, 2), Z = (C) => {
		var T = comment();
		snippet(first_child(T), D), append(C, T);
	}, Q = (C) => {
		var E = root_3$43();
		attribute_effect(E, (C) => _objectSpread2(_objectSpread2({ type: "button" }, z), {}, { class: C }), [() => get(U)({ class: F() })]);
		var D = child(E);
		next(2), reset(E), template_effect((C) => set_class(D, 0, C), [() => clsx$1(get(W)({ class: I() }))]), append(C, E);
	};
	return if_block(X, (C) => {
		D() ? C(Z) : C(Q, !1);
	}), reset(K), template_effect((C) => set_class(K, 1, C), [() => clsx$1(get(V)({ className: L() }))]), append(C, K), pop(G);
}
create_custom_element(Drawerhead, {
	closeIcon: {},
	children: {},
	buttonClass: {},
	svgClass: {},
	class: {}
}, [], [], !0);
const drawer = ce({
	slots: {
		base: "overflow-y-auto z-50 p-4 bg-white dark:bg-gray-800",
		backdrop: "fixed top-0 start-0 z-50 w-full h-full"
	},
	variants: {
		position: {
			fixed: { base: "fixed" },
			absolute: { base: "absolute" }
		},
		placement: {
			left: { base: "inset-y-0 start-0" },
			right: { base: "inset-y-0 end-0" },
			top: { base: "inset-x-0 top-0" },
			bottom: { base: "inset-x-0 bottom-0" }
		},
		width: {
			default: { base: "w-80" },
			full: { base: "w-full" },
			half: { base: "w-1/2" }
		},
		backdrop: { true: { backdrop: "bg-gray-900 bg-opacity-75" } }
	},
	defaultVariants: {
		position: "fixed",
		placement: "left",
		width: "default"
	}
}), drawerhead = ce({ slots: {
	base: "flex items-center",
	button: "ms-auto inline-flex h-8 w-8 items-center justify-center rounded-lg bg-transparent text-sm text-gray-400 hover:bg-gray-200 hover:text-gray-900 dark:hover:bg-gray-600 dark:hover:text-white",
	svg: "h-3 w-3"
} });
var root$112 = /* @__PURE__ */ from_html("<footer><!></footer>");
function Footer(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "footerType", 7, "default"), F = prop(E, "class", 7), I = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"footerType",
		"class"
	]), L = /* @__PURE__ */ user_derived(() => footer({
		footerType: O(),
		className: F()
	}));
	var z = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get footerType() {
			return O();
		},
		set footerType(C = "default") {
			O(C), flushSync();
		},
		get class() {
			return F();
		},
		set class(C) {
			F(C), flushSync();
		}
	}, B = root$112();
	return attribute_effect(B, () => _objectSpread2(_objectSpread2({}, I), {}, { class: get(L) })), snippet(child(B), D), reset(B), append(C, B), pop(z);
}
create_custom_element(Footer, {
	children: {},
	footerType: {},
	class: {}
}, [], [], !0);
var root_2$53 = /* @__PURE__ */ from_html("<img/>"), root_3$42 = /* @__PURE__ */ from_html("<span> </span>"), root_1$99 = /* @__PURE__ */ from_html("<a><!> <!> <!></a>"), root_5$22 = /* @__PURE__ */ from_html("<img/>");
function FooterBrand(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "aClass", 7), F = prop(E, "spanClass", 7), I = prop(E, "imgClass", 7), L = prop(E, "href", 7), z = prop(E, "src", 7), B = prop(E, "alt", 7), V = prop(E, "name", 7), U = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"aClass",
		"spanClass",
		"imgClass",
		"href",
		"src",
		"alt",
		"name"
	]), W = /* @__PURE__ */ user_derived(footerBrand), G = /* @__PURE__ */ user_derived(() => get(W).base), K = /* @__PURE__ */ user_derived(() => get(W).span), J = /* @__PURE__ */ user_derived(() => get(W).img);
	var Y = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get aClass() {
			return O();
		},
		set aClass(C) {
			O(C), flushSync();
		},
		get spanClass() {
			return F();
		},
		set spanClass(C) {
			F(C), flushSync();
		},
		get imgClass() {
			return I();
		},
		set imgClass(C) {
			I(C), flushSync();
		},
		get href() {
			return L();
		},
		set href(C) {
			L(C), flushSync();
		},
		get src() {
			return z();
		},
		set src(C) {
			z(C), flushSync();
		},
		get alt() {
			return B();
		},
		set alt(C) {
			B(C), flushSync();
		},
		get name() {
			return V();
		},
		set name(C) {
			V(C), flushSync();
		}
	}, X = comment(), Z = first_child(X), Q = (C) => {
		var E = root_1$99();
		attribute_effect(E, (C) => _objectSpread2(_objectSpread2({}, U), {}, {
			href: L(),
			class: C
		}), [() => get(G)({ class: O() })]);
		var W = child(E), Y = (C) => {
			var T = root_2$53();
			template_effect((C) => {
				set_attribute(T, "src", z()), set_class(T, 1, C), set_attribute(T, "alt", B());
			}, [() => clsx$1(get(J)({ class: I() }))]), append(C, T);
		};
		if_block(W, (C) => {
			z() && C(Y);
		});
		var X = sibling(W, 2), Z = (C) => {
			var T = root_3$42(), E = child(T, !0);
			reset(T), template_effect((C) => {
				set_class(T, 1, C), set_text(E, V());
			}, [() => clsx$1(get(K)({ class: F() }))]), append(C, T);
		};
		if_block(X, (C) => {
			V() && C(Z);
		});
		var Q = sibling(X, 2), NL = (C) => {
			var T = comment();
			snippet(first_child(T), D), append(C, T);
		};
		if_block(Q, (C) => {
			D() && C(NL);
		}), reset(E), append(C, E);
	}, NL = (C) => {
		var T = root_5$22();
		template_effect((C) => {
			set_attribute(T, "src", z()), set_class(T, 1, C), set_attribute(T, "alt", B());
		}, [() => clsx$1(get(J)({ class: I() }))]), append(C, T);
	};
	return if_block(Z, (C) => {
		L() ? C(Q) : C(NL, !1);
	}), append(C, X), pop(Y);
}
create_custom_element(FooterBrand, {
	children: {},
	aClass: {},
	spanClass: {},
	imgClass: {},
	href: {},
	src: {},
	alt: {},
	name: {}
}, [], [], !0);
var root_1$98 = /* @__PURE__ */ from_html("<a> </a>"), root_2$52 = /* @__PURE__ */ from_html("<span> </span>"), root$111 = /* @__PURE__ */ from_html("<span> <!> </span>");
function FooterCopyright(C, E) {
	push(E, !0);
	let D = prop(E, "spanClass", 7), O = prop(E, "aClass", 7), F = prop(E, "href", 7), I = prop(E, "by", 7), L = prop(E, "copyrightMessage", 7, "All Rights Reserved."), z = prop(E, "year", 7), B = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"spanClass",
		"aClass",
		"href",
		"by",
		"copyrightMessage",
		"year"
	]);
	z() || z((/* @__PURE__ */ new Date()).getFullYear());
	let V = /* @__PURE__ */ user_derived(footerCopyright), U = /* @__PURE__ */ user_derived(() => get(V).base), W = /* @__PURE__ */ user_derived(() => get(V).link), G = /* @__PURE__ */ user_derived(() => get(V).bySpan);
	var K = {
		get spanClass() {
			return D();
		},
		set spanClass(C) {
			D(C), flushSync();
		},
		get aClass() {
			return O();
		},
		set aClass(C) {
			O(C), flushSync();
		},
		get href() {
			return F();
		},
		set href(C) {
			F(C), flushSync();
		},
		get by() {
			return I();
		},
		set by(C) {
			I(C), flushSync();
		},
		get copyrightMessage() {
			return L();
		},
		set copyrightMessage(C = "All Rights Reserved.") {
			L(C), flushSync();
		},
		get year() {
			return z();
		},
		set year(C) {
			z(C), flushSync();
		}
	}, J = root$111(), Y = child(J), X = sibling(Y), Z = (C) => {
		var E = root_1$98();
		attribute_effect(E, (C) => _objectSpread2(_objectSpread2({}, B), {}, {
			href: F(),
			class: C
		}), [() => get(W)({ class: O() })]);
		var D = child(E, !0);
		reset(E), template_effect(() => set_text(D, I())), append(C, E);
	}, Q = (C) => {
		var T = root_2$52(), E = child(T, !0);
		reset(T), template_effect((C) => {
			set_class(T, 1, C), set_text(E, I());
		}, [() => clsx$1(get(G)())]), append(C, T);
	};
	if_block(X, (C) => {
		F() ? C(Z) : C(Q, !1);
	});
	var NL = sibling(X);
	return reset(J), template_effect((C) => {
		var T, E;
		set_class(J, 1, C), set_text(Y, ` ${(T = z()) == null ? "" : T} `), set_text(NL, ` ${(E = L()) == null ? "" : E}`);
	}, [() => clsx$1(get(U)({ class: D() }))]), append(C, J), pop(K);
}
create_custom_element(FooterCopyright, {
	spanClass: {},
	aClass: {},
	href: {},
	by: {},
	copyrightMessage: {},
	year: {}
}, [], [], !0);
var root_1$97 = /* @__PURE__ */ from_html("<a><!></a>");
function FooterIcon(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "href", 7), F = prop(E, "ariaLabel", 7), I = prop(E, "class", 7), L = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"href",
		"ariaLabel",
		"class"
	]), z = /* @__PURE__ */ user_derived(() => footerIcon({ class: I() }));
	var B = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get href() {
			return O();
		},
		set href(C) {
			O(C), flushSync();
		},
		get ariaLabel() {
			return F();
		},
		set ariaLabel(C) {
			F(C), flushSync();
		},
		get class() {
			return I();
		},
		set class(C) {
			I(C), flushSync();
		}
	}, V = comment(), U = first_child(V), W = (C) => {
		var E = root_1$97();
		attribute_effect(E, () => _objectSpread2(_objectSpread2({}, L), {}, {
			href: O(),
			"aria-label": F(),
			class: get(z)
		})), snippet(child(E), D), reset(E), append(C, E);
	}, G = (C) => {
		var T = comment();
		snippet(first_child(T), D), append(C, T);
	};
	return if_block(U, (C) => {
		O() ? C(W) : C(G, !1);
	}), append(C, V), pop(B);
}
create_custom_element(FooterIcon, {
	children: {},
	href: {},
	ariaLabel: {},
	class: {}
}, [], [], !0);
var root$110 = /* @__PURE__ */ from_html("<li><a><!></a></li>");
function FooterLi(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "liClass", 7), F = prop(E, "aClass", 7), I = prop(E, "href", 7), L = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"liClass",
		"aClass",
		"href"
	]), z = /* @__PURE__ */ user_derived(footerLi), B = /* @__PURE__ */ user_derived(() => get(z).base), V = /* @__PURE__ */ user_derived(() => get(z).link);
	var U = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get liClass() {
			return O();
		},
		set liClass(C) {
			O(C), flushSync();
		},
		get aClass() {
			return F();
		},
		set aClass(C) {
			F(C), flushSync();
		},
		get href() {
			return I();
		},
		set href(C) {
			I(C), flushSync();
		}
	}, W = root$110(), G = child(W);
	return attribute_effect(G, (C) => _objectSpread2(_objectSpread2({}, L), {}, {
		href: I(),
		class: C
	}), [() => get(V)({ class: F() })]), snippet(child(G), D), reset(G), reset(W), template_effect((C) => set_class(W, 1, C), [() => clsx$1(get(B)({ class: O() }))]), append(C, W), pop(U);
}
create_custom_element(FooterLi, {
	children: {},
	liClass: {},
	aClass: {},
	href: {}
}, [], [], !0);
var root$109 = /* @__PURE__ */ from_html("<ul><!></ul>");
function FooterUl(C, E) {
	push(E, !0);
	let D = prop(E, "class", 7), O = prop(E, "children", 7), F = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"class",
		"children"
	]), I = /* @__PURE__ */ user_derived(() => footerUl({ class: D() }));
	var L = {
		get class() {
			return D();
		},
		set class(C) {
			D(C), flushSync();
		},
		get children() {
			return O();
		},
		set children(C) {
			O(C), flushSync();
		}
	}, z = root$109();
	return attribute_effect(z, () => _objectSpread2(_objectSpread2({}, F), {}, { class: get(I) })), snippet(child(z), O), reset(z), append(C, z), pop(L);
}
create_custom_element(FooterUl, {
	class: {},
	children: {}
}, [], [], !0);
var footer = ce({
	base: "bg-white dark:bg-gray-800",
	variants: { footerType: {
		default: "p-4 rounded-lg shadow md:flex md:items-center md:justify-between md:p-6",
		sitemap: "bg-gray-800",
		socialmedia: "p-4 sm:p-6",
		logo: "p-4 rounded-lg shadow md:px-6 md:py-8",
		sticky: "fixed bottom-0 left-0 z-20 w-full p-4 bg-white border-t border-gray-200 shadow md:flex md:items-center md:justify-between md:p-6 dark:bg-gray-800 dark:border-gray-600"
	} }
}), footerBrand = ce({ slots: {
	base: "flex items-center",
	span: "self-center text-2xl font-semibold whitespace-nowrap dark:text-white",
	img: "me-3 h-8"
} }), footerCopyright = ce({ slots: {
	base: "block text-sm text-gray-500 sm:text-center dark:text-gray-400",
	link: "hover:underline",
	bySpan: "ms-1"
} }), footerIcon = ce({ base: "text-gray-500 hover:text-gray-900 dark:hover:text-white" }), footerUl = ce({ base: "text-gray-600 dark:text-gray-400" }), footerLi = ce({ slots: {
	base: "me-4 last:me-0 md:me-6",
	link: "hover:underline"
} }), root_1$96 = /* @__PURE__ */ from_html("<div><img/></div>"), root$108 = /* @__PURE__ */ from_html("<div></div>");
function Gallery(C, E) {
	push(E, !0);
	let D = (C, E = noop) => {
		var D = root_1$96(), O = child(D);
		attribute_effect(O, (C) => _objectSpread2({
			src: E().src,
			alt: E().alt,
			class: C
		}, z), [() => V({ class: I() })]), reset(D), replay_events(O), append(C, D);
	}, O = prop(E, "children", 7), F = prop(E, "items", 23, () => []), I = prop(E, "imgClass", 7), L = prop(E, "divClass", 7), z = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"items",
		"imgClass",
		"divClass"
	]);
	function B(C) {
		getComputedStyle(C).gap === "normal" && (C.style.gap = "inherit");
	}
	let { image: V, div: U } = gallery();
	var W = {
		get children() {
			return O();
		},
		set children(C) {
			O(C), flushSync();
		},
		get items() {
			return F();
		},
		set items(C = []) {
			F(C), flushSync();
		},
		get imgClass() {
			return I();
		},
		set imgClass(C) {
			I(C), flushSync();
		},
		get divClass() {
			return L();
		},
		set divClass(C) {
			L(C), flushSync();
		}
	}, G = root$108();
	return each(G, 21, F, index, (C, T) => {
		D(C, () => get(T));
	}, (C) => {
		var T = comment(), E = first_child(T), D = (C) => {
			var T = comment();
			snippet(first_child(T), O), append(C, T);
		};
		if_block(E, (C) => {
			O() && C(D);
		}), append(C, T);
	}), reset(G), action(G, (C) => B == null ? void 0 : B(C)), template_effect((C) => set_class(G, 1, C), [() => clsx$1(U({ class: L() }))]), append(C, G), pop(W);
}
create_custom_element(Gallery, {
	children: {},
	items: {},
	imgClass: {},
	divClass: {}
}, [], [], !0);
var gallery = ce({ slots: {
	image: "h-auto max-w-full rounded-lg",
	div: "grid"
} }), root$107 = /* @__PURE__ */ from_html("<div><!></div>");
function Indicator(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "color", 7, "primary"), F = prop(E, "cornerStyle", 7, "circular"), I = prop(E, "size", 7, "md"), L = prop(E, "border", 7, !1), z = prop(E, "placement", 7), B = prop(E, "offset", 7, !0), V = prop(E, "class", 7), U = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"color",
		"cornerStyle",
		"size",
		"border",
		"placement",
		"offset",
		"class"
	]), W = !!D(), G = /* @__PURE__ */ user_derived(() => indicator({
		color: O(),
		size: I(),
		cornerStyle: F(),
		border: L(),
		placement: z(),
		offset: B(),
		hasChildren: W
	})), K = /* @__PURE__ */ user_derived(() => get(G).base);
	var J = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get color() {
			return O();
		},
		set color(C = "primary") {
			O(C), flushSync();
		},
		get cornerStyle() {
			return F();
		},
		set cornerStyle(C = "circular") {
			F(C), flushSync();
		},
		get size() {
			return I();
		},
		set size(C = "md") {
			I(C), flushSync();
		},
		get border() {
			return L();
		},
		set border(C = !1) {
			L(C), flushSync();
		},
		get placement() {
			return z();
		},
		set placement(C) {
			z(C), flushSync();
		},
		get offset() {
			return B();
		},
		set offset(C = !0) {
			B(C), flushSync();
		},
		get class() {
			return V();
		},
		set class(C) {
			V(C), flushSync();
		}
	}, Y = root$107();
	attribute_effect(Y, (C) => _objectSpread2(_objectSpread2({}, U), {}, { class: C }), [() => get(K)({ className: V() })]);
	var X = child(Y), Z = (C) => {
		var T = comment();
		snippet(first_child(T), D), append(C, T);
	};
	return if_block(X, (C) => {
		D() && C(Z);
	}), reset(Y), append(C, Y), pop(J);
}
create_custom_element(Indicator, {
	children: {},
	color: {},
	cornerStyle: {},
	size: {},
	border: {},
	placement: {},
	offset: {},
	class: {}
}, [], [], !0);
var indicator = ce({
	slots: { base: "flex-shrink-0" },
	variants: {
		color: {
			primary: { base: "bg-primary-500" },
			secondary: { base: "bg-secondary-500" },
			gray: { base: "bg-gray-200" },
			red: { base: "bg-red-500" },
			orange: { base: "bg-orange-600" },
			amber: { base: "bg-amber-500" },
			yellow: { base: "bg-yellow-300" },
			lime: { base: "bg-lime-500" },
			green: { base: "bg-green-500" },
			emerald: { base: "bg-emerald-500" },
			teal: { base: "bg-teal-500" },
			cyan: { base: "bg-cyan-500" },
			sky: { base: "bg-sky-500" },
			blue: { base: "bg-blue-500" },
			indigo: { base: "bg-indigo-500" },
			violet: { base: "bg-violet-500" },
			purple: { base: "bg-purple-500" },
			fuchsia: { base: "bg-fuchsia-500" },
			pink: { base: "bg-pink-500" },
			rose: { base: "bg-rose-500" }
		},
		size: {
			xs: { base: "w-2 h-2" },
			sm: { base: "w-2.5 h-2.5" },
			md: { base: "w-3 h-3" },
			lg: { base: "w-3.5 h-3.5" },
			xl: { base: "w-6 h-6" }
		},
		cornerStyle: {
			rounded: { base: "rounded" },
			circular: { base: "rounded-full" }
		},
		border: {
			true: { base: "border border-gray-300 dark:border-gray-300" },
			false: {}
		},
		hasChildren: {
			true: { base: "inline-flex items-center justify-center" },
			false: {}
		},
		placement: {
			default: { base: "" },
			"top-left": { base: "absolute top-0 start-0" },
			"top-center": { base: "absolute top-0 start-1/2 -translate-x-1/2 rtl:translate-x-1/2" },
			"top-right": { base: "absolute top-0 end-0" },
			"center-left": { base: "absolute top-1/2 -translate-y-1/2 start-0" },
			center: { base: "absolute top-1/2 -translate-y-1/2 start-1/2 -translate-x-1/2 rtl:translate-x-1/2" },
			"center-right": { base: "absolute top-1/2 -translate-y-1/2 end-0" },
			"bottom-left": { base: "absolute bottom-0 start-0" },
			"bottom-center": { base: "absolute bottom-0 start-1/2 -translate-x-1/2 rtl:translate-x-1/2" },
			"bottom-right": { base: "absolute bottom-0 end-0" }
		},
		offset: {
			true: {},
			false: {}
		}
	},
	compoundVariants: [
		{
			placement: "top-left",
			offset: !0,
			class: { base: "-translate-x-1/3 rtl:translate-x-1/3 -translate-y-1/3" }
		},
		{
			placement: "top-center",
			offset: !0,
			class: { base: "-translate-y-1/3" }
		},
		{
			placement: "top-right",
			offset: !0,
			class: { base: "translate-x-1/3 rtl:-translate-x-1/3 -translate-y-1/3" }
		},
		{
			placement: "center-left",
			offset: !0,
			class: { base: "-translate-x-1/3 rtl:translate-x-1/3" }
		},
		{
			placement: "center-right",
			offset: !0,
			class: { base: "translate-x-1/3 rtl:-translate-x-1/3" }
		},
		{
			placement: "bottom-left",
			offset: !0,
			class: { base: "-translate-x-1/3 rtl:translate-x-1/3 translate-y-1/3" }
		},
		{
			placement: "bottom-center",
			offset: !0,
			class: { base: "translate-y-1/3" }
		},
		{
			placement: "bottom-right",
			offset: !0,
			class: { base: "translate-x-1/3 rtl:-translate-x-1/3 translate-y-1/3" }
		}
	],
	defaultVariants: {
		color: "primary",
		size: "md",
		cornerStyle: "circular",
		border: !1,
		offset: !0,
		hasChildren: !1
	}
}), root$106 = /* @__PURE__ */ from_html("<kbd><!></kbd>");
function Kbd(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "class", 7), F = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"class"
	]), I = kbd();
	var L = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get class() {
			return O();
		},
		set class(C) {
			O(C), flushSync();
		}
	}, z = root$106();
	return attribute_effect(z, (C) => _objectSpread2(_objectSpread2({}, F), {}, { class: C }), [() => twMerge(I, O())]), snippet(child(z), D), reset(z), append(C, z), pop(L);
}
create_custom_element(Kbd, {
	children: {},
	class: {}
}, [], [], !0);
const kbd = ce({ base: "text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg dark:bg-gray-600 dark:text-gray-100 dark:border-gray-500" });
var root_1$95 = /* @__PURE__ */ from_html("<li><!></li>"), root_3$41 = /* @__PURE__ */ from_html("<a> </a>"), root_4$28 = /* @__PURE__ */ from_html("<button type=\"button\"><!> <!></button>");
function ListgroupItem(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "onclick", 7), F = prop(E, "active", 7), I = prop(E, "current", 7), L = prop(E, "disabled", 7), z = prop(E, "name", 7), B = prop(E, "Icon", 7), V = prop(E, "href", 7), U = prop(E, "currentClass", 7, "text-white bg-primary-700 dark:text-white dark:bg-gray-800"), W = prop(E, "normalClass", 7), G = prop(E, "disabledClass", 7, "text-gray-900 bg-gray-100 dark:bg-gray-600 dark:text-gray-400"), K = prop(E, "liClass", 7, "py-2 px-4 w-full text-sm font-medium list-none first:rounded-t-lg last:rounded-b-lg"), J = prop(E, "class", 7), Y = prop(E, "aClasss", 7), X = prop(E, "btnClass", 7), Z = prop(E, "iconClass", 7, "me-2.5 h-5 w-5"), Q = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"onclick",
		"active",
		"current",
		"disabled",
		"name",
		"Icon",
		"href",
		"currentClass",
		"normalClass",
		"disabledClass",
		"liClass",
		"class",
		"aClasss",
		"btnClass",
		"iconClass"
	]);
	F(getContext("active"));
	let NL = listGroupItem({
		state: L() ? "disabled" : I() ? "current" : "normal",
		active: F(),
		class: twMerge(K(), L() ? G() : I() ? U() : W(), J())
	}), PL = ce({
		base: "flex items-center text-left",
		extend: listGroupItem
	})({
		state: L() ? "disabled" : I() ? "current" : "normal",
		active: F(),
		class: twMerge(NL, X())
	}), FL = ce({
		base: "block",
		extend: listGroupItem
	})({
		state: L() ? "disabled" : I() ? "current" : "normal",
		active: F(),
		class: twMerge(NL, Y())
	});
	var IL = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get onclick() {
			return O();
		},
		set onclick(C) {
			O(C), flushSync();
		},
		get active() {
			return F();
		},
		set active(C) {
			F(C), flushSync();
		},
		get current() {
			return I();
		},
		set current(C) {
			I(C), flushSync();
		},
		get disabled() {
			return L();
		},
		set disabled(C) {
			L(C), flushSync();
		},
		get name() {
			return z();
		},
		set name(C) {
			z(C), flushSync();
		},
		get Icon() {
			return B();
		},
		set Icon(C) {
			B(C), flushSync();
		},
		get href() {
			return V();
		},
		set href(C) {
			V(C), flushSync();
		},
		get currentClass() {
			return U();
		},
		set currentClass(C = "text-white bg-primary-700 dark:text-white dark:bg-gray-800") {
			U(C), flushSync();
		},
		get normalClass() {
			return W();
		},
		set normalClass(C) {
			W(C), flushSync();
		},
		get disabledClass() {
			return G();
		},
		set disabledClass(C = "text-gray-900 bg-gray-100 dark:bg-gray-600 dark:text-gray-400") {
			G(C), flushSync();
		},
		get liClass() {
			return K();
		},
		set liClass(C = "py-2 px-4 w-full text-sm font-medium list-none first:rounded-t-lg last:rounded-b-lg") {
			K(C), flushSync();
		},
		get class() {
			return J();
		},
		set class(C) {
			J(C), flushSync();
		},
		get aClasss() {
			return Y();
		},
		set aClasss(C) {
			Y(C), flushSync();
		},
		get btnClass() {
			return X();
		},
		set btnClass(C) {
			X(C), flushSync();
		},
		get iconClass() {
			return Z();
		},
		set iconClass(C = "me-2.5 h-5 w-5") {
			Z(C), flushSync();
		}
	}, LL = comment(), RL = first_child(LL), zL = (C) => {
		var T = root_1$95();
		snippet(child(T), D), reset(T), template_effect(() => set_class(T, 1, clsx$1(NL))), append(C, T);
	}, BL = (C) => {
		var E = comment(), F = first_child(E), U = (C) => {
			var E = root_3$41();
			attribute_effect(E, () => _objectSpread2(_objectSpread2({}, Q), {}, {
				onclick: O(),
				href: V(),
				class: FL,
				"aria-current": I()
			}));
			var D = child(E, !0);
			reset(E), template_effect(() => set_text(D, z())), append(C, E);
		}, W = (C) => {
			var T = root_4$28();
			T.__click = function(...C) {
				var T;
				(T = O()) == null || T.apply(this, C);
			};
			var E = child(T), F = (C) => {
				var T = comment();
				component(first_child(T), B, (C, T) => {
					T(C, { get class() {
						return Z();
					} });
				}), append(C, T);
			};
			if_block(E, (C) => {
				B() && C(F);
			});
			var V = sibling(E, 2), U = (C) => {
				var T = text();
				template_effect(() => set_text(T, z())), append(C, T);
			}, W = (C) => {
				var T = comment();
				snippet(first_child(T), D), append(C, T);
			};
			if_block(V, (C) => {
				z() ? C(U) : C(W, !1);
			}), reset(T), template_effect(() => {
				set_class(T, 1, clsx$1(PL)), T.disabled = L(), set_attribute(T, "aria-current", I());
			}), append(C, T);
		};
		if_block(F, (C) => {
			V() ? C(U) : C(W, !1);
		}, !0), append(C, E);
	};
	return if_block(RL, (C) => {
		!F() && D() ? C(zL) : C(BL, !1);
	}), append(C, LL), pop(IL);
}
delegate(["click"]), create_custom_element(ListgroupItem, {
	children: {},
	onclick: {},
	active: {},
	current: {},
	disabled: {},
	name: {},
	Icon: {},
	href: {},
	currentClass: {},
	normalClass: {},
	disabledClass: {},
	liClass: {},
	class: {},
	aClasss: {},
	btnClass: {},
	iconClass: {}
}, [], [], !0);
function Listgroup(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "items", 7), F = prop(E, "active", 7), I = prop(E, "onclick", 7), L = prop(E, "rounded", 7, !0), z = prop(E, "border", 7, !0), B = prop(E, "class", 7), V = prop(E, "itemClass", 7), U = prop(E, "iconClass", 7), W = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"items",
		"active",
		"onclick",
		"rounded",
		"border",
		"class",
		"itemClass",
		"iconClass"
	]), G = /* @__PURE__ */ user_derived(() => listGroup({
		rounded: L(),
		border: z(),
		className: B()
	})), K = F() ? "div" : "ul";
	setContext("active", F());
	var J = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get items() {
			return O();
		},
		set items(C) {
			O(C), flushSync();
		},
		get active() {
			return F();
		},
		set active(C) {
			F(C), flushSync();
		},
		get onclick() {
			return I();
		},
		set onclick(C) {
			I(C), flushSync();
		},
		get rounded() {
			return L();
		},
		set rounded(C = !0) {
			L(C), flushSync();
		},
		get border() {
			return z();
		},
		set border(C = !0) {
			z(C), flushSync();
		},
		get class() {
			return B();
		},
		set class(C) {
			B(C), flushSync();
		},
		get itemClass() {
			return V();
		},
		set itemClass(C) {
			V(C), flushSync();
		},
		get iconClass() {
			return U();
		},
		set iconClass(C) {
			U(C), flushSync();
		}
	}, Y = comment();
	return element(first_child(Y), () => K, !1, (C, E) => {
		attribute_effect(C, () => _objectSpread2(_objectSpread2({}, W), {}, { class: get(G) }));
		var L = comment(), z = first_child(L), B = (C) => {
			var T = comment();
			each(first_child(T), 17, O, index, (C, T) => {
				var E = comment(), D = first_child(E), O = (C) => {
					ListgroupItem(C, {
						get class() {
							return V();
						},
						get iconClass() {
							return U();
						},
						get active() {
							return F();
						},
						get onclick() {
							return I();
						},
						children: (C, E) => {
							next();
							var D = text();
							template_effect(() => set_text(D, get(T))), append(C, D);
						},
						$$slots: { default: !0 }
					});
				}, L = (C) => {
					ListgroupItem(C, spread_props({
						get class() {
							return V();
						},
						get iconClass() {
							return U();
						},
						get active() {
							return F();
						}
					}, () => get(T), {
						onclick: (C) => {
							console.log("item", get(T));
						},
						children: (C, E) => {
							next();
							var D = text();
							template_effect(() => set_text(D, get(T))), append(C, D);
						},
						$$slots: { default: !0 }
					}));
				};
				if_block(D, (C) => {
					typeof get(T) == "string" ? C(O) : C(L, !1);
				}), append(C, E);
			}), append(C, T);
		}, K = (C) => {
			var T = comment(), E = first_child(T), O = (C) => {
				var T = comment();
				snippet(first_child(T), D), append(C, T);
			};
			if_block(E, (C) => {
				D() && C(O);
			}, !0), append(C, T);
		};
		if_block(z, (C) => {
			O() ? C(B) : C(K, !1);
		}), append(E, L);
	}), append(C, Y), pop(J);
}
create_custom_element(Listgroup, {
	children: {},
	items: {},
	active: {},
	onclick: {},
	rounded: {},
	border: {},
	class: {},
	itemClass: {},
	iconClass: {}
}, [], [], !0);
const listGroup = ce({
	base: "bg-white dark:bg-gray-800 text-gray-500 dark:text-gray-400 divide-y divide-gray-200 dark:divide-gray-600",
	variants: {
		rounded: {
			true: "rounded-lg",
			false: ""
		},
		border: {
			true: "border border-gray-200 dark:border-gray-700",
			false: ""
		}
	},
	compoundVariants: [{
		border: !0,
		class: "divide-gray-200 dark:divide-gray-700"
	}],
	defaultVariants: {
		rounded: !0,
		border: !0
	}
}), listGroupItem = ce({
	base: "py-2 px-4 w-full text-sm font-medium list-none",
	variants: {
		state: {
			normal: "",
			current: "",
			disabled: ""
		},
		active: {
			true: "",
			false: ""
		}
	},
	compoundVariants: [{
		active: !0,
		state: "disabled",
		class: "cursor-not-allowed"
	}, {
		active: !0,
		state: "normal",
		class: "hover:bg-gray-100 hover:text-primary-700 dark:hover:bg-gray-600 dark:hover:text-white focus:z-40 focus:outline-none focus:ring-2 focus:ring-primary-700 focus:text-primary-700 dark:focus:ring-gray-500 dark:focus:text-white"
	}]
});
var root_2$51 = /* @__PURE__ */ from_html("<li><!></li>"), root_4$27 = /* @__PURE__ */ from_html("<div><!></div>"), root_1$94 = /* @__PURE__ */ from_html("<div><div><ul></ul> <!></div></div>");
function MegaMenu(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "footer", 7), F = prop(E, "items", 23, () => []), I = prop(E, "full", 7), L = prop(E, "dropdownStatus", 15), z = prop(E, "class", 7), B = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"footer",
		"items",
		"full",
		"dropdownStatus",
		"class"
	]), V = /* @__PURE__ */ user_derived(megamenu), U = /* @__PURE__ */ user_derived(() => get(V).base), W = /* @__PURE__ */ user_derived(() => get(V).div), G = /* @__PURE__ */ user_derived(() => get(V).ul), K = /* @__PURE__ */ user_derived(() => get(V).footerDiv);
	var J = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get footer() {
			return O();
		},
		set footer(C) {
			O(C), flushSync();
		},
		get items() {
			return F();
		},
		set items(C = []) {
			F(C), flushSync();
		},
		get full() {
			return I();
		},
		set full(C) {
			I(C), flushSync();
		},
		get dropdownStatus() {
			return L();
		},
		set dropdownStatus(C) {
			L(C), flushSync();
		},
		get class() {
			return z();
		},
		set class(C) {
			z(C), flushSync();
		}
	}, Y = comment(), X = first_child(Y), Z = (C) => {
		var E = root_1$94();
		attribute_effect(E, (C) => _objectSpread2(_objectSpread2({}, B), {}, { class: C }), [() => get(U)({ className: z() })]);
		var L = child(E), V = child(L);
		each(V, 21, F, index, (C, T, E) => {
			var O = root_2$51();
			snippet(child(O), D, () => ({
				item: get(T),
				index: E
			})), reset(O), append(C, O);
		}, (C) => {
			var T = comment();
			snippet(first_child(T), D, () => ({
				item: F()[0],
				index: 0
			})), append(C, T);
		}), reset(V);
		var J = sibling(V, 2), Y = (C) => {
			var T = root_4$27();
			snippet(child(T), O), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(K)())]), append(C, T);
		};
		if_block(J, (C) => {
			I() && O() && C(Y);
		}), reset(L), reset(E), template_effect((C, T) => {
			set_class(L, 1, C), set_class(V, 1, T);
		}, [() => clsx$1(get(W)()), () => clsx$1(get(G)())]), append(C, E);
	};
	return if_block(X, (C) => {
		L() && C(Z);
	}), append(C, Y), pop(J);
}
create_custom_element(MegaMenu, {
	children: {},
	footer: {},
	items: {},
	full: {},
	dropdownStatus: {},
	class: {}
}, [], [], !0);
const megamenu = ce({
	slots: {
		base: "w-full border rounded-lg",
		div: "flex flex-col md:flex-row p-4 max-w-screen-md justify-center mx-auto mt-2",
		ul: "grid grid-flow-row gap-y-4 md:gap-x-0 auto-col-max auto-row-max grid-cols-2 md:grid-cols-3 text-sm font-medium",
		footerDiv: "md:w-1/3 mt-4 md:mt-0"
	},
	variants: { full: {} }
}), closeButton = ce({
	base: "focus:outline-hidden whitespace-normal disabled:cursor-not-allowed disabled:opacity-50",
	variants: {
		color: {
			primary: "text-primary-500 focus:ring-primary-400 hover:bg-primary-200 dark:hover:bg-primary-800 dark:hover:text-primary-300",
			secondary: "text-secondary-500 focus:ring-secondary-400 hover:bg-secondary-200 dark:hover:bg-secondary-800 dark:hover:text-secondary-300",
			gray: "text-gray-500 focus:ring-gray-400 hover:bg-gray-200 dark:hover:bg-gray-800 dark:hover:text-gray-300",
			red: "text-red-500 focus:ring-red-400 hover:bg-red-200 dark:hover:bg-red-800 dark:hover:text-red-300",
			orange: "text-orange-500 focus:ring-orange-400 hover:bg-orange-200 dark:hover:bg-orange-800 dark:hover:text-orange-300",
			amber: "text-amber-500 focus:ring-amber-400 hover:bg-amber-200 dark:hover:bg-amber-800 dark:hover:text-amber-300",
			yellow: "text-yellow-500 focus:ring-yellow-400 hover:bg-yellow-200 dark:hover:bg-yellow-800 dark:hover:text-yellow-300",
			lime: "text-lime-500 focus:ring-lime-400 hover:bg-lime-200 dark:hover:bg-lime-800 dark:hover:text-lime-300",
			green: "text-green-500 focus:ring-green-400 hover:bg-green-200 dark:hover:bg-green-800 dark:hover:text-green-300",
			emerald: "text-emerald-500 focus:ring-emerald-400 hover:bg-emerald-200 dark:hover:bg-emerald-800 dark:hover:text-emerald-300",
			teal: "text-teal-500 focus:ring-teal-400 hover:bg-teal-200 dark:hover:bg-teal-800 dark:hover:text-teal-300",
			cyan: "text-cyan-500 focus:ring-cyan-400 hover:bg-cyan-200 dark:hover:bg-cyan-800 dark:hover:text-cyan-300",
			sky: "text-sky-500 focus:ring-sky-400 hover:bg-sky-200 dark:hover:bg-sky-800 dark:hover:text-sky-300",
			blue: "text-blue-500 focus:ring-blue-400 hover:bg-blue-200 dark:hover:bg-blue-800 dark:hover:text-blue-300",
			indigo: "text-indigo-500 focus:ring-indigo-400 hover:bg-indigo-200 dark:hover:bg-indigo-800 dark:hover:text-indigo-300",
			violet: "text-violet-500 focus:ring-violet-400 hover:bg-violet-200 dark:hover:bg-violet-800 dark:hover:text-violet-300",
			purple: "text-purple-500 focus:ring-purple-400 hover:bg-purple-200 dark:hover:bg-purple-800 dark:hover:text-purple-300",
			fuchsia: "text-fuchsia-500 focus:ring-fuchsia-400 hover:bg-fuchsia-200 dark:hover:bg-fuchsia-800 dark:hover:text-fuchsia-300",
			pink: "text-pink-500 focus:ring-pink-400 hover:bg-pink-200 dark:hover:bg-pink-800 dark:hover:text-pink-300",
			rose: "text-rose-500 focus:ring-rose-400 hover:bg-rose-200 dark:hover:bg-rose-800 dark:hover:text-rose-300",
			none: ""
		},
		size: {
			xs: "m-0.5 rounded-xs focus:ring-1 p-0.5",
			sm: "m-0.5 rounded-sm focus:ring-1 p-0.5",
			md: "m-0.5 rounded-lg focus:ring-2 p-1.5",
			lg: "m-0.5 rounded-lg focus:ring-2 p-2.5"
		}
	},
	defaultVariants: {
		color: "gray",
		size: "md",
		href: null
	},
	slots: { svg: "" },
	compoundVariants: [
		{
			size: "xs",
			class: { svg: "w-3 h-3" }
		},
		{
			size: "sm",
			class: { svg: "w-3.5 h-3.5" }
		},
		{
			size: ["md", "lg"],
			class: { svg: "w-5 h-5" }
		},
		{
			size: [
				"xs",
				"sm",
				"md",
				"lg"
			],
			color: "none",
			class: "focus:ring-0 rounded-none m-0"
		}
	]
});
var DISMISSABLE_KEY = Symbol("dismissable");
function createDismissableContext(C) {
	return setContext(DISMISSABLE_KEY, { dismiss: C });
}
function useDismiss() {
	return getContext(DISMISSABLE_KEY);
}
var root_2$50 = /* @__PURE__ */ from_html("<span class=\"sr-only\"> </span>"), root_4$26 = /* @__PURE__ */ from_svg("<svg fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clip-rule=\"evenodd\"></path></svg>"), root_1$93 = /* @__PURE__ */ from_html("<button><!> <!></button>"), root_6$12 = /* @__PURE__ */ from_html("<span class=\"sr-only\"> </span>"), root_8$11 = /* @__PURE__ */ from_svg("<svg fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clip-rule=\"evenodd\"></path></svg>"), root_5$21 = /* @__PURE__ */ from_html("<a><!> <!></a>");
function CloseButton(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "color", 7, "gray"), F = prop(E, "onclick", 7), I = prop(E, "name", 7, "Close"), L = prop(E, "ariaLabel", 7), z = prop(E, "size", 7, "md"), B = prop(E, "class", 7), V = prop(E, "svgClass", 7), U = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"color",
		"onclick",
		"name",
		"ariaLabel",
		"size",
		"class",
		"svgClass"
	]), W = /* @__PURE__ */ user_derived(() => closeButton({
		color: O(),
		size: z()
	})), G = /* @__PURE__ */ user_derived(() => get(W).base), K = /* @__PURE__ */ user_derived(() => get(W).svg), J = useDismiss();
	function Y(C) {
		var T, E;
		(T = F()) == null || T(C), !C.defaultPrevented && (J == null || (E = J.dismiss) == null || E.call(J, C));
	}
	var X = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get color() {
			return O();
		},
		set color(C = "gray") {
			O(C), flushSync();
		},
		get onclick() {
			return F();
		},
		set onclick(C) {
			F(C), flushSync();
		},
		get name() {
			return I();
		},
		set name(C = "Close") {
			I(C), flushSync();
		},
		get ariaLabel() {
			return L();
		},
		set ariaLabel(C) {
			L(C), flushSync();
		},
		get size() {
			return z();
		},
		set size(C = "md") {
			z(C), flushSync();
		},
		get class() {
			return B();
		},
		set class(C) {
			B(C), flushSync();
		},
		get svgClass() {
			return V();
		},
		set svgClass(C) {
			V(C), flushSync();
		}
	}, Z = comment(), Q = first_child(Z), NL = (C) => {
		var E = root_1$93();
		attribute_effect(E, (C) => {
			var E;
			return _objectSpread2(_objectSpread2({ type: "button" }, U), {}, {
				class: C,
				onclick: Y,
				"aria-label": (E = L()) == null ? I() : E
			});
		}, [() => get(G)({ class: clsx_default(B()) })]);
		var O = child(E), F = (C) => {
			var T = root_2$50(), E = child(T, !0);
			reset(T), template_effect(() => set_text(E, I())), append(C, T);
		};
		if_block(O, (C) => {
			I() && C(F);
		});
		var z = sibling(O, 2), W = (C) => {
			var T = comment();
			snippet(first_child(T), D), append(C, T);
		}, J = (C) => {
			var T = root_4$26();
			template_effect((C) => set_class(T, 0, C), [() => clsx$1(get(K)({ class: V() }))]), append(C, T);
		};
		if_block(z, (C) => {
			D() ? C(W) : C(J, !1);
		}), reset(E), append(C, E);
	}, PL = (C) => {
		var E = root_5$21();
		attribute_effect(E, (C) => {
			var E;
			return _objectSpread2(_objectSpread2({}, U), {}, {
				onclick: Y,
				class: C,
				"aria-label": (E = L()) == null ? I() : E
			});
		}, [() => get(G)({ class: clsx_default(B()) })]);
		var O = child(E), F = (C) => {
			var T = root_6$12(), E = child(T, !0);
			reset(T), template_effect(() => set_text(E, I())), append(C, T);
		};
		if_block(O, (C) => {
			I() && C(F);
		});
		var z = sibling(O, 2), V = (C) => {
			var T = comment();
			snippet(first_child(T), D), append(C, T);
		}, W = (C) => {
			var T = root_8$11();
			template_effect((C) => set_class(T, 0, C), [() => clsx$1(get(K)())]), append(C, T);
		};
		if_block(z, (C) => {
			D() ? C(V) : C(W, !1);
		}), reset(E), append(C, E);
	};
	return if_block(Q, (C) => {
		E.href === void 0 ? C(NL) : C(PL, !1);
	}), append(C, Z), pop(X);
}
create_custom_element(CloseButton, {
	children: {},
	color: {},
	onclick: {},
	name: {},
	ariaLabel: {},
	size: {},
	class: {},
	svgClass: {}
}, [], [], !0);
var root_2$49 = /* @__PURE__ */ from_html("<div role=\"presentation\"></div>"), root_4$25 = /* @__PURE__ */ from_html("<div role=\"presentation\"></div>"), root_6$11 = /* @__PURE__ */ from_html("<div role=\"presentation\" class=\"fixed start-0 top-0 z-50 h-full w-full\"></div>"), root_8$10 = /* @__PURE__ */ from_html("<div role=\"presentation\" class=\"fixed start-0 top-0 z-50 h-full w-full\"></div>"), root_10$7 = /* @__PURE__ */ from_html("<h3> </h3>"), root_9$9 = /* @__PURE__ */ from_html("<div><!> <!></div>"), root_15$3 = /* @__PURE__ */ from_html("<div><!></div>"), root_1$92 = /* @__PURE__ */ from_html("<!> <div><div><div><!> <div><!> <!></div> <!></div></div></div>", 1);
function Modal(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "header", 7), F = prop(E, "footer", 7), I = prop(E, "title", 7), L = prop(E, "modalStatus", 7), z = prop(E, "dismissable", 7, !0), B = prop(E, "closeModal", 7), V = prop(E, "divClass", 7), U = prop(E, "contentClass", 7), W = prop(E, "closeBtnClass", 7), G = prop(E, "h3Class", 7), K = prop(E, "headerClass", 7), J = prop(E, "bodyClass", 7), Y = prop(E, "footerClass", 7), X = prop(E, "outsideClose", 7, !0), Z = prop(E, "size", 7, "md"), Q = prop(E, "backdrop", 7, !0), NL = prop(E, "backdropClass", 7), PL = prop(E, "position", 7, "center"), FL = prop(E, "class", 7), IL = prop(E, "params", 23, () => ({
		duration: 100,
		easing: sineIn
	})), LL = prop(E, "transition", 7, fade), RL = prop(E, "rounded", 7, !0), zL = /* @__PURE__ */ rest_props(E, /* @__PURE__ */ "$$slots.$$events.$$legacy.$$host.children.header.footer.title.modalStatus.dismissable.closeModal.divClass.contentClass.closeBtnClass.h3Class.headerClass.bodyClass.footerClass.outsideClose.size.backdrop.backdropClass.position.class.params.transition.rounded".split(".")), BL = /* @__PURE__ */ user_derived(() => modal({
		position: PL(),
		size: Z(),
		backdrop: Q(),
		rounded: RL()
	})), VL = /* @__PURE__ */ user_derived(() => get(BL).base), HL = /* @__PURE__ */ user_derived(() => get(BL).div), UL = /* @__PURE__ */ user_derived(() => get(BL).content), WL = /* @__PURE__ */ user_derived(() => get(BL).backdrop), GL = /* @__PURE__ */ user_derived(() => get(BL).header), KL = /* @__PURE__ */ user_derived(() => get(BL).footer), qL = /* @__PURE__ */ user_derived(() => get(BL).body), JL = /* @__PURE__ */ user_derived(() => get(BL).closeBtn), YL = /* @__PURE__ */ user_derived(() => get(BL).h3);
	var XL = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get header() {
			return O();
		},
		set header(C) {
			O(C), flushSync();
		},
		get footer() {
			return F();
		},
		set footer(C) {
			F(C), flushSync();
		},
		get title() {
			return I();
		},
		set title(C) {
			I(C), flushSync();
		},
		get modalStatus() {
			return L();
		},
		set modalStatus(C) {
			L(C), flushSync();
		},
		get dismissable() {
			return z();
		},
		set dismissable(C = !0) {
			z(C), flushSync();
		},
		get closeModal() {
			return B();
		},
		set closeModal(C) {
			B(C), flushSync();
		},
		get divClass() {
			return V();
		},
		set divClass(C) {
			V(C), flushSync();
		},
		get contentClass() {
			return U();
		},
		set contentClass(C) {
			U(C), flushSync();
		},
		get closeBtnClass() {
			return W();
		},
		set closeBtnClass(C) {
			W(C), flushSync();
		},
		get h3Class() {
			return G();
		},
		set h3Class(C) {
			G(C), flushSync();
		},
		get headerClass() {
			return K();
		},
		set headerClass(C) {
			K(C), flushSync();
		},
		get bodyClass() {
			return J();
		},
		set bodyClass(C) {
			J(C), flushSync();
		},
		get footerClass() {
			return Y();
		},
		set footerClass(C) {
			Y(C), flushSync();
		},
		get outsideClose() {
			return X();
		},
		set outsideClose(C = !0) {
			X(C), flushSync();
		},
		get size() {
			return Z();
		},
		set size(C = "md") {
			Z(C), flushSync();
		},
		get backdrop() {
			return Q();
		},
		set backdrop(C = !0) {
			Q(C), flushSync();
		},
		get backdropClass() {
			return NL();
		},
		set backdropClass(C) {
			NL(C), flushSync();
		},
		get position() {
			return PL();
		},
		set position(C = "center") {
			PL(C), flushSync();
		},
		get class() {
			return FL();
		},
		set class(C) {
			FL(C), flushSync();
		},
		get params() {
			return IL();
		},
		set params(C = {
			duration: 100,
			easing: sineIn
		}) {
			IL(C), flushSync();
		},
		get transition() {
			return LL();
		},
		set transition(C = fade) {
			LL(C), flushSync();
		},
		get rounded() {
			return RL();
		},
		set rounded(C = !0) {
			RL(C), flushSync();
		}
	}, ZL = comment(), QL = first_child(ZL), $L = (C) => {
		var E = root_1$92(), L = first_child(E), Z = (C) => {
			var T = root_2$49();
			T.__click = function(...C) {
				var T;
				(T = B()) == null || T.apply(this, C);
			}, template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(WL)({ class: NL() }))]), append(C, T);
		}, PL = (C) => {
			var T = comment(), E = first_child(T), D = (C) => {
				var T = root_4$25();
				template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(WL)({ class: NL() }))]), append(C, T);
			}, O = (C) => {
				var T = comment(), E = first_child(T), D = (C) => {
					var T = root_6$11();
					T.__click = function(...C) {
						var T;
						(T = B()) == null || T.apply(this, C);
					}, append(C, T);
				}, O = (C) => {
					var T = comment(), E = first_child(T), D = (C) => {
						append(C, root_8$10());
					};
					if_block(E, (C) => {
						!Q() && !X() && C(D);
					}, !0), append(C, T);
				};
				if_block(E, (C) => {
					!Q() && X() ? C(D) : C(O, !1);
				}, !0), append(C, T);
			};
			if_block(E, (C) => {
				Q() && !X() ? C(D) : C(O, !1);
			}, !0), append(C, T);
		};
		if_block(L, (C) => {
			Q() && X() ? C(Z) : C(PL, !1);
		});
		var RL = sibling(L, 2);
		attribute_effect(RL, (C) => _objectSpread2(_objectSpread2({}, zL), {}, {
			class: C,
			tabindex: "-1"
		}), [() => get(VL)({ className: FL() })]);
		var BL = child(RL), XL = child(BL), ZL = child(XL), QL = (C) => {
			var T = root_9$9(), E = child(T), D = (C) => {
				var T = root_10$7(), E = child(T, !0);
				reset(T), template_effect((C) => {
					set_class(T, 1, C), set_text(E, I());
				}, [() => clsx$1(get(YL)({ class: G() }))]), append(C, T);
			}, F = (C) => {
				var T = comment(), E = first_child(T), D = (C) => {
					var T = comment();
					snippet(first_child(T), O), append(C, T);
				};
				if_block(E, (C) => {
					O() && C(D);
				}, !0), append(C, T);
			};
			if_block(E, (C) => {
				I() ? C(D) : C(F, !1);
			});
			var L = sibling(E, 2), V = (C) => {
				{
					let T = /* @__PURE__ */ user_derived(() => get(JL)({ class: W() }));
					CloseButton(C, {
						get onclick() {
							return B();
						},
						get class() {
							return get(T);
						}
					});
				}
			};
			if_block(L, (C) => {
				z() && C(V);
			}), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(GL)({ class: K() }))]), append(C, T);
		};
		if_block(ZL, (C) => {
			(I() || O()) && C(QL);
		});
		var $L = sibling(ZL, 2), eR = child($L), tR = (C) => {
			{
				let T = /* @__PURE__ */ user_derived(() => get(JL)({ class: W() }));
				CloseButton(C, {
					get onclick() {
						return B();
					},
					get class() {
						return get(T);
					}
				});
			}
		};
		if_block(eR, (C) => {
			z() && !I() && !O() && C(tR);
		}), snippet(sibling(eR, 2), D), reset($L);
		var nR = sibling($L, 2), rR = (C) => {
			var T = root_15$3();
			snippet(child(T), F), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(KL)({ class: Y() }))]), append(C, T);
		};
		if_block(nR, (C) => {
			F() && C(rR);
		}), reset(XL), reset(BL), reset(RL), template_effect((C, T, E) => {
			set_class(BL, 1, C), set_class(XL, 1, T), set_class($L, 1, E);
		}, [
			() => clsx$1(get(HL)({ class: V() })),
			() => clsx$1(get(UL)({ class: U() })),
			() => clsx$1(get(qL)({ class: J() }))
		]), transition(3, RL, LL, IL), append(C, E);
	};
	return if_block(QL, (C) => {
		L() && C($L);
	}), append(C, ZL), pop(XL);
}
delegate(["click"]), create_custom_element(Modal, {
	children: {},
	header: {},
	footer: {},
	title: {},
	modalStatus: {},
	dismissable: {},
	closeModal: {},
	divClass: {},
	contentClass: {},
	closeBtnClass: {},
	h3Class: {},
	headerClass: {},
	bodyClass: {},
	footerClass: {},
	outsideClose: {},
	size: {},
	backdrop: {},
	backdropClass: {},
	position: {},
	class: {},
	params: {},
	transition: {},
	rounded: {}
}, [], [], !0);
const modal = ce({
	slots: {
		base: "fixed top-0 start-0 end-0 h-modal md:inset-0 md:h-full z-50 w-full p-4 flex pointer-events-none",
		div: "flex relative w-full max-h-full",
		content: "w-full divide-y text-gray-800 dark:text-gray-300 border-gray-300 dark:border-gray-800 divide-gray-300 dark:divide-gray-800 bg-white dark:bg-gray-800 pointer-events-auto",
		backdrop: "fixed inset-0 z-50 bg-gray-900 bg-opacity-50 dark:bg-opacity-80 pointer-events-auto",
		header: "flex justify-between items-center p-4 md:p-5 rounded-t-lg",
		footer: "flex items-center p-4 md:p-5 space-x-3 rtl:space-x-reverse rounded-b-lg",
		body: "p-4 md:p-5 space-y-4 flex-1 overflow-y-auto overscroll-contain",
		closeBtn: "absolute top-3 end-2.5",
		h3: "text-xl font-semibold text-gray-900 dark:text-white p-0"
	},
	variants: {
		position: {
			"top-left": { base: "justify-start items-start" },
			"top-center": { base: "justify-center items-start" },
			"top-right": { base: "justify-end items-start" },
			"center-left": { base: "justify-start items-center" },
			center: { base: "justify-center items-center" },
			"center-right": { base: "justify-end items-center" },
			"bottom-left": { base: "justify-start items-end" },
			"bottom-center": { base: "justify-center items-end" },
			"bottom-right": { base: "justify-end items-end" },
			default: { base: "justify-center items-center" }
		},
		size: {
			xs: { div: "max-w-md" },
			sm: { div: "max-w-lg" },
			md: { div: "max-w-2xl" },
			lg: { div: "max-w-4xl" },
			xl: { div: "max-w-7xl" }
		},
		backdrop: { true: { backdrop: "bg-gray-900 bg-opacity-75" } },
		rounded: { true: { content: "rounded" } },
		shadow: { true: { content: "shadow-md" } }
	}
});
var root_2$48 = /* @__PURE__ */ from_html("<div role=\"presentation\"></div>"), root_4$24 = /* @__PURE__ */ from_html("<div role=\"presentation\"></div>"), root_6$10 = /* @__PURE__ */ from_html("<div role=\"presentation\" class=\"fixed start-0 top-0 z-50 h-full w-full\"></div>"), root_8$9 = /* @__PURE__ */ from_html("<div role=\"presentation\" class=\"fixed start-0 top-0 z-50 h-full w-full\"></div>"), root_10$6 = /* @__PURE__ */ from_html("<h3> </h3>"), root_9$8 = /* @__PURE__ */ from_html("<div><!> <!></div>"), root_15$2 = /* @__PURE__ */ from_html("<div><!></div>"), root_1$91 = /* @__PURE__ */ from_html("<!> <div><div><div><!> <div><!> <!></div> <!></div></div></div>", 1);
function Modalp(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "header", 7), F = prop(E, "footer", 7), I = prop(E, "title", 7), L = prop(E, "modalStatus", 7), z = prop(E, "dismissable", 7, !0), B = prop(E, "left", 7), V = prop(E, "top", 7), U = prop(E, "closeModal", 7), W = prop(E, "divClass", 7), G = prop(E, "contentClass", 7), K = prop(E, "closeBtnClass", 7), J = prop(E, "h3Class", 7), Y = prop(E, "headerClass", 7), X = prop(E, "bodyClass", 7), Z = prop(E, "footerClass", 7), Q = prop(E, "outsideClose", 7, !0), NL = prop(E, "size", 7, "md"), PL = prop(E, "backdrop", 7, !0), FL = prop(E, "backdropClass", 7), IL = prop(E, "position", 7, "center"), LL = prop(E, "class", 7), RL = prop(E, "params", 23, () => ({
		duration: 100,
		easing: sineIn
	})), zL = prop(E, "transition", 7, fade), BL = prop(E, "rounded", 7, !0), VL = /* @__PURE__ */ rest_props(E, /* @__PURE__ */ "$$slots.$$events.$$legacy.$$host.children.header.footer.title.modalStatus.dismissable.left.top.closeModal.divClass.contentClass.closeBtnClass.h3Class.headerClass.bodyClass.footerClass.outsideClose.size.backdrop.backdropClass.position.class.params.transition.rounded".split(".")), HL = /* @__PURE__ */ user_derived(() => modalp({
		position: IL(),
		size: NL(),
		backdrop: PL(),
		rounded: BL()
	})), UL = /* @__PURE__ */ user_derived(() => get(HL).base), WL = /* @__PURE__ */ user_derived(() => get(HL).div), GL = /* @__PURE__ */ user_derived(() => get(HL).content), KL = /* @__PURE__ */ user_derived(() => get(HL).backdrop), qL = /* @__PURE__ */ user_derived(() => get(HL).header), JL = /* @__PURE__ */ user_derived(() => get(HL).footer), YL = /* @__PURE__ */ user_derived(() => get(HL).body), XL = /* @__PURE__ */ user_derived(() => get(HL).closeBtn), ZL = /* @__PURE__ */ user_derived(() => get(HL).h3);
	var QL = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get header() {
			return O();
		},
		set header(C) {
			O(C), flushSync();
		},
		get footer() {
			return F();
		},
		set footer(C) {
			F(C), flushSync();
		},
		get title() {
			return I();
		},
		set title(C) {
			I(C), flushSync();
		},
		get modalStatus() {
			return L();
		},
		set modalStatus(C) {
			L(C), flushSync();
		},
		get dismissable() {
			return z();
		},
		set dismissable(C = !0) {
			z(C), flushSync();
		},
		get left() {
			return B();
		},
		set left(C) {
			B(C), flushSync();
		},
		get top() {
			return V();
		},
		set top(C) {
			V(C), flushSync();
		},
		get closeModal() {
			return U();
		},
		set closeModal(C) {
			U(C), flushSync();
		},
		get divClass() {
			return W();
		},
		set divClass(C) {
			W(C), flushSync();
		},
		get contentClass() {
			return G();
		},
		set contentClass(C) {
			G(C), flushSync();
		},
		get closeBtnClass() {
			return K();
		},
		set closeBtnClass(C) {
			K(C), flushSync();
		},
		get h3Class() {
			return J();
		},
		set h3Class(C) {
			J(C), flushSync();
		},
		get headerClass() {
			return Y();
		},
		set headerClass(C) {
			Y(C), flushSync();
		},
		get bodyClass() {
			return X();
		},
		set bodyClass(C) {
			X(C), flushSync();
		},
		get footerClass() {
			return Z();
		},
		set footerClass(C) {
			Z(C), flushSync();
		},
		get outsideClose() {
			return Q();
		},
		set outsideClose(C = !0) {
			Q(C), flushSync();
		},
		get size() {
			return NL();
		},
		set size(C = "md") {
			NL(C), flushSync();
		},
		get backdrop() {
			return PL();
		},
		set backdrop(C = !0) {
			PL(C), flushSync();
		},
		get backdropClass() {
			return FL();
		},
		set backdropClass(C) {
			FL(C), flushSync();
		},
		get position() {
			return IL();
		},
		set position(C = "center") {
			IL(C), flushSync();
		},
		get class() {
			return LL();
		},
		set class(C) {
			LL(C), flushSync();
		},
		get params() {
			return RL();
		},
		set params(C = {
			duration: 100,
			easing: sineIn
		}) {
			RL(C), flushSync();
		},
		get transition() {
			return zL();
		},
		set transition(C = fade) {
			zL(C), flushSync();
		},
		get rounded() {
			return BL();
		},
		set rounded(C = !0) {
			BL(C), flushSync();
		}
	}, $L = comment(), eR = first_child($L), tR = (C) => {
		var E = root_1$91(), L = first_child(E), NL = (C) => {
			var T = root_2$48();
			T.__click = function(...C) {
				var T;
				(T = U()) == null || T.apply(this, C);
			}, template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(KL)({ class: FL() }))]), append(C, T);
		}, IL = (C) => {
			var T = comment(), E = first_child(T), D = (C) => {
				var T = root_4$24();
				template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(KL)({ class: FL() }))]), append(C, T);
			}, O = (C) => {
				var T = comment(), E = first_child(T), D = (C) => {
					var T = root_6$10();
					T.__click = function(...C) {
						var T;
						(T = U()) == null || T.apply(this, C);
					}, append(C, T);
				}, O = (C) => {
					var T = comment(), E = first_child(T), D = (C) => {
						append(C, root_8$9());
					};
					if_block(E, (C) => {
						!PL() && !Q() && C(D);
					}, !0), append(C, T);
				};
				if_block(E, (C) => {
					!PL() && Q() ? C(D) : C(O, !1);
				}, !0), append(C, T);
			};
			if_block(E, (C) => {
				PL() && !Q() ? C(D) : C(O, !1);
			}, !0), append(C, T);
		};
		if_block(L, (C) => {
			PL() && Q() ? C(NL) : C(IL, !1);
		});
		var BL = sibling(L, 2);
		attribute_effect(BL, (C) => _objectSpread2(_objectSpread2({}, VL), {}, {
			class: C,
			tabindex: "-1",
			[STYLE]: {
				left: B(),
				top: V()
			}
		}), [() => get(UL)({ className: LL() })]);
		var HL = child(BL), QL = child(HL), $L = child(QL), eR = (C) => {
			var T = root_9$8(), E = child(T), D = (C) => {
				var T = root_10$6(), E = child(T, !0);
				reset(T), template_effect((C) => {
					set_class(T, 1, C), set_text(E, I());
				}, [() => clsx$1(get(ZL)({ class: J() }))]), append(C, T);
			}, F = (C) => {
				var T = comment(), E = first_child(T), D = (C) => {
					var T = comment();
					snippet(first_child(T), O), append(C, T);
				};
				if_block(E, (C) => {
					O() && C(D);
				}, !0), append(C, T);
			};
			if_block(E, (C) => {
				I() ? C(D) : C(F, !1);
			});
			var L = sibling(E, 2), B = (C) => {
				{
					let T = /* @__PURE__ */ user_derived(() => get(XL)({ class: K() }));
					CloseButton(C, {
						get onclick() {
							return U();
						},
						get class() {
							return get(T);
						}
					});
				}
			};
			if_block(L, (C) => {
				z() && C(B);
			}), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(qL)({ class: Y() }))]), append(C, T);
		};
		if_block($L, (C) => {
			(I() || O()) && C(eR);
		});
		var tR = sibling($L, 2), nR = child(tR), rR = (C) => {
			{
				let T = /* @__PURE__ */ user_derived(() => get(XL)({ class: K() }));
				CloseButton(C, {
					get onclick() {
						return U();
					},
					get class() {
						return get(T);
					}
				});
			}
		};
		if_block(nR, (C) => {
			z() && !I() && !O() && C(rR);
		}), snippet(sibling(nR, 2), D), reset(tR);
		var iR = sibling(tR, 2), aR = (C) => {
			var T = root_15$2();
			snippet(child(T), F), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(JL)({ class: Z() }))]), append(C, T);
		};
		if_block(iR, (C) => {
			F() && C(aR);
		}), reset(QL), reset(HL), reset(BL), template_effect((C, T, E) => {
			set_class(HL, 1, C), set_class(QL, 1, T), set_class(tR, 1, E);
		}, [
			() => clsx$1(get(WL)({ class: W() })),
			() => clsx$1(get(GL)({ class: G() })),
			() => clsx$1(get(YL)({ class: X() }))
		]), transition(3, BL, zL, RL), append(C, E);
	};
	return if_block(eR, (C) => {
		L() && C(tR);
	}), append(C, $L), pop(QL);
}
delegate(["click"]), create_custom_element(Modalp, {
	children: {},
	header: {},
	footer: {},
	title: {},
	modalStatus: {},
	dismissable: {},
	left: {},
	top: {},
	closeModal: {},
	divClass: {},
	contentClass: {},
	closeBtnClass: {},
	h3Class: {},
	headerClass: {},
	bodyClass: {},
	footerClass: {},
	outsideClose: {},
	size: {},
	backdrop: {},
	backdropClass: {},
	position: {},
	class: {},
	params: {},
	transition: {},
	rounded: {}
}, [], [], !0);
const modalp = ce({
	slots: {
		base: "fixed top-0  start-0 end-0 h-modal  z-50  p-4 flex pointer-events-none w-1/4 h-1/3",
		div: "flex relative w-full max-h-full",
		content: "w-full divide-y text-gray-800 dark:text-gray-300 border-gray-300 dark:border-gray-800 divide-gray-300 dark:divide-gray-800 bg-white dark:bg-gray-800 pointer-events-auto",
		backdrop: "fixed inset-0 z-50 bg-gray-900 bg-opacity-50 dark:bg-opacity-80 pointer-events-auto",
		header: "flex justify-between items-center p-4 md:p-5 rounded-t-lg",
		footer: "flex items-center p-4 md:p-5 space-x-3 rtl:space-x-reverse rounded-b-lg",
		body: "p-4 md:p-5 space-y-4 flex-1 overflow-y-auto overscroll-contain",
		closeBtn: "absolute top-3 end-2.5",
		h3: "text-xl font-semibold text-gray-900 dark:text-white p-0"
	},
	variants: {
		position: {
			"top-left": { base: "justify-start items-start" },
			"top-center": { base: "justify-center items-start" },
			"top-right": { base: "justify-end items-start" },
			"center-left": { base: "justify-start items-center" },
			center: { base: " " },
			"center-right": { base: "justify-end items-center" },
			"bottom-left": { base: "justify-start items-end" },
			"bottom-center": { base: "justify-center items-end" },
			"bottom-right": { base: "justify-end items-end" },
			default: { base: "justify-center items-center" }
		},
		size: {
			xs: { div: "max-w-md" },
			sm: { div: "max-w-lg" },
			md: { div: "max-w-2xl" },
			lg: { div: "max-w-4xl" },
			xl: { div: "max-w-7xl" }
		},
		backdrop: { true: { backdrop: "bg-gray-900 bg-opacity-75" } },
		rounded: { true: { content: "rounded" } },
		shadow: { true: { content: "shadow-md" } }
	}
});
var root_2$47 = /* @__PURE__ */ from_html("<button type=\"button\"><span class=\"sr-only\">Open main menu</span> <svg class=\"h-5 w-5\" aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 17 14\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M1 1h15M1 7h15M1 13h15\"></path></svg></button>"), root_4$23 = /* @__PURE__ */ from_html("<!> <div><!></div> <!>", 1), root_7$14 = /* @__PURE__ */ from_html("<div><!></div>"), root$105 = /* @__PURE__ */ from_html("<nav><div><!> <!> <!> <!></div></nav>");
function Navbar(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "navSlotBlock", 7), F = prop(E, "navSlotHiddenTop", 7), I = prop(E, "navSlotHiddenBottom", 7), L = prop(E, "toggleNav", 7), z = prop(E, "closeNav", 7, () => {}), B = prop(E, "navStatus", 7), V = prop(E, "fluid", 7), U = prop(E, "brand", 7), W = prop(E, "hamburgerMenu", 7, !0), G = prop(E, "breakPoint", 7, "md"), K = prop(E, "navClass", 7), J = prop(E, "divClass", 7), Y = prop(E, "btnClass", 7), X = prop(E, "div2Class", 7), Z = prop(E, "activeClass", 7), Q = prop(E, "nonActiveClass", 7), NL = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"navSlotBlock",
		"navSlotHiddenTop",
		"navSlotHiddenBottom",
		"toggleNav",
		"closeNav",
		"navStatus",
		"fluid",
		"brand",
		"hamburgerMenu",
		"breakPoint",
		"navClass",
		"divClass",
		"btnClass",
		"div2Class",
		"activeClass",
		"nonActiveClass"
	]), PL = /* @__PURE__ */ user_derived(() => navbar({
		fluid: V(),
		breakPoint: G(),
		navStatus: B()
	})), FL = /* @__PURE__ */ user_derived(() => get(PL).base), IL = /* @__PURE__ */ user_derived(() => get(PL).container), LL = /* @__PURE__ */ user_derived(() => get(PL).toggleButton), RL = /* @__PURE__ */ user_derived(() => get(PL).menuContainer), zL = /* @__PURE__ */ user_derived(() => get(PL).activeLink), BL = /* @__PURE__ */ user_derived(() => get(PL).inactiveLink);
	setContext("navbarContext", {
		navStatus: B(),
		breakPoint: G(),
		get activeClass() {
			return get(zL)({ class: Z() });
		},
		get nonActiveClass() {
			return get(BL)({ class: Q() });
		},
		closeNav: z()
	});
	let VL = {
		delay: 250,
		duration: 500,
		easing: quintOut
	};
	function HL(C) {
		return C ? {
			role: "menu",
			tabindex: 0
		} : {
			role: "none",
			tabindex: -1
		};
	}
	var UL = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get navSlotBlock() {
			return O();
		},
		set navSlotBlock(C) {
			O(C), flushSync();
		},
		get navSlotHiddenTop() {
			return F();
		},
		set navSlotHiddenTop(C) {
			F(C), flushSync();
		},
		get navSlotHiddenBottom() {
			return I();
		},
		set navSlotHiddenBottom(C) {
			I(C), flushSync();
		},
		get toggleNav() {
			return L();
		},
		set toggleNav(C) {
			L(C), flushSync();
		},
		get closeNav() {
			return z();
		},
		set closeNav(C = () => {}) {
			z(C), flushSync();
		},
		get navStatus() {
			return B();
		},
		set navStatus(C) {
			B(C), flushSync();
		},
		get fluid() {
			return V();
		},
		set fluid(C) {
			V(C), flushSync();
		},
		get brand() {
			return U();
		},
		set brand(C) {
			U(C), flushSync();
		},
		get hamburgerMenu() {
			return W();
		},
		set hamburgerMenu(C = !0) {
			W(C), flushSync();
		},
		get breakPoint() {
			return G();
		},
		set breakPoint(C = "md") {
			G(C), flushSync();
		},
		get navClass() {
			return K();
		},
		set navClass(C) {
			K(C), flushSync();
		},
		get divClass() {
			return J();
		},
		set divClass(C) {
			J(C), flushSync();
		},
		get btnClass() {
			return Y();
		},
		set btnClass(C) {
			Y(C), flushSync();
		},
		get div2Class() {
			return X();
		},
		set div2Class(C) {
			X(C), flushSync();
		},
		get activeClass() {
			return Z();
		},
		set activeClass(C) {
			Z(C), flushSync();
		},
		get nonActiveClass() {
			return Q();
		},
		set nonActiveClass(C) {
			Q(C), flushSync();
		}
	}, WL = root$105();
	attribute_effect(WL, (C) => _objectSpread2(_objectSpread2({}, NL), {}, { class: C }), [() => get(FL)({ class: K() })]);
	var GL = child(WL), KL = child(GL), qL = (C) => {
		var T = comment();
		snippet(first_child(T), U), append(C, T);
	};
	if_block(KL, (C) => {
		U() && C(qL);
	});
	var JL = sibling(KL, 2), YL = (C) => {
		var T = root_2$47();
		T.__click = function(...C) {
			var T;
			(T = L()) == null || T.apply(this, C);
		}, template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(LL)({ class: Y() }))]), append(C, T);
	};
	if_block(JL, (C) => {
		W() && C(YL);
	});
	var XL = sibling(JL, 2), ZL = (C) => {
		var T = comment();
		snippet(first_child(T), O), append(C, T);
	};
	if_block(XL, (C) => {
		O() && C(ZL);
	});
	var QL = sibling(XL, 2), $L = (C) => {
		var E = root_4$23(), O = first_child(E), L = (C) => {
			var T = comment();
			snippet(first_child(T), F), append(C, T);
		};
		if_block(O, (C) => {
			F() && C(L);
		});
		var z = sibling(O, 2);
		attribute_effect(z, (C, E) => _objectSpread2({ class: C }, E), [() => get(RL)({ class: X() }), () => HL(!0)]), snippet(child(z), D), reset(z);
		var B = sibling(z, 2), V = (C) => {
			var T = comment();
			snippet(first_child(T), I), append(C, T);
		};
		if_block(B, (C) => {
			I() && C(V);
		}), transition(3, z, () => slide, () => VL), append(C, E);
	}, eR = (C) => {
		var E = root_7$14();
		attribute_effect(E, (C, E) => _objectSpread2({ class: C }, E), [() => get(RL)({ class: X() }), () => HL(!1)]), snippet(child(E), D), reset(E), append(C, E);
	};
	return if_block(QL, (C) => {
		B() ? C($L) : C(eR, !1);
	}), reset(GL), reset(WL), action(WL, (C, T) => clickOutside == null ? void 0 : clickOutside(C, T), z), template_effect((C) => set_class(GL, 1, C), [() => clsx$1(get(IL)({ class: J() }))]), append(C, WL), pop(UL);
}
delegate(["click"]), create_custom_element(Navbar, {
	children: {},
	navSlotBlock: {},
	navSlotHiddenTop: {},
	navSlotHiddenBottom: {},
	toggleNav: {},
	closeNav: {},
	navStatus: {},
	fluid: {},
	brand: {},
	hamburgerMenu: {},
	breakPoint: {},
	navClass: {},
	divClass: {},
	btnClass: {},
	div2Class: {},
	activeClass: {},
	nonActiveClass: {}
}, [], [], !0);
var root_2$46 = /* @__PURE__ */ from_html("<span> </span>"), root$104 = /* @__PURE__ */ from_html("<a><!> <!></a>");
function NavBrand(C, E) {
	var D;
	push(E, !0);
	let O = prop(E, "children", 7), F = prop(E, "siteName", 7), I = prop(E, "closeNav", 7), L = prop(E, "aClass", 7), z = prop(E, "spanClass", 7), B = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"siteName",
		"closeNav",
		"aClass",
		"spanClass"
	]);
	I((D = getContext("navbarContext").closeNav) == null ? I() : D);
	let V = /* @__PURE__ */ user_derived(navbrand), U = /* @__PURE__ */ user_derived(() => get(V).base), W = /* @__PURE__ */ user_derived(() => get(V).span);
	var G = {
		get children() {
			return O();
		},
		set children(C) {
			O(C), flushSync();
		},
		get siteName() {
			return F();
		},
		set siteName(C) {
			F(C), flushSync();
		},
		get closeNav() {
			return I();
		},
		set closeNav(C) {
			I(C), flushSync();
		},
		get aClass() {
			return L();
		},
		set aClass(C) {
			L(C), flushSync();
		},
		get spanClass() {
			return z();
		},
		set spanClass(C) {
			z(C), flushSync();
		}
	}, K = root$104();
	attribute_effect(K, (C) => _objectSpread2(_objectSpread2({
		href: "/",
		onclick: I()
	}, B), {}, { class: C }), [() => get(U)({ class: L() })]);
	var J = child(K), Y = (C) => {
		var T = comment();
		snippet(first_child(T), O), append(C, T);
	};
	if_block(J, (C) => {
		O() && C(Y);
	});
	var X = sibling(J, 2), Z = (C) => {
		var T = root_2$46(), E = child(T, !0);
		reset(T), template_effect((C) => {
			set_class(T, 1, C), set_text(E, F());
		}, [() => clsx$1(get(W)({ class: z() }))]), append(C, T);
	};
	return if_block(X, (C) => {
		F() && C(Z);
	}), reset(K), append(C, K), pop(G);
}
create_custom_element(NavBrand, {
	children: {},
	siteName: {},
	closeNav: {},
	aClass: {},
	spanClass: {}
}, [], [], !0);
var root$103 = /* @__PURE__ */ from_html("<li><a><!></a></li>");
function NavLi(C, E) {
	var D, O;
	push(E, !0);
	let F = prop(E, "closeNav", 7), I = prop(E, "href", 7), L = prop(E, "children", 7), z = prop(E, "aClass", 7), B = prop(E, "class", 7), V = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"closeNav",
		"href",
		"children",
		"aClass",
		"class"
	]), U, W = getContext("navbarContext");
	U = (D = W.breakPoint) == null ? "md" : D, F((O = W.closeNav) == null ? F() : O);
	let G = getContext("activeUrl"), K = /* @__PURE__ */ state("");
	G.subscribe((C) => {
		set(K, C, !0);
	});
	let J = /* @__PURE__ */ user_derived(() => get(K) ? I() === get(K) : !1);
	user_effect(() => {});
	let Y = /* @__PURE__ */ user_derived(() => navLi({
		active: get(J),
		breakPoint: U
	})), X = /* @__PURE__ */ user_derived(() => get(Y).base), Z = /* @__PURE__ */ user_derived(() => get(Y).link);
	var Q = {
		get closeNav() {
			return F();
		},
		set closeNav(C) {
			F(C), flushSync();
		},
		get href() {
			return I();
		},
		set href(C) {
			I(C), flushSync();
		},
		get children() {
			return L();
		},
		set children(C) {
			L(C), flushSync();
		},
		get aClass() {
			return z();
		},
		set aClass(C) {
			z(C), flushSync();
		},
		get class() {
			return B();
		},
		set class(C) {
			B(C), flushSync();
		}
	}, NL = root$103(), PL = child(NL);
	return attribute_effect(PL, (C) => _objectSpread2(_objectSpread2({
		href: I(),
		onclick: F()
	}, V), {}, {
		"aria-current": get(J),
		class: C
	}), [() => get(Z)({ class: z() })]), snippet(child(PL), L), reset(PL), reset(NL), template_effect((C) => set_class(NL, 1, C), [() => clsx$1(get(X)({ class: B() }))]), append(C, NL), pop(Q);
}
create_custom_element(NavLi, {
	closeNav: {},
	href: {},
	children: {},
	aClass: {},
	class: {}
}, [], [], !0);
var root$102 = /* @__PURE__ */ from_html("<ul><!></ul>");
function NavUl(C, E) {
	var D;
	push(E, !0);
	let O = prop(E, "children", 7), F = prop(E, "activeUrl", 7, ""), I = prop(E, "class", 7), L = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"activeUrl",
		"class"
	]), z;
	z = (D = getContext("navbarContext").breakPoint) == null ? "md" : D;
	let B = /* @__PURE__ */ user_derived(() => navUl({
		breakPoint: z,
		className: I()
	})), V = writable("");
	user_effect(() => {
		V.set(F());
	}), setContext("activeUrl", V);
	var U = {
		get children() {
			return O();
		},
		set children(C) {
			O(C), flushSync();
		},
		get activeUrl() {
			return F();
		},
		set activeUrl(C = "") {
			F(C), flushSync();
		},
		get class() {
			return I();
		},
		set class(C) {
			I(C), flushSync();
		}
	}, W = root$102();
	return attribute_effect(W, () => _objectSpread2(_objectSpread2({}, L), {}, { class: get(B) })), snippet(child(W), O), reset(W), append(C, W), pop(U);
}
create_custom_element(NavUl, {
	children: {},
	activeUrl: {},
	class: {}
}, [], [], !0);
var root$101 = /* @__PURE__ */ from_html("<button><span class=\"sr-only\">Open main menu</span> <svg class=\"h-5 w-5\" aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 17 14\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M1 1h15M1 7h15M1 13h15\"></path></svg></button>");
function NavHamburger(C, E) {
	var D;
	push(E, !0);
	let O = prop(E, "toggleNav", 7), F = prop(E, "class", 7), I = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"toggleNav",
		"class"
	]), L;
	L = (D = getContext("navbarContext").breakPoint) == null ? "md" : D;
	let z = /* @__PURE__ */ user_derived(() => navhamburger({
		breakPoint: L,
		className: F()
	}));
	var B = {
		get toggleNav() {
			return O();
		},
		set toggleNav(C) {
			O(C), flushSync();
		},
		get class() {
			return F();
		},
		set class(C) {
			F(C), flushSync();
		}
	}, V = root$101();
	return attribute_effect(V, () => _objectSpread2(_objectSpread2({
		onclick: O(),
		type: "button"
	}, I), {}, { class: get(z) })), append(C, V), pop(B);
}
create_custom_element(NavHamburger, {
	toggleNav: {},
	class: {}
}, [], [], !0);
const navbar = ce({
	slots: {
		base: "bg-white dark:bg-gray-900 text-gray-700 dark:text-gray-200 border-gray-100 dark:border-gray-700 divide-gray-100 dark:divide-gray-700 px-2 sm:px-4 py-2.5 w-full",
		container: "mx-auto flex flex-wrap items-center justify-between",
		toggleButton: "inline-flex h-10 w-10 items-center justify-center rounded-lg p-2 text-sm text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600",
		menuContainer: "w-full",
		activeLink: "block py-2 px-3 text-white bg-primary-700 rounded dark:text-white",
		inactiveLink: "block py-2 px-3 text-gray-900 rounded hover:bg-gray-100 dark:text-white dark:hover:bg-gray-700 dark:hover:text-white"
	},
	variants: {
		fluid: {
			true: { container: "w-full" },
			false: { container: "container" }
		},
		breakPoint: {
			md: {
				container: "max-w-screen-xl",
				toggleButton: "md:hidden",
				menuContainer: "md:block md:w-auto"
			},
			lg: {
				container: "max-w-screen-xl",
				toggleButton: "lg:hidden",
				menuContainer: "lg:block lg:w-auto"
			},
			xl: {
				container: "max-w-screen-xl",
				toggleButton: "xl:hidden",
				menuContainer: "xl:block xl:w-auto"
			},
			xxl: {
				container: "w-full",
				toggleButton: "2xl:hidden",
				menuContainer: "2xl:block 2xl:w-auto"
			}
		},
		navStatus: {
			true: { menuContainer: "block" },
			false: { menuContainer: "hidden" }
		}
	},
	defaultVariants: {
		fluid: !1,
		breakPoint: "md",
		navStatus: !1
	}
}), navUl = ce({
	base: "font-medium flex flex-col p-4 mt-4 border border-gray-100 rounded-lg bg-transparent rtl:space-x-reverse dark:bg-gray-800 dark:border-gray-700",
	variants: { breakPoint: {
		md: "md:mt-0 md:flex-row md:space-x-8 md:border-0 md:p-0 md:dark:bg-gray-900",
		lg: "lg:mt-0 lg:flex-row lg:space-x-8 lg:border-0 lg:p-0 lg:dark:bg-gray-900",
		xl: "xl:mt-0 xl:flex-row xl:space-x-8 xl:border-0 lg:p-0 xl:dark:bg-gray-900",
		xxl: "2xl:mt-0 2xl:flex-row 2xl:space-x-8 2xl:border-0 2xl:p-0 2xl:dark:bg-gray-900"
	} }
}), navbrand = ce({ slots: {
	base: "flex items-center space-x-3 rtl:space-x-reverse",
	span: "self-center whitespace-nowrap text-2xl font-semibold text-primary-900 dark:text-white sm:text-3xl"
} }), navLi = ce({
	slots: {
		base: "list-none",
		link: "block py-2 pl-3 pr-4 text-gray-900 rounded hover:bg-gray-100 dark:text-white dark:hover:bg-gray-700 dark:hover:text-white"
	},
	variants: {
		active: { true: { link: "bg-primary-700 text-white" } },
		breakPoint: {
			md: { link: "md:hover:bg-transparent md:border-0 md:hover:text-primary-700 md:p-0 md:dark:hover:text-primary-500 md:dark:hover:bg-transparent" },
			lg: { link: "lg:hover:bg-transparent lg:border-0 lg:hover:text-primary-700 lg:p-0 lg:dark:hover:text-primary-500 lg:dark:hover:bg-transparent" },
			xl: { link: "xl:hover:bg-transparent xl:border-0 xl:hover:text-primary-700 xl:p-0 xl:dark:hover:text-primary-500 xl:dark:hover:bg-transparent" },
			xxl: { link: "2xl:hover:bg-transparent 2xl:border-0 2xl:hover:text-primary-700 2xl:p-0 2xl:dark:hover:text-primary-500 2xl:dark:hover:bg-transparent" }
		}
	},
	compoundVariants: [
		{
			active: !0,
			breakPoint: "md",
			class: { link: "md:bg-transparent md:text-primary-700 md:p-0 md:dark:text-primary-500" }
		},
		{
			active: !0,
			breakPoint: "lg",
			class: { link: "lg:bg-transparent lg:text-primary-700 lg:p-0 lg:dark:text-primary-500" }
		},
		{
			active: !0,
			breakPoint: "xl",
			class: { link: "xl:bg-transparent xl:text-primary-700 xl:p-0 xl:dark:text-primary-500" }
		},
		{
			active: !0,
			breakPoint: "xxl",
			class: { link: "2xl:bg-transparent 2xl:text-primary-700 2xl:p-0 2xl:dark:text-primary-500" }
		}
	],
	defaultVariants: {
		breakPoint: "md",
		active: !1
	}
});
ce({
	base: "mx-auto flex flex-wrap justify-between items-center",
	variants: { fluid: {
		true: "w-full",
		false: "container"
	} }
});
const navhamburger = ce({
	base: "inline-flex h-10 w-10 items-center justify-center rounded-lg p-2 text-sm text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600",
	variants: { breakPoint: {
		md: "md:hidden",
		lg: "lg:hidden",
		xl: "xl:hidden",
		xxl: "2xl:hidden"
	} }
}), paginationItem = ce({
	base: "flex items-center font-medium",
	variants: {
		size: {
			default: "h-8 px-3 text-sm",
			large: "h-10 px-4 text-base"
		},
		active: {
			true: "text-blue-600 border border-gray-300 bg-blue-50 hover:bg-blue-100 hover:text-blue-700 dark:border-gray-700 dark:bg-gray-700 dark:text-white",
			false: "text-gray-500 bg-white hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white"
		},
		group: {
			true: "",
			false: "rounded-lg"
		},
		table: {
			true: "rounded",
			false: "border"
		}
	},
	compoundVariants: [{
		group: !1,
		table: !1,
		class: "rounded-lg"
	}],
	defaultVariants: {
		size: "default",
		active: !1,
		group: !1,
		table: !1
	}
}), pagination = ce({
	base: "inline-flex -space-x-px rtl:space-x-reverse items-center",
	variants: {
		table: {
			true: "divide-x rtl:divide-x-reverse dark divide-gray-700 dark:divide-gray-700",
			false: ""
		},
		size: {
			default: "",
			large: ""
		}
	},
	defaultVariants: {
		table: !1,
		size: "default"
	}
});
var root_1$90 = /* @__PURE__ */ from_html("<li><!></li>"), root_5$20 = /* @__PURE__ */ from_html("<li><!></li>"), root_7$13 = /* @__PURE__ */ from_html("<li><!></li>"), root$100 = /* @__PURE__ */ from_html("<nav><ul><!> <!> <!></ul></nav>");
function Pagination(C, E) {
	push(E, !0);
	let D = prop(E, "pages", 23, () => []), O = prop(E, "previous", 7), F = prop(E, "next", 7), I = prop(E, "prevContent", 7), L = prop(E, "nextContent", 7), z = prop(E, "table", 7), B = prop(E, "size", 7), V = prop(E, "ariaLabel", 7), U = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"pages",
		"previous",
		"next",
		"prevContent",
		"nextContent",
		"table",
		"size",
		"ariaLabel"
	]);
	setContext("group", !0), setContext("table", z()), setContext("size", B());
	let W = /* @__PURE__ */ user_derived(() => pagination({
		table: z(),
		size: B()
	}));
	var G = {
		get pages() {
			return D();
		},
		set pages(C = []) {
			D(C), flushSync();
		},
		get previous() {
			return O();
		},
		set previous(C) {
			O(C), flushSync();
		},
		get next() {
			return F();
		},
		set next(C) {
			F(C), flushSync();
		},
		get prevContent() {
			return I();
		},
		set prevContent(C) {
			I(C), flushSync();
		},
		get nextContent() {
			return L();
		},
		set nextContent(C) {
			L(C), flushSync();
		},
		get table() {
			return z();
		},
		set table(C) {
			z(C), flushSync();
		},
		get size() {
			return B();
		},
		set size(C) {
			B(C), flushSync();
		},
		get ariaLabel() {
			return V();
		},
		set ariaLabel(C) {
			V(C), flushSync();
		}
	}, K = root$100(), J = child(K), Y = child(J), X = (C) => {
		var E = root_1$90();
		attribute_effect(E, () => _objectSpread2({}, U));
		var D = child(E);
		{
			let C = /* @__PURE__ */ user_derived(() => z() ? "rounded-none rounded-l" : "rounded-none  rounded-s-lg");
			PaginationItem(D, {
				get size() {
					return B();
				},
				onclick: () => O()(),
				get class() {
					return get(C);
				},
				children: (C, T) => {
					var E = comment(), D = first_child(E), O = (C) => {
						var T = comment();
						snippet(first_child(T), I), append(C, T);
					}, F = (C) => {
						append(C, text("Previous"));
					};
					if_block(D, (C) => {
						I() ? C(O) : C(F, !1);
					}), append(C, E);
				},
				$$slots: { default: !0 }
			});
		}
		reset(E), append(C, E);
	};
	if_block(Y, (C) => {
		typeof O() == "function" && C(X);
	});
	var Z = sibling(Y, 2);
	each(Z, 17, D, index, (C, E, D, O) => {
		let F = () => get(E).name, I = () => get(E).href, L = () => get(E).active, z = () => get(E).size;
		var B = root_5$20();
		attribute_effect(B, () => _objectSpread2({}, U)), PaginationItem(child(B), {
			get size() {
				return z();
			},
			get active() {
				return L();
			},
			get href() {
				return I();
			},
			children: (C, T) => {
				next();
				var E = text();
				template_effect(() => set_text(E, F())), append(C, E);
			},
			$$slots: { default: !0 }
		}), reset(B), append(C, B);
	});
	var Q = sibling(Z, 2), NL = (C) => {
		var E = root_7$13();
		attribute_effect(E, () => _objectSpread2({}, U));
		var D = child(E);
		{
			let C = /* @__PURE__ */ user_derived(() => z() ? "rounded-none rounded-r" : "rounded-none rounded-e-lg");
			PaginationItem(D, {
				get size() {
					return B();
				},
				onclick: () => F()(),
				get class() {
					return get(C);
				},
				children: (C, T) => {
					var E = comment(), D = first_child(E), O = (C) => {
						var T = comment();
						snippet(first_child(T), L), append(C, T);
					}, F = (C) => {
						append(C, text("Next"));
					};
					if_block(D, (C) => {
						L() ? C(O) : C(F, !1);
					}), append(C, E);
				},
				$$slots: { default: !0 }
			});
		}
		reset(E), append(C, E);
	};
	return if_block(Q, (C) => {
		typeof F() == "function" && C(NL);
	}), reset(J), reset(K), template_effect(() => {
		set_attribute(K, "aria-label", V()), set_class(J, 1, clsx$1(get(W)));
	}), append(C, K), pop(G);
}
create_custom_element(Pagination, {
	pages: {},
	previous: {},
	next: {},
	prevContent: {},
	nextContent: {},
	table: {},
	size: {},
	ariaLabel: {}
}, [], [], !0);
var root_1$89 = /* @__PURE__ */ from_html("<a><!></a>"), root_3$40 = /* @__PURE__ */ from_html("<button><!></button>");
function PaginationItem(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "size", 7), F = prop(E, "class", 7), I = prop(E, "href", 7), L = prop(E, "active", 7), z = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"size",
		"class",
		"href",
		"active"
	]), B = getContext("group"), V = getContext("table"), U = /* @__PURE__ */ user_derived(() => paginationItem({
		size: O(),
		active: L(),
		group: B,
		table: V,
		className: F()
	}));
	var W = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get size() {
			return O();
		},
		set size(C) {
			O(C), flushSync();
		},
		get class() {
			return F();
		},
		set class(C) {
			F(C), flushSync();
		},
		get href() {
			return I();
		},
		set href(C) {
			I(C), flushSync();
		},
		get active() {
			return L();
		},
		set active(C) {
			L(C), flushSync();
		}
	}, G = comment(), K = first_child(G), J = (C) => {
		var E = root_1$89();
		attribute_effect(E, () => _objectSpread2(_objectSpread2({ href: I() }, z), {}, { class: get(U) }));
		var O = child(E), F = (C) => {
			var T = comment();
			snippet(first_child(T), D), append(C, T);
		};
		if_block(O, (C) => {
			D() && C(F);
		}), reset(E), append(C, E);
	}, Y = (C) => {
		var E = root_3$40();
		attribute_effect(E, () => _objectSpread2(_objectSpread2({}, z), {}, { class: get(U) }));
		var O = child(E), F = (C) => {
			var T = comment();
			snippet(first_child(T), D), append(C, T);
		};
		if_block(O, (C) => {
			D() && C(F);
		}), reset(E), append(C, E);
	};
	return if_block(K, (C) => {
		I() ? C(J) : C(Y, !1);
	}), append(C, G), pop(W);
}
create_custom_element(PaginationItem, {
	children: {},
	size: {},
	class: {},
	href: {},
	active: {}
}, [], [], !0);
var root_2$45 = /* @__PURE__ */ from_html("<div><h3> </h3></div>"), root_5$19 = /* @__PURE__ */ from_html("<div></div>"), root_1$88 = /* @__PURE__ */ from_html("<div><!> <!> <!></div>"), root_8$8 = /* @__PURE__ */ from_html("<div><h3> </h3></div>"), root_11$4 = /* @__PURE__ */ from_html("<div></div>"), root_7$12 = /* @__PURE__ */ from_html("<div><!> <!> <!></div>");
function Popover(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "titleSlot", 7), F = prop(E, "color", 7, "default"), I = prop(E, "arrow", 7, !0), L = prop(E, "offset", 7, 0), z = prop(E, "triggeredBy", 7), B = prop(E, "position", 7, "top"), V = prop(E, "class", 7), U = prop(E, "reference", 7), W = prop(E, "transition", 7, fade), G = prop(E, "params", 7), K = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"titleSlot",
		"color",
		"arrow",
		"offset",
		"triggeredBy",
		"position",
		"class",
		"reference",
		"transition",
		"params"
	]), J = /* @__PURE__ */ user_derived(() => popover({
		color: F(),
		arrow: I(),
		position: B()
	})), Y = /* @__PURE__ */ user_derived(() => get(J).base), X = /* @__PURE__ */ user_derived(() => get(J).title), Z = /* @__PURE__ */ user_derived(() => get(J).h3), Q = /* @__PURE__ */ user_derived(() => get(J).arrowBase), NL = {
		duration: 100,
		easing: linear
	}, PL = /* @__PURE__ */ state(null), FL = null, IL = null, LL = /* @__PURE__ */ state(null), RL = /* @__PURE__ */ state(!1), zL = /* @__PURE__ */ state(!1), BL, VL = () => {
		set(RL, !0), setTimeout(() => {
			KL(), set(zL, !0);
		}, 0);
	}, HL = () => {
		set(RL, !1), set(zL, !1);
	}, UL = () => {
		BL !== void 0 && (clearTimeout(BL), BL = void 0);
	}, WL = () => {
		HL();
	}, GL = () => {
		BL = setTimeout(HL, 100);
	}, KL = () => {
		if (!get(PL) || !FL) return;
		let C = FL.getBoundingClientRect(), T = U() && IL ? IL.getBoundingClientRect() : C, E = get(PL).getBoundingClientRect(), D = I() && get(LL) ? get(LL).getBoundingClientRect() : null, O = window.scrollX || document.documentElement.scrollLeft, F = window.scrollY || document.documentElement.scrollTop, z, V, W, G;
		switch (B()) {
			case "top":
				z = T.top + F - E.height - 10 - L(), V = T.left + O + T.width / 2 - E.width / 2, D && L() === 0 && (W = E.height - 5, G = E.width / 2 - D.width / 2);
				break;
			case "top-start":
				z = T.top + F - E.height - 10 - L(), V = T.left + O, D && L() === 0 && (W = E.height - 5, G = T.width / 2 - D.width / 2);
				break;
			case "top-end":
				z = T.top + F - E.height - 10 - L(), V = T.right + O - E.width, D && L() === 0 && (W = E.height - 5, G = E.width - T.width / 2 - D.width / 2);
				break;
			case "bottom":
				z = T.bottom + F + 10 + L(), V = T.left + O + T.width / 2 - E.width / 2, D && L() === 0 && (W = -D.height + 9, G = E.width / 2 - D.width / 2);
				break;
			case "bottom-start":
				z = T.bottom + F + 10 + L(), V = T.left + O, D && L() === 0 && (W = -D.height + 9, G = T.width / 2 - D.width / 2);
				break;
			case "bottom-end":
				z = T.bottom + F + 10 + L(), V = T.right + O - E.width, D && L() === 0 && (W = -D.height + 9, G = E.width - T.width / 2 - D.width / 2);
				break;
			case "left":
				z = T.top + F + T.height / 2 - E.height / 2, V = T.left + O - E.width - 10 - L(), D && L() === 0 && (W = E.height / 2 - D.height / 2, G = E.width - 5);
				break;
			case "left-start":
				z = T.top + F, V = T.left + O - E.width - 10 - L(), D && L() === 0 && (W = D.height, G = E.width - 5);
				break;
			case "left-end":
				z = T.bottom + F - E.height, V = T.left + O - E.width - 10 - L(), D && L() === 0 && (W = E.height - D.height * 2, G = E.width - 5);
				break;
			case "right":
				z = T.top + F + T.height / 2 - E.height / 2, V = T.right + O + 10 + L(), D && L() === 0 && (W = E.height / 2 - D.height / 2, G = -D.width / 2 + 2);
				break;
			case "right-start":
				z = T.top + F, V = T.right + O + 10 + L(), D && L() === 0 && (W = D.height, G = -D.width / 2 + 2);
				break;
			case "right-end":
				z = T.bottom + F - E.height, V = T.right + O + 10 + L(), D && L() === 0 && (W = E.height - D.height * 2, G = -D.width / 2 + 2);
				break;
		}
		get(PL).style.top = `${z}px`, get(PL).style.left = `${V}px`, get(LL) && D && (get(LL).style.top = `${W}px`, get(LL).style.left = `${G}px`);
	};
	user_effect(() => {
		FL = document.querySelector(z()), IL = U() ? document.querySelector(U()) : FL, FL && (FL.addEventListener("mouseenter", VL), FL.addEventListener("mouseleave", GL));
		let C = () => {
			get(RL) && KL();
		};
		window.addEventListener("resize", C), window.addEventListener("scroll", C, !0), onDestroy(() => {
			FL && (FL.removeEventListener("mouseenter", VL), FL.removeEventListener("mouseleave", GL)), window.removeEventListener("resize", C), window.removeEventListener("scroll", C, !0), BL !== void 0 && clearTimeout(BL);
		});
	});
	var qL = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get titleSlot() {
			return O();
		},
		set titleSlot(C) {
			O(C), flushSync();
		},
		get color() {
			return F();
		},
		set color(C = "default") {
			F(C), flushSync();
		},
		get arrow() {
			return I();
		},
		set arrow(C = !0) {
			I(C), flushSync();
		},
		get offset() {
			return L();
		},
		set offset(C = 0) {
			L(C), flushSync();
		},
		get triggeredBy() {
			return z();
		},
		set triggeredBy(C) {
			z(C), flushSync();
		},
		get position() {
			return B();
		},
		set position(C = "top") {
			B(C), flushSync();
		},
		get class() {
			return V();
		},
		set class(C) {
			V(C), flushSync();
		},
		get reference() {
			return U();
		},
		set reference(C) {
			U(C), flushSync();
		},
		get transition() {
			return W();
		},
		set transition(C = fade) {
			W(C), flushSync();
		},
		get params() {
			return G();
		},
		set params(C) {
			G(C), flushSync();
		}
	}, JL = comment(), YL = first_child(JL), XL = (C) => {
		var E = root_1$88();
		attribute_effect(E, (C) => _objectSpread2(_objectSpread2({ role: "tooltip" }, K), {}, {
			class: C,
			onmouseenter: UL,
			onmouseleave: WL
		}), [() => `${get(Y)({ className: V() })} ${get(zL) ? "visible opacity-100" : "invisible opacity-0"} transition-opacity duration-200`]);
		var F = child(E), L = (C) => {
			var T = root_2$45(), E = child(T), D = child(E, !0);
			reset(E), reset(T), template_effect((C, F) => {
				set_class(T, 1, C), set_class(E, 1, F), set_text(D, O());
			}, [() => clsx$1(get(X)()), () => clsx$1(get(Z)())]), append(C, T);
		}, z = (C) => {
			var T = comment(), E = first_child(T), D = (C) => {
				var T = comment();
				snippet(first_child(T), O), append(C, T);
			};
			if_block(E, (C) => {
				O() && C(D);
			}, !0), append(C, T);
		};
		if_block(F, (C) => {
			typeof O() == "string" ? C(L) : C(z, !1);
		});
		var U = sibling(F, 2);
		snippet(U, D);
		var J = sibling(U, 2), FL = (C) => {
			var T = root_5$19();
			bind_this(T, (C) => set(LL, C), () => get(LL)), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(Q)({
				arrow: I(),
				position: B()
			}))]), append(C, T);
		};
		if_block(J, (C) => {
			I() && C(FL);
		}), reset(E), bind_this(E, (C) => set(PL, C), () => get(PL)), transition(3, E, W, () => G() || NL), append(C, E);
	}, ZL = (C) => {
		var E = comment(), F = first_child(E), L = (C) => {
			var E = root_7$12();
			attribute_effect(E, (C) => _objectSpread2(_objectSpread2({ role: "tooltip" }, K), {}, {
				class: C,
				onmouseenter: UL,
				onmouseleave: WL
			}), [() => `${get(Y)({ className: V() })} ${get(zL) ? "visible opacity-100" : "invisible opacity-0"} transition-opacity duration-200`]);
			var F = child(E), L = (C) => {
				var T = root_8$8(), E = child(T), D = child(E, !0);
				reset(E), reset(T), template_effect((C, F) => {
					set_class(T, 1, C), set_class(E, 1, F), set_text(D, O());
				}, [() => clsx$1(get(X)()), () => clsx$1(get(Z)())]), append(C, T);
			}, z = (C) => {
				var T = comment(), E = first_child(T), D = (C) => {
					var T = comment();
					snippet(first_child(T), O), append(C, T);
				};
				if_block(E, (C) => {
					O() && C(D);
				}, !0), append(C, T);
			};
			if_block(F, (C) => {
				typeof O() == "string" ? C(L) : C(z, !1);
			});
			var U = sibling(F, 2);
			snippet(U, D);
			var W = sibling(U, 2), G = (C) => {
				var T = root_11$4();
				bind_this(T, (C) => set(LL, C), () => get(LL)), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(Q)({
					arrow: I(),
					position: B()
				}))]), append(C, T);
			};
			if_block(W, (C) => {
				I() && C(G);
			}), reset(E), bind_this(E, (C) => set(PL, C), () => get(PL)), append(C, E);
		};
		if_block(F, (C) => {
			get(RL) && C(L);
		}, !0), append(C, E);
	};
	return if_block(YL, (C) => {
		W() && get(RL) ? C(XL) : C(ZL, !1);
	}), append(C, JL), pop(qL);
}
create_custom_element(Popover, {
	children: {},
	titleSlot: {},
	color: {},
	arrow: {},
	offset: {},
	triggeredBy: {},
	position: {},
	class: {},
	reference: {},
	transition: {},
	params: {}
}, [], [], !0);
const popover = ce({
	slots: {
		base: "popover absolute rounded-lg shadow-md",
		title: "py-2 px-3 rounded-t-md border-b ",
		h3: "font-semibold",
		arrowBase: "absolute pointer-events-none block w-[10px] h-[10px] rotate-45 bg-inherit border-inherit shadow-md"
	},
	variants: {
		color: {
			default: {
				base: "bg-white dark:bg-gray-800 text-gray-500 dark:text-gray-400 border border-gray-200 dark:border-gray-700 divide-gray-200 dark:divide-gray-700",
				title: "bg-gray-100 border-gray-200 dark:border-gray-600 dark:bg-gray-700",
				h3: "text-gray-900 dark:text-white"
			},
			primary: {
				base: "bg-primary-600 text-white",
				title: "bg-primary-700",
				h3: "text-white"
			},
			secondary: {
				base: "bg-secondary-600 text-white",
				title: "bg-secondary-700",
				h3: "text-white"
			},
			gray: {
				base: "bg-gray-600 text-white",
				title: "bg-gray-700",
				h3: "text-white"
			},
			red: {
				base: "bg-red-600 text-white",
				title: "bg-red-700",
				h3: "text-white"
			},
			orange: {
				base: "bg-orange-600 text-white",
				title: "bg-orange-700",
				h3: "text-white"
			},
			amber: {
				base: "bg-amber-600 text-white",
				title: "bg-amber-700",
				h3: "text-white"
			},
			yellow: {
				base: "bg-yellow-400 text-white",
				title: "bg-yellow-500",
				h3: "text-white"
			},
			lime: {
				base: "bg-lime-600 text-white",
				title: "bg-lime-700",
				h3: "text-white"
			},
			green: {
				base: "bg-green-600 text-white",
				title: "bg-green-700",
				h3: "text-white"
			},
			emerald: {
				base: "bg-emerald-600 text-white",
				title: "bg-emerald-700",
				h3: "text-white"
			},
			teal: {
				base: "bg-teal-600 text-white",
				title: "bg-teal-700",
				h3: "text-white"
			},
			cyan: {
				base: "bg-cyan-600 text-white",
				title: "bg-cyan-700",
				h3: "text-white"
			},
			sky: {
				base: "bg-sky-600 text-white",
				title: "bg-sky-700 text-white",
				h3: "text-white"
			},
			blue: {
				base: "bg-blue-600 text-white",
				title: "bg-blue-700 text-white",
				h3: "text-white"
			},
			indigo: {
				base: "bg-indigo-600 text-white",
				title: "bg-indigo-700",
				h3: "text-white"
			},
			violet: {
				base: "bg-violet-600 text-white",
				title: "bg-violet-700",
				h3: "text-white"
			},
			purple: {
				base: "bg-purple-600 text-white",
				title: "bg-purple-700",
				h3: "text-white"
			},
			fuchsia: {
				base: "bg-fuchsia-600 text-white",
				title: "bg-fuchsia-700",
				h3: "text-white"
			},
			pink: {
				base: "bg-pink-600 text-white",
				title: "bg-pink-700",
				h3: "text-white"
			},
			rose: {
				base: "bg-rose-800 text-white",
				title: "bg-rose-700",
				h3: "text-white"
			}
		},
		arrow: {
			true: "",
			false: ""
		},
		position: {
			top: "",
			bottom: "",
			left: "",
			right: "",
			"right-start": "",
			"right-end": "",
			"left-start": "",
			"left-end": "",
			"top-start": "",
			"top-end": "",
			"bottom-start": "",
			"bottom-end": ""
		}
	},
	compoundVariants: [
		{
			arrow: !0,
			position: "bottom",
			color: "default",
			class: { arrowBase: "bg-gray-100 dark:bg-gray-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom",
			color: "primary",
			class: { arrowBase: "bg-primary-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom",
			color: "secondary",
			class: { arrowBase: "bg-secondary-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom",
			color: "gray",
			class: { arrowBase: "bg-gray-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom",
			color: "red",
			class: { arrowBase: "bg-red-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom",
			color: "orange",
			class: { arrowBase: "bg-orange-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom",
			color: "amber",
			class: { arrowBase: "bg-amber-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom",
			color: "yellow",
			class: { arrowBase: "bg-yellow-500 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom",
			color: "lime",
			class: { arrowBase: "bg-lime-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom",
			color: "green",
			class: { arrowBase: "bg-green-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom",
			color: "emerald",
			class: { arrowBase: "bg-emerald-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom",
			color: "teal",
			class: { arrowBase: "bg-teal-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom",
			color: "cyan",
			class: { arrowBase: "bg-cyan-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom",
			color: "sky",
			class: { arrowBase: "bg-sky-700   " }
		},
		{
			arrow: !0,
			position: "bottom",
			color: "blue",
			class: { arrowBase: "bg-blue-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom",
			color: "indigo",
			class: { arrowBase: "bg-indigo-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom",
			color: "violet",
			class: { arrowBase: "bg-violet-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom",
			color: "purple",
			class: { arrowBase: "bg-purple-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom",
			color: "fuchsia",
			class: { arrowBase: "bg-fuchsia-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom",
			color: "pink",
			class: { arrowBase: "bg-pink-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom",
			color: "rose",
			class: { arrowBase: "bg-rose-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "default",
			class: { arrowBase: "bg-gray-100 dark:bg-gray-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "primary",
			class: { arrowBase: "bg-primary-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "secondary",
			class: { arrowBase: "bg-secondary-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "gray",
			class: { arrowBase: "bg-gray-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "red",
			class: { arrowBase: "bg-red-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "orange",
			class: { arrowBase: "bg-orange-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "amber",
			class: { arrowBase: "bg-amber-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "yellow",
			class: { arrowBase: "bg-yellow-500 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "lime",
			class: { arrowBase: "bg-lime-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "green",
			class: { arrowBase: "bg-green-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "emerald",
			class: { arrowBase: "bg-emerald-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "teal",
			class: { arrowBase: "bg-teal-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "cyan",
			class: { arrowBase: "bg-cyan-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "sky",
			class: { arrowBase: "bg-sky-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "blue",
			class: { arrowBase: "bg-blue-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "indigo",
			class: { arrowBase: "bg-indigo-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "violet",
			class: { arrowBase: "bg-violet-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "purple",
			class: { arrowBase: "bg-purple-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "fuchsia",
			class: { arrowBase: "bg-fuchsia-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "pink",
			class: { arrowBase: "bg-pink-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "right-start",
			color: "rose",
			class: { arrowBase: "bg-rose-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "default",
			class: { arrowBase: "bg-gray-100 dark:bg-gray-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "primary",
			class: { arrowBase: "bg-primary-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "secondary",
			class: { arrowBase: "bg-secondary-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "gray",
			class: { arrowBase: "bg-gray-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "red",
			class: { arrowBase: "bg-red-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "orange",
			class: { arrowBase: "bg-orange-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "amber",
			class: { arrowBase: "bg-amber-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "yellow",
			class: { arrowBase: "bg-yellow-500 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "lime",
			class: { arrowBase: "bg-lime-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "green",
			class: { arrowBase: "bg-green-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "emerald",
			class: { arrowBase: "bg-emerald-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "teal",
			class: { arrowBase: "bg-teal-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "cyan",
			class: { arrowBase: "bg-cyan-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "sky",
			class: { arrowBase: "bg-sky-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "blue",
			class: { arrowBase: "bg-blue-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "indigo",
			class: { arrowBase: "bg-indigo-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "violet",
			class: { arrowBase: "bg-violet-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "purple",
			class: { arrowBase: "bg-purple-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "fuchsia",
			class: { arrowBase: "bg-fuchsia-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "pink",
			class: { arrowBase: "bg-pink-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-start",
			color: "rose",
			class: { arrowBase: "bg-rose-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "left",
			color: "default",
			class: { arrowBase: "bg-white border-t border-r dark:bg-gray-800 shadow-none" }
		},
		{
			arrow: !0,
			position: "left-end",
			color: "default",
			class: { arrowBase: "bg-white border-t border-r dark:bg-gray-800 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "default",
			class: { arrowBase: "bg-gray-100 dark:bg-gray-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "primary",
			class: { arrowBase: "bg-primary-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "secondary",
			class: { arrowBase: "bg-secondary-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "gray",
			class: { arrowBase: "bg-gray-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "red",
			class: { arrowBase: "bg-red-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "orange",
			class: { arrowBase: "bg-orange-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "amber",
			class: { arrowBase: "bg-amber-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "yellow",
			class: { arrowBase: "bg-yellow-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "lime",
			class: { arrowBase: "bg-lime-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "green",
			class: { arrowBase: "bg-green-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "emerald",
			class: { arrowBase: "bg-emerald-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "teal",
			class: { arrowBase: "bg-teal-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "cyan",
			class: { arrowBase: "bg-cyan-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "sky",
			class: { arrowBase: "bg-sky-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "blue",
			class: { arrowBase: "bg-blue-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "indigo",
			class: { arrowBase: "bg-indigo-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "violet",
			class: { arrowBase: "bg-violet-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "purple",
			class: { arrowBase: "bg-purple-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "fuchsia",
			class: { arrowBase: "bg-fuchsia-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "pink",
			class: { arrowBase: "bg-pink-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-start",
			color: "rose",
			class: { arrowBase: "bg-rose-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "default",
			class: { arrowBase: "bg-gray-100 dark:bg-gray-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "primary",
			class: { arrowBase: "bg-primary-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "secondary",
			class: { arrowBase: "bg-secondary-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "gray",
			class: { arrowBase: "bg-gray-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "red",
			class: { arrowBase: "bg-red-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "orange",
			class: { arrowBase: "bg-orange-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "amber",
			class: { arrowBase: "bg-amber-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "yellow",
			class: { arrowBase: "bg-yellow-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "lime",
			class: { arrowBase: "bg-lime-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "green",
			class: { arrowBase: "bg-green-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "emerald",
			class: { arrowBase: "bg-emerald-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "teal",
			class: { arrowBase: "bg-teal-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "cyan",
			class: { arrowBase: "bg-cyan-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "sky",
			class: { arrowBase: "bg-sky-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "blue",
			class: { arrowBase: "bg-blue-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "indigo",
			class: { arrowBase: "bg-indigo-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "violet",
			class: { arrowBase: "bg-violet-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "purple",
			class: { arrowBase: "bg-purple-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "fuchsia",
			class: { arrowBase: "bg-fuchsia-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "pink",
			class: { arrowBase: "bg-pink-700 shadow-none" }
		},
		{
			arrow: !0,
			position: "bottom-end",
			color: "rose",
			class: { arrowBase: "bg-rose-700 shadow-none" }
		}
	]
});
var _SvelteDate, inited$1 = !1, _time = /* @__PURE__ */ new WeakMap(), _deriveds = /* @__PURE__ */ new WeakMap(), _reaction = /* @__PURE__ */ new WeakMap(), _SvelteDate_brand = /* @__PURE__ */ new WeakSet();
_SvelteDate = class extends Date {
	constructor(...C) {
		super(...C), _classPrivateMethodInitSpec(this, _SvelteDate_brand), _classPrivateFieldInitSpec(this, _time, /* @__PURE__ */ state(super.getTime())), _classPrivateFieldInitSpec(this, _deriveds, /* @__PURE__ */ new Map()), _classPrivateFieldInitSpec(this, _reaction, active_reaction), inited$1 || _assertClassBrand(_SvelteDate_brand, this, _init$1).call(this);
	}
};
function _init$1() {
	inited$1 = !0;
	var C = _SvelteDate.prototype, T = Date.prototype, E = Object.getOwnPropertyNames(T);
	for (let D of E) (D.startsWith("get") || D.startsWith("to") || D === "valueOf") && (C[D] = function(...C) {
		if (C.length > 0) return get(_classPrivateFieldGet2(_time, this)), T[D].apply(this, C);
		var E = _classPrivateFieldGet2(_deriveds, this).get(D);
		if (E === void 0) {
			let O = active_reaction;
			set_active_reaction(_classPrivateFieldGet2(_reaction, this)), E = /* @__PURE__ */ user_derived(() => (get(_classPrivateFieldGet2(_time, this)), T[D].apply(this, C))), _classPrivateFieldGet2(_deriveds, this).set(D, E), set_active_reaction(O);
		}
		return get(E);
	}), D.startsWith("set") && (C[D] = function(...C) {
		var E = T[D].apply(this, C);
		return set(_classPrivateFieldGet2(_time, this), T.getTime.call(this)), E;
	});
}
var _SvelteSet, _Symbol$iterator$2, read_methods = [
	"forEach",
	"isDisjointFrom",
	"isSubsetOf",
	"isSupersetOf"
], set_like_methods = [
	"difference",
	"intersection",
	"symmetricDifference",
	"union"
], inited = !1, _sources$1 = /* @__PURE__ */ new WeakMap(), _version$2 = /* @__PURE__ */ new WeakMap(), _size$1 = /* @__PURE__ */ new WeakMap(), _update_version$1 = /* @__PURE__ */ new WeakMap(), _SvelteSet_brand = /* @__PURE__ */ new WeakSet();
_Symbol$iterator$2 = Symbol.iterator, _SvelteSet = class extends Set {
	constructor(C) {
		if (super(), _classPrivateMethodInitSpec(this, _SvelteSet_brand), _classPrivateFieldInitSpec(this, _sources$1, /* @__PURE__ */ new Map()), _classPrivateFieldInitSpec(this, _version$2, /* @__PURE__ */ state(0)), _classPrivateFieldInitSpec(this, _size$1, /* @__PURE__ */ state(0)), _classPrivateFieldInitSpec(this, _update_version$1, update_version || -1), C) {
			for (var T of C) super.add(T);
			_classPrivateFieldGet2(_size$1, this).v = super.size;
		}
		inited || _assertClassBrand(_SvelteSet_brand, this, _init).call(this);
	}
	has(C) {
		var T = super.has(C), E = _classPrivateFieldGet2(_sources$1, this), D = E.get(C);
		if (D === void 0) {
			if (!T) return get(_classPrivateFieldGet2(_version$2, this)), !1;
			D = _assertClassBrand(_SvelteSet_brand, this, _source$1).call(this, !0), E.set(C, D);
		}
		return get(D), T;
	}
	add(C) {
		return super.has(C) || (super.add(C), set(_classPrivateFieldGet2(_size$1, this), super.size), increment(_classPrivateFieldGet2(_version$2, this))), this;
	}
	delete(C) {
		var T = super.delete(C), E = _classPrivateFieldGet2(_sources$1, this), D = E.get(C);
		return D !== void 0 && (E.delete(C), set(D, !1)), T && (set(_classPrivateFieldGet2(_size$1, this), super.size), increment(_classPrivateFieldGet2(_version$2, this))), T;
	}
	clear() {
		if (super.size !== 0) {
			super.clear();
			var C = _classPrivateFieldGet2(_sources$1, this);
			for (var T of C.values()) set(T, !1);
			C.clear(), set(_classPrivateFieldGet2(_size$1, this), 0), increment(_classPrivateFieldGet2(_version$2, this));
		}
	}
	keys() {
		return this.values();
	}
	values() {
		return get(_classPrivateFieldGet2(_version$2, this)), super.values();
	}
	entries() {
		return get(_classPrivateFieldGet2(_version$2, this)), super.entries();
	}
	[_Symbol$iterator$2]() {
		return this.keys();
	}
	get size() {
		return get(_classPrivateFieldGet2(_size$1, this));
	}
};
function _source$1(C) {
	return update_version === _classPrivateFieldGet2(_update_version$1, this) ? /* @__PURE__ */ state(C) : source(C);
}
function _init() {
	inited = !0;
	var C = _SvelteSet.prototype, T = Set.prototype;
	for (let E of read_methods) C[E] = function(...C) {
		return get(_classPrivateFieldGet2(_version$2, this)), T[E].apply(this, C);
	};
	for (let E of set_like_methods) C[E] = function(...C) {
		get(_classPrivateFieldGet2(_version$2, this));
		var D = T[E].apply(this, C);
		return new _SvelteSet(D);
	};
}
function _getPrototypeOf(C) {
	return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(C) {
		return C.__proto__ || Object.getPrototypeOf(C);
	}, _getPrototypeOf(C);
}
function _superPropBase(C, T) {
	for (; !{}.hasOwnProperty.call(C, T) && (C = _getPrototypeOf(C)) !== null;);
	return C;
}
function _get() {
	return _get = typeof Reflect < "u" && Reflect.get ? Reflect.get.bind() : function(C, T, E) {
		var D = _superPropBase(C, T);
		if (D) {
			var O = Object.getOwnPropertyDescriptor(D, T);
			return O.get ? O.get.call(arguments.length < 3 ? C : E) : O.value;
		}
	}, _get.apply(null, arguments);
}
function _superPropGet(C, T, E, D) {
	var O = _get(_getPrototypeOf(1 & D ? C.prototype : C), T, E);
	return 2 & D && typeof O == "function" ? function(C) {
		return O.apply(E, C);
	} : O;
}
var _SvelteMap, _Symbol$iterator$1, _sources = /* @__PURE__ */ new WeakMap(), _version$1 = /* @__PURE__ */ new WeakMap(), _size = /* @__PURE__ */ new WeakMap(), _update_version = /* @__PURE__ */ new WeakMap(), _SvelteMap_brand = /* @__PURE__ */ new WeakSet();
_Symbol$iterator$1 = Symbol.iterator, _SvelteMap = class extends Map {
	constructor(C) {
		if (super(), _classPrivateMethodInitSpec(this, _SvelteMap_brand), _classPrivateFieldInitSpec(this, _sources, /* @__PURE__ */ new Map()), _classPrivateFieldInitSpec(this, _version$1, /* @__PURE__ */ state(0)), _classPrivateFieldInitSpec(this, _size, /* @__PURE__ */ state(0)), _classPrivateFieldInitSpec(this, _update_version, update_version || -1), C) {
			for (var [T, E] of C) super.set(T, E);
			_classPrivateFieldGet2(_size, this).v = super.size;
		}
	}
	has(C) {
		var T = _classPrivateFieldGet2(_sources, this), E = T.get(C);
		if (E === void 0) if (super.get(C) !== void 0) E = _assertClassBrand(_SvelteMap_brand, this, _source).call(this, 0), T.set(C, E);
		else return get(_classPrivateFieldGet2(_version$1, this)), !1;
		return get(E), !0;
	}
	forEach(C, T) {
		_assertClassBrand(_SvelteMap_brand, this, _read_all).call(this), super.forEach(C, T);
	}
	get(C) {
		var T = _classPrivateFieldGet2(_sources, this), E = T.get(C);
		if (E === void 0) if (super.get(C) !== void 0) E = _assertClassBrand(_SvelteMap_brand, this, _source).call(this, 0), T.set(C, E);
		else {
			get(_classPrivateFieldGet2(_version$1, this));
			return;
		}
		return get(E), super.get(C);
	}
	set(C, T) {
		var E = _classPrivateFieldGet2(_sources, this), D = E.get(C), O = super.get(C), F = super.set(C, T), I = _classPrivateFieldGet2(_version$1, this);
		if (D === void 0) D = _assertClassBrand(_SvelteMap_brand, this, _source).call(this, 0), E.set(C, D), set(_classPrivateFieldGet2(_size, this), super.size), increment(I);
		else if (O !== T) {
			var L;
			increment(D);
			var z = I.reactions === null ? null : new Set(I.reactions);
			(z === null || !((L = D.reactions) != null && L.every((C) => z.has(C)))) && increment(I);
		}
		return F;
	}
	delete(C) {
		var T = _classPrivateFieldGet2(_sources, this), E = T.get(C), D = super.delete(C);
		return E !== void 0 && (T.delete(C), set(_classPrivateFieldGet2(_size, this), super.size), set(E, -1), increment(_classPrivateFieldGet2(_version$1, this))), D;
	}
	clear() {
		if (super.size !== 0) {
			super.clear();
			var C = _classPrivateFieldGet2(_sources, this);
			set(_classPrivateFieldGet2(_size, this), 0);
			for (var T of C.values()) set(T, -1);
			increment(_classPrivateFieldGet2(_version$1, this)), C.clear();
		}
	}
	keys() {
		return get(_classPrivateFieldGet2(_version$1, this)), super.keys();
	}
	values() {
		return _assertClassBrand(_SvelteMap_brand, this, _read_all).call(this), super.values();
	}
	entries() {
		return _assertClassBrand(_SvelteMap_brand, this, _read_all).call(this), super.entries();
	}
	[_Symbol$iterator$1]() {
		return this.entries();
	}
	get size() {
		return get(_classPrivateFieldGet2(_size, this)), super.size;
	}
};
function _source(C) {
	return update_version === _classPrivateFieldGet2(_update_version, this) ? /* @__PURE__ */ state(C) : source(C);
}
function _read_all() {
	get(_classPrivateFieldGet2(_version$1, this));
	var C = _classPrivateFieldGet2(_sources, this);
	if (_classPrivateFieldGet2(_size, this).v !== C.size) {
		for (var T of _superPropGet(_SvelteMap.prototype, "keys", this, 2)([])) if (!C.has(T)) {
			var E = _assertClassBrand(_SvelteMap_brand, this, _source).call(this, 0);
			C.set(T, E);
		}
	}
	for ([, E] of _classPrivateFieldGet2(_sources, this)) get(E);
}
Symbol.iterator, URLSearchParams;
function is_date(C) {
	return Object.prototype.toString.call(C) === "[object Date]";
}
function get_interpolator(C, T) {
	if (C === T || C !== C) return () => C;
	let E = typeof C;
	if (E !== typeof T || Array.isArray(C) !== Array.isArray(T)) throw Error("Cannot interpolate values of different type");
	if (Array.isArray(C)) {
		let E = T.map((T, E) => get_interpolator(C[E], T));
		return (C) => E.map((T) => T(C));
	}
	if (E === "object") {
		if (!C || !T) throw Error("Object cannot be null");
		if (is_date(C) && is_date(T)) {
			let E = C.getTime(), D = T.getTime() - E;
			return (C) => new Date(E + C * D);
		}
		let E = Object.keys(T), D = {};
		return E.forEach((E) => {
			D[E] = get_interpolator(C[E], T[E]);
		}), (C) => {
			let T = {};
			return E.forEach((E) => {
				T[E] = D[E](C);
			}), T;
		};
	}
	if (E === "number") {
		let E = T - C;
		return (T) => C + T * E;
	}
	return () => T;
}
function tweened(C, E = {}) {
	let D = writable(C), O, F = C;
	function I(I, L) {
		if (F = I, C == null) return D.set(C = I), Promise.resolve();
		let z = O, B = !1, { delay: V = 0, duration: U = 400, easing: W = linear, interpolate: G = get_interpolator } = _objectSpread2(_objectSpread2({}, E), L);
		if (U === 0) return z && (z.abort(), z = null), D.set(C = F), Promise.resolve();
		let K = raf.now() + V, J;
		return O = loop((T) => {
			if (T < K) return !0;
			B || (J = G(C, I), typeof U == "function" && (U = U(C, I)), B = !0), z && (z.abort(), z = null);
			let E = T - K;
			return E > U ? (D.set(C = I), !1) : (D.set(C = J(W(E / U))), !0);
		}), O.promise;
	}
	return {
		set: I,
		update: (T, E) => I(T(F, C), E),
		subscribe: D.subscribe
	};
}
var root_1$87 = /* @__PURE__ */ from_html("<div><span> </span> <span> </span></div>"), root_2$44 = /* @__PURE__ */ from_html("<div> </div>"), root_3$39 = /* @__PURE__ */ from_html("<div></div>"), root$99 = /* @__PURE__ */ from_html("<!> <div><!></div>", 1);
function Progressbar(C, E) {
	push(E, !0);
	let D = () => store_get(PL, "$_progress", O), [O, F] = setup_stores(), I = prop(E, "progress", 7, "45"), L = prop(E, "precision", 7, 0), z = prop(E, "tweenDuration", 7, 400), B = prop(E, "animate", 7, !1), V = prop(E, "size", 7, "h-2.5"), U = prop(E, "labelInside", 7, !1), W = prop(E, "labelOutside", 7, ""), G = prop(E, "easing", 7, cubicOut), K = prop(E, "color", 7, "primary"), J = prop(E, "div2Class", 7), Y = prop(E, "oustsideSpanClass", 7), X = prop(E, "oustsideProgressClass", 7), Z = prop(E, "labeloutsidedivClass", 7), Q = prop(E, "divClass", 7), NL = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"progress",
		"precision",
		"tweenDuration",
		"animate",
		"size",
		"labelInside",
		"labelOutside",
		"easing",
		"color",
		"div2Class",
		"oustsideSpanClass",
		"oustsideProgressClass",
		"labeloutsidedivClass",
		"divClass"
	]), PL = tweened(0, {
		duration: B() ? z() : 0,
		easing: G()
	}), FL = /* @__PURE__ */ user_derived(() => progressbar({
		color: K(),
		labelInside: U()
	})), IL = /* @__PURE__ */ user_derived(() => get(FL).base), LL = /* @__PURE__ */ user_derived(() => get(FL).labelInsideDiv), RL = /* @__PURE__ */ user_derived(() => get(FL).insideDiv), zL = /* @__PURE__ */ user_derived(() => get(FL).outsideDiv), BL = /* @__PURE__ */ user_derived(() => get(FL).oustsideSpan), VL = /* @__PURE__ */ user_derived(() => get(FL).outsideProgress);
	user_effect(() => {
		PL.set(Number(I()));
	});
	var HL = {
		get progress() {
			return I();
		},
		set progress(C = "45") {
			I(C), flushSync();
		},
		get precision() {
			return L();
		},
		set precision(C = 0) {
			L(C), flushSync();
		},
		get tweenDuration() {
			return z();
		},
		set tweenDuration(C = 400) {
			z(C), flushSync();
		},
		get animate() {
			return B();
		},
		set animate(C = !1) {
			B(C), flushSync();
		},
		get size() {
			return V();
		},
		set size(C = "h-2.5") {
			V(C), flushSync();
		},
		get labelInside() {
			return U();
		},
		set labelInside(C = !1) {
			U(C), flushSync();
		},
		get labelOutside() {
			return W();
		},
		set labelOutside(C = "") {
			W(C), flushSync();
		},
		get easing() {
			return G();
		},
		set easing(C = cubicOut) {
			G(C), flushSync();
		},
		get color() {
			return K();
		},
		set color(C = "primary") {
			K(C), flushSync();
		},
		get div2Class() {
			return J();
		},
		set div2Class(C) {
			J(C), flushSync();
		},
		get oustsideSpanClass() {
			return Y();
		},
		set oustsideSpanClass(C) {
			Y(C), flushSync();
		},
		get oustsideProgressClass() {
			return X();
		},
		set oustsideProgressClass(C) {
			X(C), flushSync();
		},
		get labeloutsidedivClass() {
			return Z();
		},
		set labeloutsidedivClass(C) {
			Z(C), flushSync();
		},
		get divClass() {
			return Q();
		},
		set divClass(C) {
			Q(C), flushSync();
		}
	}, UL = root$99(), WL = first_child(UL), GL = (C) => {
		var E = root_1$87();
		attribute_effect(E, (C) => _objectSpread2(_objectSpread2({}, NL), {}, { class: C }), [() => get(zL)({ class: Z() })]);
		var D = child(E), O = child(D, !0);
		reset(D);
		var F = sibling(D, 2), L = child(F);
		reset(F), reset(E), template_effect((C, T) => {
			var E;
			set_class(D, 1, C), set_text(O, W()), set_class(F, 1, T), set_text(L, `${(E = I()) == null ? "" : E}%`);
		}, [() => clsx$1(get(BL)({ class: Y() })), () => clsx$1(get(VL)({ class: X() }))]), append(C, E);
	};
	if_block(WL, (C) => {
		W() && C(GL);
	});
	var KL = sibling(WL, 2);
	attribute_effect(KL, (C) => _objectSpread2(_objectSpread2({}, NL), {}, { class: C }), [() => twMerge(get(IL)({ class: Q() }), V())]);
	var qL = child(KL), JL = (C) => {
		var T = root_2$44(), E = child(T);
		reset(T), template_effect((C, O) => {
			var F;
			set_class(T, 1, C), set_style(T, `width: ${(F = D()) == null ? "" : F}%`), set_text(E, `${O == null ? "" : O}%`);
		}, [() => clsx$1(twMerge(get(LL)({ class: J() }), V())), () => D().toFixed(L())]), append(C, T);
	}, YL = (C) => {
		var T = root_3$39();
		template_effect((C) => {
			var E;
			set_class(T, 1, C), set_style(T, `width: ${(E = D()) == null ? "" : E}%`);
		}, [() => clsx$1(twMerge(get(RL)({ class: J() }), V()))]), append(C, T);
	};
	if_block(qL, (C) => {
		U() ? C(JL) : C(YL, !1);
	}), reset(KL), append(C, UL);
	var XL = pop(HL);
	return F(), XL;
}
create_custom_element(Progressbar, {
	progress: {},
	precision: {},
	tweenDuration: {},
	animate: {},
	size: {},
	labelInside: {},
	labelOutside: {},
	easing: {},
	color: {},
	div2Class: {},
	oustsideSpanClass: {},
	oustsideProgressClass: {},
	labeloutsidedivClass: {},
	divClass: {}
}, [], [], !0);
const progressbar = ce({
	slots: {
		base: "w-full bg-gray-200 rounded-full dark:bg-gray-700",
		labelInsideDiv: "text-primary-100 text-xs font-medium text-center leading-none rounded-full",
		insideDiv: "rounded-full",
		outsideDiv: "mb-1 flex justify-between",
		oustsideSpan: "text-base font-medium text-blue-700 dark:text-white",
		outsideProgress: "text-sm font-medium text-blue-700 dark:text-white"
	},
	variants: {
		color: {
			primary: {
				labelInsideDiv: "bg-primary-600",
				insideDiv: "bg-primary-600"
			},
			gray: {
				labelInsideDiv: "bg-gray-600 dark:bg-gray-300",
				insideDiv: "bg-gray-600 dark:bg-gray-300"
			},
			red: {
				labelInsideDiv: "bg-red-600 dark:bg-red-500",
				insideDiv: "bg-red-600 dark:bg-red-500"
			},
			orange: {
				labelInsideDiv: "bg-orange-600 dark:bg-orange-500",
				insideDiv: "bg-orange-600 dark:bg-orange-500"
			},
			amber: {
				labelInsideDiv: "bg-amber-600 dark:bg-amber-500",
				insideDiv: "bg-amber-600 dark:bg-amber-500"
			},
			yellow: {
				labelInsideDiv: "bg-yellow-400",
				insideDiv: "bg-yellow-400"
			},
			lime: {
				labelInsideDiv: "bg-lime-600 dark:bg-lime-500",
				insideDiv: "bg-lime-600 dark:bg-lime-500"
			},
			green: {
				labelInsideDiv: "bg-green-600 dark:bg-green-500",
				insideDiv: "bg-green-600 dark:bg-green-500"
			},
			emerald: {
				labelInsideDiv: "bg-emerald-600 dark:bg-emerald-500",
				insideDiv: "bg-emerald-600 dark:bg-emerald-500"
			},
			teal: {
				labelInsideDiv: "bg-teal-600 dark:bg-teal-500",
				insideDiv: "bg-teal-600 dark:bg-teal-500"
			},
			cyan: {
				labelInsideDiv: "bg-cyan-600 dark:bg-cyan-500",
				insideDiv: "bg-cyan-600 dark:bg-cyan-500"
			},
			sky: {
				labelInsideDiv: "bg-sky-600 dark:bg-sky-500",
				insideDiv: "bg-sky-600 dark:bg-sky-500"
			},
			blue: {
				labelInsideDiv: "bg-blue-600",
				insideDiv: "bg-blue-600"
			},
			indigo: {
				labelInsideDiv: "bg-indigo-600 dark:bg-indigo-500",
				insideDiv: "bg-indigo-600 dark:bg-indigo-500"
			},
			violet: {
				labelInsideDiv: "bg-violet-600 dark:bg-violet-500",
				insideDiv: "bg-violet-600 dark:bg-violet-500"
			},
			purple: {
				labelInsideDiv: "bg-purple-600 dark:bg-purple-500",
				insideDiv: "bg-purple-600 dark:bg-purple-500"
			},
			fuchsia: {
				labelInsideDiv: "bg-fuchsia-600 dark:bg-fuchsia-500",
				insideDiv: "bg-fuchsia-600 dark:bg-fuchsia-500"
			},
			pink: {
				labelInsideDiv: "bg-pink-600 dark:bg-pink-500",
				insideDiv: "bg-pink-600 dark:bg-pink-500"
			},
			rose: {
				labelInsideDiv: "bg-rose-600 dark:bg-rose-500",
				insideDiv: "bg-rose-600 dark:bg-rose-500"
			}
		},
		labelInside: {
			true: "",
			false: ""
		}
	},
	compoundVariants: [{
		labelInside: !0,
		class: {
			base: "text-primary-100 text-xs font-medium text-center leading-none rounded-full",
			labelInsideDiv: "p-0.5"
		}
	}, {
		labelInside: !1,
		class: { base: "rounded-full" }
	}],
	defaultVariants: {
		color: "primary",
		labelInside: !1
	}
});
var root_3$38 = /* @__PURE__ */ from_html("<div><span> </span> <div><div></div></div> <span> </span></div>"), root$98 = /* @__PURE__ */ from_html("<!> <!> <!>", 1);
function AdvancedRating(C, T) {
	push(T, !0);
	let E = prop(T, "rating", 7), D = prop(T, "globalText", 7), O = prop(T, "ratings", 7), F = prop(T, "divClass", 7), I = prop(T, "spanClass", 7), L = prop(T, "div2Class", 7), z = prop(T, "div3Class", 7), B = prop(T, "span2Class", 7), V = prop(T, "unit", 7), U = /* @__PURE__ */ user_derived(advancedrating), W = /* @__PURE__ */ user_derived(() => get(U).base), G = /* @__PURE__ */ user_derived(() => get(U).span), K = /* @__PURE__ */ user_derived(() => get(U).div2), J = /* @__PURE__ */ user_derived(() => get(U).div3), Y = /* @__PURE__ */ user_derived(() => get(U).span2);
	var X = {
		get rating() {
			return E();
		},
		set rating(C) {
			E(C), flushSync();
		},
		get globalText() {
			return D();
		},
		set globalText(C) {
			D(C), flushSync();
		},
		get ratings() {
			return O();
		},
		set ratings(C) {
			O(C), flushSync();
		},
		get divClass() {
			return F();
		},
		set divClass(C) {
			F(C), flushSync();
		},
		get spanClass() {
			return I();
		},
		set spanClass(C) {
			I(C), flushSync();
		},
		get div2Class() {
			return L();
		},
		set div2Class(C) {
			L(C), flushSync();
		},
		get div3Class() {
			return z();
		},
		set div3Class(C) {
			z(C), flushSync();
		},
		get span2Class() {
			return B();
		},
		set span2Class(C) {
			B(C), flushSync();
		},
		get unit() {
			return V();
		},
		set unit(C) {
			V(C), flushSync();
		}
	}, Z = root$98(), Q = first_child(Z), NL = (C) => {
		var T = comment();
		snippet(first_child(T), E), append(C, T);
	};
	if_block(Q, (C) => {
		E() && C(NL);
	});
	var PL = sibling(Q, 2), FL = (C) => {
		var T = comment();
		snippet(first_child(T), D), append(C, T);
	};
	return if_block(PL, (C) => {
		D() && C(FL);
	}), each(sibling(PL, 2), 17, O, index, (C, T, E, D) => {
		let O = () => get(T).label, U = () => get(T).rating;
		var X = root_3$38(), Z = child(X), Q = child(Z, !0);
		reset(Z);
		var NL = sibling(Z, 2), PL = child(NL);
		reset(NL);
		var FL = sibling(NL, 2), IL = child(FL);
		reset(FL), reset(X), template_effect((C, T, E, D, F) => {
			var I, L, z;
			set_class(X, 1, C), set_class(Z, 1, T), set_text(Q, O()), set_class(NL, 1, E), set_class(PL, 1, D), set_style(PL, `width: ${(I = U()) == null ? "" : I}%`), set_class(FL, 1, F), set_text(IL, `${(L = U()) == null ? "" : L}${(z = V()) == null ? "" : z}`);
		}, [
			() => clsx$1(get(W)({ class: F() })),
			() => clsx$1(get(G)({ class: I() })),
			() => clsx$1(get(K)({ class: L() })),
			() => clsx$1(get(J)({ class: z() })),
			() => clsx$1(get(Y)({ class: B() }))
		]), append(C, X);
	}), append(C, Z), pop(X);
}
create_custom_element(AdvancedRating, {
	rating: {},
	globalText: {},
	ratings: {},
	divClass: {},
	spanClass: {},
	div2Class: {},
	div3Class: {},
	span2Class: {},
	unit: {}
}, [], [], !0);
var root_1$86 = /* @__PURE__ */ from_svg("<stop offset=\"0%\"></stop><stop></stop><stop stop-color=\"transparent\"></stop><stop offset=\"100%\" stop-color=\"transparent\"></stop>", 1), root_2$43 = /* @__PURE__ */ from_svg("<stop offset=\"0%\"></stop><stop offset=\"100%\"></stop>", 1), root$97 = /* @__PURE__ */ from_svg("<svg><defs><linearGradient><!></linearGradient></defs><path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M21 8.25c0-2.485-2.099-4.5-4.688-4.5-1.935 0-3.597 1.126-4.312 2.733-.715-1.607-2.377-2.733-4.313-2.733C5.1 3.75 3 5.765 3 8.25c0 7.22 9 12 9 12s9-4.78 9-12z\"></path></svg>");
function Heart(C, E) {
	push(E, !0);
	let D = prop(E, "fillPercent", 7, 100), O = prop(E, "fillColor", 7, "#ff0000"), F = prop(E, "strokeColor", 7, "#ff0000"), I = prop(E, "size", 7, 24), L = prop(E, "ariaLabel", 7, "star"), z = prop(E, "iconIndex", 7, 0), B = prop(E, "groupId", 7, "star"), V = prop(E, "role", 7, "img"), U = prop(E, "svgClass", 7), W = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"fillPercent",
		"fillColor",
		"strokeColor",
		"size",
		"ariaLabel",
		"iconIndex",
		"groupId",
		"role",
		"svgClass"
	]), G = `${B()}-${z()}`;
	var K = {
		get fillPercent() {
			return D();
		},
		set fillPercent(C = 100) {
			D(C), flushSync();
		},
		get fillColor() {
			return O();
		},
		set fillColor(C = "#ff0000") {
			O(C), flushSync();
		},
		get strokeColor() {
			return F();
		},
		set strokeColor(C = "#ff0000") {
			F(C), flushSync();
		},
		get size() {
			return I();
		},
		set size(C = 24) {
			I(C), flushSync();
		},
		get ariaLabel() {
			return L();
		},
		set ariaLabel(C = "star") {
			L(C), flushSync();
		},
		get iconIndex() {
			return z();
		},
		set iconIndex(C = 0) {
			z(C), flushSync();
		},
		get groupId() {
			return B();
		},
		set groupId(C = "star") {
			B(C), flushSync();
		},
		get role() {
			return V();
		},
		set role(C = "img") {
			V(C), flushSync();
		},
		get svgClass() {
			return U();
		},
		set svgClass(C) {
			U(C), flushSync();
		}
	}, J = root$97();
	attribute_effect(J, () => _objectSpread2(_objectSpread2({
		width: I(),
		height: I(),
		class: U()
	}, W), {}, {
		"aria-label": L(),
		viewBox: "0 0 24 24",
		role: V(),
		"stroke-width": "1.5",
		stroke: "currentColor",
		fill: "none"
	}));
	var Y = child(J), X = child(Y), Z = child(X), Q = (C) => {
		var T = root_1$86(), E = first_child(T), F = sibling(E), I = sibling(F);
		next(), template_effect(() => {
			var C, T;
			set_attribute(E, "stop-color", O()), set_attribute(F, "offset", `${(C = D()) == null ? "" : C}%`), set_attribute(F, "stop-color", O()), set_attribute(I, "offset", `${(T = D()) == null ? "" : T}%`);
		}), append(C, T);
	}, NL = (C) => {
		var T = root_2$43(), E = first_child(T), D = sibling(E);
		template_effect(() => {
			set_attribute(E, "stop-color", O()), set_attribute(D, "stop-color", O());
		}), append(C, T);
	};
	if_block(Z, (C) => {
		D() === 100 ? C(NL, !1) : C(Q);
	}), reset(X), reset(Y);
	var PL = sibling(Y);
	return reset(J), template_effect(() => {
		set_attribute(X, "id", G), set_attribute(PL, "fill", `url(#${G})`), set_attribute(PL, "stroke", F());
	}), append(C, J), pop(K);
}
create_custom_element(Heart, {
	fillPercent: {},
	fillColor: {},
	strokeColor: {},
	size: {},
	ariaLabel: {},
	iconIndex: {},
	groupId: {},
	role: {},
	svgClass: {}
}, [], [], !0);
var root_1$85 = /* @__PURE__ */ from_svg("<stop offset=\"0%\"></stop><stop></stop><stop stop-color=\"transparent\"></stop><stop offset=\"100%\" stop-color=\"transparent\"></stop>", 1), root_2$42 = /* @__PURE__ */ from_svg("<stop offset=\"0%\"></stop><stop offset=\"100%\"></stop>", 1), root$96 = /* @__PURE__ */ from_svg("<svg><defs><linearGradient><!></linearGradient></defs><g stroke-width=\"2\"><polygon points=\"165.000, 185.000, 188.511, 197.361, 184.021, 171.180, \n      203.042, 152.639, 176.756, 148.820, 165.000, 125.000, \n      153.244, 148.820, 126.958, 152.639, 145.979, 171.180,\n      141.489, 197.361, 165.000, 185.000\"></polygon></g></svg>");
function Star(C, E) {
	push(E, !0);
	let D = prop(E, "fillPercent", 7, 100), O = prop(E, "fillColor", 7, "#F5CA14"), F = prop(E, "strokeColor", 7, "#F5CA14"), I = prop(E, "size", 7, 24), L = prop(E, "ariaLabel", 7, "star"), z = prop(E, "iconIndex", 7, 0), B = prop(E, "groupId", 7, "star"), V = prop(E, "role", 7, "img"), U = prop(E, "svgClass", 7), W = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"fillPercent",
		"fillColor",
		"strokeColor",
		"size",
		"ariaLabel",
		"iconIndex",
		"groupId",
		"role",
		"svgClass"
	]), G = `${B()}-${z()}`;
	var K = {
		get fillPercent() {
			return D();
		},
		set fillPercent(C = 100) {
			D(C), flushSync();
		},
		get fillColor() {
			return O();
		},
		set fillColor(C = "#F5CA14") {
			O(C), flushSync();
		},
		get strokeColor() {
			return F();
		},
		set strokeColor(C = "#F5CA14") {
			F(C), flushSync();
		},
		get size() {
			return I();
		},
		set size(C = 24) {
			I(C), flushSync();
		},
		get ariaLabel() {
			return L();
		},
		set ariaLabel(C = "star") {
			L(C), flushSync();
		},
		get iconIndex() {
			return z();
		},
		set iconIndex(C = 0) {
			z(C), flushSync();
		},
		get groupId() {
			return B();
		},
		set groupId(C = "star") {
			B(C), flushSync();
		},
		get role() {
			return V();
		},
		set role(C = "img") {
			V(C), flushSync();
		},
		get svgClass() {
			return U();
		},
		set svgClass(C) {
			U(C), flushSync();
		}
	}, J = root$96();
	attribute_effect(J, () => _objectSpread2(_objectSpread2({
		width: I(),
		height: I()
	}, W), {}, {
		class: U(),
		"aria-label": L(),
		viewBox: "100 100 120 120",
		role: V()
	}));
	var Y = child(J), X = child(Y), Z = child(X), Q = (C) => {
		var T = root_1$85(), E = first_child(T), F = sibling(E), I = sibling(F);
		next(), template_effect(() => {
			var C, T;
			set_attribute(E, "stop-color", O()), set_attribute(F, "offset", `${(C = D()) == null ? "" : C}%`), set_attribute(F, "stop-color", O()), set_attribute(I, "offset", `${(T = D()) == null ? "" : T}%`);
		}), append(C, T);
	}, NL = (C) => {
		var T = root_2$42(), E = first_child(T), D = sibling(E);
		template_effect(() => {
			set_attribute(E, "stop-color", O()), set_attribute(D, "stop-color", O());
		}), append(C, T);
	};
	if_block(Z, (C) => {
		D() === 100 ? C(NL, !1) : C(Q);
	}), reset(X), reset(Y);
	var PL = sibling(Y);
	return reset(J), template_effect(() => {
		set_attribute(X, "id", G), set_attribute(PL, "fill", `url(#${G})`), set_attribute(PL, "stroke", F());
	}), append(C, J), pop(K);
}
create_custom_element(Star, {
	fillPercent: {},
	fillColor: {},
	strokeColor: {},
	size: {},
	ariaLabel: {},
	iconIndex: {},
	groupId: {},
	role: {},
	svgClass: {}
}, [], [], !0);
var root_1$84 = /* @__PURE__ */ from_html("<!> <p> </p> <!>", 1), root_2$41 = /* @__PURE__ */ from_html("<!> <!> <!> <!>", 1), root$95 = /* @__PURE__ */ from_html("<div><!></div>");
function Rating(C, T) {
	push(T, !0);
	let E = prop(T, "children", 7), D = prop(T, "text", 7), O = prop(T, "divClass", 7), F = prop(T, "size", 7, 24), I = prop(T, "total", 7, 5), L = prop(T, "rating", 7, 4), z = prop(T, "Icon", 7, Star), B = prop(T, "count", 7, !1), V = prop(T, "pClass", 7), U = /* @__PURE__ */ user_derived(rating), W = /* @__PURE__ */ user_derived(() => get(U).base), G = /* @__PURE__ */ user_derived(() => get(U).p), K = crypto.randomUUID(), J = Math.floor(L()), Y = L() - J, X = Math.round(Y * 100), Z = I() - (J + Math.ceil(Y));
	var Q = {
		get children() {
			return E();
		},
		set children(C) {
			E(C), flushSync();
		},
		get text() {
			return D();
		},
		set text(C) {
			D(C), flushSync();
		},
		get divClass() {
			return O();
		},
		set divClass(C) {
			O(C), flushSync();
		},
		get size() {
			return F();
		},
		set size(C = 24) {
			F(C), flushSync();
		},
		get total() {
			return I();
		},
		set total(C = 5) {
			I(C), flushSync();
		},
		get rating() {
			return L();
		},
		set rating(C = 4) {
			L(C), flushSync();
		},
		get Icon() {
			return z();
		},
		set Icon(C = Star) {
			z(C), flushSync();
		},
		get count() {
			return B();
		},
		set count(C = !1) {
			B(C), flushSync();
		},
		get pClass() {
			return V();
		},
		set pClass(C) {
			V(C), flushSync();
		}
	}, NL = root$95(), PL = child(NL), FL = (C) => {
		var T = root_1$84(), D = first_child(T);
		component(D, z, (C, T) => {
			T(C, {
				fillPercent: 100,
				get size() {
					return F();
				},
				iconIndex: 0,
				get groupId() {
					return K;
				}
			});
		});
		var O = sibling(D, 2), I = child(O, !0);
		reset(O), snippet(sibling(O, 2), E), template_effect((C) => {
			set_class(O, 1, C), set_text(I, L());
		}, [() => clsx$1(get(G)({ class: V() }))]), append(C, T);
	}, IL = (C) => {
		var T = root_2$41(), E = first_child(T);
		each(E, 17, () => Array(J), index, (C, T, E) => {
			var D = comment(), O = first_child(D);
			{
				let C = /* @__PURE__ */ user_derived(() => `rating-${K}-full`);
				component(O, z, (T, D) => {
					D(T, {
						get size() {
							return F();
						},
						fillPercent: 100,
						iconIndex: E,
						get groupId() {
							return get(C);
						}
					});
				});
			}
			append(C, D);
		});
		var O = sibling(E, 2), I = (C) => {
			var T = comment(), E = first_child(T);
			{
				let C = /* @__PURE__ */ user_derived(() => `rating-${K}-partial`);
				component(E, z, (T, E) => {
					E(T, {
						get size() {
							return F();
						},
						get fillPercent() {
							return X;
						},
						get iconIndex() {
							return J;
						},
						get groupId() {
							return get(C);
						}
					});
				});
			}
			append(C, T);
		};
		if_block(O, (C) => {
			X && C(I);
		});
		var L = sibling(O, 2);
		each(L, 17, () => Array(Z), index, (C, T, E) => {
			var D = comment(), O = first_child(D);
			{
				let C = /* @__PURE__ */ user_derived(() => `rating-${K}-empty`);
				component(O, z, (T, D) => {
					D(T, {
						get size() {
							return F();
						},
						fillPercent: 0,
						iconIndex: E,
						get groupId() {
							return get(C);
						}
					});
				});
			}
			append(C, D);
		});
		var B = sibling(L, 2), V = (C) => {
			var T = comment();
			snippet(first_child(T), D), append(C, T);
		};
		if_block(B, (C) => {
			D() && C(V);
		}), append(C, T);
	};
	return if_block(PL, (C) => {
		B() && E() ? C(FL) : C(IL, !1);
	}), reset(NL), template_effect((C) => set_class(NL, 1, C), [() => clsx$1(get(W)({ class: O() }))]), append(C, NL), pop(Q);
}
create_custom_element(Rating, {
	children: {},
	text: {},
	divClass: {},
	size: {},
	total: {},
	rating: {},
	Icon: {},
	count: {},
	pClass: {}
}, [], [], !0);
var root_1$83 = /* @__PURE__ */ from_html("<p class=\"ms-2 pt-1 text-sm font-medium text-gray-500 dark:text-gray-400\"> </p>"), root_2$40 = /* @__PURE__ */ from_html("<h3 class=\"ms-2 text-sm font-semibold text-gray-900 dark:text-white\"> </h3>"), root_3$37 = /* @__PURE__ */ from_html("<footer class=\"mb-5 text-sm text-gray-500 dark:text-gray-400\"><p> </p></footer>"), root_8$7 = /* @__PURE__ */ from_html("<a class=\"ps-4 text-sm font-medium text-primary-600 hover:underline dark:text-primary-500\">Report abuse</a>"), root_5$18 = /* @__PURE__ */ from_html("<div class=\"mt-3 flex items-center space-x-3 divide-x divide-gray-200 rtl:space-x-reverse rtl:divide-x-reverse dark:divide-gray-600\"><!> <!></div>"), root$94 = /* @__PURE__ */ from_html("<article><div class=\"mb-4 flex items-center space-x-4 rtl:space-x-reverse\"><img class=\"h-10 w-10 rounded-full\"/> <div class=\"space-y-1 font-medium dark:text-white\"><p> <time datetime=\"2014-08-16 19:00\" class=\"block text-sm text-gray-500 dark:text-gray-400\"> </time></p></div></div> <div class=\"mb-1 flex items-center\"><!> <!></div> <!> <!> <aside><p class=\"mt-1 text-xs text-gray-500 dark:text-gray-400\"><!></p> <!></aside></article>");
function RatingComment(C, T) {
	push(T, !0);
	let E = prop(T, "children", 7), D = prop(T, "evaluation", 7), O = prop(T, "helpfullink", 7), F = prop(T, "abuselink", 7), I = prop(T, "comment", 7);
	var L = {
		get children() {
			return E();
		},
		set children(C) {
			E(C), flushSync();
		},
		get evaluation() {
			return D();
		},
		set evaluation(C) {
			D(C), flushSync();
		},
		get helpfullink() {
			return O();
		},
		set helpfullink(C) {
			O(C), flushSync();
		},
		get abuselink() {
			return F();
		},
		set abuselink(C) {
			F(C), flushSync();
		},
		get comment() {
			return I();
		},
		set comment(C) {
			I(C), flushSync();
		}
	}, z = root$94(), B = child(z), V = child(B), U = sibling(V, 2), W = child(U), G = child(W), K = sibling(G), J = child(K, !0);
	reset(K), reset(W), reset(U), reset(B);
	var Y = sibling(B, 2), X = child(Y);
	Rating(X, {
		get total() {
			return I().total;
		},
		get rating() {
			return I().rating;
		},
		text: (C) => {
			var T = root_1$83(), E = child(T);
			reset(T), template_effect(() => {
				var C, T;
				return set_text(E, `${(C = I().rating) == null ? "" : C} out of ${(T = I().total) == null ? "" : T}`);
			}), append(C, T);
		},
		$$slots: { text: !0 }
	});
	var Z = sibling(X, 2), Q = (C) => {
		var T = root_2$40(), E = child(T, !0);
		reset(T), template_effect(() => set_text(E, I().heading)), append(C, T);
	};
	if_block(Z, (C) => {
		I().heading && C(Q);
	}), reset(Y);
	var NL = sibling(Y, 2), PL = (C) => {
		var T = root_3$37(), E = child(T), D = child(E);
		reset(E), reset(T), template_effect(() => {
			var C, T;
			return set_text(D, `Reviewed in ${(C = I().address) == null ? "" : C} on ${(T = I().datetime) == null ? "" : T}`);
		}), append(C, T);
	};
	if_block(NL, (C) => {
		(I().address || I().datetime) && C(PL);
	});
	var FL = sibling(NL, 2);
	snippet(FL, E);
	var IL = sibling(FL, 2), LL = child(IL), RL = child(LL), zL = (C) => {
		var T = comment();
		snippet(first_child(T), D), append(C, T);
	};
	if_block(RL, (C) => {
		D() && C(zL);
	}), reset(LL);
	var BL = sibling(LL, 2), VL = (C) => {
		var T = root_5$18(), E = child(T), D = (C) => {
			Button(C, {
				size: "xs",
				href: "/",
				color: "dark",
				children: (C, T) => {
					next(), append(C, text("Helpful"));
				},
				$$slots: { default: !0 }
			});
		};
		if_block(E, (C) => {
			O() && C(D);
		});
		var I = sibling(E, 2), L = (C) => {
			var T = root_8$7();
			template_effect(() => set_attribute(T, "href", F())), append(C, T);
		};
		if_block(I, (C) => {
			F() && C(L);
		}), reset(T), append(C, T);
	};
	return if_block(BL, (C) => {
		(O() || F()) && C(VL);
	}), reset(IL), reset(z), template_effect(() => {
		var C;
		set_attribute(V, "src", I().user.img.src), set_attribute(V, "alt", I().user.img.alt), set_text(G, `${(C = I().user.name) == null ? "" : C} `), set_text(J, I().user.joined);
	}), append(C, z), pop(L);
}
create_custom_element(RatingComment, {
	children: {},
	evaluation: {},
	helpfullink: {},
	abuselink: {},
	comment: {}
}, [], [], !0);
var root_3$36 = /* @__PURE__ */ from_html("<div><!></div>"), root_5$17 = /* @__PURE__ */ from_html("<li><!></li>"), root_7$11 = /* @__PURE__ */ from_html("<li><!></li>"), root_9$7 = /* @__PURE__ */ from_html("<li><!></li>"), root_4$22 = /* @__PURE__ */ from_html("<ul><!> <!> <!></ul>"), root_11$3 = /* @__PURE__ */ from_html("<footer><p class=\"mb-2 text-sm text-gray-500 dark:text-gray-400\"> </p></footer>"), root_1$82 = /* @__PURE__ */ from_html("<article><div><div><img/> <div><p> </p> <!></div></div> <!></div> <div class=\"col-span-2 mt-6 md:mt-0\"><div class=\"mb-5 flex items-start\"><div class=\"pe-4\"><!> <h4 class=\"text-xl font-bold text-gray-900 dark:text-white\"> </h4></div> <p class=\"inline-flex items-center rounded bg-primary-700 p-1.5 text-sm font-semibold text-white\"> </p></div> <!></div></article>");
function Review(C, T) {
	push(T, !0);
	let E = prop(T, "children", 7), D = prop(T, "address", 7), O = prop(T, "item1", 7), F = prop(T, "item2", 7), I = prop(T, "item3", 7), L = prop(T, "review", 7), z = prop(T, "articleClass", 7), B = prop(T, "divClass", 7), V = prop(T, "div2Class", 7), U = prop(T, "div3Class", 7), W = prop(T, "imgClass", 7), G = prop(T, "ulClass", 7), K = prop(T, "liClass", 7), J = /* @__PURE__ */ user_derived(review), Y = /* @__PURE__ */ user_derived(() => get(J).article), X = /* @__PURE__ */ user_derived(() => get(J).div), Z = /* @__PURE__ */ user_derived(() => get(J).div2), Q = /* @__PURE__ */ user_derived(() => get(J).div3), NL = /* @__PURE__ */ user_derived(() => get(J).img), PL = /* @__PURE__ */ user_derived(() => get(J).ul), FL = /* @__PURE__ */ user_derived(() => get(J).li);
	var IL = {
		get children() {
			return E();
		},
		set children(C) {
			E(C), flushSync();
		},
		get address() {
			return D();
		},
		set address(C) {
			D(C), flushSync();
		},
		get item1() {
			return O();
		},
		set item1(C) {
			O(C), flushSync();
		},
		get item2() {
			return F();
		},
		set item2(C) {
			F(C), flushSync();
		},
		get item3() {
			return I();
		},
		set item3(C) {
			I(C), flushSync();
		},
		get review() {
			return L();
		},
		set review(C) {
			L(C), flushSync();
		},
		get articleClass() {
			return z();
		},
		set articleClass(C) {
			z(C), flushSync();
		},
		get divClass() {
			return B();
		},
		set divClass(C) {
			B(C), flushSync();
		},
		get div2Class() {
			return V();
		},
		set div2Class(C) {
			V(C), flushSync();
		},
		get div3Class() {
			return U();
		},
		set div3Class(C) {
			U(C), flushSync();
		},
		get imgClass() {
			return W();
		},
		set imgClass(C) {
			W(C), flushSync();
		},
		get ulClass() {
			return G();
		},
		set ulClass(C) {
			G(C), flushSync();
		},
		get liClass() {
			return K();
		},
		set liClass(C) {
			K(C), flushSync();
		}
	}, LL = comment(), RL = first_child(LL), zL = (C) => {
		var T = root_1$82(), J = child(T), IL = child(J), LL = child(IL), RL = sibling(LL, 2), zL = child(RL), BL = child(zL, !0);
		reset(zL);
		var VL = sibling(zL, 2), HL = (C) => {
			var T = comment(), E = first_child(T), O = (C) => {
				var T = root_3$36();
				snippet(child(T), D), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(Q)({ class: U() }))]), append(C, T);
			};
			if_block(E, (C) => {
				D() && C(O);
			}), append(C, T);
		};
		if_block(VL, (C) => {
			L().address && C(HL);
		}), reset(RL), reset(IL);
		var UL = sibling(IL, 2), WL = (C) => {
			var T = root_4$22(), E = child(T), D = (C) => {
				var T = root_5$17(), E = child(T), D = (C) => {
					var T = comment();
					snippet(first_child(T), O), append(C, T);
				};
				if_block(E, (C) => {
					O() && C(D);
				}), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(twMerge(get(FL)({ class: K() })))]), append(C, T);
			};
			if_block(E, (C) => {
				L().item1 && C(D);
			});
			var z = sibling(E, 2), B = (C) => {
				var T = root_7$11(), E = child(T), D = (C) => {
					var T = comment();
					snippet(first_child(T), F), append(C, T);
				};
				if_block(E, (C) => {
					F() && C(D);
				}), reset(T), template_effect(() => set_class(T, 1, clsx$1(K()))), append(C, T);
			};
			if_block(z, (C) => {
				L().item2 && C(B);
			});
			var V = sibling(z, 2), U = (C) => {
				var T = root_9$7(), E = child(T), D = (C) => {
					var T = comment();
					snippet(first_child(T), I), append(C, T);
				};
				if_block(E, (C) => {
					I() && C(D);
				}), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(twMerge(K()))]), append(C, T);
			};
			if_block(V, (C) => {
				L().item3 && C(U);
			}), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(PL)({ class: G() }))]), append(C, T);
		};
		if_block(UL, (C) => {
			(L().item1 || L().item2 || L().item3) && C(WL);
		}), reset(J);
		var GL = sibling(J, 2), KL = child(GL), qL = child(KL), JL = child(qL), YL = (C) => {
			var T = root_11$3(), E = child(T), D = child(E);
			reset(E), reset(T), template_effect(() => {
				var C;
				return set_text(D, `Reviewed: ${(C = L().reviewDate) == null ? "" : C}`);
			}), append(C, T);
		};
		if_block(JL, (C) => {
			L().reviewDate && C(YL);
		});
		var XL = sibling(JL, 2), ZL = child(XL, !0);
		reset(XL), reset(qL);
		var QL = sibling(qL, 2), $L = child(QL, !0);
		reset(QL), reset(KL), snippet(sibling(KL, 2), E), reset(GL), reset(T), template_effect((C, E, D, O) => {
			set_class(T, 1, C), set_class(IL, 1, E), set_class(LL, 1, D), set_attribute(LL, "src", L().imgSrc), set_attribute(LL, "alt", L().imgAlt), set_class(RL, 1, O), set_text(BL, L().name), set_text(ZL, L().title), set_text($L, L().rating);
		}, [
			() => clsx$1(get(Y)({ class: z() })),
			() => clsx$1(get(X)({ class: B() })),
			() => clsx$1(get(NL)({ class: W() })),
			() => clsx$1(get(Z)({ class: V() }))
		]), append(C, T);
	};
	return if_block(RL, (C) => {
		L() && C(zL);
	}), append(C, LL), pop(IL);
}
create_custom_element(Review, {
	children: {},
	address: {},
	item1: {},
	item2: {},
	item3: {},
	review: {},
	articleClass: {},
	divClass: {},
	div2Class: {},
	div3Class: {},
	imgClass: {},
	ulClass: {},
	liClass: {}
}, [], [], !0);
var root_2$39 = /* @__PURE__ */ from_html("<p> </p>"), root_3$35 = /* @__PURE__ */ from_html("<p> </p>"), root_4$21 = /* @__PURE__ */ from_html("<span></span> <p> </p>", 1), root_5$16 = /* @__PURE__ */ from_html("<a> </a>"), root_1$81 = /* @__PURE__ */ from_html("<!> <!> <!> <!>", 1), root_7$10 = /* @__PURE__ */ from_html("<dl><dt class=\"text-sm font-medium text-gray-500 dark:text-gray-400\"> </dt> <dd class=\"mb-3 flex items-center\"><div class=\"me-2 h-2.5 w-full rounded bg-gray-200 dark:bg-gray-700\"><div></div></div> <span class=\"text-sm font-medium text-gray-500 dark:text-gray-400\"> </span></dd></dl>"), root_9$6 = /* @__PURE__ */ from_html("<dl><dt class=\"text-sm font-medium text-gray-500 dark:text-gray-400\"> </dt> <dd class=\"mb-3 flex items-center\"><div class=\"me-2 h-2.5 w-full rounded bg-gray-200 dark:bg-gray-700\"><div></div></div> <span class=\"text-sm font-medium text-gray-500 dark:text-gray-400\"> </span></dd></dl>"), root$93 = /* @__PURE__ */ from_html("<div class=\"mb-5 flex items-center\"><!></div> <div class=\"gap-8 sm:grid sm:grid-cols-2\"><div><!></div> <div><!></div></div>", 1);
function ScoreRating(C, T) {
	push(T, !0);
	let E = prop(T, "ratings", 7), D = prop(T, "ratings2", 7), O = prop(T, "headerLabel", 7), F = /* @__PURE__ */ user_derived(scorerating), I = /* @__PURE__ */ user_derived(() => get(F).desc1), L = /* @__PURE__ */ user_derived(() => get(F).desc2), z = /* @__PURE__ */ user_derived(() => get(F).desc3span), B = /* @__PURE__ */ user_derived(() => get(F).desc3p), V = /* @__PURE__ */ user_derived(() => get(F).link), U = /* @__PURE__ */ user_derived(() => get(F).bar);
	var W = {
		get ratings() {
			return E();
		},
		set ratings(C) {
			E(C), flushSync();
		},
		get ratings2() {
			return D();
		},
		set ratings2(C) {
			D(C), flushSync();
		},
		get headerLabel() {
			return O();
		},
		set headerLabel(C) {
			O(C), flushSync();
		}
	}, G = root$93(), K = first_child(G), J = child(K), Y = (C) => {
		var T = root_1$81(), E = first_child(T), D = (C) => {
			var T = root_2$39(), E = child(T, !0);
			reset(T), template_effect((C) => {
				set_class(T, 1, C), set_text(E, O().desc1);
			}, [() => clsx$1(get(I)())]), append(C, T);
		};
		if_block(E, (C) => {
			O().desc1 && C(D);
		});
		var F = sibling(E, 2), U = (C) => {
			var T = root_3$35(), E = child(T, !0);
			reset(T), template_effect((C) => {
				set_class(T, 1, C), set_text(E, O().desc2);
			}, [() => clsx$1(get(L)())]), append(C, T);
		};
		if_block(F, (C) => {
			O().desc2 && C(U);
		});
		var W = sibling(F, 2), G = (C) => {
			var T = root_4$21(), E = first_child(T), D = sibling(E, 2), F = child(D, !0);
			reset(D), template_effect((C, T) => {
				set_class(E, 1, C), set_class(D, 1, T), set_text(F, O().desc3);
			}, [() => clsx$1(get(z)()), () => clsx$1(get(B)())]), append(C, T);
		};
		if_block(W, (C) => {
			O().desc3 && C(G);
		});
		var K = sibling(W, 2), J = (C) => {
			var T = root_5$16(), E = child(T, !0);
			reset(T), template_effect((C) => {
				set_attribute(T, "href", O().link.url), set_class(T, 1, C), set_text(E, O().link.label);
			}, [() => clsx$1(get(V)())]), append(C, T);
		};
		if_block(K, (C) => {
			O().link && C(J);
		}), append(C, T);
	};
	if_block(J, (C) => {
		O() && C(Y);
	}), reset(K);
	var X = sibling(K, 2), Z = child(X), Q = child(Z), NL = (C) => {
		var T = comment();
		each(first_child(T), 17, E, index, (C, T) => {
			let E = () => get(T).label, D = () => get(T).rating;
			var O = root_7$10(), F = child(O), I = child(F, !0);
			reset(F);
			var L = sibling(F, 2), z = child(L), B = child(z);
			reset(z);
			var V = sibling(z, 2), W = child(V, !0);
			reset(V), reset(L), reset(O), template_effect((C) => {
				set_text(I, E()), set_class(B, 1, C), set_style(B, `width: ${D() * 10}%`), set_text(W, D());
			}, [() => clsx$1(get(U)())]), append(C, O);
		}), append(C, T);
	};
	if_block(Q, (C) => {
		E() && C(NL);
	}), reset(Z);
	var PL = sibling(Z, 2), FL = child(PL), IL = (C) => {
		var T = comment();
		each(first_child(T), 17, D, index, (C, T) => {
			let E = () => get(T).label, D = () => get(T).rating;
			var O = root_9$6(), F = child(O), I = child(F, !0);
			reset(F);
			var L = sibling(F, 2), z = child(L), B = child(z);
			reset(z);
			var V = sibling(z, 2), W = child(V, !0);
			reset(V), reset(L), reset(O), template_effect((C) => {
				set_text(I, E()), set_class(B, 1, C), set_style(B, `width: ${D() * 10}%`), set_text(W, D());
			}, [() => clsx$1(get(U)())]), append(C, O);
		}), append(C, T);
	};
	return if_block(FL, (C) => {
		D() && C(IL);
	}), reset(PL), reset(X), append(C, G), pop(W);
}
create_custom_element(ScoreRating, {
	ratings: {},
	ratings2: {},
	headerLabel: {}
}, [], [], !0);
var root_1$80 = /* @__PURE__ */ from_svg("<stop offset=\"0%\"></stop><stop></stop><stop stop-color=\"transparent\"></stop><stop offset=\"100%\" stop-color=\"transparent\"></stop>", 1), root_2$38 = /* @__PURE__ */ from_svg("<stop offset=\"0%\"></stop><stop offset=\"100%\"></stop>", 1), root$92 = /* @__PURE__ */ from_svg("<svg><defs><linearGradient><!></linearGradient></defs><path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M6.633 10.5c.806 0 1.533-.446 2.031-1.08a9.041 9.041 0 012.861-2.4c.723-.384 1.35-.956 1.653-1.715a4.498 4.498 0 00.322-1.672V3a.75.75 0 01.75-.75A2.25 2.25 0 0116.5 4.5c0 1.152-.26 2.243-.723 3.218-.266.558.107 1.282.725 1.282h3.126c1.026 0 1.945.694 2.054 1.715.045.422.068.85.068 1.285a11.95 11.95 0 01-2.649 7.521c-.388.482-.987.729-1.605.729H13.48c-.483 0-.964-.078-1.423-.23l-3.114-1.04a4.501 4.501 0 00-1.423-.23H5.904M14.25 9h2.25M5.904 18.75c.083.205.173.405.27.602.197.4-.078.898-.523.898h-.908c-.889 0-1.713-.518-1.972-1.368a12 12 0 01-.521-3.507c0-1.553.295-3.036.831-4.398C3.387 10.203 4.167 9.75 5 9.75h1.053c.472 0 .745.556.5.96a8.958 8.958 0 00-1.302 4.665c0 1.194.232 2.333.654 3.375z\"></path></svg>");
function Thumbup(C, E) {
	push(E, !0);
	let D = prop(E, "fillPercent", 7, 100), O = prop(E, "fillColor", 7, "#00b500"), F = prop(E, "strokeColor", 7, "#00b500"), I = prop(E, "size", 7, 24), L = prop(E, "ariaLabel", 7, "thumbup"), z = prop(E, "iconIndex", 7, 0), B = prop(E, "groupId", 7, "star"), V = prop(E, "role", 7, "img"), U = prop(E, "svgClass", 7), W = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"fillPercent",
		"fillColor",
		"strokeColor",
		"size",
		"ariaLabel",
		"iconIndex",
		"groupId",
		"role",
		"svgClass"
	]), G = `${B()}-${z()}`;
	var K = {
		get fillPercent() {
			return D();
		},
		set fillPercent(C = 100) {
			D(C), flushSync();
		},
		get fillColor() {
			return O();
		},
		set fillColor(C = "#00b500") {
			O(C), flushSync();
		},
		get strokeColor() {
			return F();
		},
		set strokeColor(C = "#00b500") {
			F(C), flushSync();
		},
		get size() {
			return I();
		},
		set size(C = 24) {
			I(C), flushSync();
		},
		get ariaLabel() {
			return L();
		},
		set ariaLabel(C = "thumbup") {
			L(C), flushSync();
		},
		get iconIndex() {
			return z();
		},
		set iconIndex(C = 0) {
			z(C), flushSync();
		},
		get groupId() {
			return B();
		},
		set groupId(C = "star") {
			B(C), flushSync();
		},
		get role() {
			return V();
		},
		set role(C = "img") {
			V(C), flushSync();
		},
		get svgClass() {
			return U();
		},
		set svgClass(C) {
			U(C), flushSync();
		}
	}, J = root$92();
	attribute_effect(J, () => _objectSpread2(_objectSpread2({
		width: I(),
		height: I()
	}, W), {}, {
		class: U(),
		"aria-label": L(),
		viewBox: "0 0 24 24",
		role: V(),
		"stroke-width": "1.5",
		stroke: "currentColor",
		fill: "none"
	}));
	var Y = child(J), X = child(Y), Z = child(X), Q = (C) => {
		var T = root_1$80(), E = first_child(T), F = sibling(E), I = sibling(F);
		next(), template_effect(() => {
			var C, T;
			set_attribute(E, "stop-color", O()), set_attribute(F, "offset", `${(C = D()) == null ? "" : C}%`), set_attribute(F, "stop-color", O()), set_attribute(I, "offset", `${(T = D()) == null ? "" : T}%`);
		}), append(C, T);
	}, NL = (C) => {
		var T = root_2$38(), E = first_child(T), D = sibling(E);
		template_effect(() => {
			set_attribute(E, "stop-color", O()), set_attribute(D, "stop-color", O());
		}), append(C, T);
	};
	if_block(Z, (C) => {
		D() === 100 ? C(NL, !1) : C(Q);
	}), reset(X), reset(Y);
	var PL = sibling(Y);
	return reset(J), template_effect(() => {
		set_attribute(X, "id", G), set_attribute(PL, "fill", `url(#${G})`), set_attribute(PL, "stroke", F());
	}), append(C, J), pop(K);
}
create_custom_element(Thumbup, {
	fillPercent: {},
	fillColor: {},
	strokeColor: {},
	size: {},
	ariaLabel: {},
	iconIndex: {},
	groupId: {},
	role: {},
	svgClass: {}
}, [], [], !0);
var root_1$79 = /* @__PURE__ */ from_svg("<stop offset=\"0%\"></stop><stop></stop><stop stop-color=\"transparent\"></stop><stop offset=\"100%\" stop-color=\"transparent\"></stop>", 1), root_2$37 = /* @__PURE__ */ from_svg("<stop offset=\"0%\"></stop><stop offset=\"100%\"></stop>", 1), root$91 = /* @__PURE__ */ from_svg("<svg><defs><linearGradient x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\"><!></linearGradient></defs><path stroke-linecap=\"round\" stroke-linejoin=\"round\"></path></svg>");
function CustomIcon(C, E) {
	push(E, !0);
	let D = prop(E, "fillPercent", 7, 100), O = prop(E, "fillColor", 7, "#00ff00"), F = prop(E, "strokeColor", 7, "#00ff00"), I = prop(E, "size", 7, 24), L = prop(E, "ariaLabel", 7, "custom icon"), z = prop(E, "iconIndex", 7, 0), B = prop(E, "groupId", 7, "custom"), V = prop(E, "role", 7, "img"), U = prop(E, "svgClass", 7), W = prop(E, "pathd", 7, "M21 8.25c0-2.485-2.099-4.5-4.688-4.5-1.935 0-3.597 1.126-4.312 2.733-.715-1.607-2.377-2.733-4.313-2.733C5.1 3.75 3 5.765 3 8.25c0 7.22 9 12 9 12s9-4.78 9-12z"), G = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"fillPercent",
		"fillColor",
		"strokeColor",
		"size",
		"ariaLabel",
		"iconIndex",
		"groupId",
		"role",
		"svgClass",
		"pathd"
	]), K = `${B()}-${z()}`;
	var J = {
		get fillPercent() {
			return D();
		},
		set fillPercent(C = 100) {
			D(C), flushSync();
		},
		get fillColor() {
			return O();
		},
		set fillColor(C = "#00ff00") {
			O(C), flushSync();
		},
		get strokeColor() {
			return F();
		},
		set strokeColor(C = "#00ff00") {
			F(C), flushSync();
		},
		get size() {
			return I();
		},
		set size(C = 24) {
			I(C), flushSync();
		},
		get ariaLabel() {
			return L();
		},
		set ariaLabel(C = "custom icon") {
			L(C), flushSync();
		},
		get iconIndex() {
			return z();
		},
		set iconIndex(C = 0) {
			z(C), flushSync();
		},
		get groupId() {
			return B();
		},
		set groupId(C = "custom") {
			B(C), flushSync();
		},
		get role() {
			return V();
		},
		set role(C = "img") {
			V(C), flushSync();
		},
		get svgClass() {
			return U();
		},
		set svgClass(C) {
			U(C), flushSync();
		},
		get pathd() {
			return W();
		},
		set pathd(C = "M21 8.25c0-2.485-2.099-4.5-4.688-4.5-1.935 0-3.597 1.126-4.312 2.733-.715-1.607-2.377-2.733-4.313-2.733C5.1 3.75 3 5.765 3 8.25c0 7.22 9 12 9 12s9-4.78 9-12z") {
			W(C), flushSync();
		}
	}, Y = root$91();
	attribute_effect(Y, () => _objectSpread2(_objectSpread2({
		width: I(),
		height: I(),
		class: U()
	}, G), {}, {
		"aria-label": L(),
		viewBox: "0 0 24 24",
		role: V(),
		"stroke-width": "1.5"
	}));
	var X = child(Y), Z = child(X), Q = child(Z), NL = (C) => {
		var T = root_1$79(), E = first_child(T), F = sibling(E), I = sibling(F);
		next(), template_effect(() => {
			var C, T;
			set_attribute(E, "stop-color", O()), set_attribute(F, "offset", `${(C = D()) == null ? "" : C}%`), set_attribute(F, "stop-color", O()), set_attribute(I, "offset", `${(T = D()) == null ? "" : T}%`);
		}), append(C, T);
	}, PL = (C) => {
		var T = root_2$37(), E = first_child(T), D = sibling(E);
		template_effect(() => {
			set_attribute(E, "stop-color", O()), set_attribute(D, "stop-color", O());
		}), append(C, T);
	};
	if_block(Q, (C) => {
		D() === 100 ? C(PL, !1) : C(NL);
	}), reset(Z), reset(X);
	var FL = sibling(X);
	return reset(Y), template_effect(() => {
		set_attribute(Z, "id", K), set_attribute(FL, "d", W()), set_attribute(FL, "fill", `url(#${K})`), set_attribute(FL, "stroke", F());
	}), append(C, Y), pop(J);
}
create_custom_element(CustomIcon, {
	fillPercent: {},
	fillColor: {},
	strokeColor: {},
	size: {},
	ariaLabel: {},
	iconIndex: {},
	groupId: {},
	role: {},
	svgClass: {},
	pathd: {}
}, [], [], !0);
const advancedrating = ce({ slots: {
	base: "flex items-center mt-4",
	span: "text-sm font-medium text-gray-600 dark:text-gray-500",
	div2: "mx-4 w-2/4 h-5 bg-gray-200 rounded dark:bg-gray-700",
	div3: "h-5 bg-yellow-400 rounded",
	span2: "text-sm font-medium text-gray-600 dark:text-gray-500"
} }), rating = ce({ slots: {
	base: "flex items-center",
	p: "ms-2 text-sm font-bold text-gray-900 dark:text-white"
} }), review = ce({ slots: {
	article: "md:grid md:grid-cols-3 md:gap-8",
	div: "mb-6 flex items-center space-x-4 rtl:space-x-reverse",
	div2: "space-y-1 font-medium dark:text-white",
	div3: "flex items-center text-sm text-gray-500 dark:text-gray-400",
	img: "h-10 w-10 rounded-full",
	ul: "space-y-4 text-sm text-gray-500 dark:text-gray-400",
	li: "flex items-center"
} }), scorerating = ce({ slots: {
	desc1: "bg-primary-100 w-8 text-primary-800 text-sm font-semibold inline-flex items-center p-1.5 rounded dark:bg-primary-200 dark:text-primary-800",
	desc2: "ms-2 font-medium text-gray-900 dark:text-white",
	desc3: "mx-2 w-1 h-1 mx-2 bg-gray-900 rounded-full dark:bg-gray-500",
	desc3span: "text-sm w-24 font-medium text-gray-500 dark:text-gray-400",
	desc3p: "text-sm w-24 font-medium text-gray-500 dark:text-gray-400",
	link: "ms-auto w-32 text-sm font-medium text-primary-600 hover:underline dark:text-primary-500",
	bar: "bg-primary-600 h-2.5 rounded dark:bg-primary-500"
} });
var root_3$34 = /* @__PURE__ */ from_html("<div role=\"presentation\"></div>"), root_5$15 = /* @__PURE__ */ from_html("<div role=\"presentation\"></div>"), root_7$9 = /* @__PURE__ */ from_html("<div role=\"presentation\" class=\"fixed start-0 top-0 z-50 h-full w-full\"></div>"), root_9$5 = /* @__PURE__ */ from_html("<div role=\"presentation\" class=\"fixed start-0 top-0 z-50 h-full w-full\"></div>"), root_1$78 = /* @__PURE__ */ from_html("<!> <aside><div><!></div></aside>", 1);
function Sidebar(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "isOpen", 7, !1), F = prop(E, "closeSidebar", 7), I = prop(E, "isSingle", 7, !0), L = prop(E, "breakpoint", 7, "md"), z = prop(E, "position", 7, "fixed"), B = prop(E, "activateClickOutside", 7, !0), V = prop(E, "backdrop", 7, !0), U = prop(E, "backdropClass", 7), W = prop(E, "transition", 7, fly), G = prop(E, "params", 7), K = prop(E, "divClass", 7), J = prop(E, "ariaLabel", 7), Y = prop(E, "nonActiveClass", 7), X = prop(E, "activeClass", 7), Z = prop(E, "activeUrl", 7, ""), Q = prop(E, "class", 7), NL = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"isOpen",
		"closeSidebar",
		"isSingle",
		"breakpoint",
		"position",
		"activateClickOutside",
		"backdrop",
		"backdropClass",
		"transition",
		"params",
		"divClass",
		"ariaLabel",
		"nonActiveClass",
		"activeClass",
		"activeUrl",
		"class"
	]), PL = {
		sm: 640,
		md: 768,
		lg: 1024,
		xl: 1280,
		"2xl": 1536
	}, FL = /* @__PURE__ */ state(!1), IL = writable("");
	setContext("activeUrl", IL), user_effect(() => {
		IL.set(Z());
	});
	function LL() {
		set(FL, window.innerWidth >= PL[L()]);
	}
	let RL = /* @__PURE__ */ user_derived(() => sidebar({
		isOpen: O(),
		breakpoint: L(),
		position: z(),
		backdrop: V()
	})), zL = /* @__PURE__ */ user_derived(() => get(RL).base), BL = /* @__PURE__ */ user_derived(() => get(RL).active), VL = /* @__PURE__ */ user_derived(() => get(RL).nonactive), HL = /* @__PURE__ */ user_derived(() => get(RL).div), UL = /* @__PURE__ */ user_derived(() => get(RL).backdrop), WL = {
		get closeSidebar() {
			return F();
		},
		get activeClass() {
			return get(BL)({ class: X() });
		},
		get nonActiveClass() {
			return get(VL)({ class: Y() });
		},
		isSingle: I()
	}, GL = G() ? G() : {
		x: -320,
		duration: 200,
		easing: sineIn
	};
	setContext("sidebarContext", WL), user_effect(() => (LL(), window.addEventListener("resize", LL), () => window.removeEventListener("resize", LL)));
	var KL = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get isOpen() {
			return O();
		},
		set isOpen(C = !1) {
			O(C), flushSync();
		},
		get closeSidebar() {
			return F();
		},
		set closeSidebar(C) {
			F(C), flushSync();
		},
		get isSingle() {
			return I();
		},
		set isSingle(C = !0) {
			I(C), flushSync();
		},
		get breakpoint() {
			return L();
		},
		set breakpoint(C = "md") {
			L(C), flushSync();
		},
		get position() {
			return z();
		},
		set position(C = "fixed") {
			z(C), flushSync();
		},
		get activateClickOutside() {
			return B();
		},
		set activateClickOutside(C = !0) {
			B(C), flushSync();
		},
		get backdrop() {
			return V();
		},
		set backdrop(C = !0) {
			V(C), flushSync();
		},
		get backdropClass() {
			return U();
		},
		set backdropClass(C) {
			U(C), flushSync();
		},
		get transition() {
			return W();
		},
		set transition(C = fly) {
			W(C), flushSync();
		},
		get params() {
			return G();
		},
		set params(C) {
			G(C), flushSync();
		},
		get divClass() {
			return K();
		},
		set divClass(C) {
			K(C), flushSync();
		},
		get ariaLabel() {
			return J();
		},
		set ariaLabel(C) {
			J(C), flushSync();
		},
		get nonActiveClass() {
			return Y();
		},
		set nonActiveClass(C) {
			Y(C), flushSync();
		},
		get activeClass() {
			return X();
		},
		set activeClass(C) {
			X(C), flushSync();
		},
		get activeUrl() {
			return Z();
		},
		set activeUrl(C = "") {
			Z(C), flushSync();
		},
		get class() {
			return Q();
		},
		set class(C) {
			Q(C), flushSync();
		}
	}, qL = comment(), JL = first_child(qL), YL = (C) => {
		var E = root_1$78(), I = first_child(E), L = (C) => {
			var T = comment(), E = first_child(T), D = (C) => {
				var T = root_3$34();
				T.__click = function(...C) {
					var T;
					(T = F()) == null || T.apply(this, C);
				}, template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(UL)({ class: U() }))]), append(C, T);
			}, O = (C) => {
				var T = comment(), E = first_child(T), D = (C) => {
					var T = root_5$15();
					template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(UL)({ class: U() }))]), append(C, T);
				}, O = (C) => {
					var T = comment(), E = first_child(T), D = (C) => {
						var T = root_7$9();
						T.__click = function(...C) {
							var T;
							(T = F()) == null || T.apply(this, C);
						}, append(C, T);
					}, O = (C) => {
						var T = comment(), E = first_child(T), D = (C) => {
							append(C, root_9$5());
						};
						if_block(E, (C) => {
							!V() && !B() && C(D);
						}, !0), append(C, T);
					};
					if_block(E, (C) => {
						!V() && B() ? C(D) : C(O, !1);
					}, !0), append(C, T);
				};
				if_block(E, (C) => {
					V() && !B() ? C(D) : C(O, !1);
				}, !0), append(C, T);
			};
			if_block(E, (C) => {
				V() && B() ? C(D) : C(O, !1);
			}), append(C, T);
		};
		if_block(I, (C) => {
			O() && C(L);
		});
		var z = sibling(I, 2);
		attribute_effect(z, (C) => _objectSpread2(_objectSpread2({}, NL), {}, {
			class: C,
			"aria-label": J()
		}), [() => get(zL)({ className: Q() })]);
		var G = child(z);
		snippet(child(G), D), reset(G), reset(z), template_effect((C) => set_class(G, 1, C), [() => clsx$1(get(HL)({ class: K() }))]), transition(3, z, W, () => GL), append(C, E);
	};
	return if_block(JL, (C) => {
		(O() || get(FL)) && C(YL);
	}), append(C, qL), pop(KL);
}
delegate(["click"]), create_custom_element(Sidebar, {
	children: {},
	isOpen: {},
	closeSidebar: {},
	isSingle: {},
	breakpoint: {},
	position: {},
	activateClickOutside: {},
	backdrop: {},
	backdropClass: {},
	transition: {},
	params: {},
	divClass: {},
	ariaLabel: {},
	nonActiveClass: {},
	activeClass: {},
	activeUrl: {},
	class: {}
}, [], [], !0);
var root_4$20 = /* @__PURE__ */ from_svg("<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 10 6\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9 5 5 1 1 5\"></path></svg>"), root_7$8 = /* @__PURE__ */ from_svg("<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 10 6\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"m1 1 4 4 4-4\"></path></svg>"), root_8$6 = /* @__PURE__ */ from_html("<ul><!></ul>"), root$90 = /* @__PURE__ */ from_html("<li><button><!> <span> </span> <!></button> <!></li>");
function SidebarDropdownWrapper(C, E) {
	push(E, !0);
	let D = () => store_get(UL, "$selected", O), [O, F] = setup_stores(), I = prop(E, "children", 7), L = prop(E, "arrowup", 7), z = prop(E, "arrowdown", 7), B = prop(E, "iconSlot", 7), V = prop(E, "isOpen", 7, !1), U = prop(E, "btnClass", 7), W = prop(E, "label", 7), G = prop(E, "spanClass", 7), K = prop(E, "ulClass", 7), J = prop(E, "transition", 7, slide), Y = prop(E, "params", 7), X = prop(E, "svgClass", 7), Z = prop(E, "class", 7), Q = prop(E, "onclick", 7), NL = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"arrowup",
		"arrowdown",
		"iconSlot",
		"isOpen",
		"btnClass",
		"label",
		"spanClass",
		"ulClass",
		"transition",
		"params",
		"svgClass",
		"class",
		"onclick"
	]), PL = /* @__PURE__ */ user_derived(sidebardropdownwrapper), FL = /* @__PURE__ */ user_derived(() => get(PL).base), IL = /* @__PURE__ */ user_derived(() => get(PL).btn), LL = /* @__PURE__ */ user_derived(() => get(PL).span), RL = /* @__PURE__ */ user_derived(() => get(PL).svg), zL = /* @__PURE__ */ user_derived(() => get(PL).ul), BL = uiHelpers();
	BL.isOpen = V();
	let VL = getContext("sidebarContext") || { isSingle: !1 }, HL = {};
	VL.isSingle && !VL.selected && (VL.selected = writable(null));
	let UL = VL.isSingle ? VL.selected : writable(HL);
	user_effect(() => {
		VL.isSingle ? V(D() === HL) : V(BL.isOpen);
	});
	function WL() {
		VL.isSingle ? UL.update((C) => C === HL ? null : HL) : BL.toggle(), Q() && Q()();
	}
	var GL = {
		get children() {
			return I();
		},
		set children(C) {
			I(C), flushSync();
		},
		get arrowup() {
			return L();
		},
		set arrowup(C) {
			L(C), flushSync();
		},
		get arrowdown() {
			return z();
		},
		set arrowdown(C) {
			z(C), flushSync();
		},
		get iconSlot() {
			return B();
		},
		set iconSlot(C) {
			B(C), flushSync();
		},
		get isOpen() {
			return V();
		},
		set isOpen(C = !1) {
			V(C), flushSync();
		},
		get btnClass() {
			return U();
		},
		set btnClass(C) {
			U(C), flushSync();
		},
		get label() {
			return W();
		},
		set label(C) {
			W(C), flushSync();
		},
		get spanClass() {
			return G();
		},
		set spanClass(C) {
			G(C), flushSync();
		},
		get ulClass() {
			return K();
		},
		set ulClass(C) {
			K(C), flushSync();
		},
		get transition() {
			return J();
		},
		set transition(C = slide) {
			J(C), flushSync();
		},
		get params() {
			return Y();
		},
		set params(C) {
			Y(C), flushSync();
		},
		get svgClass() {
			return X();
		},
		set svgClass(C) {
			X(C), flushSync();
		},
		get class() {
			return Z();
		},
		set class(C) {
			Z(C), flushSync();
		},
		get onclick() {
			return Q();
		},
		set onclick(C) {
			Q(C), flushSync();
		}
	}, KL = root$90(), qL = child(KL);
	attribute_effect(qL, (C) => _objectSpread2(_objectSpread2({}, NL), {}, {
		onclick: WL,
		type: "button",
		class: C,
		"aria-controls": "sidebar-dropdown"
	}), [() => get(IL)({ class: U() })]);
	var JL = child(qL), YL = (C) => {
		var T = comment();
		snippet(first_child(T), B), append(C, T);
	};
	if_block(JL, (C) => {
		B() && C(YL);
	});
	var XL = sibling(JL, 2), ZL = child(XL, !0);
	reset(XL);
	var QL = sibling(XL, 2), $L = (C) => {
		var T = comment(), E = first_child(T), D = (C) => {
			var T = comment();
			snippet(first_child(T), L), append(C, T);
		}, O = (C) => {
			var T = root_4$20();
			template_effect((C) => set_class(T, 0, C), [() => clsx$1(get(RL)({ class: X() }))]), append(C, T);
		};
		if_block(E, (C) => {
			L() ? C(D) : C(O, !1);
		}), append(C, T);
	}, eR = (C) => {
		var T = comment(), E = first_child(T), D = (C) => {
			var T = comment();
			snippet(first_child(T), z), append(C, T);
		}, O = (C) => {
			var T = root_7$8();
			template_effect((C) => set_class(T, 0, C), [() => clsx$1(get(RL)({ class: X() }))]), append(C, T);
		};
		if_block(E, (C) => {
			z() ? C(D) : C(O, !1);
		}, !0), append(C, T);
	};
	if_block(QL, (C) => {
		V() ? C($L) : C(eR, !1);
	}), reset(qL);
	var tR = sibling(qL, 2), nR = (C) => {
		var T = root_8$6();
		snippet(child(T), I), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(zL)({ class: K() }))]), transition(3, T, J, Y), append(C, T);
	};
	if_block(tR, (C) => {
		V() && C(nR);
	}), reset(KL), template_effect((C, T) => {
		set_class(KL, 1, C), set_class(XL, 1, T), set_text(ZL, W());
	}, [() => clsx$1(get(FL)({ className: Z() })), () => clsx$1(get(LL)({ class: G() }))]), append(C, KL);
	var rR = pop(GL);
	return F(), rR;
}
create_custom_element(SidebarDropdownWrapper, {
	children: {},
	arrowup: {},
	arrowdown: {},
	iconSlot: {},
	isOpen: {},
	btnClass: {},
	label: {},
	spanClass: {},
	ulClass: {},
	transition: {},
	params: {},
	svgClass: {},
	class: {},
	onclick: {}
}, [], [], !0);
var root$89 = /* @__PURE__ */ from_html("<ul><!></ul>");
function SidebarGroup(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "class", 7, "space-y-2"), F = prop(E, "borderClass", 7, "pt-4 mt-4 border-t border-gray-200 dark:border-gray-700"), I = prop(E, "border", 7, !1), L = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"class",
		"borderClass",
		"border"
	]);
	var z = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get class() {
			return O();
		},
		set class(C = "space-y-2") {
			O(C), flushSync();
		},
		get borderClass() {
			return F();
		},
		set borderClass(C = "pt-4 mt-4 border-t border-gray-200 dark:border-gray-700") {
			F(C), flushSync();
		},
		get border() {
			return I();
		},
		set border(C = !1) {
			I(C), flushSync();
		}
	}, B = root$89();
	return attribute_effect(B, () => _objectSpread2(_objectSpread2({}, L), {}, { class: I() ? F() : O() })), snippet(child(B), D), reset(B), append(C, B), pop(z);
}
create_custom_element(SidebarGroup, {
	children: {},
	class: {},
	borderClass: {},
	border: {}
}, [], [], !0);
var root$88 = /* @__PURE__ */ from_html("<li><a><!> <span> </span> <!></a></li>");
function SidebarItem(C, E) {
	var D;
	push(E, !0);
	let O = prop(E, "iconSlot", 7), F = prop(E, "subtext", 7), I = prop(E, "href", 7), L = prop(E, "label", 7), z = prop(E, "spanClass", 7, "ms-3"), B = prop(E, "activeClass", 7), V = prop(E, "nonActiveClass", 7), U = prop(E, "aClass", 7), W = prop(E, "active", 7), G = prop(E, "class", 7), K = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"iconSlot",
		"subtext",
		"href",
		"label",
		"spanClass",
		"activeClass",
		"nonActiveClass",
		"aClass",
		"active",
		"class"
	]), J = (D = getContext("sidebarContext")) == null ? {} : D, Y = getContext("activeUrl"), X = /* @__PURE__ */ state("");
	Y.subscribe((C) => {
		set(X, C, !0);
	});
	let Z = /* @__PURE__ */ state(void 0);
	user_effect(() => {
		set(Z, W() === void 0 ? get(X) ? I() === get(X) : !1 : W(), !0);
	});
	let Q = /* @__PURE__ */ user_derived(() => {
		var C, T, E;
		return ((C = get(Z)) == null ? get(X) === I() : C) ? (T = B()) == null ? J.activeClass : T : (E = V()) == null ? J.nonActiveClass : E;
	});
	var NL = {
		get iconSlot() {
			return O();
		},
		set iconSlot(C) {
			O(C), flushSync();
		},
		get subtext() {
			return F();
		},
		set subtext(C) {
			F(C), flushSync();
		},
		get href() {
			return I();
		},
		set href(C) {
			I(C), flushSync();
		},
		get label() {
			return L();
		},
		set label(C) {
			L(C), flushSync();
		},
		get spanClass() {
			return z();
		},
		set spanClass(C = "ms-3") {
			z(C), flushSync();
		},
		get activeClass() {
			return B();
		},
		set activeClass(C) {
			B(C), flushSync();
		},
		get nonActiveClass() {
			return V();
		},
		set nonActiveClass(C) {
			V(C), flushSync();
		},
		get aClass() {
			return U();
		},
		set aClass(C) {
			U(C), flushSync();
		},
		get active() {
			return W();
		},
		set active(C) {
			W(C), flushSync();
		},
		get class() {
			return G();
		},
		set class(C) {
			G(C), flushSync();
		}
	}, PL = root$88(), FL = child(PL);
	attribute_effect(FL, (C) => {
		var E;
		return _objectSpread2(_objectSpread2({ onclick: J.closeSidebar }, K), {}, {
			href: I(),
			"aria-current": ((E = get(Z)) == null ? get(X) === I() : E) ? "page" : void 0,
			class: C
		});
	}, [() => twMerge(get(Q), U())]);
	var IL = child(FL), LL = (C) => {
		var T = comment();
		snippet(first_child(T), O), append(C, T);
	};
	if_block(IL, (C) => {
		O() && C(LL);
	});
	var RL = sibling(IL, 2), zL = child(RL, !0);
	reset(RL);
	var BL = sibling(RL, 2), VL = (C) => {
		var T = comment();
		snippet(first_child(T), F), append(C, T);
	};
	return if_block(BL, (C) => {
		F() && C(VL);
	}), reset(FL), reset(PL), template_effect(() => {
		set_class(PL, 1, clsx$1(G())), set_class(RL, 1, clsx$1(z())), set_text(zL, L());
	}), append(C, PL), pop(NL);
}
create_custom_element(SidebarItem, {
	iconSlot: {},
	subtext: {},
	href: {},
	label: {},
	spanClass: {},
	activeClass: {},
	nonActiveClass: {},
	aClass: {},
	active: {},
	class: {}
}, [], [], !0);
var root$87 = /* @__PURE__ */ from_html("<button><span class=\"sr-only\">Open sidebar</span> <svg class=\"h-6 w-6\" aria-hidden=\"true\" fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path clip-rule=\"evenodd\" fill-rule=\"evenodd\" d=\"M2 4.75A.75.75 0 012.75 4h14.5a.75.75 0 010 1.5H2.75A.75.75 0 012 4.75zm0 10.5a.75.75 0 01.75-.75h7.5a.75.75 0 010 1.5h-7.5a.75.75 0 01-.75-.75zM2 10a.75.75 0 01.75-.75h14.5a.75.75 0 010 1.5H2.75A.75.75 0 012 10z\"></path></svg></button>");
function SidebarButton(C, E) {
	push(E, !0);
	let D = prop(E, "breakpoint", 7, "md"), O = prop(E, "class", 7), F = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"breakpoint",
		"class"
	]), I = /* @__PURE__ */ user_derived(() => sidebarbutton({
		breakpoint: D(),
		className: O()
	}));
	var L = {
		get breakpoint() {
			return D();
		},
		set breakpoint(C = "md") {
			D(C), flushSync();
		},
		get class() {
			return O();
		},
		set class(C) {
			O(C), flushSync();
		}
	}, z = root$87();
	return attribute_effect(z, () => _objectSpread2(_objectSpread2({}, F), {}, {
		type: "button",
		class: get(I)
	})), append(C, z), pop(L);
}
create_custom_element(SidebarButton, {
	breakpoint: {},
	class: {}
}, [], [], !0);
var root$86 = /* @__PURE__ */ from_html("<div><div><span> </span> <!></div> <!></div>");
function SidebarCta(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "icon", 7), F = prop(E, "divClass", 7), I = prop(E, "spanClass", 7), L = prop(E, "label", 7), z = prop(E, "class", 7), B = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"icon",
		"divClass",
		"spanClass",
		"label",
		"class"
	]), V = /* @__PURE__ */ user_derived(sidebarcta), U = /* @__PURE__ */ user_derived(() => get(V).base), W = /* @__PURE__ */ user_derived(() => get(V).div), G = /* @__PURE__ */ user_derived(() => get(V).span);
	var K = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get icon() {
			return O();
		},
		set icon(C) {
			O(C), flushSync();
		},
		get divClass() {
			return F();
		},
		set divClass(C) {
			F(C), flushSync();
		},
		get spanClass() {
			return I();
		},
		set spanClass(C) {
			I(C), flushSync();
		},
		get label() {
			return L();
		},
		set label(C) {
			L(C), flushSync();
		},
		get class() {
			return z();
		},
		set class(C) {
			z(C), flushSync();
		}
	}, J = root$86();
	attribute_effect(J, (C) => _objectSpread2(_objectSpread2({}, B), {}, {
		id: "dropdown-cta",
		class: C,
		role: "alert"
	}), [() => get(U)({ className: z() })]);
	var Y = child(J), X = child(Y), Z = child(X, !0);
	reset(X);
	var Q = sibling(X, 2), NL = (C) => {
		var T = comment();
		snippet(first_child(T), O), append(C, T);
	};
	return if_block(Q, (C) => {
		O() && C(NL);
	}), reset(Y), snippet(sibling(Y, 2), D), reset(J), template_effect((C, T) => {
		set_class(Y, 1, C), set_class(X, 1, T), set_text(Z, L());
	}, [() => clsx$1(get(W)({ class: F() })), () => clsx$1(get(G)({ class: I() }))]), append(C, J), pop(K);
}
create_custom_element(SidebarCta, {
	children: {},
	icon: {},
	divClass: {},
	spanClass: {},
	label: {},
	class: {}
}, [], [], !0);
var root_1$77 = /* @__PURE__ */ from_html("<img/> <span> </span>", 1), root$85 = /* @__PURE__ */ from_html("<a><!></a>");
function SidebarBrand(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "site", 7), F = prop(E, "imgClass", 7), I = prop(E, "spanClass", 7), L = prop(E, "class", 7), z = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"site",
		"imgClass",
		"spanClass",
		"class"
	]), B = /* @__PURE__ */ user_derived(sitebarbrand), V = /* @__PURE__ */ user_derived(() => get(B).base), U = /* @__PURE__ */ user_derived(() => get(B).img), W = /* @__PURE__ */ user_derived(() => get(B).span);
	var G = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get site() {
			return O();
		},
		set site(C) {
			O(C), flushSync();
		},
		get imgClass() {
			return F();
		},
		set imgClass(C) {
			F(C), flushSync();
		},
		get spanClass() {
			return I();
		},
		set spanClass(C) {
			I(C), flushSync();
		},
		get class() {
			return L();
		},
		set class(C) {
			L(C), flushSync();
		}
	}, K = root$85();
	attribute_effect(K, (C) => {
		var E;
		return _objectSpread2(_objectSpread2({}, z), {}, {
			href: (E = O()) != null && E.href ? O().href : "/",
			class: C
		});
	}, [() => get(V)({ className: L() })]);
	var J = child(K), Y = (C) => {
		var T = root_1$77(), E = first_child(T), D = sibling(E, 2), L = child(D, !0);
		reset(D), template_effect((C, T) => {
			set_attribute(E, "src", O().img), set_class(E, 1, C), set_attribute(E, "alt", O().name), set_class(D, 1, T), set_text(L, O().name);
		}, [() => clsx$1(get(U)({ class: F() })), () => clsx$1(get(W)({ class: I() }))]), append(C, T);
	}, X = (C) => {
		var T = comment(), E = first_child(T), O = (C) => {
			var T = comment();
			snippet(first_child(T), D), append(C, T);
		};
		if_block(E, (C) => {
			D() && C(O);
		}, !0), append(C, T);
	};
	return if_block(J, (C) => {
		O() ? C(Y) : C(X, !1);
	}), reset(K), append(C, K), pop(G);
}
create_custom_element(SidebarBrand, {
	children: {},
	site: {},
	imgClass: {},
	spanClass: {},
	class: {}
}, [], [], !0);
const sidebar = ce({
	slots: {
		base: "top-0 left-0 z-50 w-64 transition-transform bg-gray-50 dark:bg-gray-800",
		active: "flex items-center text-base font-normal text-gray-900 bg-gray-200 dark:bg-gray-700 rounded dark:text-white hover:bg-gray-100 dark:hover:bg-gray-700",
		nonactive: "flex items-center text-base font-normal text-gray-900 rounded dark:text-white hover:bg-gray-100 dark:hover:bg-gray-700",
		div: "overflow-y-auto h-full px-3 py-4 overflow-y-auto bg-gray-50 dark:bg-gray-800",
		backdrop: "fixed top-0 start-0 z-40 w-full h-full"
	},
	variants: {
		position: {
			fixed: { base: "fixed" },
			absolute: { base: "absolute" },
			static: { base: "static" }
		},
		isOpen: {
			true: "block",
			false: "hidden"
		},
		breakpoint: {
			sm: { base: "sm:block" },
			md: { base: "md:block" },
			lg: { base: "lg:block" },
			xl: { base: "xl:block" },
			"2xl": { base: "2xl:block" }
		},
		backdrop: { true: { backdrop: "bg-gray-900 bg-opacity-75" } }
	}
}), sidebarbutton = ce({
	base: "inline-flex items-center p-2 mt-2 ms-3 text-sm text-gray-500 rounded-lg hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600",
	variants: { breakpoint: {
		sm: "sm:hidden",
		md: "md:hidden",
		lg: "lg:hidden",
		xl: "xl:hidden",
		"2xl": "2xl:hidden"
	} }
}), sidebarcta = ce({ slots: {
	base: "p-4 mt-6 bg-primary-50 rounded-lg dark:bg-primary-900",
	div: "flex items-center mb-3",
	span: "bg-primary-100 text-primary-800 text-sm font-semibold me-2 px-2.5 py-0.5 rounded dark:bg-primary-200 dark:text-primary-900"
} }), sitebarbrand = ce({ slots: {
	base: "flex items-center ps-2.5 mb-5",
	img: "h-6 me-3 sm:h-7",
	span: "self-center text-xl font-semibold whitespace-nowrap dark:text-white"
} }), sidebardropdownwrapper = ce({ slots: {
	base: "",
	btn: "flex items-center w-full text-base font-normal text-gray-900 rounded transition duration-75 group hover:bg-gray-100 dark:text-white dark:hover:bg-gray-700",
	span: "flex-1 ms-3 text-left whitespace-nowrap",
	svg: "h-3 w-3 text-gray-800 dark:text-white",
	ul: "py-2 space-y-2"
} });
var root$84 = /* @__PURE__ */ from_html("<div><div><svg width=\"48\" height=\"48\" xmlns=\"http://www.w3.org/2000/svg\" aria-hidden=\"true\" fill=\"currentColor\" viewBox=\"0 0 640 512\"><path d=\"M480 80C480 35.82 515.8 0 560 0C604.2 0 640 35.82 640 80C640 124.2 604.2 160 560 160C515.8 160 480 124.2 480 80zM0 456.1C0 445.6 2.964 435.3 8.551 426.4L225.3 81.01C231.9 70.42 243.5 64 256 64C268.5 64 280.1 70.42 286.8 81.01L412.7 281.7L460.9 202.7C464.1 196.1 472.2 192 480 192C487.8 192 495 196.1 499.1 202.7L631.1 419.1C636.9 428.6 640 439.7 640 450.9C640 484.6 612.6 512 578.9 512H55.91C25.03 512 .0006 486.1 .0006 456.1L0 456.1z\"></path></svg></div> <div></div> <div></div> <div></div> <div></div> <div><svg aria-hidden=\"true\" fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" d=\"M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-6-3a2 2 0 11-4 0 2 2 0 014 0zm-2 4a5 5 0 00-4.546 2.916A5.986 5.986 0 0010 16a5.986 5.986 0 004.546-2.084A5 5 0 0010 11z\" clip-rule=\"evenodd\"></path></svg> <div></div> <div></div></div> <span class=\"sr-only\">Loading...</span></div>");
function CardPlaceholder(C, E) {
	push(E, !0);
	let D = prop(E, "size", 7, "sm"), O = prop(E, "class", 7), F = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"size",
		"class"
	]), I = /* @__PURE__ */ user_derived(() => cardPlaceholder({ size: D() })), L = /* @__PURE__ */ user_derived(() => get(I).base), z = /* @__PURE__ */ user_derived(() => get(I).imageArea), B = /* @__PURE__ */ user_derived(() => get(I).imageIcon), V = /* @__PURE__ */ user_derived(() => get(I).line), U = /* @__PURE__ */ user_derived(() => get(I).footerArea);
	var W = {
		get size() {
			return D();
		},
		set size(C = "sm") {
			D(C), flushSync();
		},
		get class() {
			return O();
		},
		set class(C) {
			O(C), flushSync();
		}
	}, G = root$84();
	attribute_effect(G, (C) => _objectSpread2(_objectSpread2({ role: "status" }, F), {}, { class: C }), [() => get(L)({ className: O() })]);
	var K = child(G), J = child(K);
	reset(K);
	var Y = sibling(K, 2), X = sibling(Y, 2), Z = sibling(X, 2), Q = sibling(Z, 2), NL = sibling(Q, 2), PL = child(NL), FL = sibling(PL, 2), IL = sibling(FL, 2);
	return reset(NL), next(2), reset(G), template_effect((C, T, E, D, O, F, I, L, z, B) => {
		set_class(K, 1, C), set_class(J, 0, T), set_class(Y, 1, E), set_class(X, 1, D), set_class(Z, 1, O), set_class(Q, 1, F), set_class(NL, 1, I), set_class(PL, 0, L), set_class(FL, 1, z), set_class(IL, 1, B);
	}, [
		() => clsx$1(get(z)()),
		() => clsx$1(get(B)()),
		() => clsx$1(get(V)({ class: "mb-4 h-2.5 w-1/2" })),
		() => clsx$1(get(V)({ class: "mb-2.5 h-2" })),
		() => clsx$1(get(V)({ class: "mb-2.5 h-2" })),
		() => clsx$1(get(V)({ class: "h-2" })),
		() => clsx$1(get(U)()),
		() => clsx$1(get(V)({ class: "h-14 w-14" })),
		() => clsx$1(get(V)({ class: "mb-2 h-2.5 w-32" })),
		() => clsx$1(get(V)({ class: "mb-2 h-2 w-32" }))
	]), append(C, G), pop(W);
}
create_custom_element(CardPlaceholder, {
	size: {},
	class: {}
}, [], [], !0);
var root$83 = /* @__PURE__ */ from_html("<div><div><svg width=\"48\" height=\"48\" xmlns=\"http://www.w3.org/2000/svg\" aria-hidden=\"true\" fill=\"currentColor\" viewBox=\"0 0 640 512\"><path d=\"M480 80C480 35.82 515.8 0 560 0C604.2 0 640 35.82 640 80C640 124.2 604.2 160 560 160C515.8 160 480 124.2 480 80zM0 456.1C0 445.6 2.964 435.3 8.551 426.4L225.3 81.01C231.9 70.42 243.5 64 256 64C268.5 64 280.1 70.42 286.8 81.01L412.7 281.7L460.9 202.7C464.1 196.1 472.2 192 480 192C487.8 192 495 196.1 499.1 202.7L631.1 419.1C636.9 428.6 640 439.7 640 450.9C640 484.6 612.6 512 578.9 512H55.91C25.03 512 .0006 486.1 .0006 456.1L0 456.1z\"></path></svg></div> <div><div></div> <div></div> <div></div> <div></div> <div></div> <div></div> <div></div></div> <span class=\"sr-only\">Loading...</span></div>");
function ImagePlaceholder(C, E) {
	push(E, !0);
	let D = prop(E, "size", 7, "md"), O = prop(E, "rounded", 7), F = prop(E, "class", 7), I = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"size",
		"rounded",
		"class"
	]), L = /* @__PURE__ */ user_derived(() => imagePlaceholder({
		size: D(),
		rounded: O()
	})), z = /* @__PURE__ */ user_derived(() => get(L).base), B = /* @__PURE__ */ user_derived(() => get(L).image), V = /* @__PURE__ */ user_derived(() => get(L).svg), U = /* @__PURE__ */ user_derived(() => get(L).content), W = /* @__PURE__ */ user_derived(() => get(L).line);
	var G = {
		get size() {
			return D();
		},
		set size(C = "md") {
			D(C), flushSync();
		},
		get rounded() {
			return O();
		},
		set rounded(C) {
			O(C), flushSync();
		},
		get class() {
			return F();
		},
		set class(C) {
			F(C), flushSync();
		}
	}, K = root$83();
	attribute_effect(K, (C) => _objectSpread2(_objectSpread2({ role: "status" }, I), {}, { class: C }), [() => get(z)({ className: F() })]);
	var J = child(K), Y = child(J);
	reset(J);
	var X = sibling(J, 2), Z = child(X), Q = sibling(Z, 2), NL = sibling(Q, 2), PL = sibling(NL, 2), FL = sibling(PL, 2), IL = sibling(FL, 2), LL = sibling(IL, 2);
	return reset(X), next(2), reset(K), template_effect((C, T, E, D, O, F, I, L, z, B) => {
		set_class(J, 1, C), set_class(Y, 0, T), set_class(X, 1, E), set_class(Z, 1, D), set_class(Q, 1, O), set_class(NL, 1, F), set_class(PL, 1, I), set_class(FL, 1, L), set_class(IL, 1, z), set_class(LL, 1, B);
	}, [
		() => clsx$1(get(B)()),
		() => clsx$1(get(V)()),
		() => clsx$1(get(U)()),
		() => clsx$1(get(W)({ class: "mb-4 h-2.5 w-1/2" })),
		() => clsx$1(get(W)({ class: "mb-2.5 h-2 w-9/12" })),
		() => clsx$1(get(W)({ class: "mb-2.5 h-2" })),
		() => clsx$1(get(W)({ class: "mb-2.5 h-2" })),
		() => clsx$1(get(W)({ class: "mb-2.5 h-2 w-10/12" })),
		() => clsx$1(get(W)({ class: "mb-2.5 h-2 w-11/12" })),
		() => clsx$1(get(W)({ class: "h-2 w-9/12" }))
	]), append(C, K), pop(G);
}
create_custom_element(ImagePlaceholder, {
	size: {},
	rounded: {},
	class: {}
}, [], [], !0);
var root_1$76 = /* @__PURE__ */ from_html("<div><div><div></div> <div></div></div> <div></div></div>"), root$82 = /* @__PURE__ */ from_html("<div><!> <span class=\"sr-only\">Loading...</span></div>");
function ListPlaceholder(C, E) {
	push(E, !0);
	let D = prop(E, "itemNumber", 7, 5), O = prop(E, "size", 7, "md"), F = prop(E, "rounded", 7), I = prop(E, "class", 7), L = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"itemNumber",
		"size",
		"rounded",
		"class"
	]), z = /* @__PURE__ */ user_derived(() => listPlaceholder({
		size: O(),
		rounded: F()
	})), B = /* @__PURE__ */ user_derived(() => get(z).base), V = /* @__PURE__ */ user_derived(() => get(z).item), U = /* @__PURE__ */ user_derived(() => get(z).itemContent), W = /* @__PURE__ */ user_derived(() => get(z).itemTitle), G = /* @__PURE__ */ user_derived(() => get(z).itemSubtitle), K = /* @__PURE__ */ user_derived(() => get(z).itemExtra), J = /* @__PURE__ */ user_derived(() => [...Array(D()).keys()]);
	var Y = {
		get itemNumber() {
			return D();
		},
		set itemNumber(C = 5) {
			D(C), flushSync();
		},
		get size() {
			return O();
		},
		set size(C = "md") {
			O(C), flushSync();
		},
		get rounded() {
			return F();
		},
		set rounded(C) {
			F(C), flushSync();
		},
		get class() {
			return I();
		},
		set class(C) {
			I(C), flushSync();
		}
	}, X = root$82();
	return attribute_effect(X, (C) => _objectSpread2(_objectSpread2({ role: "status" }, L), {}, { class: C }), [() => get(B)({ className: I() })]), each(child(X), 17, () => get(J), index, (C, T, E) => {
		var D = root_1$76(), O = child(D), F = child(O), I = sibling(F, 2);
		reset(O);
		var L = sibling(O, 2);
		reset(D), template_effect((C, T, E, z, B) => {
			set_class(D, 1, C), set_class(O, 1, T), set_class(F, 1, E), set_class(I, 1, z), set_class(L, 1, B);
		}, [
			() => clsx$1(get(V)({ class: E > 0 ? "pt-4" : "" })),
			() => clsx$1(get(U)()),
			() => clsx$1(get(W)()),
			() => clsx$1(get(G)()),
			() => clsx$1(get(K)())
		]), append(C, D);
	}), next(2), reset(X), append(C, X), pop(Y);
}
create_custom_element(ListPlaceholder, {
	itemNumber: {},
	size: {},
	rounded: {},
	class: {}
}, [], [], !0);
var root$81 = /* @__PURE__ */ from_html("<div><div></div> <div></div> <div></div> <div></div> <div></div> <div></div> <div></div> <span class=\"sr-only\">Loading...</span></div>");
function Skeleton(C, E) {
	push(E, !0);
	let D = prop(E, "size", 7, "sm"), O = prop(E, "class", 7), F = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"size",
		"class"
	]), I = /* @__PURE__ */ user_derived(() => skeleton({ size: D() })), L = /* @__PURE__ */ user_derived(() => get(I).wrapper), z = /* @__PURE__ */ user_derived(() => get(I).line);
	var B = {
		get size() {
			return D();
		},
		set size(C = "sm") {
			D(C), flushSync();
		},
		get class() {
			return O();
		},
		set class(C) {
			O(C), flushSync();
		}
	}, V = root$81();
	attribute_effect(V, (C) => _objectSpread2(_objectSpread2({ role: "status" }, F), {}, { class: C }), [() => get(L)({ className: O() })]);
	var U = child(V), W = sibling(U, 2), G = sibling(W, 2), K = sibling(G, 2), J = sibling(K, 2), Y = sibling(J, 2), X = sibling(Y, 2);
	return next(2), reset(V), template_effect((C, T, E, D, O, F, I) => {
		set_class(U, 1, C), set_class(W, 1, T), set_class(G, 1, E), set_class(K, 1, D), set_class(J, 1, O), set_class(Y, 1, F), set_class(X, 1, I);
	}, [
		() => clsx$1(get(z)({ class: "mb-4 h-2.5 w-1/2" })),
		() => clsx$1(get(z)({ class: "mb-2.5 h-2 w-9/12" })),
		() => clsx$1(get(z)({ class: "mb-2.5 h-2" })),
		() => clsx$1(get(z)({ class: "mb-2.5 h-2" })),
		() => clsx$1(get(z)({ class: "mb-2.5 h-2 w-10/12" })),
		() => clsx$1(get(z)({ class: "mb-2.5 h-2 w-11/12" })),
		() => clsx$1(get(z)({ class: "h-2 w-9/12" }))
	]), append(C, V), pop(B);
}
create_custom_element(Skeleton, {
	size: {},
	class: {}
}, [], [], !0);
var root$80 = /* @__PURE__ */ from_html("<div><div></div> <div></div> <div><svg aria-hidden=\"true\" fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" d=\"M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-6-3a2 2 0 11-4 0 2 2 0 014 0zm-2 4a5 5 0 00-4.546 2.916A5.986 5.986 0 0010 16a5.986 5.986 0 004.546-2.084A5 5 0 0010 11z\" clip-rule=\"evenodd\"></path></svg> <div></div> <div></div></div> <span class=\"sr-only\">Loading...</span></div>");
function TestimonialPlaceholder(C, E) {
	push(E, !0);
	let D = prop(E, "class", 7), O = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"class"
	]), { wrapper: F, line1: I, line2: L, svg: z, subContent: B } = testimonialPlaceholder();
	var V = {
		get class() {
			return D();
		},
		set class(C) {
			D(C), flushSync();
		}
	}, U = root$80();
	attribute_effect(U, (C) => _objectSpread2(_objectSpread2({ role: "status" }, O), {}, { class: C }), [() => F({ className: D() })]);
	var W = child(U), G = sibling(W, 2), K = sibling(G, 2), J = child(K), Y = sibling(J, 2), X = sibling(Y, 2);
	return reset(K), next(2), reset(U), template_effect((C, T, E, D, O, F) => {
		set_class(W, 1, C), set_class(G, 1, T), set_class(K, 1, E), set_class(J, 0, D), set_class(Y, 1, O), set_class(X, 1, F);
	}, [
		() => clsx$1(L({ class: "mx-auto mb-2.5 h-2.5 max-w-[640px]" })),
		() => clsx$1(L({ class: "mx-auto h-2.5 max-w-[540px]" })),
		() => clsx$1(B()),
		() => clsx$1(z()),
		() => clsx$1(I({ class: "me-3 h-2.5 w-20" })),
		() => clsx$1(I({ class: "h-2 w-24" }))
	]), append(C, U), pop(V);
}
create_custom_element(TestimonialPlaceholder, { class: {} }, [], [], !0);
var root$79 = /* @__PURE__ */ from_html("<div><div><div></div> <div></div> <div></div></div> <div><div></div> <div></div> <div></div></div> <div><div></div> <div></div> <div></div></div> <div><div></div> <div></div> <div></div></div> <div><div></div> <div></div> <div></div></div> <div><div></div> <div></div> <div></div></div> <span class=\"sr-only\">Loading...</span></div>");
function TextPlaceholder(C, E) {
	push(E, !0);
	let D = prop(E, "size", 7, "sm"), O = prop(E, "class", 7), F = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"size",
		"class"
	]), I = /* @__PURE__ */ user_derived(() => textPlaceholder({ size: D() })), L = /* @__PURE__ */ user_derived(() => get(I).baseWrapper), z = /* @__PURE__ */ user_derived(() => get(I).divWrapper), B = /* @__PURE__ */ user_derived(() => get(I).lineA), V = /* @__PURE__ */ user_derived(() => get(I).lineB);
	var U = {
		get size() {
			return D();
		},
		set size(C = "sm") {
			D(C), flushSync();
		},
		get class() {
			return O();
		},
		set class(C) {
			O(C), flushSync();
		}
	}, W = root$79();
	attribute_effect(W, (C) => _objectSpread2(_objectSpread2({ role: "status" }, F), {}, { class: C }), [() => get(L)({ className: O() })]);
	var G = child(W), K = child(G), J = sibling(K, 2), Y = sibling(J, 2);
	reset(G);
	var X = sibling(G, 2), Z = child(X), Q = sibling(Z, 2), NL = sibling(Q, 2);
	reset(X);
	var PL = sibling(X, 2), FL = child(PL), IL = sibling(FL, 2), LL = sibling(IL, 2);
	reset(PL);
	var RL = sibling(PL, 2), zL = child(RL), BL = sibling(zL, 2), VL = sibling(BL, 2);
	reset(RL);
	var HL = sibling(RL, 2), UL = child(HL), WL = sibling(UL, 2), GL = sibling(WL, 2);
	reset(HL);
	var KL = sibling(HL, 2), qL = child(KL), JL = sibling(qL, 2), YL = sibling(JL, 2);
	return reset(KL), next(2), reset(W), template_effect((C, T, E, D, O, F, I, L, z, B, V, U, W, XL, ZL, QL, $L, eR, tR, nR, rR, iR, aR, oR) => {
		set_class(G, 1, C), set_class(K, 1, T), set_class(J, 1, E), set_class(Y, 1, D), set_class(X, 1, O), set_class(Z, 1, F), set_class(Q, 1, I), set_class(NL, 1, L), set_class(PL, 1, z), set_class(FL, 1, B), set_class(IL, 1, V), set_class(LL, 1, U), set_class(RL, 1, W), set_class(zL, 1, XL), set_class(BL, 1, ZL), set_class(VL, 1, QL), set_class(HL, 1, $L), set_class(UL, 1, eR), set_class(WL, 1, tR), set_class(GL, 1, nR), set_class(KL, 1, rR), set_class(qL, 1, iR), set_class(JL, 1, aR), set_class(YL, 1, oR);
	}, [
		() => clsx$1(get(z)({ class: "w-full" })),
		() => clsx$1(get(B)({ class: "h-2.5 w-32" })),
		() => clsx$1(get(V)({ class: "h-2.5 w-24" })),
		() => clsx$1(get(V)({ class: "h-2.5 w-full" })),
		() => clsx$1(get(z)({ class: "w-11/12" })),
		() => clsx$1(get(B)({ class: "h-2.5 w-full" })),
		() => clsx$1(get(V)({ class: "h-2.5 w-full" })),
		() => clsx$1(get(V)({ class: "h-2.5 w-24" })),
		() => clsx$1(get(z)({ class: "w-9/12" })),
		() => clsx$1(get(V)({ class: "h-2.5 w-full" })),
		() => clsx$1(get(B)({ class: "h-2.5 w-80" })),
		() => clsx$1(get(V)({ class: "h-2.5 w-full" })),
		() => clsx$1(get(z)({ class: "w-11/12" })),
		() => clsx$1(get(B)({ class: "h-2.5 w-full" })),
		() => clsx$1(get(V)({ class: "h-2.5 w-full" })),
		() => clsx$1(get(V)({ class: "h-2.5 w-24" })),
		() => clsx$1(get(z)({ class: "w-10/12" })),
		() => clsx$1(get(V)({ class: "h-2.5 w-32" })),
		() => clsx$1(get(V)({ class: "h-2.5 w-24" })),
		() => clsx$1(get(B)({ class: "h-2.5 w-full" })),
		() => clsx$1(get(z)({ class: "w-8/12" })),
		() => clsx$1(get(V)({ class: "h-2.5 w-full" })),
		() => clsx$1(get(B)({ class: "h-2.5 w-80" })),
		() => clsx$1(get(V)({ class: "h-2.5 w-full" }))
	]), append(C, W), pop(U);
}
create_custom_element(TextPlaceholder, {
	size: {},
	class: {}
}, [], [], !0);
var root$78 = /* @__PURE__ */ from_html("<div role=\"status\"><svg width=\"48\" height=\"48\" class=\"text-gray-200 dark:text-gray-600\" xmlns=\"http://www.w3.org/2000/svg\" aria-hidden=\"true\" fill=\"currentColor\" viewBox=\"0 0 384 512\"><path d=\"M361 215C375.3 223.8 384 239.3 384 256C384 272.7 375.3 288.2 361 296.1L73.03 472.1C58.21 482 39.66 482.4 24.52 473.9C9.377 465.4 0 449.4 0 432V80C0 62.64 9.377 46.63 24.52 38.13C39.66 29.64 58.21 29.99 73.03 39.04L361 215z\"></path></svg> <span class=\"sr-only\">Loading...</span></div>");
function VideoPlaceholder(C, T) {
	push(T, !0);
	let E = prop(T, "size", 7, "sm"), D = prop(T, "class", 7), O = /* @__PURE__ */ user_derived(() => videoPlaceholder({
		size: E(),
		className: D()
	}));
	var F = {
		get size() {
			return E();
		},
		set size(C = "sm") {
			E(C), flushSync();
		},
		get class() {
			return D();
		},
		set class(C) {
			D(C), flushSync();
		}
	}, I = root$78();
	return template_effect(() => set_class(I, 1, clsx$1(get(O)))), append(C, I), pop(F);
}
create_custom_element(VideoPlaceholder, {
	size: {},
	class: {}
}, [], [], !0);
var root$77 = /* @__PURE__ */ from_html("<div role=\"status\"><div></div> <div></div> <div><div></div> <div></div> <div></div> <div></div> <div></div> <div></div> <div></div></div> <span class=\"sr-only\">Loading...</span></div>");
function WidgetPlaceholder(C, T) {
	push(T, !0);
	let E = prop(T, "class", 7), { base: D, wrapper: O, vLine: F, hLine: I } = widgetPlaceholder({});
	var L = {
		get class() {
			return E();
		},
		set class(C) {
			E(C), flushSync();
		}
	}, z = root$77(), B = child(z), V = sibling(B, 2), U = sibling(V, 2), W = child(U), G = sibling(W, 2), K = sibling(G, 2), J = sibling(K, 2), Y = sibling(J, 2), X = sibling(Y, 2), Z = sibling(X, 2);
	return reset(U), next(2), reset(z), template_effect((C, T, E, D, O, F, I, L, Q, NL, PL) => {
		set_class(z, 1, C), set_class(B, 1, T), set_class(V, 1, E), set_class(U, 1, D), set_class(W, 1, O), set_class(G, 1, F), set_class(K, 1, I), set_class(J, 1, L), set_class(Y, 1, Q), set_class(X, 1, NL), set_class(Z, 1, PL);
	}, [
		() => clsx$1(D({ className: E() })),
		() => clsx$1(I({ class: "mb-2.5 h-2.5 w-32" })),
		() => clsx$1(I({ class: "mb-10 h-2 w-48" })),
		() => clsx$1(O()),
		() => clsx$1(F({ class: "h-72" })),
		() => clsx$1(F({ class: "h-56" })),
		() => clsx$1(F({ class: "h-72" })),
		() => clsx$1(F({ class: "h-64" })),
		() => clsx$1(F({ class: "h-80" })),
		() => clsx$1(F({ class: "h-72" })),
		() => clsx$1(F({ class: "h-80" }))
	]), append(C, z), pop(L);
}
create_custom_element(WidgetPlaceholder, { class: {} }, [], [], !0);
var cardPlaceholder = ce({
	slots: {
		base: "p-4 rounded border border-gray-200 shadow animate-pulse md:p-6 dark:border-gray-700",
		imageArea: "mb-4 flex h-48 items-center justify-center rounded bg-gray-300 dark:bg-gray-700",
		imageIcon: "text-gray-200 dark:text-gray-600",
		line: "rounded-full bg-gray-200 dark:bg-gray-700",
		footerArea: "mt-4 flex items-center space-x-3 rtl:space-x-reverse"
	},
	variants: { size: {
		sm: { base: "max-w-sm" },
		md: { base: "max-w-md" },
		lg: { base: "max-w-lg" },
		xl: { base: "max-w-xl" },
		"2xl": { base: "max-w-2xl" }
	} }
}), imagePlaceholder = ce({
	slots: {
		base: "space-y-8 animate-pulse md:space-y-0 md:space-x-8 rtl:space-x-reverse md:flex md:items-center",
		image: "flex w-full items-center justify-center rounded bg-gray-300 sm:w-96 dark:bg-gray-700",
		svg: "text-gray-200",
		content: "w-full",
		line: "rounded-full bg-gray-200 dark:bg-gray-700"
	},
	variants: {
		size: {
			sm: {
				image: "h-32",
				content: "space-y-2"
			},
			md: {
				image: "h-48",
				content: "space-y-3"
			},
			lg: {
				image: "h-64",
				content: "space-y-4"
			}
		},
		rounded: {
			none: {
				image: "rounded-none",
				line: "rounded-none"
			},
			sm: {
				image: "rounded-sm",
				line: "rounded-sm"
			},
			md: {
				image: "rounded",
				line: "rounded"
			},
			lg: {
				image: "rounded-lg",
				line: "rounded-lg"
			},
			full: {
				image: "rounded-full",
				line: "rounded-full"
			}
		}
	}
}), listPlaceholder = ce({
	slots: {
		base: "p-4 space-y-4 max-w-md rounded border border-gray-200 divide-y divide-gray-200 shadow animate-pulse dark:divide-gray-700 md:p-6 dark:border-gray-700",
		item: "flex items-center justify-between",
		itemContent: "",
		itemTitle: "mb-2.5 h-2.5 w-24 rounded-full bg-gray-300 dark:bg-gray-600",
		itemSubtitle: "h-2 w-32 rounded-full bg-gray-200 dark:bg-gray-700",
		itemExtra: "h-2.5 w-12 rounded-full bg-gray-300 dark:bg-gray-700"
	},
	variants: {
		size: {
			sm: {
				base: "p-3 space-y-3 max-w-sm md:p-4",
				itemTitle: "mb-2 h-2 w-20",
				itemSubtitle: "h-1.5 w-28",
				itemExtra: "h-2 w-10"
			},
			md: {},
			lg: {
				base: "p-5 space-y-5 max-w-lg md:p-7",
				itemTitle: "mb-3 h-3 w-28",
				itemSubtitle: "h-2.5 w-36",
				itemExtra: "h-3 w-14"
			}
		},
		rounded: {
			none: { base: "rounded-none" },
			sm: { base: "rounded-sm" },
			md: { base: "rounded" },
			lg: { base: "rounded-lg" },
			full: { base: "rounded-full p-8 md:p-16" }
		}
	}
}), skeleton = ce({
	slots: {
		wrapper: "animate-pulse",
		line: "rounded-full bg-gray-200 dark:bg-gray-700"
	},
	variants: { size: {
		sm: { wrapper: "max-w-sm" },
		md: { wrapper: "max-w-md" },
		lg: { wrapper: "max-w-lg" },
		xl: { wrapper: "max-w-xl" },
		"2xl": { wrapper: "max-w-2xl" }
	} }
}), testimonialPlaceholder = ce({ slots: {
	wrapper: "animate-pulse",
	line1: "rounded-full bg-gray-200 dark:bg-gray-700",
	line2: "rounded-full bg-gray-300 dark:bg-gray-700",
	svg: "me-2 h-10 w-10 text-gray-200 dark:text-gray-700",
	subContent: "mt-4 flex items-center justify-center"
} }), textPlaceholder = ce({
	slots: {
		baseWrapper: "space-y-2.5 animate-pulse",
		divWrapper: "flex items-center space-x-2 rtl:space-x-reverse",
		lineA: "rounded-full bg-gray-200 dark:bg-gray-700",
		lineB: "rounded-full bg-gray-300 dark:bg-gray-600"
	},
	variants: { size: {
		sm: { baseWrapper: "max-w-sm" },
		md: { baseWrapper: "max-w-md" },
		lg: { baseWrapper: "max-w-lg" },
		xl: { baseWrapper: "max-w-xl" },
		"2xl": { baseWrapper: "max-w-2xl" }
	} }
}), videoPlaceholder = ce({
	base: "flex justify-center items-center h-56 bg-gray-300 rounded-lg animate-pulse dark:bg-gray-700",
	variants: { size: {
		sm: "max-w-sm",
		md: "max-w-md",
		lg: "max-w-lg",
		xl: "max-w-xl",
		"2xl": "max-w-2xl"
	} }
}), widgetPlaceholder = ce({ slots: {
	base: "p-4 max-w-sm rounded border border-gray-200 shadow animate-pulse md:p-6 dark:border-gray-700",
	wrapper: "mt-4 flex items-baseline space-x-6 rtl:space-x-reverse",
	hLine: "rounded-full bg-gray-200 dark:bg-gray-700",
	vLine: "w-full rounded-t-lg bg-gray-200 dark:bg-gray-700"
} }), root$76 = /* @__PURE__ */ from_svg("<svg><path d=\"M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z\"></path><path d=\"M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z\"></path></svg>");
function Spinner(C, E) {
	push(E, !0);
	let D = prop(E, "color", 7, "primary"), O = prop(E, "size", 7, "8"), F = prop(E, "class", 7), I = prop(E, "currentFill", 7, "currentFill"), L = prop(E, "currentColor", 7, "currentColor"), z = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"color",
		"size",
		"class",
		"currentFill",
		"currentColor"
	]), B = /* @__PURE__ */ user_derived(() => spinner({
		color: D(),
		size: O(),
		className: F()
	}));
	var V = {
		get color() {
			return D();
		},
		set color(C = "primary") {
			D(C), flushSync();
		},
		get size() {
			return O();
		},
		set size(C = "8") {
			O(C), flushSync();
		},
		get class() {
			return F();
		},
		set class(C) {
			F(C), flushSync();
		},
		get currentFill() {
			return I();
		},
		set currentFill(C = "currentFill") {
			I(C), flushSync();
		},
		get currentColor() {
			return L();
		},
		set currentColor(C = "currentColor") {
			L(C), flushSync();
		}
	}, U = root$76();
	attribute_effect(U, () => _objectSpread2(_objectSpread2({}, z), {}, {
		role: "status",
		class: get(B),
		viewBox: "0 0 100 101",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg"
	}));
	var W = child(U), G = sibling(W);
	return reset(U), template_effect(() => {
		set_attribute(W, "fill", L()), set_attribute(G, "fill", I());
	}), append(C, U), pop(V);
}
create_custom_element(Spinner, {
	color: {},
	size: {},
	class: {},
	currentFill: {},
	currentColor: {}
}, [], [], !0);
const spinner = ce({
	base: "inline-block animate-spin text-gray-300",
	variants: {
		color: {
			primary: "fill-primary-600",
			secondary: "fill-secondary-600",
			gray: "fill-gray-600 dark:fill-gray-300",
			red: "fill-red-600",
			orange: "fill-orange-500",
			amber: "fill-amber-500",
			yellow: "fill-yellow-400",
			lime: "fill-lime-500",
			green: "fill-green-500",
			emerald: "fill-emerald-500",
			teal: "fill-teal-500",
			cyan: "fill-cyan-500",
			sky: "fill-sky-500",
			blue: "fill-blue-600",
			indigo: "fill-indigo-600",
			violet: "fill-violet-600",
			purple: "fill-purple-600",
			fuchsia: "fill-fuchsia-600",
			pink: "fill-pink-600",
			rose: "fill-rose-600"
		},
		size: {
			4: "w-4 h-4",
			5: "w-5 h-5",
			6: "w-6 h-6",
			8: "w-8 h-8",
			10: "w-10 h-10",
			12: "w-12 h-12",
			16: "w-16 h-16"
		}
	},
	defaultVariants: {
		color: "primary",
		size: "8"
	}
});
var root_3$33 = /* @__PURE__ */ from_html("<div><div><!></div></div>"), root$75 = /* @__PURE__ */ from_html("<li><button type=\"button\" role=\"tab\"><!></button> <!></li>");
function TabItem(C, E) {
	var D;
	push(E, !0);
	let O = prop(E, "children", 7), F = prop(E, "titleSlot", 7), I = prop(E, "open", 7, !1), L = prop(E, "title", 7, "Tab title"), z = prop(E, "activeClass", 7), B = prop(E, "inactiveClass", 7), V = prop(E, "class", 7), U = prop(E, "disabled", 7), W = prop(E, "tabStyle", 7), G = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"titleSlot",
		"open",
		"title",
		"activeClass",
		"inactiveClass",
		"class",
		"disabled",
		"tabStyle"
	]), K = getContext("ctx"), J = /* @__PURE__ */ user_derived(() => W() ? W() : K.tabStyle || "full"), Y = /* @__PURE__ */ user_derived(() => tabs({
		tabStyle: get(J),
		hasDivider: !0
	})), X = /* @__PURE__ */ user_derived(() => get(Y).active), Z = /* @__PURE__ */ user_derived(() => get(Y).inactive), Q = (D = K.selected) == null ? writable() : D, NL = `tab-${Math.random().toString(36).substring(2)}`;
	function PL(C) {
		return Q.set(C), { destroy: Q.subscribe((T) => {
			T !== C && I(!1);
		}) };
	}
	let FL = /* @__PURE__ */ user_derived(() => tabItem({
		open: I(),
		disabled: U()
	})), IL = /* @__PURE__ */ user_derived(() => get(FL).base), LL = /* @__PURE__ */ user_derived(() => get(FL).button), RL = /* @__PURE__ */ user_derived(() => get(FL).content);
	var zL = {
		get children() {
			return O();
		},
		set children(C) {
			O(C), flushSync();
		},
		get titleSlot() {
			return F();
		},
		set titleSlot(C) {
			F(C), flushSync();
		},
		get open() {
			return I();
		},
		set open(C = !1) {
			I(C), flushSync();
		},
		get title() {
			return L();
		},
		set title(C = "Tab title") {
			L(C), flushSync();
		},
		get activeClass() {
			return z();
		},
		set activeClass(C) {
			z(C), flushSync();
		},
		get inactiveClass() {
			return B();
		},
		set inactiveClass(C) {
			B(C), flushSync();
		},
		get class() {
			return V();
		},
		set class(C) {
			V(C), flushSync();
		},
		get disabled() {
			return U();
		},
		set disabled(C) {
			U(C), flushSync();
		},
		get tabStyle() {
			return W();
		},
		set tabStyle(C) {
			W(C), flushSync();
		}
	}, BL = root$75();
	attribute_effect(BL, (C) => _objectSpread2(_objectSpread2({}, G), {}, {
		class: C,
		role: "presentation"
	}), [() => get(IL)({ class: V() })]);
	var VL = child(BL);
	VL.__click = () => I(!0);
	var HL = child(VL), UL = (C) => {
		var T = comment();
		snippet(first_child(T), F), append(C, T);
	}, WL = (C) => {
		var T = text();
		template_effect(() => set_text(T, L())), append(C, T);
	};
	if_block(HL, (C) => {
		F() ? C(UL) : C(WL, !1);
	}), reset(VL);
	var GL = sibling(VL, 2), KL = (C) => {
		var T = root_3$33(), E = child(T);
		snippet(child(E), O), reset(E), action(E, (C) => PL == null ? void 0 : PL(C)), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(RL)())]), append(C, T);
	};
	return if_block(GL, (C) => {
		I() && O() && C(KL);
	}), reset(BL), template_effect((C) => {
		set_attribute(VL, "id", NL), set_attribute(VL, "aria-controls", K.panelId), set_attribute(VL, "aria-selected", I()), VL.disabled = U(), set_class(VL, 1, C);
	}, [() => {
		var C, T;
		return clsx$1(get(LL)({ class: I() ? (C = z()) == null ? get(X)() : C : (T = B()) == null ? get(Z)() : T }));
	}]), append(C, BL), pop(zL);
}
delegate(["click"]), create_custom_element(TabItem, {
	children: {},
	titleSlot: {},
	open: {},
	title: {},
	activeClass: {},
	inactiveClass: {},
	class: {},
	disabled: {},
	tabStyle: {}
}, [], [], !0);
var root_1$75 = /* @__PURE__ */ from_html("<div></div>"), root$74 = /* @__PURE__ */ from_html("<ul><!></ul> <!> <div role=\"tabpanel\"></div>", 1);
function Tabs$1(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "tabStyle", 7, "none"), F = prop(E, "ulClass", 7), I = prop(E, "contentClass", 7), L = prop(E, "divider", 7, !0), z = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"tabStyle",
		"ulClass",
		"contentClass",
		"divider"
	]), B = /* @__PURE__ */ user_derived(() => tabs({
		tabStyle: O(),
		hasDivider: L()
	})), V = /* @__PURE__ */ user_derived(() => get(B).base), U = /* @__PURE__ */ user_derived(() => get(B).content), W = /* @__PURE__ */ user_derived(() => get(B).divider), G = `tab-panel-${Math.random().toString(36).substring(2)}`, K = {
		get tabStyle() {
			return O();
		},
		selected: writable(),
		panelId: G
	}, J = /* @__PURE__ */ user_derived(() => ["full", "pill"].includes(O()) ? !1 : L());
	setContext("ctx", K);
	function Y(C) {
		return { destroy: K.selected.subscribe((T) => {
			T && C.replaceChildren(T);
		}) };
	}
	var X = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get tabStyle() {
			return O();
		},
		set tabStyle(C = "none") {
			O(C), flushSync();
		},
		get ulClass() {
			return F();
		},
		set ulClass(C) {
			F(C), flushSync();
		},
		get contentClass() {
			return I();
		},
		set contentClass(C) {
			I(C), flushSync();
		},
		get divider() {
			return L();
		},
		set divider(C = !0) {
			L(C), flushSync();
		}
	}, Z = root$74(), Q = first_child(Z);
	attribute_effect(Q, (C) => _objectSpread2(_objectSpread2({}, z), {}, { class: C }), [() => get(V)({ class: F() })]), snippet(child(Q), D), reset(Q);
	var NL = sibling(Q, 2), PL = (C) => {
		var T = root_1$75();
		template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(W)())]), append(C, T);
	};
	if_block(NL, (C) => {
		get(J) && C(PL);
	});
	var FL = sibling(NL, 2);
	return action(FL, (C) => Y == null ? void 0 : Y(C)), template_effect((C) => {
		set_attribute(FL, "id", G), set_class(FL, 1, C), set_attribute(FL, "aria-labelledby", G);
	}, [() => clsx$1(get(U)({ class: I() }))]), append(C, Z), pop(X);
}
create_custom_element(Tabs$1, {
	children: {},
	tabStyle: {},
	ulClass: {},
	contentClass: {},
	divider: {}
}, [], [], !0);
const tabs = ce({
	slots: {
		base: "flex flex-wrap space-x-2 rtl:space-x-reverse",
		content: "p-4 bg-gray-50 rounded-lg dark:bg-gray-800 mt-4",
		divider: "h-px bg-gray-200 dark:bg-gray-700",
		active: "p-4 text-primary-600 bg-gray-100 rounded-t-lg dark:bg-gray-800 dark:text-primary-500",
		inactive: "p-4 text-gray-500 rounded-t-lg hover:text-gray-600 hover:bg-gray-50 dark:text-gray-400 dark:hover:bg-gray-800 dark:hover:text-gray-300"
	},
	variants: {
		tabStyle: {
			full: {
				active: "p-4 w-full rounded-none group-first:rounded-s-lg group-last:rounded-e-lg text-gray-900 bg-gray-100 focus:ring-4 focus:ring-primary-300 focus:outline-none dark:bg-gray-700 dark:text-white",
				inactive: "p-4 w-full rounded-none group-first:rounded-s-lg group-last:rounded-e-lg text-gray-500 dark:text-gray-400 bg-white hover:text-gray-700 hover:bg-gray-50 focus:ring-4 focus:ring-primary-300 focus:outline-none dark:hover:text-white dark:bg-gray-800 dark:hover:bg-gray-700"
			},
			pill: {
				active: "py-3 px-4 text-white bg-primary-600 rounded-lg",
				inactive: "py-3 px-4 text-gray-500 rounded-lg hover:text-gray-900 hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-800 dark:hover:text-white"
			},
			underline: {
				base: "-mb-px",
				active: "p-4 text-primary-600 border-b-2 border-primary-600 dark:text-primary-500 dark:border-primary-500 bg-transparent",
				inactive: "p-4 border-b-2 border-transparent hover:text-gray-600 hover:border-gray-300 dark:hover:text-gray-300 text-gray-500 dark:text-gray-400 bg-transparent"
			},
			none: {
				active: "",
				inactive: ""
			}
		},
		hasDivider: { true: {} }
	},
	compoundVariants: [{
		tabStyle: ["full", "pill"],
		hasDivider: !0,
		class: { divider: "hidden" }
	}],
	defaultVariants: {
		tabStyle: "none",
		hasDivider: !0
	}
}), tabItem = ce({
	slots: {
		base: "group focus-within:z-10",
		button: "inline-block text-sm font-medium text-center disabled:cursor-not-allowed",
		content: "hidden"
	},
	variants: {
		open: { true: { button: "active" } },
		disabled: { true: { button: "cursor-not-allowed" } }
	},
	compoundVariants: [{
		open: !0,
		class: { button: "" }
	}, {
		open: !1,
		class: { button: "" }
	}],
	defaultVariants: {
		open: !1,
		disabled: !1
	}
});
var root_2$36 = /* @__PURE__ */ from_html("<!> <!>", 1), root$73 = /* @__PURE__ */ from_html("<div><table><!><!><!></table></div>");
function Table(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "footerSlot", 7), F = prop(E, "captionSlot", 7), I = prop(E, "tableItems", 7), L = prop(E, "divClass", 7, "relative overflow-x-auto"), z = prop(E, "striped", 7), B = prop(E, "hoverable", 7), V = prop(E, "noborder", 7), U = prop(E, "shadow", 7), W = prop(E, "color", 7, "default"), G = prop(E, "class", 7), K = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"footerSlot",
		"captionSlot",
		"tableItems",
		"divClass",
		"striped",
		"hoverable",
		"noborder",
		"shadow",
		"color",
		"class"
	]), J = /* @__PURE__ */ user_derived(() => table({
		color: W(),
		shadow: U()
	})), Y = /* @__PURE__ */ user_derived(() => get(J).base), X = /* @__PURE__ */ user_derived(() => get(J).table);
	setContext("tableCtx", {
		get striped() {
			return z();
		},
		get hoverable() {
			return B();
		},
		get noborder() {
			return V();
		},
		get color() {
			return W();
		}
	});
	let Z = /* @__PURE__ */ state(proxy([])), Q = /* @__PURE__ */ state(proxy([]));
	I() && (set(Z, Object.keys(I()[0]).map((C) => ({ text: C.charAt(0).toUpperCase() + C.slice(1) })), !0), set(Q, I().map((C) => Object.values(C)), !0));
	var NL = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get footerSlot() {
			return O();
		},
		set footerSlot(C) {
			O(C), flushSync();
		},
		get captionSlot() {
			return F();
		},
		set captionSlot(C) {
			F(C), flushSync();
		},
		get tableItems() {
			return I();
		},
		set tableItems(C) {
			I(C), flushSync();
		},
		get divClass() {
			return L();
		},
		set divClass(C = "relative overflow-x-auto") {
			L(C), flushSync();
		},
		get striped() {
			return z();
		},
		set striped(C) {
			z(C), flushSync();
		},
		get hoverable() {
			return B();
		},
		set hoverable(C) {
			B(C), flushSync();
		},
		get noborder() {
			return V();
		},
		set noborder(C) {
			V(C), flushSync();
		},
		get shadow() {
			return U();
		},
		set shadow(C) {
			U(C), flushSync();
		},
		get color() {
			return W();
		},
		set color(C = "default") {
			W(C), flushSync();
		},
		get class() {
			return G();
		},
		set class(C) {
			G(C), flushSync();
		}
	}, PL = root$73(), FL = child(PL);
	attribute_effect(FL, (C) => _objectSpread2(_objectSpread2({}, K), {}, { class: C }), [() => get(X)({ className: G() })]);
	var IL = child(FL), LL = (C) => {
		var T = comment();
		snippet(first_child(T), F), append(C, T);
	};
	if_block(IL, (C) => {
		F() && C(LL);
	});
	var RL = sibling(IL), zL = (C) => {
		var T = root_2$36(), E = first_child(T);
		TableHead(E, { get headItems() {
			return get(Z);
		} }), TableBody(sibling(E, 2), { get bodyItems() {
			return get(Q);
		} }), append(C, T);
	}, BL = (C) => {
		var T = comment(), E = first_child(T), O = (C) => {
			var T = comment();
			snippet(first_child(T), D), append(C, T);
		};
		if_block(E, (C) => {
			D() && C(O);
		}, !0), append(C, T);
	};
	if_block(RL, (C) => {
		I() ? C(zL) : C(BL, !1);
	});
	var VL = sibling(RL), HL = (C) => {
		var T = comment();
		snippet(first_child(T), O), append(C, T);
	};
	return if_block(VL, (C) => {
		O() && C(HL);
	}), reset(FL), reset(PL), template_effect((C) => set_class(PL, 1, C), [() => clsx$1(get(Y)({ class: L() }))]), append(C, PL), pop(NL);
}
create_custom_element(Table, {
	children: {},
	footerSlot: {},
	captionSlot: {},
	tableItems: {},
	divClass: {},
	striped: {},
	hoverable: {},
	noborder: {},
	shadow: {},
	color: {},
	class: {}
}, [], [], !0);
var root$72 = /* @__PURE__ */ from_html("<tbody><!></tbody>");
function TableBody(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "bodyItems", 7), F = prop(E, "class", 7), I = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"bodyItems",
		"class"
	]);
	function L(C) {
		return Array.isArray(C) ? C : Object.values(C);
	}
	var z = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get bodyItems() {
			return O();
		},
		set bodyItems(C) {
			O(C), flushSync();
		},
		get class() {
			return F();
		},
		set class(C) {
			F(C), flushSync();
		}
	}, B = root$72();
	attribute_effect(B, () => _objectSpread2(_objectSpread2({}, I), {}, { class: F() }));
	var V = child(B), U = (C) => {
		var T = comment();
		each(first_child(T), 17, O, index, (C, T) => {
			TableBodyRow(C, {
				children: (C, E) => {
					var D = comment();
					each(first_child(D), 17, () => L(get(T)), index, (C, T) => {
						TableBodyCell(C, {
							children: (C, E) => {
								next();
								var D = text();
								template_effect(() => {
									var C;
									return set_text(D, (C = get(T)) == null ? "" : C);
								}), append(C, D);
							},
							$$slots: { default: !0 }
						});
					}), append(C, D);
				},
				$$slots: { default: !0 }
			});
		}), append(C, T);
	}, W = (C) => {
		var T = comment(), E = first_child(T), O = (C) => {
			var T = comment();
			snippet(first_child(T), D), append(C, T);
		};
		if_block(E, (C) => {
			D() && C(O);
		}, !0), append(C, T);
	};
	return if_block(V, (C) => {
		O() ? C(U) : C(W, !1);
	}), reset(B), append(C, B), pop(z);
}
create_custom_element(TableBody, {
	children: {},
	bodyItems: {},
	class: {}
}, [], [], !0);
var root_1$74 = /* @__PURE__ */ from_html("<button><!></button>"), root$71 = /* @__PURE__ */ from_html("<td><!></td>");
function TableBodyCell(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "class", 7), F = prop(E, "colspan", 7), I = prop(E, "onclick", 7), L = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"class",
		"colspan",
		"onclick"
	]), z = /* @__PURE__ */ user_derived(() => tablebodycell({ className: O() }));
	var B = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get class() {
			return O();
		},
		set class(C) {
			O(C), flushSync();
		},
		get colspan() {
			return F();
		},
		set colspan(C) {
			F(C), flushSync();
		},
		get onclick() {
			return I();
		},
		set onclick(C) {
			I(C), flushSync();
		}
	}, V = root$71();
	attribute_effect(V, () => {
		var C;
		return _objectSpread2(_objectSpread2({}, L), {}, {
			class: get(z),
			colspan: (C = F()) == null ? 1 : C
		});
	});
	var U = child(V), W = (C) => {
		var T = root_1$74();
		T.__click = function(...C) {
			var T;
			(T = I()) == null || T.apply(this, C);
		};
		var E = child(T), O = (C) => {
			var T = comment();
			snippet(first_child(T), D), append(C, T);
		};
		if_block(E, (C) => {
			D() && C(O);
		}), reset(T), append(C, T);
	}, G = (C) => {
		var T = comment(), E = first_child(T), O = (C) => {
			var T = comment();
			snippet(first_child(T), D), append(C, T);
		};
		if_block(E, (C) => {
			D() && C(O);
		}, !0), append(C, T);
	};
	return if_block(U, (C) => {
		I() ? C(W) : C(G, !1);
	}), reset(V), append(C, V), pop(B);
}
delegate(["click"]), create_custom_element(TableBodyCell, {
	children: {},
	class: {},
	colspan: {},
	onclick: {}
}, [], [], !0);
var root$70 = /* @__PURE__ */ from_html("<tr><!></tr>");
function TableBodyRow(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "class", 7), F = prop(E, "color", 7), I = prop(E, "striped", 7), L = prop(E, "hoverable", 7), z = prop(E, "noborder", 7), B = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"class",
		"color",
		"striped",
		"hoverable",
		"noborder"
	]), V = getContext("tableCtx"), U = /* @__PURE__ */ user_derived(() => F() ? F() : V.color || "default"), W = /* @__PURE__ */ user_derived(() => L() ? L() : V.hoverable || !1), G = /* @__PURE__ */ user_derived(() => I() ? I() : V.striped || !1), K = /* @__PURE__ */ user_derived(() => z() ? z() : V.noborder || !1), J = /* @__PURE__ */ user_derived(() => tablebodyrow({
		color: get(U),
		hoverable: get(W),
		striped: get(G),
		border: get(K),
		className: O()
	}));
	var Y = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get class() {
			return O();
		},
		set class(C) {
			O(C), flushSync();
		},
		get color() {
			return F();
		},
		set color(C) {
			F(C), flushSync();
		},
		get striped() {
			return I();
		},
		set striped(C) {
			I(C), flushSync();
		},
		get hoverable() {
			return L();
		},
		set hoverable(C) {
			L(C), flushSync();
		},
		get noborder() {
			return z();
		},
		set noborder(C) {
			z(C), flushSync();
		}
	}, X = root$70();
	attribute_effect(X, () => _objectSpread2(_objectSpread2({}, B), {}, { class: get(J) }));
	var Z = child(X), Q = (C) => {
		var T = comment();
		snippet(first_child(T), D), append(C, T);
	};
	return if_block(Z, (C) => {
		D() && C(Q);
	}), reset(X), append(C, X), pop(Y);
}
create_custom_element(TableBodyRow, {
	children: {},
	class: {},
	color: {},
	striped: {},
	hoverable: {},
	noborder: {}
}, [], [], !0);
var root$69 = /* @__PURE__ */ from_html("<th><!></th>");
function TableHeadCell(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "class", 7), F = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"class"
	]), I = /* @__PURE__ */ user_derived(() => tableheadcell({ className: O() }));
	var L = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get class() {
			return O();
		},
		set class(C) {
			O(C), flushSync();
		}
	}, z = root$69();
	attribute_effect(z, () => _objectSpread2(_objectSpread2({}, F), {}, { class: get(I) }));
	var B = child(z), V = (C) => {
		var T = comment();
		snippet(first_child(T), D), append(C, T);
	};
	return if_block(B, (C) => {
		D() && C(V);
	}), reset(z), append(C, z), pop(L);
}
create_custom_element(TableHeadCell, {
	children: {},
	class: {}
}, [], [], !0);
var root_1$73 = /* @__PURE__ */ from_html("<!> <tr></tr>", 1), root_7$7 = /* @__PURE__ */ from_html("<tr><!></tr>"), root$68 = /* @__PURE__ */ from_html("<thead><!></thead>");
function TableHead(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "headerSlot", 7), F = prop(E, "color", 7), I = prop(E, "striped", 7), L = prop(E, "noborder", 7), z = prop(E, "class", 7), B = prop(E, "headItems", 7), V = prop(E, "defaultRow", 7, !0), U = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"headerSlot",
		"color",
		"striped",
		"noborder",
		"class",
		"headItems",
		"defaultRow"
	]), W = getContext("tableCtx"), G = /* @__PURE__ */ user_derived(() => F() ? F() : W.color || "default"), K = /* @__PURE__ */ user_derived(() => I() ? I() : W.striped || !1), J = /* @__PURE__ */ user_derived(() => L() ? L() : W.noborder || !1), Y = /* @__PURE__ */ user_derived(() => tablehead({
		color: get(G),
		noborder: get(J),
		striped: get(K),
		className: z()
	}));
	function X(C) {
		return typeof C == "object" && "text" in C ? C.text : String(C);
	}
	var Z = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get headerSlot() {
			return O();
		},
		set headerSlot(C) {
			O(C), flushSync();
		},
		get color() {
			return F();
		},
		set color(C) {
			F(C), flushSync();
		},
		get striped() {
			return I();
		},
		set striped(C) {
			I(C), flushSync();
		},
		get noborder() {
			return L();
		},
		set noborder(C) {
			L(C), flushSync();
		},
		get class() {
			return z();
		},
		set class(C) {
			z(C), flushSync();
		},
		get headItems() {
			return B();
		},
		set headItems(C) {
			B(C), flushSync();
		},
		get defaultRow() {
			return V();
		},
		set defaultRow(C = !0) {
			V(C), flushSync();
		}
	}, Q = root$68();
	attribute_effect(Q, () => _objectSpread2(_objectSpread2({}, U), {}, { class: get(Y) }));
	var NL = child(Q), PL = (C) => {
		var T = root_1$73(), E = first_child(T), D = (C) => {
			var T = comment();
			snippet(first_child(T), O), append(C, T);
		};
		if_block(E, (C) => {
			O() && C(D);
		});
		var F = sibling(E, 2);
		each(F, 21, B, index, (C, T) => {
			TableHeadCell(C, {
				children: (C, E) => {
					next();
					var D = text();
					template_effect((C) => set_text(D, C), [() => X(get(T))]), append(C, D);
				},
				$$slots: { default: !0 }
			});
		}), reset(F), append(C, T);
	}, FL = (C) => {
		var T = comment(), E = first_child(T), O = (C) => {
			var T = comment(), E = first_child(T), O = (C) => {
				var T = root_7$7();
				snippet(child(T), D), reset(T), append(C, T);
			}, F = (C) => {
				var T = comment();
				snippet(first_child(T), D), append(C, T);
			};
			if_block(E, (C) => {
				V() ? C(O) : C(F, !1);
			}), append(C, T);
		};
		if_block(E, (C) => {
			D() && C(O);
		}, !0), append(C, T);
	};
	return if_block(NL, (C) => {
		B() ? C(PL) : C(FL, !1);
	}), reset(Q), append(C, Q), pop(Z);
}
create_custom_element(TableHead, {
	children: {},
	headerSlot: {},
	color: {},
	striped: {},
	noborder: {},
	class: {},
	headItems: {},
	defaultRow: {}
}, [], [], !0);
var root$67 = /* @__PURE__ */ from_html("<div><div><label for=\"table-search\" class=\"sr-only\">Search</label> <div><div><svg fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" d=\"M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z\" clip-rule=\"evenodd\"></path></svg></div> <input type=\"text\" id=\"table-search\"/></div> <!></div> <table><!></table> <!></div>");
function TableSearch(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "header", 7), F = prop(E, "footer", 7), I = prop(E, "divClass", 7, "relative overflow-x-auto shadow-md sm:rounded-lg"), L = prop(E, "inputValue", 15), z = prop(E, "striped", 7), B = prop(E, "hoverable", 7), V = prop(E, "customColor", 7, ""), U = prop(E, "color", 7, "default"), W = prop(E, "innerDivClass", 7, "p-4"), G = prop(E, "inputClass", 7), K = prop(E, "searchClass", 7, "relative mt-1"), J = prop(E, "svgDivClass", 7), Y = prop(E, "svgClass", 7, "w-5 h-5 text-gray-500 dark:text-gray-400"), X = prop(E, "tableClass", 7, "w-full text-left text-sm"), Z = prop(E, "class", 7), Q = prop(E, "placeholder", 7, "Search"), NL = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"header",
		"footer",
		"divClass",
		"inputValue",
		"striped",
		"hoverable",
		"customColor",
		"color",
		"innerDivClass",
		"inputClass",
		"searchClass",
		"svgDivClass",
		"svgClass",
		"tableClass",
		"class",
		"placeholder"
	]), PL = twMerge("bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-80 p-2.5 ps-10 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500", G()), FL = twMerge("absolute inset-y-0 start-0 flex items-center ps-3 pointer-events-none", J()), IL = {
		default: "text-gray-500 dark:text-gray-400",
		blue: "text-blue-100 dark:text-blue-100",
		green: "text-green-100 dark:text-green-100",
		red: "text-red-100 dark:text-red-100",
		yellow: "text-yellow-100 dark:text-yellow-100",
		purple: "text-purple-100 dark:text-purple-100",
		indigo: "text-indigo-100 dark:text-indigo-100",
		pink: "text-pink-100 dark:text-pink-100",
		custom: V()
	};
	setContext("tableCtx", {
		striped: z(),
		hoverable: B(),
		color: U()
	});
	var LL = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get header() {
			return O();
		},
		set header(C) {
			O(C), flushSync();
		},
		get footer() {
			return F();
		},
		set footer(C) {
			F(C), flushSync();
		},
		get divClass() {
			return I();
		},
		set divClass(C = "relative overflow-x-auto shadow-md sm:rounded-lg") {
			I(C), flushSync();
		},
		get inputValue() {
			return L();
		},
		set inputValue(C) {
			L(C), flushSync();
		},
		get striped() {
			return z();
		},
		set striped(C) {
			z(C), flushSync();
		},
		get hoverable() {
			return B();
		},
		set hoverable(C) {
			B(C), flushSync();
		},
		get customColor() {
			return V();
		},
		set customColor(C = "") {
			V(C), flushSync();
		},
		get color() {
			return U();
		},
		set color(C = "default") {
			U(C), flushSync();
		},
		get innerDivClass() {
			return W();
		},
		set innerDivClass(C = "p-4") {
			W(C), flushSync();
		},
		get inputClass() {
			return G();
		},
		set inputClass(C) {
			G(C), flushSync();
		},
		get searchClass() {
			return K();
		},
		set searchClass(C = "relative mt-1") {
			K(C), flushSync();
		},
		get svgDivClass() {
			return J();
		},
		set svgDivClass(C) {
			J(C), flushSync();
		},
		get svgClass() {
			return Y();
		},
		set svgClass(C = "w-5 h-5 text-gray-500 dark:text-gray-400") {
			Y(C), flushSync();
		},
		get tableClass() {
			return X();
		},
		set tableClass(C = "w-full text-left text-sm") {
			X(C), flushSync();
		},
		get class() {
			return Z();
		},
		set class(C) {
			Z(C), flushSync();
		},
		get placeholder() {
			return Q();
		},
		set placeholder(C = "Search") {
			Q(C), flushSync();
		}
	}, RL = root$67(), zL = child(RL), BL = sibling(child(zL), 2), VL = child(BL), HL = child(VL);
	reset(VL);
	var UL = sibling(VL, 2);
	remove_input_defaults(UL), reset(BL);
	var WL = sibling(BL, 2), GL = (C) => {
		var T = comment();
		snippet(first_child(T), O), append(C, T);
	};
	if_block(WL, (C) => {
		O() && C(GL);
	}), reset(zL);
	var KL = sibling(zL, 2);
	attribute_effect(KL, (C) => _objectSpread2(_objectSpread2({}, NL), {}, { class: C }), [() => twMerge(X(), IL[U()], Z())]);
	var qL = child(KL), JL = (C) => {
		var T = comment();
		snippet(first_child(T), D), append(C, T);
	};
	if_block(qL, (C) => {
		D() && C(JL);
	}), reset(KL);
	var YL = sibling(KL, 2), XL = (C) => {
		var T = comment();
		snippet(first_child(T), F), append(C, T);
	};
	return if_block(YL, (C) => {
		F() && C(XL);
	}), reset(RL), template_effect(() => {
		set_class(RL, 1, clsx$1(I())), set_class(zL, 1, clsx$1(W())), set_class(BL, 1, clsx$1(K())), set_class(VL, 1, clsx$1(FL)), set_class(HL, 0, clsx$1(Y())), set_class(UL, 1, clsx$1(PL)), set_attribute(UL, "placeholder", Q());
	}), bind_value(UL, L), append(C, RL), pop(LL);
}
create_custom_element(TableSearch, {
	children: {},
	header: {},
	footer: {},
	divClass: {},
	inputValue: {},
	striped: {},
	hoverable: {},
	customColor: {},
	color: {},
	innerDivClass: {},
	inputClass: {},
	searchClass: {},
	svgDivClass: {},
	svgClass: {},
	tableClass: {},
	class: {},
	placeholder: {}
}, [], [], !0);
const table = ce({
	slots: {
		base: "",
		table: "w-full text-left text-sm"
	},
	variants: {
		color: {
			default: { table: "text-gray-500 dark:text-gray-400" },
			primary: { table: "text-primary-100 dark:text-primary-100" },
			secondary: { table: "text-secondary-100 dark:text-secondary-100" },
			gray: { table: "text-gray-100 dark:text-gray-100" },
			red: { table: "text-red-100 dark:text-red-100" },
			orange: { table: "text-orange-100 dark:text-orange-100" },
			amber: { table: "text-amber-100 dark:text-amber-100" },
			yellow: { table: "text-yellow-100 dark:text-yellow-100" },
			lime: { table: "text-lime-100 dark:text-lime-100" },
			green: { table: "text-green-100 dark:text-green-100" },
			emerald: { table: "text-emerald-100 dark:text-emerald-100" },
			teal: { table: "text-teal-100 dark:text-teal-100" },
			cyan: { table: "text-cyan-100 dark:text-cyan-100" },
			sky: { table: "text-sky-100 dark:text-sky-100" },
			blue: { table: "text-blue-100 dark:text-blue-100" },
			indigo: { table: "text-indigo-100 dark:text-indigo-100" },
			violet: { table: "text-violet-100 dark:text-violet-100" },
			purple: { table: "text-purple-100 dark:text-purple-100" },
			fuchsia: { table: "text-fuchsia-100 dark:text-fuchsia-100" },
			pink: { table: "text-pink-100 dark:text-pink-100" },
			rose: { table: "text-rose-100 dark:text-rose-100" }
		},
		shadow: { true: { base: "shadow-md sm:rounded-lg" } }
	}
}), tablebodyrow = ce({
	base: "",
	variants: {
		color: {
			default: "bg-white dark:bg-gray-800 dark:border-gray-700",
			primary: "bg-white bg-primary-500 border-primary-400",
			secondary: "bg-white bg-secondary-500 border-secondary-400",
			gray: "bg-gray-500 border-gray-400",
			red: "bg-red-500 border-red-400",
			orange: "bg-orange-500 border-orange-400",
			amber: "bg-amber-500 border-amber-400",
			yellow: "bg-yellow-500 border-yellow-400",
			lime: "bg-lime-500 border-lime-400",
			green: "bg-white bg-green-500 border-green-400",
			emerald: "bg-emerald-500 border-emerald-400",
			teal: "bg-teal-500 border-teal-400",
			cyan: "bg-cyan-500 border-cyan-400",
			sky: "bg-sky-500 border-sky-400",
			blue: "bg-white bg-blue-500 border-blue-400",
			indigo: "bg-indigo-500 border-indigo-400",
			violet: "bg-violet-500 border-violet-400",
			purple: "bg-purple-500 border-purple-400",
			fuchsia: "bg-fuchsia-500 border-fuchsia-400",
			pink: "bg-pink-500 border-pink-400",
			rose: "bg-rose-500 border-rose-400"
		},
		hoverable: { true: "" },
		striped: { true: "" },
		border: { true: "border-b last:border-b-0" }
	},
	compoundVariants: [
		{
			hoverable: !0,
			color: "default",
			class: "hover:bg-gray-50 dark:hover:bg-gray-600"
		},
		{
			hoverable: !0,
			color: "primary",
			class: "hover:bg-primary-400 dark:hover:bg-primary-400"
		},
		{
			hoverable: !0,
			color: "secondary",
			class: "hover:bg-secondary-400 dark:hover:bg-secondary-400"
		},
		{
			hoverable: !0,
			color: "gray",
			class: "hover:bg-gray-400 dark:hover:bg-gray-400"
		},
		{
			hoverable: !0,
			color: "red",
			class: "hover:bg-red-400 dark:hover:bg-red-400"
		},
		{
			hoverable: !0,
			color: "orange",
			class: "hover:bg-orange-400 dark:hover:bg-orange-400"
		},
		{
			hoverable: !0,
			color: "amber",
			class: "hover:bg-amber-400 dark:hover:bg-amber-400"
		},
		{
			hoverable: !0,
			color: "yellow",
			class: "hover:bg-yellow-400 dark:hover:bg-yellow-400"
		},
		{
			hoverable: !0,
			color: "lime",
			class: "hover:bg-lime-400 dark:hover:bg-lime-400"
		},
		{
			hoverable: !0,
			color: "green",
			class: "hover:bg-green-400 dark:hover:bg-green-400"
		},
		{
			hoverable: !0,
			color: "emerald",
			class: "hover:bg-emerald-400 dark:hover:bg-emerald-400"
		},
		{
			hoverable: !0,
			color: "teal",
			class: "hover:bg-teal-400 dark:hover:bg-teal-400"
		},
		{
			hoverable: !0,
			color: "cyan",
			class: "hover:bg-cyan-400 dark:hover:bg-cyan-400"
		},
		{
			hoverable: !0,
			color: "sky",
			class: "hover:bg-sky-400 dark:hover:bg-sky-400"
		},
		{
			hoverable: !0,
			color: "blue",
			class: "hover:bg-blue-400 dark:hover:bg-blue-400"
		},
		{
			hoverable: !0,
			color: "indigo",
			class: "hover:bg-indigo-400 dark:hover:bg-indigo-400"
		},
		{
			hoverable: !0,
			color: "violet",
			class: "hover:bg-violet-400 dark:hover:bg-violet-400"
		},
		{
			hoverable: !0,
			color: "purple",
			class: "hover:bg-purple-400 dark:hover:bg-purple-400"
		},
		{
			hoverable: !0,
			color: "fuchsia",
			class: "hover:bg-fuchsia-400 dark:hover:bg-fuchsia-400"
		},
		{
			hoverable: !0,
			color: "pink",
			class: "hover:bg-pink-400 dark:hover:bg-pink-400"
		},
		{
			hoverable: !0,
			color: "rose",
			class: "hover:bg-rose-400 dark:hover:bg-rose-400"
		},
		{
			striped: !0,
			color: "default",
			class: "odd:bg-white even:bg-gray-50 odd:dark:bg-gray-800 even:dark:bg-gray-700"
		},
		{
			striped: !0,
			color: "primary",
			class: "odd:bg-primary-500 even:bg-primary-600 odd:dark:bg-primary-500 even:dark:bg-primary-600"
		},
		{
			striped: !0,
			color: "secondary",
			class: "odd:bg-secondary-500 even:bg-secondary-600 odd:dark:bg-secondary-500 even:dark:bg-secondary-600"
		},
		{
			striped: !0,
			color: "gray",
			class: "odd:bg-gray-500 even:bg-gray-600 odd:dark:bg-gray-500 even:dark:bg-gray-600"
		},
		{
			striped: !0,
			color: "red",
			class: "odd:bg-red-500 even:bg-red-600 odd:dark:bg-red-500 even:dark:bg-red-600"
		},
		{
			striped: !0,
			color: "orange",
			class: "odd:bg-orange-500 even:bg-orange-600 odd:dark:bg-orange-500 even:dark:bg-orange-600"
		},
		{
			striped: !0,
			color: "amber",
			class: "odd:bg-amber-500 even:bg-amber-600 odd:dark:bg-amber-500 even:dark:bg-amber-600"
		},
		{
			striped: !0,
			color: "yellow",
			class: "odd:bg-yellow-500 even:bg-yellow-600 odd:dark:bg-yellow-500 even:dark:bg-yellow-600"
		},
		{
			striped: !0,
			color: "lime",
			class: "odd:bg-lime-500 even:bg-lime-600 odd:dark:bg-lime-500 even:dark:bg-lime-600"
		},
		{
			striped: !0,
			color: "green",
			class: "odd:bg-green-500 even:bg-green-600 odd:dark:bg-green-500 even:dark:bg-green-600"
		},
		{
			striped: !0,
			color: "emerald",
			class: "odd:bg-emerald-500 even:bg-emerald-600 odd:dark:bg-emerald-500 even:dark:bg-emerald-600"
		},
		{
			striped: !0,
			color: "teal",
			class: "odd:bg-teal-500 even:bg-teal-600 odd:dark:bg-teal-500 even:dark:bg-teal-600"
		},
		{
			striped: !0,
			color: "cyan",
			class: "odd:bg-cyan-500 even:bg-cyan-600 odd:dark:bg-cyan-500 even:dark:bg-cyan-600"
		},
		{
			striped: !0,
			color: "sky",
			class: "odd:bg-sky-500 even:bg-sky-600 odd:dark:bg-sky-500 even:dark:bg-sky-600"
		},
		{
			striped: !0,
			color: "blue",
			class: "odd:bg-blue-500 even:bg-blue-600 odd:dark:bg-blue-500 even:dark:bg-blue-600"
		},
		{
			striped: !0,
			color: "indigo",
			class: "odd:bg-indigo-500 even:bg-indigo-600 odd:dark:bg-indigo-500 even:dark:bg-indigo-600"
		},
		{
			striped: !0,
			color: "violet",
			class: "odd:bg-violet-500 even:bg-violet-600 odd:dark:bg-violet-500 even:dark:bg-violet-600"
		},
		{
			striped: !0,
			color: "purple",
			class: "odd:bg-purple-500 even:bg-purple-600 odd:dark:bg-purple-500 even:dark:bg-purple-600"
		},
		{
			striped: !0,
			color: "fuchsia",
			class: "odd:bg-fuchsia-500 even:bg-fuchsia-600 odd:dark:bg-fuchsia-500 even:dark:bg-fuchsia-600"
		},
		{
			striped: !0,
			color: "pink",
			class: "odd:bg-pink-500 even:bg-pink-600 odd:dark:bg-pink-500 even:dark:bg-pink-600"
		},
		{
			striped: !0,
			color: "rose",
			class: "odd:bg-rose-500 even:bg-rose-600 odd:dark:bg-rose-500 even:dark:bg-rose-600"
		}
	]
}), tablehead = ce({
	base: "text-xs uppercase",
	variants: {
		color: {
			default: "text-gray-700 dark:text-gray-400 bg-gray-50 dark:bg-gray-700",
			primary: "text-white dark:text-white bg-primary-700 dark:bg-primary-700",
			secondary: "text-white dark:text-white bg-secondary-700 dark:bg-secondary-700",
			gray: "text-white dark:text-white bg-gray-700 dark:bg-gray-700",
			red: "text-white dark:text-white bg-red-700 dark:bg-red-700",
			orange: "text-white dark:text-white bg-orange-700 dark:bg-orange-700",
			amber: "text-white dark:text-white bg-amber-700 dark:bg-amber-700",
			yellow: "text-white dark:text-white bg-yellow-700 dark:bg-yellow-700",
			lime: "text-white dark:text-white bg-lime-700 dark:bg-lime-700",
			green: "text-white dark:text-white bg-green-700 dark:bg-green-700",
			emerald: "text-white dark:text-white bg-emerald-700 dark:bg-emerald-700",
			teal: "text-white dark:text-white bg-teal-700 dark:bg-teal-700",
			cyan: "text-white dark:text-white bg-cyan-700 dark:bg-cyan-700",
			sky: "text-white dark:text-white bg-sky-700 dark:bg-sky-700",
			blue: "text-white dark:text-white bg-blue-700 dark:bg-blue-700",
			indigo: "text-white dark:text-white bg-indigo-700 dark:bg-indigo-700",
			violet: "text-white dark:text-white bg-violet-700 dark:bg-violet-700",
			purple: "text-white dark:text-white bg-purple-700 dark:bg-purple-700",
			fuchsia: "text-white dark:text-white bg-fuchsia-700 dark:bg-fuchsia-700",
			pink: "text-white dark:text-white bg-pink-700 dark:bg-pink-700",
			rose: "text-white dark:text-white bg-rose-700 dark:bg-rose-700"
		},
		noborder: {
			true: "",
			false: ""
		},
		striped: {
			true: "",
			false: ""
		}
	},
	compoundVariants: [
		{
			color: "default",
			noborder: !0,
			class: "bg-transparent dark:bg-transparent"
		},
		{
			color: "default",
			striped: !0,
			class: "bg-transparent dark:bg-transparent border-gray-700"
		},
		{
			striped: !0,
			color: "blue",
			class: "border-blue-400"
		},
		{
			striped: !0,
			color: "green",
			class: "border-green-400"
		},
		{
			striped: !0,
			color: "red",
			class: "border-red-400"
		},
		{
			striped: !0,
			color: "yellow",
			class: "border-yellow-400"
		},
		{
			striped: !0,
			color: "purple",
			class: "border-purple-400"
		},
		{
			striped: !0,
			color: "indigo",
			class: "border-indigo-400"
		},
		{
			striped: !0,
			color: "pink",
			class: "border-pink-400"
		}
	]
}), tablebodycell = ce({ base: "px-6 py-4 whitespace-nowrap font-medium" }), tableheadcell = ce({ base: "px-6 py-3" });
var root$66 = /* @__PURE__ */ from_html("<ol><!></ol>");
function Activity(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "class", 7), F = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"class"
	]), I = activity({ class: O() });
	var L = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get class() {
			return O();
		},
		set class(C) {
			O(C), flushSync();
		}
	}, z = root$66();
	return attribute_effect(z, () => _objectSpread2(_objectSpread2({}, F), {}, { class: I })), snippet(child(z), D), reset(z), append(C, z), pop(L);
}
create_custom_element(Activity, {
	children: {},
	class: {}
}, [], [], !0);
var root_2$35 = /* @__PURE__ */ from_html("<div><!></div>"), root_1$72 = /* @__PURE__ */ from_html("<li><span><img/></span> <div><div><time> </time> <div><!></div></div> <!></div></li>");
function ActivityItem(C, E) {
	push(E, !0);
	let D = prop(E, "activities", 7), O = prop(E, "liClass", 7), F = prop(E, "spanClass", 7), I = prop(E, "imgClass", 7), L = prop(E, "outerDivClass", 7), z = prop(E, "innerDivClass", 7), B = prop(E, "timeClass", 7), V = prop(E, "titleClass", 7), U = prop(E, "textClass", 7), W = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"activities",
		"liClass",
		"spanClass",
		"imgClass",
		"outerDivClass",
		"innerDivClass",
		"timeClass",
		"titleClass",
		"textClass"
	]), G = /* @__PURE__ */ user_derived(activityitem), K = /* @__PURE__ */ user_derived(() => get(G).li), J = /* @__PURE__ */ user_derived(() => get(G).span), Y = /* @__PURE__ */ user_derived(() => get(G).img), X = /* @__PURE__ */ user_derived(() => get(G).outerDiv), Z = /* @__PURE__ */ user_derived(() => get(G).innerDiv), Q = /* @__PURE__ */ user_derived(() => get(G).time), NL = /* @__PURE__ */ user_derived(() => get(G).title), PL = /* @__PURE__ */ user_derived(() => get(G).text);
	var FL = {
		get activities() {
			return D();
		},
		set activities(C) {
			D(C), flushSync();
		},
		get liClass() {
			return O();
		},
		set liClass(C) {
			O(C), flushSync();
		},
		get spanClass() {
			return F();
		},
		set spanClass(C) {
			F(C), flushSync();
		},
		get imgClass() {
			return I();
		},
		set imgClass(C) {
			I(C), flushSync();
		},
		get outerDivClass() {
			return L();
		},
		set outerDivClass(C) {
			L(C), flushSync();
		},
		get innerDivClass() {
			return z();
		},
		set innerDivClass(C) {
			z(C), flushSync();
		},
		get timeClass() {
			return B();
		},
		set timeClass(C) {
			B(C), flushSync();
		},
		get titleClass() {
			return V();
		},
		set titleClass(C) {
			V(C), flushSync();
		},
		get textClass() {
			return U();
		},
		set textClass(C) {
			U(C), flushSync();
		}
	}, IL = comment();
	return each(first_child(IL), 17, D, index, (C, E) => {
		let D = () => get(E).name, G = () => get(E).date, FL = () => get(E).src, IL = () => get(E).alt, LL = () => get(E).activity;
		var RL = root_1$72();
		attribute_effect(RL, (C) => _objectSpread2(_objectSpread2({}, W), {}, { class: C }), [() => get(K)({ class: O() })]);
		var zL = child(RL), BL = child(zL);
		reset(zL);
		var VL = sibling(zL, 2), HL = child(VL), UL = child(HL), WL = child(UL, !0);
		reset(UL);
		var GL = sibling(UL, 2);
		html(child(GL), D), reset(GL), reset(HL);
		var KL = sibling(HL, 2), qL = (C) => {
			var T = root_2$35();
			html(child(T), LL), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(PL)({ class: U() }))]), append(C, T);
		};
		if_block(KL, (C) => {
			LL() && C(qL);
		}), reset(VL), reset(RL), template_effect((C, T, E, D, O, F) => {
			set_class(zL, 1, C), set_class(BL, 1, T), set_attribute(BL, "src", FL()), set_attribute(BL, "alt", IL()), set_class(VL, 1, E), set_class(HL, 1, D), set_class(UL, 1, O), set_text(WL, G()), set_class(GL, 1, F);
		}, [
			() => clsx$1(get(J)({ class: F() })),
			() => clsx$1(get(Y)({ class: I() })),
			() => clsx$1(get(X)({ class: L() })),
			() => clsx$1(get(Z)({ class: z() })),
			() => clsx$1(get(Q)({ class: B() })),
			() => clsx$1(get(NL)({ class: V() }))
		]), append(C, RL);
	}), append(C, IL), pop(FL);
}
create_custom_element(ActivityItem, {
	activities: {},
	liClass: {},
	spanClass: {},
	imgClass: {},
	outerDivClass: {},
	innerDivClass: {},
	timeClass: {},
	titleClass: {},
	textClass: {}
}, [], [], !0);
var root$65 = /* @__PURE__ */ from_html("<div><time> </time> <ol><!></ol></div>");
function Group(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "divClass", 7), F = prop(E, "timeClass", 7), I = prop(E, "date", 7), L = prop(E, "olClass", 7), z = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"divClass",
		"timeClass",
		"date",
		"olClass"
	]), B = /* @__PURE__ */ user_derived(group), V = /* @__PURE__ */ user_derived(() => get(B).div), U = /* @__PURE__ */ user_derived(() => get(B).time), W = /* @__PURE__ */ user_derived(() => get(B).ol);
	var G = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get divClass() {
			return O();
		},
		set divClass(C) {
			O(C), flushSync();
		},
		get timeClass() {
			return F();
		},
		set timeClass(C) {
			F(C), flushSync();
		},
		get date() {
			return I();
		},
		set date(C) {
			I(C), flushSync();
		},
		get olClass() {
			return L();
		},
		set olClass(C) {
			L(C), flushSync();
		}
	}, K = root$65(), J = child(K), Y = child(J, !0);
	reset(J);
	var X = sibling(J, 2);
	return attribute_effect(X, (C) => _objectSpread2(_objectSpread2({}, z), {}, { class: C }), [() => get(W)({ class: L() })]), snippet(child(X), D), reset(X), reset(K), template_effect((C, T) => {
		set_class(K, 1, C), set_class(J, 1, T), set_text(Y, I());
	}, [() => clsx$1(get(V)({ class: O() })), () => clsx$1(get(U)({ class: F() }))]), append(C, K), pop(G);
}
create_custom_element(Group, {
	children: {},
	divClass: {},
	timeClass: {},
	date: {},
	olClass: {}
}, [], [], !0);
var root_2$34 = /* @__PURE__ */ from_html("<div class=\"text-sm font-normal\"> </div>"), root_3$32 = /* @__PURE__ */ from_svg("<svg class=\"me-1 h-3 w-3\" fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" d=\"M3.707 2.293a1 1 0 00-1.414 1.414l14 14a1 1 0 001.414-1.414l-1.473-1.473A10.014 10.014 0 0019.542 10C18.268 5.943 14.478 3 10 3a9.958 9.958 0 00-4.512 1.074l-1.78-1.781zm4.261 4.26l1.514 1.515a2.003 2.003 0 012.45 2.45l1.514 1.514a4 4 0 00-5.478-5.478z\" clip-rule=\"evenodd\"></path><path d=\"M12.454 16.697L9.75 13.992a4 4 0 01-3.742-3.741L2.335 6.578A9.98 9.98 0 00.458 10c1.274 4.057 5.065 7 9.542 7 .847 0 1.669-.105 2.454-.303z\"></path></svg> Private", 1), root_4$19 = /* @__PURE__ */ from_svg("<svg class=\"me-1 h-3 w-3\" fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" d=\"M4.083 9h1.946c.089-1.546.383-2.97.837-4.118A6.004 6.004 0 004.083 9zM10 2a8 8 0 100 16 8 8 0 000-16zm0 2c-.076 0-.232.032-.465.262-.238.234-.497.623-.737 1.182-.389.907-.673 2.142-.766 3.556h3.936c-.093-1.414-.377-2.649-.766-3.556-.24-.56-.5-.948-.737-1.182C10.232 4.032 10.076 4 10 4zm3.971 5c-.089-1.546-.383-2.97-.837-4.118A6.004 6.004 0 0115.917 9h-1.946zm-2.003 2H8.032c.093 1.414.377 2.649.766 3.556.24.56.5.948.737 1.182.233.23.389.262.465.262.076 0 .232-.032.465-.262.238-.234.498-.623.737-1.182.389-.907.673-2.142.766-3.556zm1.166 4.118c.454-1.147.748-2.572.837-4.118h1.946a6.004 6.004 0 01-2.783 4.118zm-6.268 0C6.412 13.97 6.118 12.546 6.03 11H4.083a6.004 6.004 0 002.783 4.118z\" clip-rule=\"evenodd\"></path></svg> Public", 1), root_1$71 = /* @__PURE__ */ from_html("<li><a><img/> <div><div><!></div> <!> <span><!></span></div></a></li>");
function GroupItem(C, E) {
	push(E, !0);
	let D = prop(E, "timelines", 7), O = prop(E, "aClass", 7), F = prop(E, "imgClass", 7), I = prop(E, "divClass", 7), L = prop(E, "titleClass", 7), z = prop(E, "spanClass", 7), B = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"timelines",
		"aClass",
		"imgClass",
		"divClass",
		"titleClass",
		"spanClass"
	]), V = /* @__PURE__ */ user_derived(groupitem), U = /* @__PURE__ */ user_derived(() => get(V).a), W = /* @__PURE__ */ user_derived(() => get(V).img), G = /* @__PURE__ */ user_derived(() => get(V).div), K = /* @__PURE__ */ user_derived(() => get(V).title), J = /* @__PURE__ */ user_derived(() => get(V).span);
	var Y = {
		get timelines() {
			return D();
		},
		set timelines(C) {
			D(C), flushSync();
		},
		get aClass() {
			return O();
		},
		set aClass(C) {
			O(C), flushSync();
		},
		get imgClass() {
			return F();
		},
		set imgClass(C) {
			F(C), flushSync();
		},
		get divClass() {
			return I();
		},
		set divClass(C) {
			I(C), flushSync();
		},
		get titleClass() {
			return L();
		},
		set titleClass(C) {
			L(C), flushSync();
		},
		get spanClass() {
			return z();
		},
		set spanClass(C) {
			z(C), flushSync();
		}
	}, X = comment();
	return each(first_child(X), 17, D, index, (C, E) => {
		let D = () => get(E).name, V = () => get(E).src, Y = () => get(E).alt, X = () => get(E).isPrivate, Z = () => get(E).href, Q = () => get(E).comment;
		var NL = root_1$71();
		attribute_effect(NL, () => _objectSpread2({}, B));
		var PL = child(NL), FL = child(PL), IL = sibling(FL, 2), LL = child(IL);
		html(child(LL), D), reset(LL);
		var RL = sibling(LL, 2), zL = (C) => {
			var T = root_2$34(), E = child(T, !0);
			reset(T), template_effect(() => set_text(E, Q())), append(C, T);
		};
		if_block(RL, (C) => {
			Q() && C(zL);
		});
		var BL = sibling(RL, 2), VL = child(BL), HL = (C) => {
			var T = root_3$32();
			next(), append(C, T);
		}, UL = (C) => {
			var T = root_4$19();
			next(), append(C, T);
		};
		if_block(VL, (C) => {
			X() ? C(HL) : C(UL, !1);
		}), reset(BL), reset(IL), reset(PL), reset(NL), template_effect((C, T, E, D, O) => {
			set_attribute(PL, "href", Z()), set_class(PL, 1, C), set_class(FL, 1, T), set_attribute(FL, "src", V()), set_attribute(FL, "alt", Y()), set_class(IL, 1, E), set_class(LL, 1, D), set_class(BL, 1, O);
		}, [
			() => clsx$1(get(U)({ class: O() })),
			() => clsx$1(get(W)({ class: F() })),
			() => clsx$1(get(G)({ class: I() })),
			() => clsx$1(get(K)({ class: L() })),
			() => clsx$1(get(J)({ class: z() }))
		]), append(C, NL);
	}), append(C, X), pop(Y);
}
create_custom_element(GroupItem, {
	timelines: {},
	aClass: {},
	imgClass: {},
	divClass: {},
	titleClass: {},
	spanClass: {}
}, [], [], !0);
var root$64 = /* @__PURE__ */ from_html("<ol><!></ol>");
function Timeline(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "order", 7, "default"), F = prop(E, "class", 7), I = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"order",
		"class"
	]);
	setContext("order", O());
	let L = /* @__PURE__ */ user_derived(() => timeline({
		order: O(),
		className: F()
	}));
	var z = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get order() {
			return O();
		},
		set order(C = "default") {
			O(C), flushSync();
		},
		get class() {
			return F();
		},
		set class(C) {
			F(C), flushSync();
		}
	}, B = root$64();
	return attribute_effect(B, () => _objectSpread2(_objectSpread2({}, I), {}, { class: get(L) })), snippet(child(B), D), reset(B), append(C, B), pop(z);
}
create_custom_element(Timeline, {
	children: {},
	order: {},
	class: {}
}, [], [], !0);
var root_3$31 = /* @__PURE__ */ from_svg("<svg aria-hidden=\"true\" fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" d=\"M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z\" clip-rule=\"evenodd\"></path></svg>"), root_5$14 = /* @__PURE__ */ from_html("<time> </time>"), root_6$9 = /* @__PURE__ */ from_html("<h3> </h3>"), root_8$5 = /* @__PURE__ */ from_html("<time> </time>"), root$63 = /* @__PURE__ */ from_html("<li><div></div> <!> <!> <!> <!></li>");
function TimelineItem(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "orientationSlot", 7), F = prop(E, "title", 7), I = prop(E, "date", 7), L = prop(E, "dateFormat", 7, "month-year"), z = prop(E, "svgClass", 7), B = prop(E, "liClass", 7), V = prop(E, "divClass", 7), U = prop(E, "timeClass", 7), W = prop(E, "h3Class", 7), G = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"orientationSlot",
		"title",
		"date",
		"dateFormat",
		"svgClass",
		"liClass",
		"divClass",
		"timeClass",
		"h3Class"
	]), K = getContext("order"), J = /* @__PURE__ */ user_derived(() => timelineitem({ order: K })), Y = /* @__PURE__ */ user_derived(() => get(J).li), X = /* @__PURE__ */ user_derived(() => get(J).div), Z = /* @__PURE__ */ user_derived(() => get(J).time), Q = /* @__PURE__ */ user_derived(() => get(J).h3), NL = /* @__PURE__ */ user_derived(() => get(J).svg);
	function PL(C, T) {
		let E = new Date(C);
		switch (T) {
			case "year": return E.toLocaleDateString(void 0, { year: "numeric" });
			case "month-year": return E.toLocaleDateString(void 0, {
				month: "long",
				year: "numeric"
			});
			case "full-date": return E.toLocaleDateString(void 0, {
				day: "numeric",
				month: "long",
				year: "numeric"
			});
			default: return E.toLocaleDateString(void 0, {
				month: "long",
				year: "numeric"
			});
		}
	}
	var FL = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get orientationSlot() {
			return O();
		},
		set orientationSlot(C) {
			O(C), flushSync();
		},
		get title() {
			return F();
		},
		set title(C) {
			F(C), flushSync();
		},
		get date() {
			return I();
		},
		set date(C) {
			I(C), flushSync();
		},
		get dateFormat() {
			return L();
		},
		set dateFormat(C = "month-year") {
			L(C), flushSync();
		},
		get svgClass() {
			return z();
		},
		set svgClass(C) {
			z(C), flushSync();
		},
		get liClass() {
			return B();
		},
		set liClass(C) {
			B(C), flushSync();
		},
		get divClass() {
			return V();
		},
		set divClass(C) {
			V(C), flushSync();
		},
		get timeClass() {
			return U();
		},
		set timeClass(C) {
			U(C), flushSync();
		},
		get h3Class() {
			return W();
		},
		set h3Class(C) {
			W(C), flushSync();
		}
	}, IL = root$63();
	attribute_effect(IL, (C) => _objectSpread2(_objectSpread2({}, G), {}, { class: C }), [() => get(Y)({ class: B() })]);
	var LL = child(IL), RL = sibling(LL, 2), zL = (C) => {
		var T = comment(), E = first_child(T), D = (C) => {
			var T = comment();
			snippet(first_child(T), O), append(C, T);
		}, F = (C) => {
			var T = root_3$31();
			template_effect((C) => set_class(T, 0, C), [() => clsx$1(get(NL)({ class: z() }))]), append(C, T);
		};
		if_block(E, (C) => {
			O() && (K === "vertical" || K === "horizontal") ? C(D) : C(F, !1);
		}), append(C, T);
	}, BL = (C) => {
		var T = comment(), E = first_child(T), D = (C) => {
			var T = root_5$14(), E = child(T, !0);
			reset(T), template_effect((C, D) => {
				set_attribute(T, "datetime", I()), set_class(T, 1, C), set_text(E, D);
			}, [() => clsx$1(get(Z)({ class: U() })), () => PL(I(), L())]), append(C, T);
		};
		if_block(E, (C) => {
			I() && C(D);
		}, !0), append(C, T);
	};
	if_block(RL, (C) => {
		K === "default" ? C(BL, !1) : C(zL);
	});
	var VL = sibling(RL, 2), HL = (C) => {
		var T = root_6$9(), E = child(T, !0);
		reset(T), template_effect((C) => {
			set_class(T, 1, C), set_text(E, F());
		}, [() => clsx$1(get(Q)({ class: W() }))]), append(C, T);
	};
	if_block(VL, (C) => {
		F() && C(HL);
	});
	var UL = sibling(VL, 2), WL = (C) => {
		var T = comment(), E = first_child(T), D = (C) => {
			var T = root_8$5(), E = child(T, !0);
			reset(T), template_effect((C, D) => {
				set_attribute(T, "datetime", I()), set_class(T, 1, C), set_text(E, D);
			}, [() => clsx$1(get(Z)({ class: U() })), () => PL(I(), L())]), append(C, T);
		};
		if_block(E, (C) => {
			I() && C(D);
		}), append(C, T);
	};
	return if_block(UL, (C) => {
		K !== "default" && C(WL);
	}), snippet(sibling(UL, 2), D), reset(IL), template_effect((C) => set_class(LL, 1, C), [() => clsx$1(get(X)({ class: V() }))]), append(C, IL), pop(FL);
}
create_custom_element(TimelineItem, {
	children: {},
	orientationSlot: {},
	title: {},
	date: {},
	dateFormat: {},
	svgClass: {},
	liClass: {},
	divClass: {},
	timeClass: {},
	h3Class: {}
}, [], [], !0);
const activity = ce({ base: "relative border-s border-gray-200 dark:border-gray-700" }), activityitem = ce({ slots: {
	li: "mb-10 ms-6",
	span: "flex absolute -start-3 justify-center items-center w-6 h-6 bg-blue-200 rounded-full ring-8 ring-white dark:ring-gray-900 dark:bg-blue-900",
	img: "rounded-full shadow-lg",
	outerDiv: "p-4 bg-white rounded-lg border border-gray-200 shadow-sm dark:bg-gray-700 dark:border-gray-600",
	innerDiv: "justify-between items-center mb-3 sm:flex",
	time: "mb-1 text-xs font-normal text-gray-400 sm:order-last sm:mb-0",
	title: "text-sm font-normal text-gray-500 lex dark:text-gray-300",
	text: "p-3 text-xs italic font-normal text-gray-500 bg-gray-50 rounded-lg border border-gray-200 dark:bg-gray-600 dark:border-gray-500 dark:text-gray-300"
} }), group = ce({ slots: {
	div: "p-5 mb-4 bg-gray-50 rounded-lg border border-gray-100 dark:bg-gray-800 dark:border-gray-700",
	time: "text-lg font-semibold text-gray-900 dark:text-white",
	ol: "mt-3 divide-y divider-gray-200 dark:divide-gray-700"
} }), groupitem = ce({ slots: {
	a: "block items-center p-3 sm:flex hover:bg-gray-100 dark:hover:bg-gray-700",
	img: "me-3 mb-3 w-12 h-12 rounded-full sm:mb-0",
	div: "text-gray-600 dark:text-gray-400",
	title: "text-base font-normal",
	span: "inline-flex items-center text-xs font-normal text-gray-500 dark:text-gray-400"
} }), timeline = ce({
	variants: { order: {
		group: "p-5 mb-4 bg-gray-50 rounded-lg border border-gray-100 dark:bg-gray-800 dark:border-gray-700",
		horizontal: "sm:flex",
		activity: "relative border-s border-gray-200 dark:border-gray-700",
		vertical: "relative border-s border-gray-200 dark:border-gray-700",
		default: "relative border-s border-gray-200 dark:border-gray-700"
	} },
	defaultVariants: { order: "default" }
}), timelineitem = ce({
	slots: {
		li: "",
		div: "",
		time: "",
		h3: "",
		svg: "w-3 h-3 text-primary-600 dark:text-primary-400"
	},
	variants: { order: {
		default: {
			li: "mb-10 ms-4",
			div: "absolute w-3 h-3 bg-gray-200 rounded-full mt-1.5 -start-1.5 border border-white dark:border-gray-900 dark:bg-gray-700",
			time: "mb-1 text-sm font-normal leading-none text-gray-400 dark:text-gray-500",
			h3: "text-lg font-semibold text-gray-900 dark:text-white"
		},
		vertical: {
			li: "mb-10 ms-6",
			div: "flex absolute -start-3 justify-center items-center w-6 h-6 bg-primary-200 rounded-full ring-8 ring-white dark:ring-gray-900 dark:bg-primary-900",
			time: "mb-1 text-sm font-normal leading-none text-gray-400 dark:text-gray-500",
			h3: "flex items-center mb-1 text-lg font-semibold text-gray-900 dark:text-white"
		},
		horizontal: {
			li: "relative mb-6 sm:mb-0",
			div: "flex items-center",
			time: "mb-1 text-sm font-normal leading-none text-gray-400 dark:text-gray-500",
			h3: "text-lg font-semibold text-gray-900 dark:text-white"
		},
		activity: {
			li: "mb-10 ms-6",
			div: "flex absolute -start-3 justify-center items-center w-6 h-6 bg-primary-200 rounded-full ring-8 ring-white dark:ring-gray-900 dark:bg-primary-900",
			time: "mb-1 text-sm font-normal leading-none text-gray-400 dark:text-gray-500",
			h3: "text-lg font-semibold text-gray-900 dark:text-white"
		},
		group: {
			li: "",
			div: "p-5 mb-4 bg-gray-50 rounded-lg border border-gray-100 dark:bg-gray-800 dark:border-gray-700",
			time: "text-lg font-semibold text-gray-900 dark:text-white",
			h3: "text-lg font-semibold text-gray-900 dark:text-white"
		}
	} },
	defaultVariants: { order: "default" }
});
var root_2$33 = /* @__PURE__ */ from_html("<div><!></div>"), root_1$70 = /* @__PURE__ */ from_html("<div><!> <div><!></div> <!></div>");
function Toast(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "icon", 7), F = prop(E, "toastStatus", 15, !0), I = prop(E, "dismissable", 7, !0), L = prop(E, "color", 7, "primary"), z = prop(E, "position", 7), B = prop(E, "baseClass", 7), V = prop(E, "iconClass", 7), U = prop(E, "contentClass", 7), W = prop(E, "align", 7, !0), G = prop(E, "params", 7), K = prop(E, "transition", 7, fly), J = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"icon",
		"toastStatus",
		"dismissable",
		"color",
		"position",
		"baseClass",
		"iconClass",
		"contentClass",
		"align",
		"params",
		"transition"
	]), Y = /* @__PURE__ */ user_derived(() => toast({
		color: L(),
		position: z(),
		align: W()
	})), X = /* @__PURE__ */ user_derived(() => get(Y).base), Z = /* @__PURE__ */ user_derived(() => get(Y).icon), Q = /* @__PURE__ */ user_derived(() => get(Y).content), NL = /* @__PURE__ */ user_derived(() => get(Y).close);
	var PL = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get icon() {
			return O();
		},
		set icon(C) {
			O(C), flushSync();
		},
		get toastStatus() {
			return F();
		},
		set toastStatus(C = !0) {
			F(C), flushSync();
		},
		get dismissable() {
			return I();
		},
		set dismissable(C = !0) {
			I(C), flushSync();
		},
		get color() {
			return L();
		},
		set color(C = "primary") {
			L(C), flushSync();
		},
		get position() {
			return z();
		},
		set position(C) {
			z(C), flushSync();
		},
		get baseClass() {
			return B();
		},
		set baseClass(C) {
			B(C), flushSync();
		},
		get iconClass() {
			return V();
		},
		set iconClass(C) {
			V(C), flushSync();
		},
		get contentClass() {
			return U();
		},
		set contentClass(C) {
			U(C), flushSync();
		},
		get align() {
			return W();
		},
		set align(C = !0) {
			W(C), flushSync();
		},
		get params() {
			return G();
		},
		set params(C) {
			G(C), flushSync();
		},
		get transition() {
			return K();
		},
		set transition(C = fly) {
			K(C), flushSync();
		}
	}, FL = comment(), IL = first_child(FL), LL = (C) => {
		var E = root_1$70();
		attribute_effect(E, (C) => _objectSpread2(_objectSpread2({ role: "alert" }, J), {}, { class: C }), [() => get(X)({ class: B() })]);
		var z = child(E), W = (C) => {
			var T = root_2$33();
			snippet(child(T), O), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(Z)({ class: V() }))]), append(C, T);
		};
		if_block(z, (C) => {
			O() && C(W);
		});
		var Y = sibling(z, 2);
		snippet(child(Y), D), reset(Y);
		var PL = sibling(Y, 2), FL = (C) => {
			{
				let T = /* @__PURE__ */ user_derived(() => get(NL)());
				CloseButton(C, {
					get class() {
						return get(T);
					},
					ariaLabel: "Remove toast",
					get color() {
						return L();
					},
					onclick: () => {
						F(!1);
					}
				});
			}
		};
		if_block(PL, (C) => {
			I() && C(FL);
		}), reset(E), template_effect((C) => set_class(Y, 1, C), [() => clsx$1(get(Q)({ class: U() }))]), transition(3, E, K, G), append(C, E);
	};
	return if_block(IL, (C) => {
		F() && C(LL);
	}), append(C, FL), pop(PL);
}
create_custom_element(Toast, {
	children: {},
	icon: {},
	toastStatus: {},
	dismissable: {},
	color: {},
	position: {},
	baseClass: {},
	iconClass: {},
	contentClass: {},
	align: {},
	params: {},
	transition: {}
}, [], [], !0);
const toast = ce({
	slots: {
		base: "flex w-full max-w-xs p-4 text-gray-500 bg-white rounded-lg shadow dark:text-gray-400 dark:bg-gray-800 gap-3",
		icon: "w-8 h-8 inline-flex items-center justify-center shrink-0 rounded-lg",
		content: "w-full text-sm font-normal",
		close: "ms-auto -mx-1.5 -my-1.5 bg-white text-gray-400 hover:text-gray-900 rounded-lg focus:ring-2 focus:ring-gray-300 p-1.5 hover:bg-gray-100 inline-flex items-center justify-center h-8 w-8 dark:text-gray-500 dark:hover:text-white dark:bg-gray-800 dark:hover:bg-gray-700"
	},
	variants: {
		position: {
			"top-left": { base: "absolute top-5 start-5" },
			"top-right": { base: "absolute top-5 end-5" },
			"bottom-left": { base: "absolute bottom-5 start-5" },
			"bottom-right": { base: "absolute bottom-5 end-5" }
		},
		color: {
			primary: {
				icon: "text-primary-500 bg-primary-100 dark:bg-primary-800 dark:text-primary-200",
				close: "text-primary-500 dark:text-primary-200 hover:text-primary-600 dark:hover:text-primary-500"
			},
			gray: {
				icon: "text-gray-500 bg-gray-100 dark:bg-gray-700 dark:text-gray-200",
				close: "text-gray-500 dark:text-gray-200 hover:text-gray-600 dark:hover:text-gray-500"
			},
			red: {
				icon: "text-red-500 bg-red-100 dark:bg-red-800 dark:text-red-200",
				close: "text-red-500 dark:text-red-200 hover:text-red-600 dark:hover:text-red-500"
			},
			orange: {
				icon: "text-orange-500 bg-orange-100 dark:bg-orange-700 dark:text-orange-200",
				close: "text-orange-500 dark:text-orange-200 hover:text-orange-600 dark:hover:text-orange-500"
			},
			amber: {
				icon: "text-amber-500 bg-amber-100 dark:bg-amber-700 dark:text-amber-200",
				close: "text-amber-500 dark:text-amber-200 hover:text-amber-600 dark:hover:text-amber-500"
			},
			yellow: {
				icon: "text-yellow-500 bg-yellow-100 dark:bg-yellow-800 dark:text-yellow-200",
				close: "text-yellow-500 dark:text-yellow-200 hover:text-yellow-600 dark:hover:text-yellow-500"
			},
			lime: {
				icon: "text-lime-500 bg-lime-100 dark:bg-lime-700 dark:text-lime-200",
				close: "text-lime-500 dark:text-lime-200 hover:text-lime-600 dark:hover:text-lime-500"
			},
			green: {
				icon: "text-green-500 bg-green-100 dark:bg-green-800 dark:text-green-200",
				close: "text-green-500 dark:text-green-200 hover:text-green-600 dark:hover:text-green-500"
			},
			emerald: {
				icon: "text-emerald-500 bg-emerald-100 dark:bg-emerald-800 dark:text-emerald-200",
				close: "text-emerald-500 dark:text-emerald-200 hover:text-emerald-600 dark:hover:text-emerald-500"
			},
			teal: {
				icon: "text-teal-500 bg-teal-100 dark:bg-teal-800 dark:text-teal-200",
				close: "text-teal-500 dark:text-teal-200 hover:text-teal-600 dark:hover:text-teal-500"
			},
			cyan: {
				icon: "text-cyan-500 bg-cyan-100 dark:bg-cyan-800 dark:text-cyan-200",
				close: "text-cyan-500 dark:text-cyan-200 hover:text-cyan-600 dark:hover:text-cyan-500"
			},
			sky: {
				icon: "text-sky-500 bg-sky-100 dark:bg-sky-800 dark:text-sky-200",
				close: "text-sky-500 dark:text-sky-200 hover:text-sky-600 dark:hover:text-sky-500"
			},
			blue: {
				icon: "text-blue-500 bg-blue-100 dark:bg-blue-800 dark:text-blue-200",
				close: "text-blue-500 dark:text-blue-200 hover:text-blue-600 dark:hover:text-blue-500"
			},
			indigo: {
				icon: "text-indigo-500 bg-indigo-100 dark:bg-indigo-800 dark:text-indigo-200",
				close: "text-indigo-500 dark:text-indigo-200 hover:text-indigo-600 dark:hover:text-indigo-500"
			},
			violet: {
				icon: "text-violet-500 bg-violet-100 dark:bg-violet-800 dark:text-violet-200",
				close: "text-violet-500 dark:text-violet-200 hover:text-violet-600 dark:hover:text-violet-500"
			},
			purple: {
				icon: "text-purple-500 bg-purple-100 dark:bg-purple-800 dark:text-purple-200",
				close: "text-purple-500 dark:text-purple-200 hover:text-purple-600 dark:hover:text-purple-500"
			},
			fuchsia: {
				icon: "text-fuchsia-500 bg-fuchsia-100 dark:bg-fuchsia-800 dark:text-fuchsia-200",
				close: "text-fuchsia-500 dark:text-fuchsia-200 hover:text-fuchsia-600 dark:hover:text-fuchsia-500"
			},
			pink: {
				icon: "text-pink-500 bg-pink-100 dark:bg-pink-700 dark:text-pink-200",
				close: "text-pink-500 dark:text-pink-200 hover:text-pink-600 dark:hover:text-pink-500"
			},
			rose: {
				icon: "text-rose-500 bg-rose-100 dark:bg-rose-700 dark:text-rose-200",
				close: "text-rose-500 dark:text-rose-200 hover:text-rose-600 dark:hover:text-rose-500"
			}
		},
		align: {
			true: { base: "items-center" },
			false: { base: "items-start" }
		}
	}
});
var root$62 = /* @__PURE__ */ from_html("<div><div><!></div> <!></div>");
function Toolbar(C, E) {
	push(E, !0);
	let D = () => store_get(W, "$separators", O), [O, F] = setup_stores(), I = prop(E, "children", 7), L = prop(E, "end", 7), z = prop(E, "color", 7, "default"), B = prop(E, "embedded", 7), V = prop(E, "class", 7), U = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"end",
		"color",
		"embedded",
		"class"
	]), W = writable(!1);
	setContext("toolbar", W);
	let G = /* @__PURE__ */ user_derived(() => B() ? "default" : z()), K = /* @__PURE__ */ user_derived(() => toolbar({
		color: get(G),
		embedded: B(),
		separators: D()
	})), J = /* @__PURE__ */ user_derived(() => get(K).base), Y = /* @__PURE__ */ user_derived(() => get(K).content);
	var X = {
		get children() {
			return I();
		},
		set children(C) {
			I(C), flushSync();
		},
		get end() {
			return L();
		},
		set end(C) {
			L(C), flushSync();
		},
		get color() {
			return z();
		},
		set color(C = "default") {
			z(C), flushSync();
		},
		get embedded() {
			return B();
		},
		set embedded(C) {
			B(C), flushSync();
		},
		get class() {
			return V();
		},
		set class(C) {
			V(C), flushSync();
		}
	}, Z = root$62();
	attribute_effect(Z, (C) => _objectSpread2(_objectSpread2({}, U), {}, { class: C }), [() => get(J)({ className: V() })]);
	var Q = child(Z);
	snippet(child(Q), I), reset(Q);
	var NL = sibling(Q, 2), PL = (C) => {
		var T = comment();
		snippet(first_child(T), L), append(C, T);
	};
	if_block(NL, (C) => {
		L() && C(PL);
	}), reset(Z), template_effect((C) => set_class(Q, 1, C), [() => clsx$1(get(Y)())]), append(C, Z);
	var FL = pop(X);
	return F(), FL;
}
create_custom_element(Toolbar, {
	children: {},
	end: {},
	color: {},
	embedded: {},
	class: {}
}, [], [], !0);
var root_2$32 = /* @__PURE__ */ from_html("<span class=\"sr-only\"> </span>"), root_1$69 = /* @__PURE__ */ from_html("<a><!> <!></a>"), root_4$18 = /* @__PURE__ */ from_html("<span class=\"sr-only\"> </span>"), root_3$30 = /* @__PURE__ */ from_html("<button><!> <!></button>");
function ToolbarButton(C, E) {
	push(E, !0);
	let D = getContext("background"), O = prop(E, "children", 7), F = prop(E, "color", 7, "default"), I = prop(E, "name", 7), L = prop(E, "ariaLabel", 7), z = prop(E, "size", 7, "md"), B = prop(E, "href", 7), V = prop(E, "class", 7), U = prop(E, "onclick", 7), W = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"color",
		"name",
		"ariaLabel",
		"size",
		"href",
		"class",
		"onclick"
	]), G = /* @__PURE__ */ user_derived(() => toolbarButton({
		color: F(),
		size: z(),
		background: !!D,
		class: V()
	}));
	var K = {
		get children() {
			return O();
		},
		set children(C) {
			O(C), flushSync();
		},
		get color() {
			return F();
		},
		set color(C = "default") {
			F(C), flushSync();
		},
		get name() {
			return I();
		},
		set name(C) {
			I(C), flushSync();
		},
		get ariaLabel() {
			return L();
		},
		set ariaLabel(C) {
			L(C), flushSync();
		},
		get size() {
			return z();
		},
		set size(C = "md") {
			z(C), flushSync();
		},
		get href() {
			return B();
		},
		set href(C) {
			B(C), flushSync();
		},
		get class() {
			return V();
		},
		set class(C) {
			V(C), flushSync();
		},
		get onclick() {
			return U();
		},
		set onclick(C) {
			U(C), flushSync();
		}
	}, J = comment(), Y = first_child(J), X = (C) => {
		var E = root_1$69();
		attribute_effect(E, () => {
			var C;
			return _objectSpread2(_objectSpread2({ href: B() }, W), {}, {
				class: get(G),
				"aria-label": (C = L()) == null ? I() : C
			});
		});
		var D = child(E), F = (C) => {
			var T = root_2$32(), E = child(T, !0);
			reset(T), template_effect(() => set_text(E, I())), append(C, T);
		};
		if_block(D, (C) => {
			I() && C(F);
		}), snippet(sibling(D, 2), O), reset(E), append(C, E);
	}, Z = (C) => {
		var E = root_3$30();
		attribute_effect(E, () => {
			var C;
			return _objectSpread2(_objectSpread2({
				onclick: U(),
				type: "button"
			}, W), {}, {
				class: get(G),
				"aria-label": (C = L()) == null ? I() : C
			});
		});
		var D = child(E), F = (C) => {
			var T = root_4$18(), E = child(T, !0);
			reset(T), template_effect(() => set_text(E, I())), append(C, T);
		};
		if_block(D, (C) => {
			I() && C(F);
		}), snippet(sibling(D, 2), O), reset(E), append(C, E);
	};
	return if_block(Y, (C) => {
		B() ? C(X) : C(Z, !1);
	}), append(C, J), pop(K);
}
create_custom_element(ToolbarButton, {
	children: {},
	color: {},
	name: {},
	ariaLabel: {},
	size: {},
	href: {},
	class: {},
	onclick: {}
}, [], [], !0);
var root$61 = /* @__PURE__ */ from_html("<div><!></div>");
function ToolbarGroup(C, E) {
	push(E, !0);
	let [D, O] = setup_stores(), F = prop(E, "children", 7), I = prop(E, "spacing", 7, "default"), L = prop(E, "padding", 7, "default"), z = prop(E, "position", 7, "middle"), B = prop(E, "class", 7), V = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"spacing",
		"padding",
		"position",
		"class"
	]), U = /* @__PURE__ */ user_derived(() => toolbarGroup({
		spacing: I(),
		padding: L(),
		position: z(),
		class: B()
	})), W = getContext("toolbar");
	W && store_set(W, !0);
	var G = {
		get children() {
			return F();
		},
		set children(C) {
			F(C), flushSync();
		},
		get spacing() {
			return I();
		},
		set spacing(C = "default") {
			I(C), flushSync();
		},
		get padding() {
			return L();
		},
		set padding(C = "default") {
			L(C), flushSync();
		},
		get position() {
			return z();
		},
		set position(C = "middle") {
			z(C), flushSync();
		},
		get class() {
			return B();
		},
		set class(C) {
			B(C), flushSync();
		}
	}, K = root$61();
	attribute_effect(K, () => _objectSpread2(_objectSpread2({}, V), {}, { class: get(U) })), snippet(child(K), F), reset(K), append(C, K);
	var J = pop(G);
	return O(), J;
}
create_custom_element(ToolbarGroup, {
	children: {},
	spacing: {},
	padding: {},
	position: {},
	class: {}
}, [], [], !0);
const toolbar = ce({
	slots: {
		base: "flex justify-between items-center",
		content: "flex flex-wrap items-center"
	},
	variants: {
		embedded: {
			true: {},
			false: { base: "py-2 px-3" }
		},
		color: {
			default: {},
			primary: { base: "bg-primary-100 text-primary-800" },
			secondary: { base: "bg-secondary-100 text-secondary-800" }
		},
		separators: { true: { content: "sm:divide-x rtl:divide-x-reverse" } }
	},
	compoundVariants: [{
		embedded: !0,
		color: "default",
		class: { base: "bg-transparent" }
	}]
}), toolbarGroup = ce({
	base: "flex items-center",
	variants: {
		spacing: {
			default: "space-x-1 rtl:space-x-reverse",
			tight: "space-x-0.5 rtl:space-x-reverse",
			loose: "space-x-2 rtl:space-x-reverse"
		},
		padding: {
			default: "sm:pe-4 sm:ps-4",
			none: ""
		},
		position: {
			middle: "",
			first: "sm:ps-0",
			last: "sm:pe-0"
		}
	},
	compoundVariants: [{
		position: ["first", "last"],
		class: "sm:px-0"
	}]
}), toolbarButton = ce({
	base: "focus:outline-none whitespace-normal",
	variants: {
		color: {
			dark: "text-gray-500 hover:text-gray-900 hover:bg-gray-200 dark:text-gray-400 dark:hover:text-white dark:hover:bg-gray-600",
			gray: "text-gray-500 focus:ring-gray-400 hover:bg-gray-200 dark:hover:bg-gray-800 dark:hover:text-gray-300",
			red: "text-red-500 focus:ring-red-400 hover:bg-red-200 dark:hover:bg-red-800 dark:hover:text-red-300",
			yellow: "text-yellow-500 focus:ring-yellow-400 hover:bg-yellow-200 dark:hover:bg-yellow-800 dark:hover:text-yellow-300",
			green: "text-green-500 focus:ring-green-400 hover:bg-green-200 dark:hover:bg-green-800 dark:hover:text-green-300",
			indigo: "text-indigo-500 focus:ring-indigo-400 hover:bg-indigo-200 dark:hover:bg-indigo-800 dark:hover:text-indigo-300",
			purple: "text-purple-500 focus:ring-purple-400 hover:bg-purple-200 dark:hover:bg-purple-800 dark:hover:text-purple-300",
			pink: "text-pink-500 focus:ring-pink-400 hover:bg-pink-200 dark:hover:bg-pink-800 dark:hover:text-pink-300",
			blue: "text-blue-500 focus:ring-blue-400 hover:bg-blue-200 dark:hover:bg-blue-800 dark:hover:text-blue-300",
			primary: "text-primary-500 focus:ring-primary-400 hover:bg-primary-200 dark:hover:bg-primary-800 dark:hover:text-primary-300",
			default: "focus:ring-gray-400 hover:bg-gray-100"
		},
		size: {
			xs: "m-0.5 rounded-sm focus:ring-1 p-0.5",
			sm: "m-0.5 rounded focus:ring-1 p-0.5",
			md: "m-0.5 rounded-lg focus:ring-2 p-1.5",
			lg: "m-0.5 rounded-lg focus:ring-2 p-2.5"
		},
		background: {
			true: "",
			false: ""
		}
	},
	compoundVariants: [{
		color: "default",
		background: !0,
		class: "dark:hover:bg-gray-600"
	}, {
		color: "default",
		background: !1,
		class: "dark:hover:bg-gray-700"
	}]
});
var min = Math.min, max = Math.max, round = Math.round, floor = Math.floor, createCoords = (C) => ({
	x: C,
	y: C
}), oppositeSideMap = {
	left: "right",
	right: "left",
	bottom: "top",
	top: "bottom"
}, oppositeAlignmentMap = {
	start: "end",
	end: "start"
};
function clamp$1(C, T, E) {
	return max(C, min(T, E));
}
function evaluate(C, T) {
	return typeof C == "function" ? C(T) : C;
}
function getSide(C) {
	return C.split("-")[0];
}
function getAlignment(C) {
	return C.split("-")[1];
}
function getOppositeAxis(C) {
	return C === "x" ? "y" : "x";
}
function getAxisLength(C) {
	return C === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(C) {
	return yAxisSides.has(getSide(C)) ? "y" : "x";
}
function getAlignmentAxis(C) {
	return getOppositeAxis(getSideAxis(C));
}
function getAlignmentSides(C, T, E) {
	E === void 0 && (E = !1);
	let D = getAlignment(C), O = getAlignmentAxis(C), F = getAxisLength(O), I = O === "x" ? D === (E ? "end" : "start") ? "right" : "left" : D === "start" ? "bottom" : "top";
	return T.reference[F] > T.floating[F] && (I = getOppositePlacement(I)), [I, getOppositePlacement(I)];
}
function getExpandedPlacements(C) {
	let T = getOppositePlacement(C);
	return [
		getOppositeAlignmentPlacement(C),
		T,
		getOppositeAlignmentPlacement(T)
	];
}
function getOppositeAlignmentPlacement(C) {
	return C.replace(/start|end/g, (C) => oppositeAlignmentMap[C]);
}
var lrPlacement = ["left", "right"], rlPlacement = ["right", "left"], tbPlacement = ["top", "bottom"], btPlacement = ["bottom", "top"];
function getSideList(C, T, E) {
	switch (C) {
		case "top":
		case "bottom": return E ? T ? rlPlacement : lrPlacement : T ? lrPlacement : rlPlacement;
		case "left":
		case "right": return T ? tbPlacement : btPlacement;
		default: return [];
	}
}
function getOppositeAxisPlacements(C, T, E, D) {
	let O = getAlignment(C), F = getSideList(getSide(C), E === "start", D);
	return O && (F = F.map((C) => C + "-" + O), T && (F = F.concat(F.map(getOppositeAlignmentPlacement)))), F;
}
function getOppositePlacement(C) {
	return C.replace(/left|right|bottom|top/g, (C) => oppositeSideMap[C]);
}
function expandPaddingObject(C) {
	return _objectSpread2({
		top: 0,
		right: 0,
		bottom: 0,
		left: 0
	}, C);
}
function getPaddingObject(C) {
	return typeof C == "number" ? {
		top: C,
		right: C,
		bottom: C,
		left: C
	} : expandPaddingObject(C);
}
function rectToClientRect(C) {
	let { x: T, y: E, width: D, height: O } = C;
	return {
		width: D,
		height: O,
		top: E,
		left: T,
		right: T + D,
		bottom: E + O,
		x: T,
		y: E
	};
}
var _excluded2 = [
	"mainAxis",
	"crossAxis",
	"fallbackPlacements",
	"fallbackStrategy",
	"fallbackAxisSideDirection",
	"flipAlignment"
], _excluded4 = [
	"mainAxis",
	"crossAxis",
	"limiter"
];
function computeCoordsFromPlacement(C, T, E) {
	let { reference: D, floating: O } = C, F = getSideAxis(T), I = getAlignmentAxis(T), L = getAxisLength(I), z = getSide(T), B = F === "y", V = D.x + D.width / 2 - O.width / 2, U = D.y + D.height / 2 - O.height / 2, W = D[L] / 2 - O[L] / 2, G;
	switch (z) {
		case "top":
			G = {
				x: V,
				y: D.y - O.height
			};
			break;
		case "bottom":
			G = {
				x: V,
				y: D.y + D.height
			};
			break;
		case "right":
			G = {
				x: D.x + D.width,
				y: U
			};
			break;
		case "left":
			G = {
				x: D.x - O.width,
				y: U
			};
			break;
		default: G = {
			x: D.x,
			y: D.y
		};
	}
	switch (getAlignment(T)) {
		case "start":
			G[I] -= W * (E && B ? -1 : 1);
			break;
		case "end":
			G[I] += W * (E && B ? -1 : 1);
			break;
	}
	return G;
}
var computePosition$1 = function() {
	var C = _asyncToGenerator(function* (C, E, D) {
		let { placement: O = "bottom", strategy: F = "absolute", middleware: I = [], platform: L } = D, z = I.filter(Boolean), B = yield L.isRTL == null ? void 0 : L.isRTL(E), V = yield L.getElementRects({
			reference: C,
			floating: E,
			strategy: F
		}), { x: U, y: W } = computeCoordsFromPlacement(V, O, B), G = O, K = {}, J = 0;
		for (let D = 0; D < z.length; D++) {
			let { name: I, fn: Y } = z[D], { x: X, y: Z, data: Q, reset: NL } = yield Y({
				x: U,
				y: W,
				initialPlacement: O,
				placement: G,
				strategy: F,
				middlewareData: K,
				rects: V,
				platform: L,
				elements: {
					reference: C,
					floating: E
				}
			});
			U = X == null ? U : X, W = Z == null ? W : Z, K = _objectSpread2(_objectSpread2({}, K), {}, { [I]: _objectSpread2(_objectSpread2({}, K[I]), Q) }), NL && J <= 50 && (J++, typeof NL == "object" && (NL.placement && (G = NL.placement), NL.rects && (V = NL.rects === !0 ? yield L.getElementRects({
				reference: C,
				floating: E,
				strategy: F
			}) : NL.rects), {x: U, y: W} = computeCoordsFromPlacement(V, G, B)), D = -1);
		}
		return {
			x: U,
			y: W,
			placement: G,
			strategy: F,
			middlewareData: K
		};
	});
	return function(T, E, D) {
		return C.apply(this, arguments);
	};
}();
function detectOverflow(C, T) {
	return _detectOverflow.apply(this, arguments);
}
function _detectOverflow() {
	return _detectOverflow = _asyncToGenerator(function* (C, T) {
		var E;
		T === void 0 && (T = {});
		let { x: D, y: O, platform: F, rects: I, elements: L, strategy: z } = C, { boundary: B = "clippingAncestors", rootBoundary: V = "viewport", elementContext: U = "floating", altBoundary: W = !1, padding: G = 0 } = evaluate(T, C), K = getPaddingObject(G), J = L[W ? U === "floating" ? "reference" : "floating" : U], Y = rectToClientRect(yield F.getClippingRect({
			element: (E = yield F.isElement == null ? void 0 : F.isElement(J)) == null || E ? J : J.contextElement || (yield F.getDocumentElement == null ? void 0 : F.getDocumentElement(L.floating)),
			boundary: B,
			rootBoundary: V,
			strategy: z
		})), X = U === "floating" ? {
			x: D,
			y: O,
			width: I.floating.width,
			height: I.floating.height
		} : I.reference, Z = yield F.getOffsetParent == null ? void 0 : F.getOffsetParent(L.floating), Q = (yield F.isElement == null ? void 0 : F.isElement(Z)) && (yield F.getScale == null ? void 0 : F.getScale(Z)) || {
			x: 1,
			y: 1
		}, NL = rectToClientRect(F.convertOffsetParentRelativeRectToViewportRelativeRect ? yield F.convertOffsetParentRelativeRectToViewportRelativeRect({
			elements: L,
			rect: X,
			offsetParent: Z,
			strategy: z
		}) : X);
		return {
			top: (Y.top - NL.top + K.top) / Q.y,
			bottom: (NL.bottom - Y.bottom + K.bottom) / Q.y,
			left: (Y.left - NL.left + K.left) / Q.x,
			right: (NL.right - Y.right + K.right) / Q.x
		};
	}), _detectOverflow.apply(this, arguments);
}
var arrow$1 = (C) => ({
	name: "arrow",
	options: C,
	fn(E) {
		return _asyncToGenerator(function* () {
			let { x: D, y: O, placement: F, rects: I, platform: L, elements: z, middlewareData: B } = E, { element: V, padding: U = 0 } = evaluate(C, E) || {};
			if (V == null) return {};
			let W = getPaddingObject(U), G = {
				x: D,
				y: O
			}, K = getAlignmentAxis(F), J = getAxisLength(K), Y = yield L.getDimensions(V), X = K === "y", Z = X ? "top" : "left", Q = X ? "bottom" : "right", NL = X ? "clientHeight" : "clientWidth", PL = I.reference[J] + I.reference[K] - G[K] - I.floating[J], FL = G[K] - I.reference[K], IL = yield L.getOffsetParent == null ? void 0 : L.getOffsetParent(V), LL = IL ? IL[NL] : 0;
			(!LL || !(yield L.isElement == null ? void 0 : L.isElement(IL))) && (LL = z.floating[NL] || I.floating[J]);
			let RL = PL / 2 - FL / 2, zL = LL / 2 - Y[J] / 2 - 1, BL = min(W[Z], zL), VL = min(W[Q], zL), HL = BL, UL = LL - Y[J] - VL, WL = LL / 2 - Y[J] / 2 + RL, GL = clamp$1(HL, WL, UL), KL = !B.arrow && getAlignment(F) != null && WL !== GL && I.reference[J] / 2 - (WL < HL ? BL : VL) - Y[J] / 2 < 0, qL = KL ? WL < HL ? WL - HL : WL - UL : 0;
			return {
				[K]: G[K] + qL,
				data: _objectSpread2({
					[K]: GL,
					centerOffset: WL - GL - qL
				}, KL && { alignmentOffset: qL }),
				reset: KL
			};
		})();
	}
}), flip$1 = function(C) {
	return C === void 0 && (C = {}), {
		name: "flip",
		options: C,
		fn(T) {
			return _asyncToGenerator(function* () {
				var E, D;
				let { placement: O, middlewareData: F, rects: I, initialPlacement: L, platform: z, elements: B } = T, V = evaluate(C, T), { mainAxis: U = !0, crossAxis: W = !0, fallbackPlacements: G, fallbackStrategy: K = "bestFit", fallbackAxisSideDirection: J = "none", flipAlignment: Y = !0 } = V, X = _objectWithoutProperties(V, _excluded2);
				if ((E = F.arrow) != null && E.alignmentOffset) return {};
				let Z = getSide(O), Q = getSideAxis(L), NL = getSide(L) === L, PL = yield z.isRTL == null ? void 0 : z.isRTL(B.floating), FL = G || (NL || !Y ? [getOppositePlacement(L)] : getExpandedPlacements(L)), IL = J !== "none";
				!G && IL && FL.push(...getOppositeAxisPlacements(L, Y, J, PL));
				let LL = [L, ...FL], RL = yield detectOverflow(T, X), zL = [], BL = ((D = F.flip) == null ? void 0 : D.overflows) || [];
				if (U && zL.push(RL[Z]), W) {
					let C = getAlignmentSides(O, I, PL);
					zL.push(RL[C[0]], RL[C[1]]);
				}
				if (BL = [...BL, {
					placement: O,
					overflows: zL
				}], !zL.every((C) => C <= 0)) {
					var VL, HL;
					let C = (((VL = F.flip) == null ? void 0 : VL.index) || 0) + 1, T = LL[C];
					if (T && (!(W === "alignment" && Q !== getSideAxis(T)) || BL.every((C) => getSideAxis(C.placement) === Q ? C.overflows[0] > 0 : !0))) return {
						data: {
							index: C,
							overflows: BL
						},
						reset: { placement: T }
					};
					let E = (HL = BL.filter((C) => C.overflows[0] <= 0).sort((C, T) => C.overflows[1] - T.overflows[1])[0]) == null ? void 0 : HL.placement;
					if (!E) switch (K) {
						case "bestFit": {
							var UL;
							let C = (UL = BL.filter((C) => {
								if (IL) {
									let T = getSideAxis(C.placement);
									return T === Q || T === "y";
								}
								return !0;
							}).map((C) => [C.placement, C.overflows.filter((C) => C > 0).reduce((C, T) => C + T, 0)]).sort((C, T) => C[1] - T[1])[0]) == null ? void 0 : UL[0];
							C && (E = C);
							break;
						}
						case "initialPlacement":
							E = L;
							break;
					}
					if (O !== E) return { reset: { placement: E } };
				}
				return {};
			})();
		}
	};
}, originSides = /* @__PURE__ */ new Set(["left", "top"]);
function convertValueToCoords(C, T) {
	return _convertValueToCoords.apply(this, arguments);
}
function _convertValueToCoords() {
	return _convertValueToCoords = _asyncToGenerator(function* (C, T) {
		let { placement: E, platform: D, elements: O } = C, F = yield D.isRTL == null ? void 0 : D.isRTL(O.floating), I = getSide(E), L = getAlignment(E), z = getSideAxis(E) === "y", B = originSides.has(I) ? -1 : 1, V = F && z ? -1 : 1, U = evaluate(T, C), { mainAxis: W, crossAxis: G, alignmentAxis: K } = typeof U == "number" ? {
			mainAxis: U,
			crossAxis: 0,
			alignmentAxis: null
		} : {
			mainAxis: U.mainAxis || 0,
			crossAxis: U.crossAxis || 0,
			alignmentAxis: U.alignmentAxis
		};
		return L && typeof K == "number" && (G = L === "end" ? K * -1 : K), z ? {
			x: G * V,
			y: W * B
		} : {
			x: W * B,
			y: G * V
		};
	}), _convertValueToCoords.apply(this, arguments);
}
var offset$1 = function(C) {
	return C === void 0 && (C = 0), {
		name: "offset",
		options: C,
		fn(E) {
			return _asyncToGenerator(function* () {
				var D, O;
				let { x: F, y: I, placement: L, middlewareData: z } = E, B = yield convertValueToCoords(E, C);
				return L === ((D = z.offset) == null ? void 0 : D.placement) && (O = z.arrow) != null && O.alignmentOffset ? {} : {
					x: F + B.x,
					y: I + B.y,
					data: _objectSpread2(_objectSpread2({}, B), {}, { placement: L })
				};
			})();
		}
	};
}, shift$1 = function(C) {
	return C === void 0 && (C = {}), {
		name: "shift",
		options: C,
		fn(E) {
			return _asyncToGenerator(function* () {
				let { x: D, y: O, placement: F } = E, I = evaluate(C, E), { mainAxis: L = !0, crossAxis: z = !1, limiter: B = { fn: (C) => {
					let { x: T, y: E } = C;
					return {
						x: T,
						y: E
					};
				} } } = I, V = _objectWithoutProperties(I, _excluded4), U = {
					x: D,
					y: O
				}, W = yield detectOverflow(E, V), G = getSideAxis(getSide(F)), K = getOppositeAxis(G), J = U[K], Y = U[G];
				if (L) {
					let C = K === "y" ? "top" : "left", T = K === "y" ? "bottom" : "right", E = J + W[C], D = J - W[T];
					J = clamp$1(E, J, D);
				}
				if (z) {
					let C = G === "y" ? "top" : "left", T = G === "y" ? "bottom" : "right", E = Y + W[C], D = Y - W[T];
					Y = clamp$1(E, Y, D);
				}
				let X = B.fn(_objectSpread2(_objectSpread2({}, E), {}, {
					[K]: J,
					[G]: Y
				}));
				return _objectSpread2(_objectSpread2({}, X), {}, { data: {
					x: X.x - D,
					y: X.y - O,
					enabled: {
						[K]: L,
						[G]: z
					}
				} });
			})();
		}
	};
};
function hasWindow() {
	return typeof window < "u";
}
function getNodeName(C) {
	return isNode(C) ? (C.nodeName || "").toLowerCase() : "#document";
}
function getWindow(C) {
	var T;
	return (C == null || (T = C.ownerDocument) == null ? void 0 : T.defaultView) || window;
}
function getDocumentElement(C) {
	var T;
	return (T = (isNode(C) ? C.ownerDocument : C.document) || window.document) == null ? void 0 : T.documentElement;
}
function isNode(C) {
	return hasWindow() ? C instanceof Node || C instanceof getWindow(C).Node : !1;
}
function isElement(C) {
	return hasWindow() ? C instanceof Element || C instanceof getWindow(C).Element : !1;
}
function isHTMLElement(C) {
	return hasWindow() ? C instanceof HTMLElement || C instanceof getWindow(C).HTMLElement : !1;
}
function isShadowRoot(C) {
	return !hasWindow() || typeof ShadowRoot > "u" ? !1 : C instanceof ShadowRoot || C instanceof getWindow(C).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(C) {
	let { overflow: T, overflowX: E, overflowY: D, display: O } = getComputedStyle$1(C);
	return /auto|scroll|overlay|hidden|clip/.test(T + D + E) && !invalidOverflowDisplayValues.has(O);
}
var tableElements = /* @__PURE__ */ new Set([
	"table",
	"td",
	"th"
]);
function isTableElement(C) {
	return tableElements.has(getNodeName(C));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(C) {
	return topLayerSelectors.some((T) => {
		try {
			return C.matches(T);
		} catch (C) {
			return !1;
		}
	});
}
var transformProperties = [
	"transform",
	"translate",
	"scale",
	"rotate",
	"perspective"
], willChangeValues = [
	"transform",
	"translate",
	"scale",
	"rotate",
	"perspective",
	"filter"
], containValues = [
	"paint",
	"layout",
	"strict",
	"content"
];
function isContainingBlock(C) {
	let T = isWebKit(), E = isElement(C) ? getComputedStyle$1(C) : C;
	return transformProperties.some((C) => E[C] ? E[C] !== "none" : !1) || (E.containerType ? E.containerType !== "normal" : !1) || !T && (E.backdropFilter ? E.backdropFilter !== "none" : !1) || !T && (E.filter ? E.filter !== "none" : !1) || willChangeValues.some((C) => (E.willChange || "").includes(C)) || containValues.some((C) => (E.contain || "").includes(C));
}
function getContainingBlock(C) {
	let T = getParentNode(C);
	for (; isHTMLElement(T) && !isLastTraversableNode(T);) {
		if (isContainingBlock(T)) return T;
		if (isTopLayer(T)) return null;
		T = getParentNode(T);
	}
	return null;
}
function isWebKit() {
	return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set([
	"html",
	"body",
	"#document"
]);
function isLastTraversableNode(C) {
	return lastTraversableNodeNames.has(getNodeName(C));
}
function getComputedStyle$1(C) {
	return getWindow(C).getComputedStyle(C);
}
function getNodeScroll(C) {
	return isElement(C) ? {
		scrollLeft: C.scrollLeft,
		scrollTop: C.scrollTop
	} : {
		scrollLeft: C.scrollX,
		scrollTop: C.scrollY
	};
}
function getParentNode(C) {
	if (getNodeName(C) === "html") return C;
	let T = C.assignedSlot || C.parentNode || isShadowRoot(C) && C.host || getDocumentElement(C);
	return isShadowRoot(T) ? T.host : T;
}
function getNearestOverflowAncestor(C) {
	let T = getParentNode(C);
	return isLastTraversableNode(T) ? C.ownerDocument ? C.ownerDocument.body : C.body : isHTMLElement(T) && isOverflowElement(T) ? T : getNearestOverflowAncestor(T);
}
function getOverflowAncestors(C, T, E) {
	var D;
	T === void 0 && (T = []), E === void 0 && (E = !0);
	let O = getNearestOverflowAncestor(C), F = O === ((D = C.ownerDocument) == null ? void 0 : D.body), I = getWindow(O);
	if (F) {
		let C = getFrameElement(I);
		return T.concat(I, I.visualViewport || [], isOverflowElement(O) ? O : [], C && E ? getOverflowAncestors(C) : []);
	}
	return T.concat(O, getOverflowAncestors(O, [], E));
}
function getFrameElement(C) {
	return C.parent && Object.getPrototypeOf(C.parent) ? C.frameElement : null;
}
function getCssDimensions(C) {
	let T = getComputedStyle$1(C), E = parseFloat(T.width) || 0, D = parseFloat(T.height) || 0, O = isHTMLElement(C), F = O ? C.offsetWidth : E, I = O ? C.offsetHeight : D, L = round(E) !== F || round(D) !== I;
	return L && (E = F, D = I), {
		width: E,
		height: D,
		$: L
	};
}
function unwrapElement(C) {
	return isElement(C) ? C : C.contextElement;
}
function getScale(C) {
	let T = unwrapElement(C);
	if (!isHTMLElement(T)) return createCoords(1);
	let E = T.getBoundingClientRect(), { width: D, height: O, $: F } = getCssDimensions(T), I = (F ? round(E.width) : E.width) / D, L = (F ? round(E.height) : E.height) / O;
	return (!I || !Number.isFinite(I)) && (I = 1), (!L || !Number.isFinite(L)) && (L = 1), {
		x: I,
		y: L
	};
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(C) {
	let T = getWindow(C);
	return !isWebKit() || !T.visualViewport ? noOffsets : {
		x: T.visualViewport.offsetLeft,
		y: T.visualViewport.offsetTop
	};
}
function shouldAddVisualOffsets(C, T, E) {
	return T === void 0 && (T = !1), !E || T && E !== getWindow(C) ? !1 : T;
}
function getBoundingClientRect(C, T, E, D) {
	T === void 0 && (T = !1), E === void 0 && (E = !1);
	let O = C.getBoundingClientRect(), F = unwrapElement(C), I = createCoords(1);
	T && (D ? isElement(D) && (I = getScale(D)) : I = getScale(C));
	let L = shouldAddVisualOffsets(F, E, D) ? getVisualOffsets(F) : createCoords(0), z = (O.left + L.x) / I.x, B = (O.top + L.y) / I.y, V = O.width / I.x, U = O.height / I.y;
	if (F) {
		let C = getWindow(F), T = D && isElement(D) ? getWindow(D) : D, E = C, O = getFrameElement(E);
		for (; O && D && T !== E;) {
			let C = getScale(O), T = O.getBoundingClientRect(), D = getComputedStyle$1(O), F = T.left + (O.clientLeft + parseFloat(D.paddingLeft)) * C.x, I = T.top + (O.clientTop + parseFloat(D.paddingTop)) * C.y;
			z *= C.x, B *= C.y, V *= C.x, U *= C.y, z += F, B += I, E = getWindow(O), O = getFrameElement(E);
		}
	}
	return rectToClientRect({
		width: V,
		height: U,
		x: z,
		y: B
	});
}
function getWindowScrollBarX(C, T) {
	let E = getNodeScroll(C).scrollLeft;
	return T ? T.left + E : getBoundingClientRect(getDocumentElement(C)).left + E;
}
function getHTMLOffset(C, T) {
	let E = C.getBoundingClientRect();
	return {
		x: E.left + T.scrollLeft - getWindowScrollBarX(C, E),
		y: E.top + T.scrollTop
	};
}
function convertOffsetParentRelativeRectToViewportRelativeRect(C) {
	let { elements: T, rect: E, offsetParent: D, strategy: O } = C, F = O === "fixed", I = getDocumentElement(D), L = T ? isTopLayer(T.floating) : !1;
	if (D === I || L && F) return E;
	let z = {
		scrollLeft: 0,
		scrollTop: 0
	}, B = createCoords(1), V = createCoords(0), U = isHTMLElement(D);
	if ((U || !U && !F) && ((getNodeName(D) !== "body" || isOverflowElement(I)) && (z = getNodeScroll(D)), isHTMLElement(D))) {
		let C = getBoundingClientRect(D);
		B = getScale(D), V.x = C.x + D.clientLeft, V.y = C.y + D.clientTop;
	}
	let W = I && !U && !F ? getHTMLOffset(I, z) : createCoords(0);
	return {
		width: E.width * B.x,
		height: E.height * B.y,
		x: E.x * B.x - z.scrollLeft * B.x + V.x + W.x,
		y: E.y * B.y - z.scrollTop * B.y + V.y + W.y
	};
}
function getClientRects(C) {
	return Array.from(C.getClientRects());
}
function getDocumentRect(C) {
	let T = getDocumentElement(C), E = getNodeScroll(C), D = C.ownerDocument.body, O = max(T.scrollWidth, T.clientWidth, D.scrollWidth, D.clientWidth), F = max(T.scrollHeight, T.clientHeight, D.scrollHeight, D.clientHeight), I = -E.scrollLeft + getWindowScrollBarX(C), L = -E.scrollTop;
	return getComputedStyle$1(D).direction === "rtl" && (I += max(T.clientWidth, D.clientWidth) - O), {
		width: O,
		height: F,
		x: I,
		y: L
	};
}
var SCROLLBAR_MAX = 25;
function getViewportRect(C, T) {
	let E = getWindow(C), D = getDocumentElement(C), O = E.visualViewport, F = D.clientWidth, I = D.clientHeight, L = 0, z = 0;
	if (O) {
		F = O.width, I = O.height;
		let C = isWebKit();
		(!C || C && T === "fixed") && (L = O.offsetLeft, z = O.offsetTop);
	}
	let B = getWindowScrollBarX(D);
	if (B <= 0) {
		let C = D.ownerDocument, T = C.body, E = getComputedStyle(T), O = C.compatMode === "CSS1Compat" && parseFloat(E.marginLeft) + parseFloat(E.marginRight) || 0, I = Math.abs(D.clientWidth - T.clientWidth - O);
		I <= SCROLLBAR_MAX && (F -= I);
	} else B <= SCROLLBAR_MAX && (F += B);
	return {
		width: F,
		height: I,
		x: L,
		y: z
	};
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(C, T) {
	let E = getBoundingClientRect(C, !0, T === "fixed"), D = E.top + C.clientTop, O = E.left + C.clientLeft, F = isHTMLElement(C) ? getScale(C) : createCoords(1);
	return {
		width: C.clientWidth * F.x,
		height: C.clientHeight * F.y,
		x: O * F.x,
		y: D * F.y
	};
}
function getClientRectFromClippingAncestor(C, T, E) {
	let D;
	if (T === "viewport") D = getViewportRect(C, E);
	else if (T === "document") D = getDocumentRect(getDocumentElement(C));
	else if (isElement(T)) D = getInnerBoundingClientRect(T, E);
	else {
		let E = getVisualOffsets(C);
		D = {
			x: T.x - E.x,
			y: T.y - E.y,
			width: T.width,
			height: T.height
		};
	}
	return rectToClientRect(D);
}
function hasFixedPositionAncestor(C, T) {
	let E = getParentNode(C);
	return E === T || !isElement(E) || isLastTraversableNode(E) ? !1 : getComputedStyle$1(E).position === "fixed" || hasFixedPositionAncestor(E, T);
}
function getClippingElementAncestors(C, T) {
	let E = T.get(C);
	if (E) return E;
	let D = getOverflowAncestors(C, [], !1).filter((C) => isElement(C) && getNodeName(C) !== "body"), O = null, F = getComputedStyle$1(C).position === "fixed", I = F ? getParentNode(C) : C;
	for (; isElement(I) && !isLastTraversableNode(I);) {
		let T = getComputedStyle$1(I), E = isContainingBlock(I);
		!E && T.position === "fixed" && (O = null), (F ? !E && !O : !E && T.position === "static" && O && absoluteOrFixed.has(O.position) || isOverflowElement(I) && !E && hasFixedPositionAncestor(C, I)) ? D = D.filter((C) => C !== I) : O = T, I = getParentNode(I);
	}
	return T.set(C, D), D;
}
function getClippingRect(C) {
	let { element: T, boundary: E, rootBoundary: D, strategy: O } = C, F = [...E === "clippingAncestors" ? isTopLayer(T) ? [] : getClippingElementAncestors(T, this._c) : [].concat(E), D], I = F[0], L = F.reduce((C, E) => {
		let D = getClientRectFromClippingAncestor(T, E, O);
		return C.top = max(D.top, C.top), C.right = min(D.right, C.right), C.bottom = min(D.bottom, C.bottom), C.left = max(D.left, C.left), C;
	}, getClientRectFromClippingAncestor(T, I, O));
	return {
		width: L.right - L.left,
		height: L.bottom - L.top,
		x: L.left,
		y: L.top
	};
}
function getDimensions(C) {
	let { width: T, height: E } = getCssDimensions(C);
	return {
		width: T,
		height: E
	};
}
function getRectRelativeToOffsetParent(C, T, E) {
	let D = isHTMLElement(T), O = getDocumentElement(T), F = E === "fixed", I = getBoundingClientRect(C, !0, F, T), L = {
		scrollLeft: 0,
		scrollTop: 0
	}, z = createCoords(0);
	function B() {
		z.x = getWindowScrollBarX(O);
	}
	if (D || !D && !F) if ((getNodeName(T) !== "body" || isOverflowElement(O)) && (L = getNodeScroll(T)), D) {
		let C = getBoundingClientRect(T, !0, F, T);
		z.x = C.x + T.clientLeft, z.y = C.y + T.clientTop;
	} else O && B();
	F && !D && O && B();
	let V = O && !D && !F ? getHTMLOffset(O, L) : createCoords(0);
	return {
		x: I.left + L.scrollLeft - z.x - V.x,
		y: I.top + L.scrollTop - z.y - V.y,
		width: I.width,
		height: I.height
	};
}
function isStaticPositioned(C) {
	return getComputedStyle$1(C).position === "static";
}
function getTrueOffsetParent(C, T) {
	if (!isHTMLElement(C) || getComputedStyle$1(C).position === "fixed") return null;
	if (T) return T(C);
	let E = C.offsetParent;
	return getDocumentElement(C) === E && (E = E.ownerDocument.body), E;
}
function getOffsetParent(C, T) {
	let E = getWindow(C);
	if (isTopLayer(C)) return E;
	if (!isHTMLElement(C)) {
		let T = getParentNode(C);
		for (; T && !isLastTraversableNode(T);) {
			if (isElement(T) && !isStaticPositioned(T)) return T;
			T = getParentNode(T);
		}
		return E;
	}
	let D = getTrueOffsetParent(C, T);
	for (; D && isTableElement(D) && isStaticPositioned(D);) D = getTrueOffsetParent(D, T);
	return D && isLastTraversableNode(D) && isStaticPositioned(D) && !isContainingBlock(D) ? E : D || getContainingBlock(C) || E;
}
var getElementRects = /* @__PURE__ */ function() {
	var C = _asyncToGenerator(function* (C) {
		let T = this.getOffsetParent || getOffsetParent, E = this.getDimensions, D = yield E(C.floating);
		return {
			reference: getRectRelativeToOffsetParent(C.reference, yield T(C.floating), C.strategy),
			floating: {
				x: 0,
				y: 0,
				width: D.width,
				height: D.height
			}
		};
	});
	return function(T) {
		return C.apply(this, arguments);
	};
}();
function isRTL(C) {
	return getComputedStyle$1(C).direction === "rtl";
}
var platform = {
	convertOffsetParentRelativeRectToViewportRelativeRect,
	getDocumentElement,
	getClippingRect,
	getOffsetParent,
	getElementRects,
	getClientRects,
	getDimensions,
	getScale,
	isElement,
	isRTL
};
function rectsAreEqual(C, T) {
	return C.x === T.x && C.y === T.y && C.width === T.width && C.height === T.height;
}
function observeMove(C, E) {
	let D = null, O, F = getDocumentElement(C);
	function I() {
		var C;
		clearTimeout(O), (C = D) == null || C.disconnect(), D = null;
	}
	function L(z, B) {
		z === void 0 && (z = !1), B === void 0 && (B = 1), I();
		let V = C.getBoundingClientRect(), { left: U, top: W, width: G, height: K } = V;
		if (z || E(), !G || !K) return;
		let J = floor(W), Y = floor(F.clientWidth - (U + G)), X = floor(F.clientHeight - (W + K)), Z = floor(U), Q = {
			rootMargin: -J + "px " + -Y + "px " + -X + "px " + -Z + "px",
			threshold: max(0, min(1, B)) || 1
		}, NL = !0;
		function PL(T) {
			let E = T[0].intersectionRatio;
			if (E !== B) {
				if (!NL) return L();
				E ? L(!1, E) : O = setTimeout(() => {
					L(!1, 1e-7);
				}, 1e3);
			}
			E === 1 && !rectsAreEqual(V, C.getBoundingClientRect()) && L(), NL = !1;
		}
		try {
			D = new IntersectionObserver(PL, _objectSpread2(_objectSpread2({}, Q), {}, { root: F.ownerDocument }));
		} catch (C) {
			D = new IntersectionObserver(PL, Q);
		}
		D.observe(C);
	}
	return L(!0), I;
}
function autoUpdate(C, T, E, D) {
	D === void 0 && (D = {});
	let { ancestorScroll: O = !0, ancestorResize: F = !0, elementResize: I = typeof ResizeObserver == "function", layoutShift: L = typeof IntersectionObserver == "function", animationFrame: z = !1 } = D, B = unwrapElement(C), V = O || F ? [...B ? getOverflowAncestors(B) : [], ...getOverflowAncestors(T)] : [];
	V.forEach((C) => {
		O && C.addEventListener("scroll", E, { passive: !0 }), F && C.addEventListener("resize", E);
	});
	let U = B && L ? observeMove(B, E) : null, W = -1, G = null;
	I && (G = new ResizeObserver((C) => {
		let [D] = C;
		D && D.target === B && G && (G.unobserve(T), cancelAnimationFrame(W), W = requestAnimationFrame(() => {
			var C;
			(C = G) == null || C.observe(T);
		})), E();
	}), B && !z && G.observe(B), G.observe(T));
	let K, J = z ? getBoundingClientRect(C) : null;
	z && Y();
	function Y() {
		let T = getBoundingClientRect(C);
		J && !rectsAreEqual(J, T) && E(), J = T, K = requestAnimationFrame(Y);
	}
	return E(), () => {
		var C;
		V.forEach((C) => {
			O && C.removeEventListener("scroll", E), F && C.removeEventListener("resize", E);
		}), U?.(), (C = G) == null || C.disconnect(), G = null, z && cancelAnimationFrame(K);
	};
}
var offset = offset$1, shift = shift$1, flip = flip$1, arrow = arrow$1, computePosition = (C, E, D) => {
	let O = /* @__PURE__ */ new Map(), F = _objectSpread2({ platform }, D), I = _objectSpread2(_objectSpread2({}, F.platform), {}, { _c: O });
	return computePosition$1(C, E, _objectSpread2(_objectSpread2({}, F), {}, { platform: I }));
};
const tooltip = ce({
	slots: {
		base: "absolute bg-gray-800 text-white px-2 py-1 rounded text-sm z-50 pointer-events-none",
		arrowBase: "absolute w-2 h-2 rotate-45 bg-inherit"
	},
	variants: {
		color: {
			default: { base: "bg-gray-800" },
			primary: { base: "bg-primary-600" },
			secondary: { base: "bg-secondary-600" },
			gray: { base: "bg-gray-600" },
			red: { base: "bg-red-600" },
			orange: { base: "bg-orange-600" },
			amber: { base: "bg-amber-600" },
			yellow: { base: "bg-yellow-400" },
			lime: { base: "bg-lime-600" },
			green: { base: "bg-green-600" },
			emerald: { base: "bg-emerald-600" },
			teal: { base: "bg-teal-600" },
			cyan: { base: "bg-cyan-600" },
			sky: { base: "bg-sky-600" },
			blue: { base: "bg-blue-600" },
			indigo: { base: "bg-indigo-600" },
			violet: { base: "bg-violet-600" },
			purple: { base: "bg-purple-600" },
			fuchsia: { base: "bg-fuchsia-600" },
			pink: { base: "bg-pink-600" },
			rose: { base: "bg-rose-800" }
		},
		arrow: {
			true: { arrowBase: "visible" },
			false: { arrowBase: "hidden" }
		},
		position: {
			top: {},
			"top-start": {},
			"top-end": {},
			bottom: {},
			"bottom-start": {},
			"bottom-end": {},
			left: {},
			"left-start": {},
			"left-end": {},
			right: {},
			"right-start": {},
			"right-end": {}
		}
	},
	defaultVariants: {
		color: "default",
		arrow: !0,
		position: "top"
	}
});
var root_2$31 = /* @__PURE__ */ from_html("<div></div>"), root_1$68 = /* @__PURE__ */ from_html("<div><!> <!></div>");
function Tooltip$1(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "color", 7, "default"), F = prop(E, "showOn", 7, "hover"), I = prop(E, "arrow", 7, !0), L = prop(E, "offset", 7, 8), z = prop(E, "triggeredBy", 7), B = prop(E, "reference", 7), V = prop(E, "position", 7, "top"), U = prop(E, "strategy", 7, "absolute"), W = prop(E, "class", 7), G = prop(E, "visible", 7, !1), K = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"color",
		"showOn",
		"arrow",
		"offset",
		"triggeredBy",
		"reference",
		"position",
		"strategy",
		"class",
		"visible"
	]), J = /* @__PURE__ */ state(proxy(G())), Y = /* @__PURE__ */ state(null), X = null, Z = null, Q = /* @__PURE__ */ state(null), NL = /* @__PURE__ */ user_derived(() => tooltip({
		color: O(),
		arrow: I(),
		position: V()
	})), PL = /* @__PURE__ */ user_derived(() => get(NL).base), FL = /* @__PURE__ */ user_derived(() => get(NL).arrowBase), IL = {
		top: "bottom",
		right: "left",
		bottom: "top",
		left: "right"
	}, LL = (C) => IL[C.split("-")[0]], RL = function() {
		var C = _asyncToGenerator(function* () {
			let C = B() ? Z : X;
			if (!get(Y) || !C) return;
			let T = [
				flip(),
				shift({ padding: 8 }),
				offset(L())
			];
			I() && get(Q) && T.push(arrow({ element: get(Q) }));
			let { x: E, y: D, placement: O, middlewareData: F } = yield computePosition(C, get(Y), {
				placement: V(),
				strategy: U(),
				middleware: T
			});
			if (Object.assign(get(Y).style, {
				left: `${E}px`,
				top: `${D}px`,
				position: U()
			}), I() && get(Q) && F.arrow) {
				let { x: C, y: T } = F.arrow, E = LL(O), D = {
					left: C == null ? "" : `${C}px`,
					top: T == null ? "" : `${T}px`,
					right: "",
					bottom: ""
				};
				D[E] = "-4px", Object.assign(get(Q).style, D);
			}
		});
		return function() {
			return C.apply(this, arguments);
		};
	}(), zL = () => {
		z() && (set(J, !0), setTimeout(RL, 0));
	}, BL = () => {
		z() && set(J, !1);
	}, VL = () => {
		z() && (set(J, !get(J)), get(J) && setTimeout(RL, 0));
	}, HL = (C) => {
		F() === "click" && get(J) && get(Y) && X && !get(Y).contains(C.target) && !X.contains(C.target) && BL();
	};
	user_effect(() => {
		set(J, G());
	}), user_effect(() => {
		B() && (Z = document.querySelector(B())), z() && (X = document.querySelector(z()), X && (F() === "hover" ? (X.addEventListener("mouseenter", zL), X.addEventListener("mouseleave", BL)) : F() === "click" && (X.addEventListener("click", VL), document.addEventListener("click", HL))));
		let C = () => {
			X && (F() === "hover" ? (X.removeEventListener("mouseenter", zL), X.removeEventListener("mouseleave", BL)) : F() === "click" && (X.removeEventListener("click", VL), document.removeEventListener("click", HL)));
		};
		return onDestroy(C), C;
	}), user_effect(() => {
		if (get(J)) {
			let C = () => {
				get(J) && RL();
			};
			return window.addEventListener("resize", C), window.addEventListener("scroll", C, !0), () => {
				window.removeEventListener("resize", C), window.removeEventListener("scroll", C, !0);
			};
		}
	});
	var UL = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get color() {
			return O();
		},
		set color(C = "default") {
			O(C), flushSync();
		},
		get showOn() {
			return F();
		},
		set showOn(C = "hover") {
			F(C), flushSync();
		},
		get arrow() {
			return I();
		},
		set arrow(C = !0) {
			I(C), flushSync();
		},
		get offset() {
			return L();
		},
		set offset(C = 8) {
			L(C), flushSync();
		},
		get triggeredBy() {
			return z();
		},
		set triggeredBy(C) {
			z(C), flushSync();
		},
		get reference() {
			return B();
		},
		set reference(C) {
			B(C), flushSync();
		},
		get position() {
			return V();
		},
		set position(C = "top") {
			V(C), flushSync();
		},
		get strategy() {
			return U();
		},
		set strategy(C = "absolute") {
			U(C), flushSync();
		},
		get class() {
			return W();
		},
		set class(C) {
			W(C), flushSync();
		},
		get visible() {
			return G();
		},
		set visible(C = !1) {
			G(C), flushSync();
		}
	}, WL = comment(), GL = first_child(WL), KL = (C) => {
		var E = root_1$68();
		attribute_effect(E, (C) => _objectSpread2(_objectSpread2({ role: "tooltip" }, K), {}, { class: C }), [() => `${get(PL)({ className: W() })} ${get(J) ? "visible opacity-100" : "invisible opacity-0"} transition-opacity duration-200`]);
		var O = child(E);
		snippet(O, D);
		var F = sibling(O, 2), L = (C) => {
			var T = root_2$31();
			bind_this(T, (C) => set(Q, C), () => get(Q)), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(FL)({
				arrow: I(),
				position: V()
			}))]), append(C, T);
		};
		if_block(F, (C) => {
			I() && C(L);
		}), reset(E), bind_this(E, (C) => set(Y, C), () => get(Y)), append(C, E);
	};
	return if_block(GL, (C) => {
		get(J) && C(KL);
	}), append(C, WL), pop(UL);
}
create_custom_element(Tooltip$1, {
	children: {},
	color: {},
	showOn: {},
	arrow: {},
	offset: {},
	triggeredBy: {},
	reference: {},
	position: {},
	strategy: {},
	class: {},
	visible: {}
}, [], [], !0);
var root$60 = /* @__PURE__ */ from_html("<div></div>"), $$css$27 = {
	hash: "svelte-uu2aof",
	code: ".clip {clip-path:polygon(0 0, 0% 100%, 100% 100%, 100% 85%, 15% 0);}"
};
function Arrow(C, T) {
	push(T, !0), append_styles(C, $$css$27);
	let E = prop(T, "placement", 7, "top"), D = prop(T, "cords", 7), O = prop(T, "strategy", 7, "absolute"), F = prop(T, "class", 7, ""), I = (C) => C ? `${C}px` : "";
	function L(C) {
		let T = window.getComputedStyle(C);
		return Math.max(parseFloat(T.borderLeftWidth), parseFloat(T.borderBottomWidth)) - .3;
	}
	let z = {
		left: " rotate-45",
		right: " -rotate-135",
		top: " rotate-135",
		bottom: " -rotate-45"
	};
	function B(C) {
		user_effect(() => {
			C.style.position = O(), C.style.left = I(D().x), C.style.top = I(D().y), C.style.right = "", C.style.bottom = "";
			let T = getSide(getOppositePlacement(E()));
			C.style[T] = I(-C.offsetWidth / 2 - L(C)), C.classList.remove("rotate-45", "-rotate-45", "rotate-135", "-rotate-135"), C.className += z[T];
		});
	}
	var V = {
		get placement() {
			return E();
		},
		set placement(C = "top") {
			E(C), flushSync();
		},
		get cords() {
			return D();
		},
		set cords(C) {
			D(C), flushSync();
		},
		get strategy() {
			return O();
		},
		set strategy(C = "absolute") {
			O(C), flushSync();
		},
		get class() {
			return F();
		},
		set class(C = "") {
			F(C), flushSync();
		}
	}, U = root$60();
	return action(U, (C) => B == null ? void 0 : B(C)), template_effect(() => {
		var C;
		return set_class(U, 1, `popover-arrow clip pointer-events-none block h-[10px] w-[10px] border-b border-l border-inherit bg-inherit text-inherit ${(C = F()) == null ? "" : C}`);
	}), append(C, U), pop(V);
}
create_custom_element(Arrow, {
	placement: {},
	cords: {},
	strategy: {},
	class: {}
}, [], [], !0);
var root_1$67 = /* @__PURE__ */ from_html("<div><!> <!></div>"), root$59 = /* @__PURE__ */ from_html("<div hidden=\"\"></div> <!>", 1);
function Popper(C, E) {
	push(E, !0);
	let D = prop(E, "triggeredBy", 7), O = prop(E, "triggerDelay", 7, 200), F = prop(E, "trigger", 7, "click"), I = prop(E, "placement", 7, "top"), L = prop(E, "offset", 7, 8), z = prop(E, "arrow", 7, !1), B = prop(E, "yOnly", 7, !1), V = prop(E, "strategy", 7, "absolute"), U = prop(E, "reference", 7), W = prop(E, "middlewares", 23, () => [flip(), shift()]), G = prop(E, "onbeforetoggle", 7), K = prop(E, "ontoggle", 7), J = prop(E, "class", 7, ""), Y = prop(E, "arrowClass", 7, ""), X = prop(E, "isOpen", 15, !1), Z = prop(E, "transitionParams", 7), Q = prop(E, "transition", 7, fade), NL = prop(E, "children", 7), PL = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"triggeredBy",
		"triggerDelay",
		"trigger",
		"placement",
		"offset",
		"arrow",
		"yOnly",
		"strategy",
		"reference",
		"middlewares",
		"onbeforetoggle",
		"ontoggle",
		"class",
		"arrowClass",
		"isOpen",
		"transitionParams",
		"transition",
		"children"
	]), FL = /* @__PURE__ */ user_derived(() => F() === "click"), IL = /* @__PURE__ */ user_derived(() => F() === "hover"), LL = /* @__PURE__ */ state(null), RL = null, zL = null, BL = [], VL = /* @__PURE__ */ state(proxy({
		placement: I(),
		cords: {
			x: 0,
			y: 0
		},
		strategy: V()
	})), HL = {
		duration: 100,
		easing: sineIn
	}, UL = /* @__PURE__ */ user_derived(() => {
		var C;
		return (C = Z()) == null ? HL : C;
	}), WL = (C) => C ? `${C}px` : "";
	function GL() {
		var C;
		if (!RL || !get(LL)) return;
		let T = get(LL).querySelector(".popover-arrow"), E = [...W(), offset(L())];
		return T && E.push(arrow({ element: T })), computePosition((C = zL) == null ? RL : C, get(LL), {
			placement: I(),
			middleware: E,
			strategy: V()
		}).then(({ x: C, y: E, middlewareData: { arrow: D }, placement: O, strategy: F }) => {
			get(LL) && (Object.assign(get(LL).style, {
				position: F,
				left: B() ? "0" : WL(C),
				top: WL(E)
			}), D && T && set(VL, {
				placement: O,
				cords: {
					x: D.x,
					y: D.y
				},
				strategy: F
			}, !0));
		});
	}
	let KL = !1;
	function qL(C) {
		return JL.apply(this, arguments);
	}
	function JL() {
		return JL = _asyncToGenerator(function* (C) {
			KL = !0, yield new Promise((C) => setTimeout(C, O())), KL && (C.preventDefault(), C.target !== RL && BL.includes(C.target) && (RL = C.target, X(!1), yield new Promise((C) => setTimeout(C, O()))), C.type === "mousedown" ? X(!X()) : X(!0));
		}), JL.apply(this, arguments);
	}
	function YL(C) {
		return XL.apply(this, arguments);
	}
	function XL() {
		return XL = _asyncToGenerator(function* (C) {
			var T, E;
			if (F() === "click" && C.type === "focusout") {
				let T = C.relatedTarget;
				if (get(LL) && T && get(LL).contains(T) || !T) return;
			}
			KL = !1, yield new Promise((C) => setTimeout(C, O())), !KL && ((C == null ? void 0 : C.type) === "mouseleave" && (T = get(LL)) != null && T.contains(get(LL).ownerDocument.activeElement) || (C == null ? void 0 : C.type) === "focusout" && (E = get(LL)) != null && E.contains(get(LL).ownerDocument.activeElement) || X(!1));
		}), XL.apply(this, arguments);
	}
	let ZL = () => {};
	function QL(C) {
		var T;
		if (!(!RL || !get(LL))) if (C.trigger = RL, (T = G()) == null || T(C), C.newState === "open") {
			var E;
			ZL = autoUpdate((E = zL) == null ? RL : E, get(LL), GL), get(LL).ownerDocument.addEventListener("click", nR), get(LL).ownerDocument.addEventListener("keydown", tR);
		} else ZL(), get(LL).ownerDocument.removeEventListener("click", nR), get(LL).ownerDocument.removeEventListener("keydown", tR);
	}
	function $L(C) {
		var T;
		RL && (X(C.newState === "open"), C.trigger = RL, (T = K()) == null || T(C));
	}
	function eR(C) {
		let T = [
			[
				"focusin",
				qL,
				!0
			],
			[
				"focusout",
				YL,
				!0
			],
			[
				"mousedown",
				qL,
				get(FL)
			],
			[
				"mouseenter",
				qL,
				get(IL)
			],
			[
				"mouseleave",
				YL,
				get(IL)
			]
		];
		if (D() ? BL = [...C.ownerDocument.querySelectorAll(D())] : C.previousElementSibling ? BL = [C.previousElementSibling] : C.parentElement && (BL = [C.parentElement]), !BL.length) {
			console.error("No triggers found.", D());
			return;
		}
		U() && (zL = C.ownerDocument.querySelector(U())), RL = BL[0], BL.forEach((C) => {
			C.tabIndex < 0 && (C.tabIndex = 0);
			for (let [E, D, O] of T) O && C.addEventListener(E, D);
		}), user_effect(() => () => {
			BL.forEach((C) => {
				for (let [E, D, O] of T) O && C.removeEventListener(E, D);
			});
		});
	}
	function tR(C) {
		C.key === "Escape" && X(!1);
	}
	function nR(C) {
		if (!get(LL)) return;
		let T = C.composedPath(), E = T.includes(get(LL)), D = BL.some((C) => T.includes(C));
		!E && !D && (YL(C), X(!1));
	}
	var rR = {
		get triggeredBy() {
			return D();
		},
		set triggeredBy(C) {
			D(C), flushSync();
		},
		get triggerDelay() {
			return O();
		},
		set triggerDelay(C = 200) {
			O(C), flushSync();
		},
		get trigger() {
			return F();
		},
		set trigger(C = "click") {
			F(C), flushSync();
		},
		get placement() {
			return I();
		},
		set placement(C = "top") {
			I(C), flushSync();
		},
		get offset() {
			return L();
		},
		set offset(C = 8) {
			L(C), flushSync();
		},
		get arrow() {
			return z();
		},
		set arrow(C = !1) {
			z(C), flushSync();
		},
		get yOnly() {
			return B();
		},
		set yOnly(C = !1) {
			B(C), flushSync();
		},
		get strategy() {
			return V();
		},
		set strategy(C = "absolute") {
			V(C), flushSync();
		},
		get reference() {
			return U();
		},
		set reference(C) {
			U(C), flushSync();
		},
		get middlewares() {
			return W();
		},
		set middlewares(C = [flip(), shift()]) {
			W(C), flushSync();
		},
		get onbeforetoggle() {
			return G();
		},
		set onbeforetoggle(C) {
			G(C), flushSync();
		},
		get ontoggle() {
			return K();
		},
		set ontoggle(C) {
			K(C), flushSync();
		},
		get class() {
			return J();
		},
		set class(C = "") {
			J(C), flushSync();
		},
		get arrowClass() {
			return Y();
		},
		set arrowClass(C = "") {
			Y(C), flushSync();
		},
		get isOpen() {
			return X();
		},
		set isOpen(C = !1) {
			X(C), flushSync();
		},
		get transitionParams() {
			return Z();
		},
		set transitionParams(C) {
			Z(C), flushSync();
		},
		get transition() {
			return Q();
		},
		set transition(C = fade) {
			Q(C), flushSync();
		},
		get children() {
			return NL();
		},
		set children(C) {
			NL(C), flushSync();
		}
	}, iR = root$59(), aR = first_child(iR);
	action(aR, (C) => eR == null ? void 0 : eR(C));
	var oR = sibling(aR, 2), sR = (C) => {
		var E = root_1$67(), D = () => {
			var C;
			return (C = get(LL)) == null ? void 0 : C.showPopover();
		}, O = () => {
			var C;
			return (C = get(LL)) == null ? void 0 : C.hidePopover();
		};
		attribute_effect(E, (C) => _objectSpread2(_objectSpread2({
			popover: "manual",
			role: "tooltip",
			onfocusout: YL,
			onmouseleave: get(IL) ? YL : void 0,
			onmouseenter: get(IL) ? qL : void 0,
			onbeforetoggle: QL,
			ontoggle: $L,
			class: C,
			onintrostart: D,
			onoutroend: O
		}, PL), {}, { [CLASS]: { "overflow-visible": !0 } }), [() => clsx_default(J())]);
		var F = child(E);
		snippet(F, NL);
		var I = sibling(F, 2), L = (C) => {
			Arrow(C, spread_props(() => get(VL), { get class() {
				return Y();
			} }));
		};
		if_block(I, (C) => {
			z() && C(L);
		}), reset(E), bind_this(E, (C) => set(LL, C), () => get(LL)), transition(3, E, Q, () => get(UL)), append(C, E);
	};
	return if_block(oR, (C) => {
		X() && C(sR);
	}), append(C, iR), pop(rR);
}
create_custom_element(Popper, {
	triggeredBy: {},
	triggerDelay: {},
	trigger: {},
	placement: {},
	offset: {},
	arrow: {},
	yOnly: {},
	strategy: {},
	reference: {},
	middlewares: {},
	onbeforetoggle: {},
	ontoggle: {},
	class: {},
	arrowClass: {},
	isOpen: {},
	transitionParams: {},
	transition: {},
	children: {}
}, [], [], !0);
function Responsive(C, T) {
	push(T, !0), pop();
}
create_custom_element(Responsive, {}, [], [], !0);
function SnippetRender(C, E) {
	push(E, !0);
	let D = prop(E, "params", 7), O = prop(E, "api", 7), F = prop(E, "containerApi", 7), I = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"params",
		"api",
		"containerApi"
	]), L = /* @__PURE__ */ user_derived(() => D().snippet), z = /* @__PURE__ */ user_derived(() => exclude_from_object(D(), ["snippet"])), B = /* @__PURE__ */ user_derived(() => _objectSpread2({
		params: get(z),
		api: O(),
		containerApi: F()
	}, I));
	var V = {
		get params() {
			return D();
		},
		set params(C) {
			D(C), flushSync();
		},
		get api() {
			return O();
		},
		set api(C) {
			O(C), flushSync();
		},
		get containerApi() {
			return F();
		},
		set containerApi(C) {
			F(C), flushSync();
		}
	}, U = comment();
	return snippet(first_child(U), () => get(L), () => get(B)), append(C, U), pop(V);
}
create_custom_element(SnippetRender, {
	params: {},
	api: {},
	containerApi: {}
}, [], [], !0);
var _props = /* @__PURE__ */ new WeakMap(), PropsUpdater = class {
	get props() {
		return get(_classPrivateFieldGet2(_props, this));
	}
	set props(C) {
		set(_classPrivateFieldGet2(_props, this), C, !0);
	}
	constructor(C, T) {
		var E;
		_classPrivateFieldInitSpec(this, _props, void 0), _classPrivateFieldSet2(_props, this, /* @__PURE__ */ state()), this.props = C, this.postProcessor = T, (E = this.postProcessor) == null || E.call(this, this.props);
	}
	update(C) {
		var T;
		this.props = C, (T = this.postProcessor) == null || T.call(this, this.props);
	}
	updateSingle(...C) {
		var T;
		let E = C.pop(), D = C, { length: O } = D, F = this.props;
		for (let C = 0; C < O - 1; C++) F = F[D[C]];
		F[D[O - 1]] = E, (T = this.postProcessor) == null || T.call(this, this.props);
	}
};
const deferred = () => {
	let C, T;
	return {
		promise: new Promise((E, D) => {
			C = E, T = D;
		}),
		resolve: C,
		reject: T
	};
};
var _MountMechanism, MountMechanism = class C {
	constructor() {
		this.defferedMountMap = /* @__PURE__ */ new Map(), this.id = C.ID;
	}
	await(C, T = !1) {
		let E = this.id(C);
		if (this.defferedMountMap.has(E) && !T) return this.defferedMountMap.get(E).promise;
		let D = deferred();
		return this.defferedMountMap.set(E, D), D.promise;
	}
	get(C) {
		return this.defferedMountMap.get(C);
	}
	drop(C) {
		this.defferedMountMap.delete(C);
	}
	tryResolveAndDrop(C, T) {
		var E;
		(E = this.get(C)) == null || E.resolve(T), this.drop(C);
	}
};
_MountMechanism = MountMechanism, _MountMechanism.ID = ({ viewIndex: C, id: T, name: E }) => `${C}${T}${E}`;
var _PanelRendererBase, PanelRendererBase = class C {
	get element() {
		return this._element;
	}
	constructor(T) {
		var E, D;
		this.mountID = C.Mount.id(T), this.svelteComponent = T.svelteComponent, this.initOptionsToProps = T.initOptionsToProps, this.propsPostProcessor = T.propsPostProcessor, this.propsHasParams = (E = T.propsHasParams) == null ? !0 : E, this._element = (D = T.element) == null ? document.createElement("div") : D, this._element.classList.add("dv-react-part"), this._element.style.height = "100%", this._element.style.width = "100%", this._element.setAttribute("data-dockview-svelte", C.ReadableIdentifier(T)), this._element.id || (this._element.id = this.mountID);
	}
	init(T) {
		this.propsUpdater = new PropsUpdater(this.initOptionsToProps(T), this.propsPostProcessor), this.instance = mount(this.svelteComponent, {
			target: this.element,
			props: this.propsUpdater.props
		}), C.Mount.tryResolveAndDrop(this.mountID, this.instance);
	}
	dispose() {
		this.instance && unmount(this.instance);
	}
	update({ params: C }) {
		var T;
		for (let E in C) (T = this.propsUpdater) == null || T.updateSingle(...this.propsHasParams ? [
			"params",
			E,
			C[E]
		] : [E, C[E]]);
	}
};
_PanelRendererBase = PanelRendererBase, _PanelRendererBase.Mount = new MountMechanism(), _PanelRendererBase.ReadableIdentifier = ({ panelTarget: C, viewIndex: T, id: E, name: D }) => `${C}-${T}-${E.startsWith(prefix.component) ? "component" : "snippet"}-${D}`;
var _ReactivePanelUpdater, _value = /* @__PURE__ */ new WeakMap(), ReactivePanelUpdater = class C {
	get value() {
		return _classPrivateFieldGet2(_value, this);
	}
	constructor(T) {
		_classPrivateFieldInitSpec(this, _value, void 0), this.subscribers = /* @__PURE__ */ new Map(), _classPrivateFieldSet2(_value, this, T()), user_effect(() => {
			_classPrivateFieldSet2(_value, this, T());
			for (let T of C.Dettached) this.subscribers.delete(T), C.Attached.delete(T);
			C.Dettached.clear();
			for (let C of this.subscribers.values()) C(_classPrivateFieldGet2(_value, this));
		});
	}
	attach(T, E) {
		C.Attached.add(T);
		let D = {};
		E.reduce((C, T, E, { length: D }) => (C[T] = E === D - 1 ? _classPrivateFieldGet2(_value, this) : {}, C), D), this.subscribers.set(T, (C) => {
			E.reduce((T, E, D, { length: O }) => {
				if (D === O - 1) T[E] = C;
				else return T[E];
			}, D), T.update(D);
		});
	}
	static DettachFromAll(T) {
		let { Attached: E, Dettached: D } = C;
		E.has(T) && D.add(T);
	}
};
_ReactivePanelUpdater = ReactivePanelUpdater, _ReactivePanelUpdater.Attached = /* @__PURE__ */ new Set(), _ReactivePanelUpdater.Dettached = /* @__PURE__ */ new Set();
var n$1 = Date.now();
function idGenerator() {
	return (++n$1).toString(36);
}
const signal = (C) => new ReactivePanelUpdater(C), extractCoreOptions = (C, T) => T.reduce((T, E) => (E in C && (T[E] = C[E]), T), {}), prefix = {
	component: "c_",
	snippet: "s_"
}, createExtendedAPI = (C, E, D) => {
	let O = (O, F, ...I) => {
		var L, z, B;
		let V = O + F, { length: U } = I, W = U >= 1 ? (L = I[0]) == null ? {} : L : {}, G = U === 2 ? I[1] : null, K = U === 2 ? (z = G == null ? void 0 : G.id) == null ? V : z : V, J = (B = G == null ? void 0 : G.title) == null ? F : B, Y = PanelRendererBase.Mount.await({
			viewIndex: D,
			id: K,
			name: F,
			panelTarget: C
		}), X;
		for (let C in W) {
			let T = W[C];
			T instanceof ReactivePanelUpdater && (X != null || (X = []), X.push([T, ["params", C]]), W[C] = T.value);
		}
		let Z = E.addPanel(_objectSpread2(_objectSpread2({}, G == null ? {} : G), {}, {
			id: K,
			title: J,
			component: V,
			params: W
		}));
		if (X) for (let [C, T] of X) C.attach(Z, T);
		return [
			Y,
			Z,
			K
		];
	}, F = function() {
		var C = _asyncToGenerator(function* (C, ...T) {
			let [E, D, F] = O(prefix.component, C, ...T);
			return {
				exports: yield E,
				panel: D,
				reference: F
			};
		});
		return function(T) {
			return C.apply(this, arguments);
		};
	}(), I = function() {
		var C = _asyncToGenerator(function* (C, ...T) {
			let [E, D, F] = O(prefix.snippet, C, ...T);
			return yield E, {
				panel: D,
				reference: F
			};
		});
		return function(T) {
			return C.apply(this, arguments);
		};
	}();
	return "onDidRemovePanel" in E ? E.onDidRemovePanel(ReactivePanelUpdater.DettachFromAll) : "onDidRemoveView" in E && E.onDidRemoveView(ReactivePanelUpdater.DettachFromAll), {
		addComponentPanel: F,
		addSnippetPanel: I,
		signal
	};
};
var getSnippetPostProcessor = (C, T) => (E) => {
	var D;
	let O = C[T];
	(E == null || (D = E.params) == null ? void 0 : D.snippet) !== O && (E.params != null || (E.params = {}), E.params.snippet = O);
}, CastedSnippetRender = SnippetRender;
const getComponentToMount = (C, T, E, { name: D }) => {
	let O = D.startsWith(prefix.snippet);
	if (!O && !D.startsWith(prefix.component)) {
		let C = T == null ? void 0 : T[D], O = E == null ? void 0 : E[D];
		if (C && O) throw Error(`Component '${D}' is both a component and a snippet`);
		if (C) return {
			component: C,
			propsPostProcessor: void 0,
			name: D
		};
		if (O) return {
			name: D,
			component: CastedSnippetRender,
			propsPostProcessor: getSnippetPostProcessor(E, D)
		};
		throw Error(`Component '${D}' not found`);
	}
	let { length: F } = O ? prefix.snippet : prefix.component, I = D.slice(F);
	return {
		component: O ? CastedSnippetRender : T == null ? void 0 : T[I],
		propsPostProcessor: O ? getSnippetPostProcessor(E, I) : void 0,
		name: I
	};
};
var root$58 = /* @__PURE__ */ from_html("<video><source/> <!> <track kind=\"captions\"/> Your browser does not support the video tag.</video>", 2);
function Video(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "type", 7, "video/mp4"), F = prop(E, "trackSrc", 7), I = prop(E, "src", 7), L = prop(E, "srclang", 7, "en"), z = prop(E, "label", 7, "english_captions"), B = prop(E, "class", 7), V = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"type",
		"trackSrc",
		"src",
		"srclang",
		"label",
		"class"
	]);
	var U = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get type() {
			return O();
		},
		set type(C = "video/mp4") {
			O(C), flushSync();
		},
		get trackSrc() {
			return F();
		},
		set trackSrc(C) {
			F(C), flushSync();
		},
		get src() {
			return I();
		},
		set src(C) {
			I(C), flushSync();
		},
		get srclang() {
			return L();
		},
		set srclang(C = "en") {
			L(C), flushSync();
		},
		get label() {
			return z();
		},
		set label(C = "english_captions") {
			z(C), flushSync();
		},
		get class() {
			return B();
		},
		set class(C) {
			B(C), flushSync();
		}
	}, W = root$58();
	attribute_effect(W, () => _objectSpread2(_objectSpread2({}, V), {}, { class: B() }));
	var G = child(W), K = sibling(G, 2), J = (C) => {
		var T = comment();
		snippet(first_child(T), D), append(C, T);
	};
	if_block(K, (C) => {
		D() && C(J);
	});
	var Y = sibling(K, 2);
	return next(), reset(W), template_effect(() => {
		set_attribute(G, "src", I()), set_attribute(G, "type", O()), set_attribute(Y, "src", F()), set_attribute(Y, "srclang", L()), set_attribute(Y, "label", z());
	}), append(C, W), pop(U);
}
create_custom_element(Video, {
	children: {},
	type: {},
	trackSrc: {},
	src: {},
	srclang: {},
	label: {},
	class: {}
}, [], [], !0);
var root$57 = /* @__PURE__ */ from_html("<div class=\"inline\"><div><!></div></div>");
function ButtonToggleGroup(C, E) {
	push(E, !0);
	let D = prop(E, "multiSelect", 7, !1), O = prop(E, "name", 7, "toggle-group"), F = prop(E, "value", 23, () => D() ? [] : null), I = prop(E, "color", 7), L = prop(E, "size", 7, "md"), z = prop(E, "roundedSize", 7, "md"), B = prop(E, "onSelect", 7, (C) => {}), V = prop(E, "children", 7), U = prop(E, "ctxIconClass", 7), W = prop(E, "ctxBtnClass", 7), G = prop(E, "class", 7), K = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"multiSelect",
		"name",
		"value",
		"color",
		"size",
		"roundedSize",
		"onSelect",
		"children",
		"ctxIconClass",
		"ctxBtnClass",
		"class"
	]), J = getTheme("buttonToggleGroup"), Y = /* @__PURE__ */ user_derived(() => buttonToggleGroup({
		roundedSize: z(),
		class: clsx_default(J, G())
	})), X = /* @__PURE__ */ state(proxy(D() ? [] : null));
	user_effect(() => {
		F(get(X)), B()(get(X));
	});
	function Z(C) {
		if (D()) {
			let T = [...get(X)], E = T.indexOf(C);
			E === -1 ? set(X, [...T, C], !0) : (T.splice(E, 1), set(X, T, !0));
		} else set(X, C === get(X) ? null : C, !0);
	}
	function Q(C) {
		return D() ? get(X).includes(C) : get(X) === C;
	}
	setContext("button-toggle-group", {
		toggleSelected: Z,
		isSelected: Q
	}), setContext("multiSelect", D()), setContext("buttonToggleColor", I()), setContext("buttonToggleSize", L()), setContext("buttonToggleRounded", z()), setContext("ctxIconClass", clsx_default(U())), setContext("ctxBtnClass", clsx_default(W()));
	var NL = {
		get multiSelect() {
			return D();
		},
		set multiSelect(C = !1) {
			D(C), flushSync();
		},
		get name() {
			return O();
		},
		set name(C = "toggle-group") {
			O(C), flushSync();
		},
		get value() {
			return F();
		},
		set value(C = D ? [] : null) {
			F(C), flushSync();
		},
		get color() {
			return I();
		},
		set color(C) {
			I(C), flushSync();
		},
		get size() {
			return L();
		},
		set size(C = "md") {
			L(C), flushSync();
		},
		get roundedSize() {
			return z();
		},
		set roundedSize(C = "md") {
			z(C), flushSync();
		},
		get onSelect() {
			return B();
		},
		set onSelect(C = (C) => {}) {
			B(C), flushSync();
		},
		get children() {
			return V();
		},
		set children(C) {
			V(C), flushSync();
		},
		get ctxIconClass() {
			return U();
		},
		set ctxIconClass(C) {
			U(C), flushSync();
		},
		get ctxBtnClass() {
			return W();
		},
		set ctxBtnClass(C) {
			W(C), flushSync();
		},
		get class() {
			return G();
		},
		set class(C) {
			G(C), flushSync();
		}
	}, PL = root$57(), FL = child(PL);
	return attribute_effect(FL, () => _objectSpread2({
		class: get(Y),
		role: D() ? "group" : "radiogroup",
		"aria-label": O()
	}, K)), snippet(child(FL), V), reset(FL), reset(PL), append(C, PL), pop(NL);
}
create_custom_element(ButtonToggleGroup, {
	multiSelect: {},
	name: {},
	value: {},
	color: {},
	size: {},
	roundedSize: {},
	onSelect: {},
	children: {},
	ctxIconClass: {},
	ctxBtnClass: {},
	class: {}
}, [], [], !0);
var root$56 = /* @__PURE__ */ from_svg("<svg><polyline points=\"20 6 9 17 4 12\"></polyline></svg>");
function CheckIcon(C, E) {
	push(E, !0);
	let D = prop(E, "class", 7), O = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"class"
	]);
	var F = {
		get class() {
			return D();
		},
		set class(C) {
			D(C), flushSync();
		}
	}, I = root$56();
	return attribute_effect(I, (C) => _objectSpread2({
		xmlns: "http://www.w3.org/2000/svg",
		width: "16",
		height: "16",
		viewBox: "0 0 24 24",
		fill: "none",
		stroke: "currentColor",
		"stroke-width": "2",
		"stroke-linecap": "round",
		"stroke-linejoin": "round",
		class: C
	}, O), [() => clsx_default(D())]), append(C, I), pop(F);
}
create_custom_element(CheckIcon, { class: {} }, [], [], !0);
const buttonToggleGroup = ce({
	base: "inline-flex border border-gray-300 overflow-hidden",
	variants: { roundedSize: {
		sm: "rounded-sm",
		md: "rounded-md",
		lg: "rounded-lg",
		xl: "rounded-xl",
		full: "rounded-full"
	} }
}), buttonToggle = ce({
	slots: {
		button: "relative flex items-center transition-all duration-200 focus:outline-none border-r last:border-r-0 dark:bg-white dark:text-gray-800 disabled:cursor-not-allowed disabled:opacity-50",
		content: "flex items-center w-full overflow-hidden relative",
		text: "transition-all duration-200 ml-0",
		icon: "absolute left-0 flex-shrink-0 text-green-600"
	},
	variants: {
		selected: {
			true: { text: "ml-5" },
			false: {}
		},
		size: {
			sm: { button: "p-1 px-2 text-sm" },
			md: { button: "p-2 px-4 text-base" },
			lg: { button: "p-3 px-5 text-lg" },
			xl: { button: "p-4 px-6 text-xl" }
		},
		roundedSize: {
			sm: { button: "first:rounded-s-sm last:rounded-e-sm" },
			md: { button: "first:rounded-s-md last:rounded-e-md" },
			lg: { button: "first:rounded-s-lg last:rounded-e-lg" },
			xl: { button: "first:rounded-s-xl last:rounded-e-xl" },
			full: { button: "first:rounded-s-full last:rounded-e-full" }
		},
		color: {
			primary: { button: "data-[selected=true]:bg-primary-200 data-[selected=false]:hover:bg-gray-100" },
			secondary: { button: "data-[selected=true]:bg-secondary-200 data-[selected=false]:hover:bg-gray-100" },
			gray: { button: "data-[selected=true]:bg-gray-200 data-[selected=false]:hover:bg-gray-100" },
			red: { button: "data-[selected=true]:bg-red-200 data-[selected=false]:hover:bg-red-50" },
			orange: { button: "data-[selected=true]:bg-orange-200 data-[selected=false]:hover:bg-orange-50" },
			amber: { button: "data-[selected=true]:bg-amber-200 data-[selected=false]:hover:bg-amber-50" },
			yellow: { button: "data-[selected=true]:bg-yellow-200 data-[selected=false]:hover:bg-yellow-50" },
			lime: { button: "data-[selected=true]:bg-lime-200 data-[selected=false]:hover:bg-lime-50" },
			green: { button: "data-[selected=true]:bg-green-200 data-[selected=false]:hover:bg-green-50" },
			emerald: { button: "data-[selected=true]:bg-emerald-200 data-[selected=false]:hover:bg-emerald-50" },
			teal: { button: "data-[selected=true]:bg-teal-200 data-[selected=false]:hover:bg-teal-50" },
			cyan: { button: "data-[selected=true]:bg-cyan-200 data-[selected=false]:hover:bg-cyan-50" },
			sky: { button: "data-[selected=true]:bg-sky-200 data-[selected=false]:hover:bg-sky-50" },
			blue: { button: "data-[selected=true]:bg-blue-200 data-[selected=false]:hover:bg-blue-50" },
			indigo: { button: "data-[selected=true]:bg-indigo-200 data-[selected=false]:hover:bg-indigo-50" },
			violet: { button: "data-[selected=true]:bg-violet-200 data-[selected=false]:hover:bg-violet-50" },
			purple: { button: "data-[selected=true]:bg-purple-200 data-[selected=false]:hover:bg-purple-50" },
			fuchsia: { button: "data-[selected=true]:bg-fuchsia-200 data-[selected=false]:hover:bg-fuchsia-50" },
			pink: { button: "data-[selected=true]:bg-pink-200 data-[selected=false]:hover:bg-pink-50" },
			rose: { button: "data-[selected=true]:bg-rose-200 data-[selected=false]:hover:bg-rose-50" },
			none: {}
		}
	},
	defaultVariants: {
		selected: !1,
		color: "primary",
		size: "md",
		roundedSize: "md"
	}
});
var root$55 = /* @__PURE__ */ from_html("<button><div><!> <span><!></span></div></button>");
function ButtonToggle(C, E) {
	push(E, !0);
	let D = prop(E, "value", 7), O = prop(E, "selected", 7, !1), F = prop(E, "children", 7), I = prop(E, "iconSlot", 7), L = prop(E, "color", 7), z = prop(E, "class", 7), B = prop(E, "iconClass", 7), V = prop(E, "txtClass", 7), U = prop(E, "contentClass", 7), W = prop(E, "classes", 7), G = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"value",
		"selected",
		"children",
		"iconSlot",
		"color",
		"class",
		"iconClass",
		"txtClass",
		"contentClass",
		"classes"
	]);
	B(), V(), U();
	let K = /* @__PURE__ */ user_derived(() => {
		var C;
		return (C = W()) == null ? {
			icon: B(),
			text: V(),
			content: U()
		} : C;
	}), J = getTheme("buttonToggle"), { toggleSelected: Y, isSelected: X } = getContext("button-toggle-group"), Z = getContext("multiSelect"), Q = getContext("buttonToggleColor") ? getContext("buttonToggleColor") : L() ? L() : "primary", NL = getContext("buttonToggleSize"), PL = getContext("buttonToggleRounded"), FL = getContext("ctxIconClass"), IL = getContext("ctxBtnClass");
	function LL() {
		Y(D());
	}
	let RL = /* @__PURE__ */ user_derived(() => buttonToggle({
		selected: O(),
		color: L(),
		size: NL
	})), zL = /* @__PURE__ */ user_derived(() => get(RL).button), BL = /* @__PURE__ */ user_derived(() => get(RL).content), VL = /* @__PURE__ */ user_derived(() => get(RL).text), HL = /* @__PURE__ */ user_derived(() => get(RL).icon);
	user_effect(() => {
		O(X(D()));
	});
	var UL = {
		get value() {
			return D();
		},
		set value(C) {
			D(C), flushSync();
		},
		get selected() {
			return O();
		},
		set selected(C = !1) {
			O(C), flushSync();
		},
		get children() {
			return F();
		},
		set children(C) {
			F(C), flushSync();
		},
		get iconSlot() {
			return I();
		},
		set iconSlot(C) {
			I(C), flushSync();
		},
		get color() {
			return L();
		},
		set color(C) {
			L(C), flushSync();
		},
		get class() {
			return z();
		},
		set class(C) {
			z(C), flushSync();
		},
		get iconClass() {
			return B();
		},
		set iconClass(C) {
			B(C), flushSync();
		},
		get txtClass() {
			return V();
		},
		set txtClass(C) {
			V(C), flushSync();
		},
		get contentClass() {
			return U();
		},
		set contentClass(C) {
			U(C), flushSync();
		},
		get classes() {
			return W();
		},
		set classes(C) {
			W(C), flushSync();
		}
	}, WL = root$55();
	attribute_effect(WL, (C) => _objectSpread2({
		type: "button",
		class: C,
		"data-selected": O(),
		onclick: LL,
		role: Z ? "checkbox" : "radio",
		"aria-checked": O()
	}, G), [() => get(zL)({
		selected: O(),
		color: Q,
		size: NL,
		roundedSize: PL,
		class: clsx_default(J == null ? void 0 : J.button, IL, z())
	})]);
	var GL = child(WL), KL = child(GL), qL = (C) => {
		var T = comment(), E = first_child(T), D = (C) => {
			var T = comment();
			snippet(first_child(T), I), append(C, T);
		}, O = (C) => {
			{
				let T = /* @__PURE__ */ user_derived(() => {
					var C;
					return get(HL)({ class: clsx_default((C = J == null ? void 0 : J.icon) == null ? FL : C, get(K).icon) });
				});
				CheckIcon(C, { get class() {
					return get(T);
				} });
			}
		};
		if_block(E, (C) => {
			I() ? C(D) : C(O, !1);
		}), append(C, T);
	};
	if_block(KL, (C) => {
		O() && C(qL);
	});
	var JL = sibling(KL, 2);
	return snippet(child(JL), F), reset(JL), reset(GL), reset(WL), template_effect((C, T) => {
		set_class(GL, 1, C), set_class(JL, 1, T);
	}, [() => clsx$1(get(BL)({ class: clsx_default(J == null ? void 0 : J.content, get(K).content) })), () => clsx$1(get(VL)({
		selected: O(),
		class: clsx_default(J == null ? void 0 : J.text, get(K).text)
	}))]), append(C, WL), pop(UL);
}
create_custom_element(ButtonToggle, {
	value: {},
	selected: {},
	children: {},
	iconSlot: {},
	color: {},
	class: {},
	iconClass: {},
	txtClass: {},
	contentClass: {},
	classes: {}
}, [], [], !0);
const checkbox = ce({
	slots: {
		base: "w-4 h-4 bg-gray-100 border-gray-300 dark:ring-offset-gray-800 focus:ring-2 me-2 rounded-sm",
		div: "flex items-center"
	},
	variants: {
		color: {
			primary: { base: "text-primary-600 focus:ring-primary-500 dark:focus:ring-primary-600" },
			secondary: { base: "text-secondary-600 focus:ring-secondary-500 dark:focus:ring-secondary-600" },
			gray: { base: "text-gray-600 focus:ring-gray-600 dark:ring-offset-gray-800 dark:focus:ring-gray-600" },
			red: { base: "text-red-600 focus:ring-red-600 dark:ring-offset-red-600 dark:focus:ring-red-600" },
			orange: { base: "text-orange-600 focus:ring-orange-600 dark:ring-offset-orange-600 dark:focus:ring-orange-600" },
			amber: { base: "text-amber-600 focus:ring-amber-600 dark:ring-offset-amber-600 dark:focus:ring-amber-600" },
			yellow: { base: "text-yellow-400 focus:ring-yellow-400 dark:ring-offset-yellow-400 dark:focus:ring-yellow-400" },
			lime: { base: "text-lime-700 focus:ring-lime-700 dark:ring-offset-lime-700 dark:focus:ring-lime-700" },
			green: { base: "text-green-600 focus:ring-green-600 dark:ring-offset-green-600 dark:focus:ring-green-600" },
			emerald: { base: "text-emerald-600 focus:ring-emerald-600 dark:ring-offset-emerald-600 dark:focus:ring-emerald-600" },
			teal: { base: "text-teal-600 focus:ring-teal-600 dark:ring-offset-teal-600 dark:focus:ring-teal-600" },
			cyan: { base: "text-cyan-600 focus:ring-cyan-600 dark:ring-offset-cyan-600 dark:focus:ring-cyan-600" },
			sky: { base: "text-sky-600 focus:ring-sky-600 dark:ring-offset-sky-600 dark:focus:ring-sky-600" },
			blue: { base: "text-blue-700 focus:ring-blue-600 dark:ring-offset-blue-700 dark:focus:ring-blue-700" },
			indigo: { base: "text-indigo-700 focus:ring-indigo-700 dark:ring-offset-indigo-700 dark:focus:ring-indigo-700" },
			violet: { base: "text-violet-600 focus:ring-violet-600 dark:ring-offset-violet-600 dark:focus:ring-violet-600" },
			purple: { base: "text-purple-600 focus:ring-purple-600 dark:ring-offset-purple-600 dark:focus:ring-purple-600" },
			fuchsia: { base: "text-fuchsia-600 focus:ring-fuchsia-600 dark:ring-offset-fuchsia-600 dark:focus:ring-fuchsia-600" },
			pink: { base: "text-pink-600 focus:ring-pink-600 dark:ring-offset-pink-600 dark:focus:ring-pink-600" },
			rose: { base: "text-rose-600 focus:ring-rose-600 dark:ring-offset-rose-600 dark:focus:ring-rose-600" }
		},
		tinted: {
			true: { base: "dark:bg-gray-600 dark:border-gray-500" },
			false: { base: "dark:bg-gray-700 dark:border-gray-600" }
		},
		custom: { true: { base: "sr-only peer" } },
		rounded: { true: { base: "rounded-sm" } },
		inline: { true: {
			div: "inline-flex",
			false: "flex items-center"
		} },
		disabled: {
			true: {
				base: "cursor-not-allowed opacity-50 bg-gray-200 border-gray-300",
				div: "cursor-not-allowed opacity-70"
			},
			false: {}
		}
	},
	defaultVariants: {
		color: "primary",
		disabled: !1
	}
}), checkboxButton = ce({
	base: "",
	variants: {
		inline: {
			true: "inline-flex",
			false: "flex"
		},
		checked: { true: "outline-4 outline-green-500" }
	},
	defaultVariants: { inline: !0 }
});
var root_3$29 = /* @__PURE__ */ from_html("<input/> <!>", 1), root_7$6 = /* @__PURE__ */ from_html("<input/> <!>", 1);
function Checkbox(C, E) {
	push(E, !0);
	let D = [], O = prop(E, "children", 7), F = prop(E, "color", 7, "primary"), I = prop(E, "custom", 7), L = prop(E, "inline", 7), z = prop(E, "tinted", 7), B = prop(E, "rounded", 7), V = prop(E, "group", 31, () => proxy([])), U = prop(E, "choices", 23, () => []), W = prop(E, "checked", 15, !1), G = prop(E, "classes", 7), K = prop(E, "class", 7), J = prop(E, "divClass", 7), Y = prop(E, "disabled", 7), X = prop(E, "value", 7), Z = prop(E, "labelProps", 23, () => ({})), Q = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"color",
		"custom",
		"inline",
		"tinted",
		"rounded",
		"group",
		"choices",
		"checked",
		"classes",
		"class",
		"divClass",
		"disabled",
		"value",
		"labelProps"
	]);
	J();
	let NL = /* @__PURE__ */ user_derived(() => {
		var C;
		return (C = G()) == null ? { div: J() } : C;
	}), PL = getTheme("checkbox"), FL = /* @__PURE__ */ user_derived(() => {
		var C;
		return checkbox({
			color: F(),
			tinted: z(),
			custom: I(),
			rounded: B(),
			inline: L(),
			disabled: (C = Y()) == null ? !1 : C
		});
	}), IL = /* @__PURE__ */ user_derived(() => get(FL).base), LL = /* @__PURE__ */ user_derived(() => get(FL).div);
	user_effect(() => {
		X() !== void 0 && Array.isArray(V()) && W(V().includes(X()));
	}), user_effect(() => {
		if (X() === void 0 || !Array.isArray(V())) return;
		let C = V().indexOf(X());
		W() === void 0 && W(C >= 0), W() ? C < 0 && V().push(X()) : C >= 0 && V().splice(C, 1);
	});
	var RL = {
		get children() {
			return O();
		},
		set children(C) {
			O(C), flushSync();
		},
		get color() {
			return F();
		},
		set color(C = "primary") {
			F(C), flushSync();
		},
		get custom() {
			return I();
		},
		set custom(C) {
			I(C), flushSync();
		},
		get inline() {
			return L();
		},
		set inline(C) {
			L(C), flushSync();
		},
		get tinted() {
			return z();
		},
		set tinted(C) {
			z(C), flushSync();
		},
		get rounded() {
			return B();
		},
		set rounded(C) {
			B(C), flushSync();
		},
		get group() {
			return V();
		},
		set group(C = []) {
			V(C), flushSync();
		},
		get choices() {
			return U();
		},
		set choices(C = []) {
			U(C), flushSync();
		},
		get checked() {
			return W();
		},
		set checked(C = !1) {
			W(C), flushSync();
		},
		get classes() {
			return G();
		},
		set classes(C) {
			G(C), flushSync();
		},
		get class() {
			return K();
		},
		set class(C) {
			K(C), flushSync();
		},
		get divClass() {
			return J();
		},
		set divClass(C) {
			J(C), flushSync();
		},
		get disabled() {
			return Y();
		},
		set disabled(C) {
			Y(C), flushSync();
		},
		get value() {
			return X();
		},
		set value(C) {
			X(C), flushSync();
		},
		get labelProps() {
			return Z();
		},
		set labelProps(C = {}) {
			Z(C), flushSync();
		}
	}, zL = comment(), BL = first_child(zL), VL = (C) => {
		var E = comment();
		each(first_child(E), 19, U, (C, T) => {
			var E;
			return (E = C.value) == null ? T : E;
		}, (C, E) => {
			{
				let F = /* @__PURE__ */ user_derived(() => !!O() || !!get(E).label), I = /* @__PURE__ */ user_derived(() => get(LL)({ class: clsx_default(PL == null ? void 0 : PL.div, get(NL).div) }));
				Label(C, spread_props({ get show() {
					return get(F);
				} }, Z, {
					get class() {
						return get(I);
					},
					children: (C, F) => {
						var I = root_3$29(), L = first_child(I);
						attribute_effect(L, (C) => {
							var D;
							return _objectSpread2(_objectSpread2({
								type: "checkbox",
								value: get(E).value,
								checked: (D = get(E).checked) == null ? !1 : D,
								disabled: Y()
							}, Q), {}, { class: C });
						}, [() => get(IL)({ class: clsx_default(PL == null ? void 0 : PL.base, K()) })], void 0, void 0, void 0, !0);
						var z = sibling(L, 2), B = (C) => {
							var T = comment();
							snippet(first_child(T), O, () => ({
								value: get(E).value,
								checked: get(E).checked,
								disabled: Y()
							})), append(C, T);
						}, U = (C) => {
							var T = text();
							template_effect(() => set_text(T, get(E).label)), append(C, T);
						};
						if_block(z, (C) => {
							O() ? C(B) : C(U, !1);
						}), bind_group(D, [], L, () => (get(E).value, V()), V), append(C, I);
					},
					$$slots: { default: !0 }
				}));
			}
		}), append(C, E);
	}, HL = (C) => {
		{
			let E = /* @__PURE__ */ user_derived(() => !!O()), D = /* @__PURE__ */ user_derived(() => get(LL)({ class: clsx_default(PL == null ? void 0 : PL.div, get(NL).div) }));
			Label(C, spread_props({ get show() {
				return get(E);
			} }, Z, {
				get class() {
					return get(D);
				},
				children: (C, E) => {
					var D = root_7$6(), F = first_child(D);
					attribute_effect(F, (C) => _objectSpread2(_objectSpread2({
						type: "checkbox",
						value: X(),
						disabled: Y()
					}, Q), {}, { class: C }), [() => get(IL)({ class: clsx_default(PL == null ? void 0 : PL.base, K()) })], void 0, void 0, void 0, !0);
					var I = sibling(F, 2), L = (C) => {
						var T = comment();
						snippet(first_child(T), O, () => ({
							value: X(),
							checked: W(),
							disabled: Y()
						})), append(C, T);
					};
					if_block(I, (C) => {
						O() && C(L);
					}), bind_checked(F, W), append(C, D);
				},
				$$slots: { default: !0 }
			}));
		}
	};
	return if_block(BL, (C) => {
		U().length > 0 ? C(VL) : C(HL, !1);
	}), append(C, zL), pop(RL);
}
create_custom_element(Checkbox, {
	children: {},
	color: {},
	custom: {},
	inline: {},
	tinted: {},
	rounded: {},
	group: {},
	choices: {},
	checked: {},
	classes: {},
	class: {},
	divClass: {},
	disabled: {},
	value: {},
	labelProps: {}
}, [], [], !0);
var root_1$66 = /* @__PURE__ */ from_html("<!> <!>", 1);
function CheckboxButton(C, T) {
	push(T, !0);
	let E = prop(T, "children", 7), D = prop(T, "class", 7), O = prop(T, "group", 15), F = prop(T, "checked", 15, !1), I = prop(T, "inline", 7), L = prop(T, "pill", 7), z = prop(T, "outline", 7), B = prop(T, "size", 7), V = prop(T, "color", 7), U = prop(T, "shadow", 7), W = /* @__PURE__ */ rest_props(T, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"class",
		"group",
		"checked",
		"inline",
		"pill",
		"outline",
		"size",
		"color",
		"shadow"
	]), G = getTheme("checkboxButton"), K = /* @__PURE__ */ user_derived(() => checkboxButton({
		inline: I(),
		checked: F(),
		class: clsx_default(G, D())
	}));
	return Button(C, {
		tag: "label",
		get pill() {
			return L();
		},
		get outline() {
			return z();
		},
		get size() {
			return B();
		},
		get color() {
			return V();
		},
		get shadow() {
			return U();
		},
		get class() {
			return get(K);
		},
		children: (C, T) => {
			var D = root_1$66(), I = first_child(D);
			Checkbox(I, spread_props(() => W, {
				class: "sr-only",
				get group() {
					return O();
				},
				set group(C) {
					O(C);
				},
				get checked() {
					return F();
				},
				set checked(C) {
					F(C);
				}
			})), snippet(sibling(I, 2), () => {
				var C;
				return (C = E()) == null ? noop : C;
			}), append(C, D);
		},
		$$slots: { default: !0 }
	}), pop({
		get children() {
			return E();
		},
		set children(C) {
			E(C), flushSync();
		},
		get class() {
			return D();
		},
		set class(C) {
			D(C), flushSync();
		},
		get group() {
			return O();
		},
		set group(C) {
			O(C), flushSync();
		},
		get checked() {
			return F();
		},
		set checked(C = !1) {
			F(C), flushSync();
		},
		get inline() {
			return I();
		},
		set inline(C) {
			I(C), flushSync();
		},
		get pill() {
			return L();
		},
		set pill(C) {
			L(C), flushSync();
		},
		get outline() {
			return z();
		},
		set outline(C) {
			z(C), flushSync();
		},
		get size() {
			return B();
		},
		set size(C) {
			B(C), flushSync();
		},
		get color() {
			return V();
		},
		set color(C) {
			V(C), flushSync();
		},
		get shadow() {
			return U();
		},
		set shadow(C) {
			U(C), flushSync();
		}
	});
}
create_custom_element(CheckboxButton, {
	children: {},
	class: {},
	group: {},
	checked: {},
	inline: {},
	pill: {},
	outline: {},
	size: {},
	color: {},
	shadow: {}
}, [], [], !0);
const dropzone = ce({ base: "flex flex-col justify-center items-center w-full h-64 bg-gray-50 rounded-lg border-2 border-gray-300 border-dashed cursor-pointer dark:hover:bg-bray-800 dark:bg-gray-700 hover:bg-gray-100 dark:border-gray-600 dark:hover:border-gray-500 dark:hover:bg-gray-600" });
var root$54 = /* @__PURE__ */ from_html("<label><!> <input/></label>");
function Dropzone(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "files", 15), F = prop(E, "class", 7), I = prop(E, "onDrop", 7), L = prop(E, "onDragOver", 7), z = prop(E, "onChange", 7), B = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"files",
		"class",
		"onDrop",
		"onDragOver",
		"onChange"
	]), V = getTheme("dropzone"), U, W = function(C) {
		var T;
		C.preventDefault(), (T = C.dataTransfer) != null && T.files && C.dataTransfer.files.length > 0 && (O(C.dataTransfer.files), U && (U.files = C.dataTransfer.files)), I() && I().call(this, C);
	}, G = function(C) {
		C.preventDefault(), L() && L().call(this, C);
	}, K = function(C) {
		z() && z().call(this, C);
	};
	var J = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get files() {
			return O();
		},
		set files(C) {
			O(C), flushSync();
		},
		get class() {
			return F();
		},
		set class(C) {
			F(C), flushSync();
		},
		get onDrop() {
			return I();
		},
		set onDrop(C) {
			I(C), flushSync();
		},
		get onDragOver() {
			return L();
		},
		set onDragOver(C) {
			L(C), flushSync();
		},
		get onChange() {
			return z();
		},
		set onChange(C) {
			z(C), flushSync();
		}
	}, Y = root$54(), X = child(Y);
	snippet(X, D);
	var Z = sibling(X, 2);
	return attribute_effect(Z, () => _objectSpread2(_objectSpread2({}, B), {}, {
		onchange: K,
		type: "file",
		class: "hidden"
	}), void 0, void 0, void 0, void 0, !0), bind_this(Z, (C) => U = C, () => U), reset(Y), template_effect((C) => set_class(Y, 1, C), [() => clsx$1(dropzone({ class: clsx_default(V, F()) }))]), event("drop", Y, W), event("dragover", Y, G), bind_files(Z, O), append(C, Y), pop(J);
}
create_custom_element(Dropzone, {
	children: {},
	files: {},
	class: {},
	onDrop: {},
	onDragOver: {},
	onChange: {}
}, [], [], !0);
const fileupload = ce({
	slots: {
		base: "block w-full disabled:cursor-not-allowed disabled:opacity-50 rtl:text-right p-2.5 focus:border-primary-500 focus:ring-primary-500 dark:focus:border-primary-500 dark:focus:ring-primary-500 bg-gray-50 text-gray-900 dark:bg-gray-700 dark:placeholder-gray-400 border-gray-300 dark:border-gray-600 text-sm rounded-lg border p-0! dark:text-gray-400",
		wrapper: "relative w-full",
		close: "flex absolute inset-y-0 items-center text-gray-500 dark:text-gray-400 end-0 p-2.5",
		svg: ""
	},
	variants: { size: {
		sm: { base: "text-xs ps-9 pe-9 p-2" },
		md: { base: "text-sm ps-10 pe-10 p-2.5" },
		lg: { base: "sm:text-base ps-11 pe-11 p-3" }
	} }
});
var root$53 = /* @__PURE__ */ from_html("<div><input/> <!></div>");
function Fileupload(C, E) {
	push(E, !0);
	let D = prop(E, "files", 15), O = prop(E, "size", 7, "md"), F = prop(E, "clearable", 7, !1), I = prop(E, "elementRef", 15), L = prop(E, "class", 7), z = prop(E, "classes", 7), B = prop(E, "clearableSvgClass", 7), V = prop(E, "clearableColor", 7, "none"), U = prop(E, "clearableClass", 7), W = prop(E, "clearableOnClick", 7), G = prop(E, "wrapperClass", 7), K = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"files",
		"size",
		"clearable",
		"elementRef",
		"class",
		"classes",
		"clearableSvgClass",
		"clearableColor",
		"clearableClass",
		"clearableOnClick",
		"wrapperClass"
	]);
	G(), U(), B();
	let J = /* @__PURE__ */ user_derived(() => {
		var C;
		return (C = z()) == null ? {
			wrapper: G(),
			close: U(),
			svg: B()
		} : C;
	}), Y = getTheme("fileupload"), { base: X, wrapper: Z, close: Q } = fileupload();
	createDismissableContext(() => {
		I() && (I(I().value = "", !0), D(void 0)), W() && W()();
	});
	var NL = {
		get files() {
			return D();
		},
		set files(C) {
			D(C), flushSync();
		},
		get size() {
			return O();
		},
		set size(C = "md") {
			O(C), flushSync();
		},
		get clearable() {
			return F();
		},
		set clearable(C = !1) {
			F(C), flushSync();
		},
		get elementRef() {
			return I();
		},
		set elementRef(C) {
			I(C), flushSync();
		},
		get class() {
			return L();
		},
		set class(C) {
			L(C), flushSync();
		},
		get classes() {
			return z();
		},
		set classes(C) {
			z(C), flushSync();
		},
		get clearableSvgClass() {
			return B();
		},
		set clearableSvgClass(C) {
			B(C), flushSync();
		},
		get clearableColor() {
			return V();
		},
		set clearableColor(C = "none") {
			V(C), flushSync();
		},
		get clearableClass() {
			return U();
		},
		set clearableClass(C) {
			U(C), flushSync();
		},
		get clearableOnClick() {
			return W();
		},
		set clearableOnClick(C) {
			W(C), flushSync();
		},
		get wrapperClass() {
			return G();
		},
		set wrapperClass(C) {
			G(C), flushSync();
		}
	}, PL = root$53(), FL = child(PL);
	attribute_effect(FL, (C) => _objectSpread2(_objectSpread2({ type: "file" }, K), {}, { class: C }), [() => X({
		size: O(),
		class: clsx_default(Y == null ? void 0 : Y.base, L())
	})], void 0, void 0, void 0, !0), bind_this(FL, (C) => I(C), () => I());
	var IL = sibling(FL, 2), LL = (C) => {
		{
			let T = /* @__PURE__ */ user_derived(() => Q({ class: clsx_default(Y == null ? void 0 : Y.close, get(J).close) })), E = /* @__PURE__ */ user_derived(() => clsx_default(get(J).svg));
			CloseButton(C, {
				get class() {
					return get(T);
				},
				get color() {
					return V();
				},
				"aria-label": "Clear selected files",
				get svgClass() {
					return get(E);
				}
			});
		}
	};
	return if_block(IL, (C) => {
		D() && D().length > 0 && F() && C(LL);
	}), reset(PL), template_effect((C) => set_class(PL, 1, C), [() => clsx$1(Z({ class: clsx_default(Y == null ? void 0 : Y.wrapper, get(J).wrapper) }))]), bind_files(FL, D), append(C, PL), pop(NL);
}
create_custom_element(Fileupload, {
	files: {},
	size: {},
	clearable: {},
	elementRef: {},
	class: {},
	classes: {},
	clearableSvgClass: {},
	clearableColor: {},
	clearableClass: {},
	clearableOnClick: {},
	wrapperClass: {}
}, [], [], !0);
const floatingLabelInput = ce({
	slots: {
		base: "relative",
		input: "block w-full text-sm text-gray-900 bg-transparent appearance-none dark:text-white focus:outline-hidden focus:ring-0 peer disabled:cursor-not-allowed disabled:opacity-50",
		label: "absolute text-sm duration-300 transform scale-75 z-10 origin-left rtl:origin-right peer-placeholder-shown:scale-100 peer-focus:scale-75",
		close: "absolute right-2 top-1/2 -translate-y-1/2 text-gray-400 hover:text-black",
		combo: "absolute top-full right-0 left-0 z-10 mt-1 max-h-60 overflow-y-auto rounded-md border border-gray-200 bg-white shadow-lg dark:border-gray-700 dark:bg-gray-800",
		svg: ""
	},
	variants: {
		variant: {
			filled: {
				base: "relative",
				input: "rounded-t-lg border-0 border-b-2 bg-gray-50 dark:bg-gray-700",
				label: "-translate-y-4 start-2.5 peer-placeholder-shown:translate-y-0 peer-focus:-translate-y-4"
			},
			outlined: {
				base: "relative",
				input: "rounded-lg border",
				label: "-translate-y-4 bg-white dark:bg-gray-900 px-2 peer-focus:px-2 peer-placeholder-shown:-translate-y-1/2 peer-placeholder-shown:top-1/2 peer-focus:top-2 peer-focus:-translate-y-4 start-1"
			},
			standard: {
				base: "relative z-0",
				input: "border-0 border-b-2",
				label: "-translate-y-6 -z-10 peer-focus:start-0 peer-placeholder-shown:translate-y-0 peer-focus:-translate-y-6"
			}
		},
		size: {
			small: {},
			default: {}
		},
		color: {
			default: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-primary-500 focus:border-primary-600",
				label: "text-gray-500 dark:text-gray-400 peer-focus:text-primary-600 dark:peer-focus:text-primary-500"
			},
			primary: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-primary-500 focus:border-primary-600",
				label: "text-primary-500 dark:text-primary-400 peer-focus:text-primary-600 dark:peer-focus:text-primary-500"
			},
			secondary: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-secondary-500 focus:border-secondary-600",
				label: "text-secondary-500 dark:text-secondary-400 peer-focus:text-secondary-600 dark:peer-focus:text-secondary-500"
			},
			gray: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-gray-500 focus:border-gray-600",
				label: "text-gray-500 dark:text-gray-400 peer-focus:text-gray-600 dark:peer-focus:text-gray-500"
			},
			red: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-red-500 focus:border-red-600",
				label: "text-red-500 dark:text-red-400 peer-focus:text-red-600 dark:peer-focus:text-red-500"
			},
			orange: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-orange-500 focus:border-orange-600",
				label: "text-orange-500 dark:text-orange-400 peer-focus:text-orange-600 dark:peer-focus:text-orange-500"
			},
			amber: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-amber-500 focus:border-amber-600",
				label: "text-amber-500 dark:text-amber-400 peer-focus:text-amber-600 dark:peer-focus:text-amber-500"
			},
			yellow: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-yellow-500 focus:border-yellow-600",
				label: "text-yellow-500 dark:text-yellow-400 peer-focus:text-yellow-600 dark:peer-focus:text-yellow-500"
			},
			lime: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-lime-500 focus:border-lime-600",
				label: "text-lime-500 dark:text-lime-400 peer-focus:text-lime-600 dark:peer-focus:text-lime-500"
			},
			green: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-green-500 focus:border-green-600",
				label: "text-green-500 dark:text-green-400 peer-focus:text-green-600 dark:peer-focus:text-green-500"
			},
			emerald: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-emerald-500 focus:border-emerald-600",
				label: "text-emerald-500 dark:text-emerald-400 peer-focus:text-emerald-600 dark:peer-focus:text-emerald-500"
			},
			teal: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-teal-500 focus:border-teal-600",
				label: "text-teal-500 dark:text-teal-400 peer-focus:text-teal-600 dark:peer-focus:text-teal-500"
			},
			cyan: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-cyan-500 focus:border-cyan-600",
				label: "text-cyan-500 dark:text-cyan-400 peer-focus:text-cyan-600 dark:peer-focus:text-cyan-500"
			},
			sky: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-sky-500 focus:border-sky-600",
				label: "text-sky-500 dark:text-sky-400 peer-focus:text-sky-600 dark:peer-focus:text-sky-500"
			},
			blue: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-blue-500 focus:border-blue-600",
				label: "text-blue-500 dark:text-blue-400 peer-focus:text-blue-600 dark:peer-focus:text-blue-500"
			},
			indigo: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-indigo-500 focus:border-indigo-600",
				label: "text-indigo-500 dark:text-indigo-400 peer-focus:text-indigo-600 dark:peer-focus:text-indigo-500"
			},
			violet: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-violet-500 focus:border-violet-600",
				label: "text-violet-600 dark:text-violet-500 peer-focus:text-violet-600 dark:peer-focus:text-violet-500"
			},
			purple: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-purple-500 focus:border-purple-600",
				label: "text-purple-600 dark:text-purple-500 peer-focus:text-purple-600 dark:peer-focus:text-purple-500"
			},
			fuchsia: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-fuchsia-500 focus:border-fuchsia-600",
				label: "text-fuchsia-600 dark:text-fuchsia-500 peer-focus:text-fuchsia-600 dark:peer-focus:text-fuchsia-500"
			},
			pink: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-pink-500 focus:border-pink-600",
				label: "text-pink-600 dark:text-pink-500 peer-focus:text-pink-600 dark:peer-focus:text-pink-500"
			},
			rose: {
				input: "border-gray-300 dark:border-gray-600 dark:focus:border-rose-500 focus:border-rose-600",
				label: "text-rose-600 dark:text-rose-500 peer-focus:text-rose-600 dark:peer-focus:text-rose-500"
			}
		}
	},
	compoundVariants: [
		{
			variant: "filled",
			size: "small",
			class: {
				input: "px-2.5 pb-1.5 pt-4",
				label: "top-3"
			}
		},
		{
			variant: "filled",
			size: "default",
			class: {
				input: "px-2.5 pb-2.5 pt-5",
				label: "top-4"
			}
		},
		{
			variant: "outlined",
			size: "small",
			class: {
				input: "px-2.5 pb-1.5 pt-3",
				label: "top-1"
			}
		},
		{
			variant: "outlined",
			size: "default",
			class: {
				input: "px-2.5 pb-2.5 pt-4",
				label: "top-2"
			}
		},
		{
			variant: "standard",
			size: "small",
			class: {
				input: "py-2 px-0",
				label: "top-3"
			}
		},
		{
			variant: "standard",
			size: "default",
			class: {
				input: "py-2.5 px-0",
				label: "top-3"
			}
		},
		{
			variant: "filled",
			color: "primary",
			class: { input: "dark:focus:border-primary-500 focus:border-primary-600" }
		}
	],
	defaultVariants: {
		variant: "standard",
		size: "default",
		color: "primary"
	}
});
var root_1$65 = /* @__PURE__ */ from_html("<div tabindex=\"-1\" class=\"sr-only\"></div>"), root_4$17 = /* @__PURE__ */ from_html("<button type=\"button\"> </button>"), root_3$28 = /* @__PURE__ */ from_html("<div></div>"), root$52 = /* @__PURE__ */ from_html("<!> <div><input/> <!> <label><!></label> <!></div>", 1);
function FloatingLabelInput(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "id", 23, idGenerator), F = prop(E, "value", 15), I = prop(E, "elementRef", 15), L = prop(E, "variant", 7, "standard"), z = prop(E, "size", 7, "default"), B = prop(E, "color", 7, "default"), V = prop(E, "class", 7), U = prop(E, "classes", 7), W = prop(E, "inputClass", 7), G = prop(E, "labelClass", 7), K = prop(E, "clearable", 7), J = prop(E, "clearableSvgClass", 7), Y = prop(E, "clearableColor", 7, "none"), X = prop(E, "clearableClass", 7), Z = prop(E, "clearableOnClick", 7), Q = prop(E, "data", 23, () => []), NL = prop(E, "maxSuggestions", 7, 5), PL = prop(E, "onSelect", 7), FL = prop(E, "comboClass", 7), IL = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"id",
		"value",
		"elementRef",
		"variant",
		"size",
		"color",
		"class",
		"classes",
		"inputClass",
		"labelClass",
		"clearable",
		"clearableSvgClass",
		"clearableColor",
		"clearableClass",
		"clearableOnClick",
		"data",
		"maxSuggestions",
		"onSelect",
		"comboClass"
	]);
	W(), G(), J(), X(), FL();
	let LL = /* @__PURE__ */ user_derived(() => {
		var C;
		return (C = U()) == null ? {
			input: W(),
			label: G(),
			svg: J(),
			close: X(),
			combo: FL()
		} : C;
	}), RL = getTheme("floatingLabelInput"), zL = /* @__PURE__ */ user_derived(() => floatingLabelInput({
		variant: L(),
		size: z(),
		color: B()
	})), BL = /* @__PURE__ */ user_derived(() => get(zL).base), VL = /* @__PURE__ */ user_derived(() => get(zL).input), HL = /* @__PURE__ */ user_derived(() => get(zL).label), UL = /* @__PURE__ */ user_derived(() => get(zL).close), WL = /* @__PURE__ */ user_derived(() => get(zL).combo), GL = () => {
		I() && (I(I().value = "", !0), F(""), set(ZL, !1), QL(), qL == null || qL.focus(), setTimeout(() => {
			var C;
			(C = I()) == null || C.focus();
		}, 100)), Z() && Z()();
	}, KL = /* @__PURE__ */ user_derived(() => Array.isArray(Q()) && Q().length > 0), qL, JL = /* @__PURE__ */ state(!1), YL = /* @__PURE__ */ state(proxy([])), XL = /* @__PURE__ */ state(-1), ZL = /* @__PURE__ */ state(!1);
	function QL() {
		if (!get(KL) || !get(JL)) {
			set(YL, [], !0);
			return;
		}
		let C = (F() || "").toLowerCase(), T = C.lastIndexOf(" "), E = T === -1 ? C : C.substring(T + 1);
		E === "" && !get(ZL) ? set(YL, [], !0) : E ? set(YL, Q().filter((C) => C.toLowerCase().includes(E)).slice(0, NL()), !0) : get(ZL) && set(YL, [...Q()].slice(0, NL()), !0), set(XL, -1);
	}
	user_effect(() => {
		get(KL) && QL();
	});
	function $L() {
		F().length > 0 && set(ZL, !1), QL();
	}
	function eR() {
		set(JL, !0), QL();
	}
	function tR() {
		setTimeout(() => {
			set(JL, !1), set(ZL, !1), set(YL, [], !0);
		}, 200);
	}
	function nR(C) {
		if (get(KL) && ((C.key === "Backspace" || C.key === "Delete") && F().length <= 1 && set(ZL, !0), get(YL).length)) switch (C.key) {
			case "ArrowDown":
				C.preventDefault(), set(XL, (get(XL) + 1) % get(YL).length);
				break;
			case "ArrowUp":
				C.preventDefault(), set(XL, get(XL) <= 0 ? get(YL).length - 1 : get(XL) - 1, !0);
				break;
			case "Enter":
				get(XL) >= 0 && (C.preventDefault(), rR(get(YL)[get(XL)]));
				break;
			case "Escape":
				C.preventDefault(), set(YL, [], !0);
				break;
		}
	}
	function rR(C) {
		var T;
		let E = F() || "", D = E.lastIndexOf(" ");
		F(D === -1 ? C + " " : E.substring(0, D + 1) + C + " "), PL() && PL()(C), set(YL, [], !0), set(XL, -1), (T = I()) == null || T.focus();
	}
	createDismissableContext(GL);
	var iR = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get id() {
			return O();
		},
		set id(C = idGenerator()) {
			O(C), flushSync();
		},
		get value() {
			return F();
		},
		set value(C) {
			F(C), flushSync();
		},
		get elementRef() {
			return I();
		},
		set elementRef(C) {
			I(C), flushSync();
		},
		get variant() {
			return L();
		},
		set variant(C = "standard") {
			L(C), flushSync();
		},
		get size() {
			return z();
		},
		set size(C = "default") {
			z(C), flushSync();
		},
		get color() {
			return B();
		},
		set color(C = "default") {
			B(C), flushSync();
		},
		get class() {
			return V();
		},
		set class(C) {
			V(C), flushSync();
		},
		get classes() {
			return U();
		},
		set classes(C) {
			U(C), flushSync();
		},
		get inputClass() {
			return W();
		},
		set inputClass(C) {
			W(C), flushSync();
		},
		get labelClass() {
			return G();
		},
		set labelClass(C) {
			G(C), flushSync();
		},
		get clearable() {
			return K();
		},
		set clearable(C) {
			K(C), flushSync();
		},
		get clearableSvgClass() {
			return J();
		},
		set clearableSvgClass(C) {
			J(C), flushSync();
		},
		get clearableColor() {
			return Y();
		},
		set clearableColor(C = "none") {
			Y(C), flushSync();
		},
		get clearableClass() {
			return X();
		},
		set clearableClass(C) {
			X(C), flushSync();
		},
		get clearableOnClick() {
			return Z();
		},
		set clearableOnClick(C) {
			Z(C), flushSync();
		},
		get data() {
			return Q();
		},
		set data(C = []) {
			Q(C), flushSync();
		},
		get maxSuggestions() {
			return NL();
		},
		set maxSuggestions(C = 5) {
			NL(C), flushSync();
		},
		get onSelect() {
			return PL();
		},
		set onSelect(C) {
			PL(C), flushSync();
		},
		get comboClass() {
			return FL();
		},
		set comboClass(C) {
			FL(C), flushSync();
		}
	}, aR = root$52(), oR = first_child(aR), sR = (C) => {
		var T = root_1$65();
		bind_this(T, (C) => qL = C, () => qL), append(C, T);
	};
	if_block(oR, (C) => {
		K() && C(sR);
	});
	var cR = sibling(oR, 2), lR = child(cR);
	attribute_effect(lR, (C) => _objectSpread2(_objectSpread2({
		id: O(),
		placeholder: " "
	}, IL), {}, {
		class: C,
		oninput: $L,
		onfocus: eR,
		onblur: tR,
		onkeydown: nR
	}), [() => get(VL)({ class: clsx_default(RL == null ? void 0 : RL.input, get(LL).input) })], void 0, void 0, void 0, !0), bind_this(lR, (C) => I(C), () => I());
	var uR = sibling(lR, 2), dR = (C) => {
		{
			let T = /* @__PURE__ */ user_derived(() => get(UL)({ class: clsx_default(RL == null ? void 0 : RL.close, get(LL).close) })), E = /* @__PURE__ */ user_derived(() => clsx_default(get(LL).svg));
			CloseButton(C, {
				get class() {
					return get(T);
				},
				get color() {
					return Y();
				},
				"aria-label": "Clear search value",
				get svgClass() {
					return get(E);
				}
			});
		}
	};
	if_block(uR, (C) => {
		F() !== void 0 && F() !== "" && K() && C(dR);
	});
	var fR = sibling(uR, 2);
	snippet(child(fR), D), reset(fR);
	var pR = sibling(fR, 2), mR = (C) => {
		var T = root_3$28();
		each(T, 21, () => get(YL), index, (C, T, E) => {
			var D = root_4$17();
			D.__click = () => rR(get(T));
			var O = child(D, !0);
			reset(D), template_effect(() => {
				set_class(D, 1, `w-full px-3 py-2 text-left ${E === get(XL) ? "bg-gray-100 dark:bg-gray-700" : "hover:bg-gray-50 dark:hover:bg-gray-700"} focus:outline-none`), set_text(O, get(T));
			}), event("mouseenter", D, () => set(XL, E, !0)), append(C, D);
		}), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(WL)({ class: clsx_default(RL == null ? void 0 : RL.combo, get(LL).combo) }))]), append(C, T);
	};
	return if_block(pR, (C) => {
		get(KL) && get(JL) && get(YL).length > 0 && C(mR);
	}), reset(cR), template_effect((C, T) => {
		set_class(cR, 1, C), set_attribute(fR, "for", O()), set_class(fR, 1, T);
	}, [() => clsx$1(get(BL)({ class: clsx_default(get(KL) ? "relative" : "", RL == null ? void 0 : RL.base, V()) })), () => clsx$1(get(HL)({ class: clsx_default(RL == null ? void 0 : RL.label, get(LL).label) }))]), bind_value(lR, F), append(C, aR), pop(iR);
}
delegate(["click"]), create_custom_element(FloatingLabelInput, {
	children: {},
	id: {},
	value: {},
	elementRef: {},
	variant: {},
	size: {},
	color: {},
	class: {},
	classes: {},
	inputClass: {},
	labelClass: {},
	clearable: {},
	clearableSvgClass: {},
	clearableColor: {},
	clearableClass: {},
	clearableOnClick: {},
	data: {},
	maxSuggestions: {},
	onSelect: {},
	comboClass: {}
}, [], [], !0);
const helper = ce({
	base: "text-xs font-normal text-gray-500 dark:text-gray-300",
	variants: { color: {
		disabled: "text-gray-400 dark:text-gray-500",
		primary: "text-primary-500 dark:text-primary-400",
		secondary: "text-secondary-500 dark:text-secondary-400",
		green: "text-green-500 dark:text-green-400",
		emerald: "text-emerald-500 dark:text-emerald-400",
		red: "text-red-500 dark:text-red-400",
		blue: "text-blue-500 dark:text-blue-400",
		yellow: "text-yellow-500 dark:text-yellow-400",
		orange: "text-orange-500 dark:text-orange-400",
		gray: "text-gray-500 dark:text-gray-400",
		teal: "text-teal-500 dark:text-teal-400",
		cyan: "text-cyan-500 dark:text-cyan-400",
		sky: "text-sky-500 dark:text-sky-400",
		indigo: "text-indigo-500 dark:text-indigo-400",
		lime: "text-lime-500 dark:text-lime-400",
		amber: "text-amber-500 dark:text-amber-400",
		violet: "text-violet-500 dark:text-violet-400",
		purple: "text-purple-500 dark:text-purple-400",
		fuchsia: "text-fuchsia-500 dark:text-fuchsia-400",
		pink: "text-pink-500 dark:text-pink-400",
		rose: "text-rose-500 dark:text-rose-400"
	} }
});
var root$51 = /* @__PURE__ */ from_html("<p><!></p>");
function Helper(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "class", 7), F = prop(E, "color", 7, "gray"), I = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"class",
		"color"
	]), L = getTheme("helper"), z = /* @__PURE__ */ user_derived(() => helper({
		color: F(),
		class: clsx_default(L, O())
	}));
	var B = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get class() {
			return O();
		},
		set class(C) {
			O(C), flushSync();
		},
		get color() {
			return F();
		},
		set color(C = "gray") {
			F(C), flushSync();
		}
	}, V = root$51();
	return attribute_effect(V, () => _objectSpread2(_objectSpread2({}, I), {}, { class: get(z) })), snippet(child(V), () => {
		var C;
		return (C = D()) == null ? noop : C;
	}), reset(V), append(C, V), pop(B);
}
create_custom_element(Helper, {
	children: {},
	class: {},
	color: {}
}, [], [], !0);
const input = ce({
	slots: {
		base: "relative w-full",
		input: "block w-full disabled:cursor-not-allowed disabled:opacity-50 rtl:text-right focus:outline-hidden",
		left: "flex absolute inset-y-0 items-center text-gray-500 dark:text-gray-400 pointer-events-none start-0 p-2.5",
		right: "flex absolute inset-y-0 items-center text-gray-500 dark:text-gray-400 end-0 p-2.5",
		close: "absolute right-2 top-1/2 -translate-y-1/2 text-gray-400 hover:text-black",
		combo: "absolute top-full right-0 left-0 z-20 mt-1 max-h-60 overflow-y-auto rounded-md border border-gray-200 bg-white shadow-lg dark:border-gray-700 dark:bg-gray-800",
		comboItem: "text-gray-900 dark:text-gray-50",
		div: "",
		svg: ""
	},
	variants: {
		size: {
			sm: { input: "text-xs px-2 py-2" },
			md: { input: "text-sm px-2.5 py-2.5" },
			lg: { input: "sm:text-base px-3 py-3" }
		},
		color: {
			default: { input: "border border-gray-300 dark:border-gray-600 focus:border-primary-500 focus:ring-primary-500 dark:focus:border-primary-500 dark:focus:ring-primary-500 bg-gray-50 text-gray-900 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 bg-gray-50 text-gray-900 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400" },
			tinted: { input: "border border-gray-300 dark:border-gray-500 bg-gray-50 text-gray-900 dark:bg-gray-600 dark:text-white dark:placeholder-gray-400" },
			primary: { input: "border border-primary-200 dark:border-primary-400 focus:ring-primary-500 focus:border-primary-600 dark:focus:ring-primary-500 dark:focus:border-primary-500 bg-primary-50 text-primary-900 placeholder-primary-700 dark:text-primary-400 dark:placeholder-primary-500 dark:bg-gray-700" },
			secondary: { input: "border border-secondary-200 dark:border-secondary-400 focus:ring-secondary-500 focus:border-secondary-600 dark:focus:ring-secondary-500 dark:focus:border-secondary-500 bg-secondary-50 text-secondary-900 placeholder-secondary-700 dark:text-secondary-400 dark:placeholder-secondary-500 dark:bg-gray-700" },
			green: { input: "border border-green-200 dark:border-green-400 focus:ring-green-500 focus:border-green-600 dark:focus:ring-green-500 dark:focus:border-green-500 bg-green-50 text-green-900 placeholder-green-700 dark:text-green-400 dark:placeholder-green-500 dark:bg-gray-700" },
			emerald: { input: "border border-emerald-200 dark:border-emerald-400 focus:ring-emerald-500 focus:border-emerald-600 dark:focus:ring-emerald-500 dark:focus:border-emerald-500 bg-emerald-50 text-emerald-900 placeholder-emerald-700 dark:text-emerald-400 dark:placeholder-emerald-500 dark:bg-gray-700" },
			red: { input: "border border-red-200 dark:border-red-400 focus:ring-red-500 focus:border-red-600 dark:focus:ring-red-500 dark:focus:border-red-500 bg-red-50 text-red-900 placeholder-red-700 dark:text-red-400 dark:placeholder-red-500 dark:bg-gray-700" },
			blue: { input: "border border-blue-200 dark:border-blue-400 focus:ring-blue-500 focus:border-blue-600 dark:focus:ring-blue-500 dark:focus:border-blue-500 bg-blue-50 text-blue-900 placeholder-blue-700 dark:text-blue-400 dark:placeholder-blue-500 dark:bg-gray-700" },
			yellow: { input: "border border-yellow-200 dark:border-yellow-400 focus:ring-yellow-500 focus:border-yellow-600 dark:focus:ring-yellow-500 dark:focus:border-yellow-500 bg-yellow-50 text-yellow-900 placeholder-yellow-700 dark:text-yellow-400 dark:placeholder-yellow-500 dark:bg-gray-700" },
			orange: { input: "border border-orange-200 dark:border-orange-400 focus:ring-orange-500 focus:border-orange-600 dark:focus:ring-orange-500 dark:focus:border-orange-500 bg-orange-50 text-orange-900 placeholder-orange-700 dark:text-orange-400 dark:placeholder-orange-500 dark:bg-gray-700" },
			gray: { input: "border border-gray-200 dark:border-gray-400 focus:ring-gray-500 focus:border-gray-600 dark:focus:ring-gray-500 dark:focus:border-gray-500 bg-gray-50 text-gray-900 placeholder-gray-700 dark:text-gray-400 dark:placeholder-gray-500 dark:bg-gray-700" },
			teal: { input: "border border-teal-200 dark:border-teal-400 focus:ring-teal-500 focus:border-teal-600 dark:focus:ring-teal-500 dark:focus:border-teal-500 bg-teal-50 text-teal-900 placeholder-teal-700 dark:text-teal-400 dark:placeholder-teal-500 dark:bg-gray-700" },
			cyan: { input: "border border-cyan-200 dark:border-cyan-400 focus:ring-cyan-500 focus:border-cyan-600 dark:focus:ring-cyan-500 dark:focus:border-cyan-500 bg-cyan-50 text-cyan-900 placeholder-cyan-700 dark:text-cyan-400 dark:placeholder-cyan-500 dark:bg-gray-700" },
			sky: { input: "border border-sky-200 dark:border-sky-400 focus:ring-sky-500 focus:border-sky-600 dark:focus:ring-sky-500 dark:focus:border-sky-500 bg-sky-50 text-sky-900 placeholder-sky-700 dark:text-sky-400 dark:placeholder-sky-500 dark:bg-gray-700" },
			indigo: { input: "border border-indigo-200 dark:border-indigo-400 focus:ring-indigo-500 focus:border-indigo-600 dark:focus:ring-indigo-500 dark:focus:border-indigo-500 bg-indigo-50 text-indigo-900 placeholder-indigo-700 dark:text-indigo-400 dark:placeholder-indigo-500 dark:bg-gray-700" },
			lime: { input: "border border-lime-200 dark:border-lime-400 focus:ring-lime-500 focus:border-lime-600 dark:focus:ring-lime-500 dark:focus:border-lime-500 bg-lime-50 text-lime-900 placeholder-lime-700 dark:text-lime-400 dark:placeholder-lime-500 dark:bg-gray-700" },
			amber: { input: "border border-amber-200 dark:border-amber-400 focus:ring-amber-500 focus:border-amber-600 dark:focus:ring-amber-500 dark:focus:border-amber-500 bg-amber-50 text-amber-900 placeholder-amber-700 dark:text-amber-400 dark:placeholder-amber-500 dark:bg-gray-700" },
			violet: { input: "border border-violet-200 dark:border-violet-400 focus:ring-violet-500 focus:border-violet-600 dark:focus:ring-violet-500 dark:focus:border-violet-500 bg-violet-50 text-violet-900 placeholder-violet-700 dark:text-violet-400 dark:placeholder-violet-500 dark:bg-gray-700" },
			purple: { input: "border border-purple-200 dark:border-purple-400 focus:ring-purple-500 focus:border-purple-600 dark:focus:ring-purple-500 dark:focus:border-purple-500 bg-purple-50 text-purple-900 placeholder-purple-700 dark:text-purple-400 dark:placeholder-purple-500 dark:bg-gray-700" },
			fuchsia: { input: "border border-fuchsia-200 dark:border-fuchsia-400 focus:ring-fuchsia-500 focus:border-fuchsia-600 dark:focus:ring-fuchsia-500 dark:focus:border-fuchsia-500 bg-fuchsia-50 text-fuchsia-900 placeholder-fuchsia-700 dark:text-fuchsia-400 dark:placeholder-fuchsia-500 dark:bg-gray-700" },
			pink: { input: "border border-pink-200 dark:border-pink-400 focus:ring-pink-500 focus:border-pink-600 dark:focus:ring-pink-500 dark:focus:border-pink-500 bg-pink-50 text-pink-900 placeholder-pink-700 dark:text-pink-400 dark:placeholder-pink-500 dark:bg-gray-700" },
			rose: { input: "border border-rose-200 dark:border-rose-400 focus:ring-rose-500 focus:border-rose-600 dark:focus:ring-rose-500 dark:focus:border-rose-500 bg-rose-50 text-rose-900 placeholder-rose-700 dark:text-rose-400 dark:placeholder-rose-500 dark:bg-gray-700" }
		},
		grouped: {
			false: { input: "rounded-lg" },
			true: { input: "first:rounded-s-lg last:rounded-e-lg not-first:-ms-px" }
		}
	},
	defaultVariants: {
		size: "md",
		color: "default"
	}
});
var root_3$27 = /* @__PURE__ */ from_html("<input/> <!>", 1), root_5$13 = /* @__PURE__ */ from_html("<div tabindex=\"-1\" class=\"sr-only\"></div>"), root_7$5 = /* @__PURE__ */ from_html("<div><!></div>"), root_8$4 = /* @__PURE__ */ from_html("<div><!></div>"), root_10$5 = /* @__PURE__ */ from_html("<button type=\"button\"><p> </p></button>"), root_9$4 = /* @__PURE__ */ from_html("<div></div>"), root_6$8 = /* @__PURE__ */ from_html("<div><!> <!> <!> <!></div>"), root$50 = /* @__PURE__ */ from_html("<!> <!>", 1);
function Input(C, E) {
	push(E, !0);
	let D = (C) => {
		var E = comment(), D = first_child(E), F = (C) => {
			var E = comment(), D = first_child(E);
			{
				let C = /* @__PURE__ */ user_derived(() => _objectSpread2(_objectSpread2({}, JL), {}, { class: get(uR)() }));
				snippet(D, O, () => get(C));
			}
			append(C, E);
		}, I = (C) => {
			var E = root_3$27(), D = first_child(E);
			attribute_effect(D, (C) => _objectSpread2(_objectSpread2({}, JL), {}, {
				oninput: TR,
				onfocus: ER,
				onblur: DR,
				onkeydown: OR,
				class: C
			}), [() => get(uR)({ class: clsx_default(XL == null ? void 0 : XL.input, W()) })], void 0, void 0, void 0, !0), bind_this(D, (C) => z(C), () => z());
			var O = sibling(D, 2), F = (C) => {
				{
					let T = /* @__PURE__ */ user_derived(() => get(pR)({ class: clsx_default(XL == null ? void 0 : XL.close, get(YL).close) })), E = /* @__PURE__ */ user_derived(() => clsx_default(get(YL).svg));
					CloseButton(C, {
						get class() {
							return get(T);
						},
						get color() {
							return Q();
						},
						"aria-label": "Clear search value",
						get svgClass() {
							return get(E);
						}
					});
				}
			};
			if_block(O, (C) => {
				L() !== void 0 && L() !== "" && B() && C(F);
			}), bind_value(D, L), append(C, E);
		};
		if_block(D, (C) => {
			O() ? C(F) : C(I, !1);
		}), append(C, E);
	}, O = prop(E, "children", 7), F = prop(E, "left", 7), I = prop(E, "right", 7), L = prop(E, "value", 15), z = prop(E, "elementRef", 15), B = prop(E, "clearable", 7, !1), V = prop(E, "size", 7), U = prop(E, "color", 7, "default"), W = prop(E, "class", 7), G = prop(E, "classes", 7), K = prop(E, "wrapperClass", 7), J = prop(E, "leftClass", 7), Y = prop(E, "rightClass", 7), X = prop(E, "divClass", 7), Z = prop(E, "clearableSvgClass", 7), Q = prop(E, "clearableColor", 7, "none"), NL = prop(E, "clearableClass", 7), PL = prop(E, "clearableOnClick", 7), FL = prop(E, "data", 23, () => []), IL = prop(E, "maxSuggestions", 7, 5), LL = prop(E, "onSelect", 7), RL = prop(E, "comboClass", 7), zL = prop(E, "comboItemClass", 7), BL = prop(E, "onInput", 7), VL = prop(E, "onFocus", 7), HL = prop(E, "onBlur", 7), UL = prop(E, "onKeydown", 7), WL = prop(E, "oninput", 7), GL = prop(E, "onfocus", 7), KL = prop(E, "onblur", 7), qL = prop(E, "onkeydown", 7), JL = /* @__PURE__ */ rest_props(E, /* @__PURE__ */ "$$slots.$$events.$$legacy.$$host.children.left.right.value.elementRef.clearable.size.color.class.classes.wrapperClass.leftClass.rightClass.divClass.clearableSvgClass.clearableColor.clearableClass.clearableOnClick.data.maxSuggestions.onSelect.comboClass.comboItemClass.onInput.onFocus.onBlur.onKeydown.oninput.onfocus.onblur.onkeydown".split("."));
	K(), J(), Y(), X(), Z(), NL(), RL();
	let YL = /* @__PURE__ */ user_derived(() => {
		var C;
		return (C = G()) == null ? {
			left: J(),
			right: Y(),
			div: X(),
			svg: Z(),
			close: NL(),
			combo: RL(),
			comboItem: zL()
		} : C;
	}), XL = getTheme("input"), ZL = /* @__PURE__ */ user_derived(() => WL() || BL()), QL = /* @__PURE__ */ user_derived(() => GL() || VL()), $L = /* @__PURE__ */ user_derived(() => KL() || HL()), eR = /* @__PURE__ */ user_derived(() => qL() || UL()), tR = /* @__PURE__ */ user_derived(() => Array.isArray(FL()) && FL().length > 0), nR = getContext("background"), rR, iR = getContext("group"), aR = !!iR, oR = /* @__PURE__ */ user_derived(() => V() || clampSize(iR == null ? void 0 : iR.size) || "md"), sR = /* @__PURE__ */ user_derived(() => U() === "default" && nR ? "tinted" : U()), cR = /* @__PURE__ */ user_derived(() => input({
		size: get(oR),
		color: get(sR),
		grouped: aR
	})), lR = /* @__PURE__ */ user_derived(() => get(cR).base), uR = /* @__PURE__ */ user_derived(() => get(cR).input), dR = /* @__PURE__ */ user_derived(() => get(cR).left), fR = /* @__PURE__ */ user_derived(() => get(cR).right), pR = /* @__PURE__ */ user_derived(() => get(cR).close), mR = /* @__PURE__ */ user_derived(() => get(cR).combo), hR = /* @__PURE__ */ user_derived(() => get(cR).comboItem);
	createDismissableContext(() => {
		if (z()) {
			let C = z();
			C.value = "", L(""), set(yR, !1), bR(), rR == null || rR.focus(), setTimeout(() => {
				C.focus();
			}, 100);
		}
		PL() && PL()();
	});
	let gR = /* @__PURE__ */ state(!1), _R = /* @__PURE__ */ state(proxy([])), vR = /* @__PURE__ */ state(-1), yR = /* @__PURE__ */ state(!1);
	function bR() {
		if (!get(tR) || !get(gR)) {
			set(_R, [], !0);
			return;
		}
		let C = (L() || "").toLowerCase(), T = C.lastIndexOf(" "), E = T === -1 ? C : C.substring(T + 1);
		E === "" && !get(yR) ? set(_R, [], !0) : E ? set(_R, FL().filter((C) => C.toLowerCase().includes(E)).slice(0, IL()), !0) : get(yR) && set(_R, [...FL()].slice(0, IL()), !0), set(vR, -1);
	}
	user_effect(() => {
		get(tR) && bR();
	});
	function xR(C) {
		String(L() || "").length > 0 && set(yR, !1), bR();
	}
	function SR(C) {
		set(gR, !0), bR();
	}
	function CR(C) {
		setTimeout(() => {
			set(gR, !1), set(yR, !1), set(_R, [], !0);
		}, 200);
	}
	function wR(C) {
		if (get(tR) && ((C.key === "Backspace" || C.key === "Delete") && L().length <= 1 && set(yR, !0), get(_R).length)) switch (C.key) {
			case "ArrowDown":
				C.preventDefault(), set(vR, (get(vR) + 1) % get(_R).length);
				break;
			case "ArrowUp":
				C.preventDefault(), set(vR, get(vR) <= 0 ? get(_R).length - 1 : get(vR) - 1, !0);
				break;
			case "Enter":
				get(vR) >= 0 && (C.preventDefault(), kR(get(_R)[get(vR)]));
				break;
			case "Escape":
				C.preventDefault(), set(_R, [], !0);
				break;
		}
	}
	function TR(C) {
		get(ZL) && get(ZL)(C), xR(C);
	}
	function ER(C) {
		get(QL) && get(QL)(C), SR(C);
	}
	function DR(C) {
		get($L) && get($L)(C), CR(C);
	}
	function OR(C) {
		get(eR) && get(eR)(C), wR(C);
	}
	function kR(C) {
		let T = L() || "", E = T.lastIndexOf(" ");
		L(E === -1 ? C + " " : T.substring(0, E + 1) + C + " "), LL() && LL()(C), set(_R, [], !0), set(vR, -1), z() && z().focus();
	}
	var AR = {
		get children() {
			return O();
		},
		set children(C) {
			O(C), flushSync();
		},
		get left() {
			return F();
		},
		set left(C) {
			F(C), flushSync();
		},
		get right() {
			return I();
		},
		set right(C) {
			I(C), flushSync();
		},
		get value() {
			return L();
		},
		set value(C) {
			L(C), flushSync();
		},
		get elementRef() {
			return z();
		},
		set elementRef(C) {
			z(C), flushSync();
		},
		get clearable() {
			return B();
		},
		set clearable(C = !1) {
			B(C), flushSync();
		},
		get size() {
			return V();
		},
		set size(C) {
			V(C), flushSync();
		},
		get color() {
			return U();
		},
		set color(C = "default") {
			U(C), flushSync();
		},
		get class() {
			return W();
		},
		set class(C) {
			W(C), flushSync();
		},
		get classes() {
			return G();
		},
		set classes(C) {
			G(C), flushSync();
		},
		get wrapperClass() {
			return K();
		},
		set wrapperClass(C) {
			K(C), flushSync();
		},
		get leftClass() {
			return J();
		},
		set leftClass(C) {
			J(C), flushSync();
		},
		get rightClass() {
			return Y();
		},
		set rightClass(C) {
			Y(C), flushSync();
		},
		get divClass() {
			return X();
		},
		set divClass(C) {
			X(C), flushSync();
		},
		get clearableSvgClass() {
			return Z();
		},
		set clearableSvgClass(C) {
			Z(C), flushSync();
		},
		get clearableColor() {
			return Q();
		},
		set clearableColor(C = "none") {
			Q(C), flushSync();
		},
		get clearableClass() {
			return NL();
		},
		set clearableClass(C) {
			NL(C), flushSync();
		},
		get clearableOnClick() {
			return PL();
		},
		set clearableOnClick(C) {
			PL(C), flushSync();
		},
		get data() {
			return FL();
		},
		set data(C = []) {
			FL(C), flushSync();
		},
		get maxSuggestions() {
			return IL();
		},
		set maxSuggestions(C = 5) {
			IL(C), flushSync();
		},
		get onSelect() {
			return LL();
		},
		set onSelect(C) {
			LL(C), flushSync();
		},
		get comboClass() {
			return RL();
		},
		set comboClass(C) {
			RL(C), flushSync();
		},
		get comboItemClass() {
			return zL();
		},
		set comboItemClass(C) {
			zL(C), flushSync();
		},
		get onInput() {
			return BL();
		},
		set onInput(C) {
			BL(C), flushSync();
		},
		get onFocus() {
			return VL();
		},
		set onFocus(C) {
			VL(C), flushSync();
		},
		get onBlur() {
			return HL();
		},
		set onBlur(C) {
			HL(C), flushSync();
		},
		get onKeydown() {
			return UL();
		},
		set onKeydown(C) {
			UL(C), flushSync();
		},
		get oninput() {
			return WL();
		},
		set oninput(C) {
			WL(C), flushSync();
		},
		get onfocus() {
			return GL();
		},
		set onfocus(C) {
			GL(C), flushSync();
		},
		get onblur() {
			return KL();
		},
		set onblur(C) {
			KL(C), flushSync();
		},
		get onkeydown() {
			return qL();
		},
		set onkeydown(C) {
			qL(C), flushSync();
		}
	}, jR = root$50(), MR = first_child(jR), NR = (C) => {
		var T = root_5$13();
		bind_this(T, (C) => rR = C, () => rR), append(C, T);
	};
	if_block(MR, (C) => {
		B() && C(NR);
	});
	var PR = sibling(MR, 2), FR = (C) => {
		var T = root_6$8(), E = child(T), O = (C) => {
			var T = root_7$5();
			snippet(child(T), F), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(dR)({ class: clsx_default(XL == null ? void 0 : XL.left, get(YL).left) }))]), append(C, T);
		};
		if_block(E, (C) => {
			F() && C(O);
		});
		var L = sibling(E, 2);
		D(L);
		var z = sibling(L, 2), B = (C) => {
			var T = root_8$4();
			snippet(child(T), I), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(fR)({ class: clsx_default(XL == null ? void 0 : XL.right, get(YL).right) }))]), append(C, T);
		};
		if_block(z, (C) => {
			I() && C(B);
		});
		var V = sibling(z, 2), U = (C) => {
			var T = root_9$4();
			each(T, 22, () => get(_R), (C) => C, (C, T, E) => {
				var D = root_10$5();
				D.__click = () => kR(T);
				var O = child(D), F = child(O, !0);
				reset(O), reset(D), template_effect((C) => {
					set_class(D, 1, `w-full px-3 py-2 text-left ${get(E) === get(vR) ? "bg-gray-100 dark:bg-gray-700" : "hover:bg-gray-50 dark:hover:bg-gray-700"} focus:outline-none`), set_class(O, 1, C), set_text(F, T);
				}, [() => clsx$1(get(hR)({ class: clsx_default(XL == null ? void 0 : XL.comboItem, get(YL).comboItem) }))]), event("mouseenter", D, () => set(vR, get(E), !0)), append(C, D);
			}), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(mR)({ class: clsx_default(XL == null ? void 0 : XL.combo, get(YL).combo) }))]), append(C, T);
		};
		if_block(V, (C) => {
			get(tR) && get(gR) && get(_R).length > 0 && C(U);
		}), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(lR)({ class: clsx_default(XL == null ? void 0 : XL.base, get(YL).div) }))]), append(C, T);
	}, IR = (C) => {
		D(C);
	};
	return if_block(PR, (C) => {
		get(tR) || I() || F() || B() ? C(FR) : C(IR, !1);
	}), append(C, jR), pop(AR);
}
delegate(["click"]), create_custom_element(Input, {
	children: {},
	left: {},
	right: {},
	value: {},
	elementRef: {},
	clearable: {},
	size: {},
	color: {},
	class: {},
	classes: {},
	wrapperClass: {},
	leftClass: {},
	rightClass: {},
	divClass: {},
	clearableSvgClass: {},
	clearableColor: {},
	clearableClass: {},
	clearableOnClick: {},
	data: {},
	maxSuggestions: {},
	onSelect: {},
	comboClass: {},
	comboItemClass: {},
	onInput: {},
	onFocus: {},
	onBlur: {},
	onKeydown: {},
	oninput: {},
	onfocus: {},
	onblur: {},
	onkeydown: {}
}, [], [], !0);
function clampSize(C) {
	return C && C === "xs" ? "sm" : C === "xl" ? "lg" : C;
}
var root$49 = /* @__PURE__ */ from_html("<div><!></div>");
function InputAddon(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "class", 7), F = prop(E, "size", 7), I = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"class",
		"size"
	]), L = getContext("background"), z = getContext("group"), B = {
		base: "border-gray-300 dark:border-gray-600",
		tinted: "border-gray-300 dark:border-gray-500"
	}, V = {
		base: "dark:bg-gray-600 dark:text-gray-400",
		tinted: "dark:bg-gray-500 dark:text-gray-300"
	}, U = {
		base: "dark:border-e-gray-700 dark:last:border-e-gray-600",
		tinted: "dark:border-e-gray-600 dark:last:border-e-gray-500"
	}, W = {
		sm: "sm:text-xs",
		md: "text-sm",
		lg: "sm:text-base"
	}, G = {
		sm: "px-2",
		md: "px-3",
		lg: "px-4"
	}, K = F() || clampSize(z == null ? void 0 : z.size) || "md", J = clsx_default(W[K], G[K], "text-gray-500 bg-gray-200", L ? V.tinted : V.base, L ? U.tinted : U.base, L ? B.tinted : B.base, "inline-flex items-center border", z && "not-first:-ms-px", "first:rounded-s-lg last:rounded-e-lg", O());
	var Y = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get class() {
			return O();
		},
		set class(C) {
			O(C), flushSync();
		},
		get size() {
			return F();
		},
		set size(C) {
			F(C), flushSync();
		}
	}, X = root$49();
	return attribute_effect(X, () => _objectSpread2(_objectSpread2({}, I), {}, { class: J })), snippet(child(X), D), reset(X), append(C, X), pop(Y);
}
create_custom_element(InputAddon, {
	children: {},
	class: {},
	size: {}
}, [], [], !0);
const label = ce({
	base: "text-sm rtl:text-right font-medium block",
	variants: { color: {
		disabled: "text-gray-500 dark:text-gray-500",
		primary: "text-primary-700 dark:text-primary-500",
		secondary: "text-secondary-700 dark:text-secondary-500",
		green: "text-green-700 dark:text-green-500",
		emerald: "text-emerald-700 dark:text-emerald-500",
		red: "text-red-700 dark:text-red-500",
		blue: "text-blue-700 dark:text-blue-500",
		yellow: "text-yellow-700 dark:text-yellow-500",
		orange: "text-orange-700 dark:text-orange-500",
		gray: "text-gray-700 dark:text-gray-200",
		teal: "text-teal-700 dark:text-teal-500",
		cyan: "text-cyan-700 dark:text-cyan-500",
		sky: "text-sky-700 dark:text-sky-500",
		indigo: "text-indigo-700 dark:text-indigo-500",
		lime: "text-lime-700 dark:text-lime-500",
		amber: "text-amber-700 dark:text-amber-500",
		violet: "text-violet-700 dark:text-violet-500",
		purple: "text-purple-700 dark:text-purple-500",
		fuchsia: "text-fuchsia-700 dark:text-fuchsia-500",
		pink: "text-pink-700 dark:text-pink-500",
		rose: "text-rose-700 dark:text-rose-500"
	} }
});
var root_1$64 = /* @__PURE__ */ from_html("<label><!></label>");
function Label(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "color", 7, "gray"), F = prop(E, "show", 7, !0), I = prop(E, "class", 7), L = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"color",
		"show",
		"class"
	]), z = getTheme("label"), B = /* @__PURE__ */ user_derived(() => label({
		color: O(),
		class: clsx_default(z, I())
	}));
	var V = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get color() {
			return O();
		},
		set color(C = "gray") {
			O(C), flushSync();
		},
		get show() {
			return F();
		},
		set show(C = !0) {
			F(C), flushSync();
		},
		get class() {
			return I();
		},
		set class(C) {
			I(C), flushSync();
		}
	}, U = comment(), W = first_child(U), G = (C) => {
		var E = root_1$64();
		attribute_effect(E, () => _objectSpread2(_objectSpread2({}, L), {}, { class: get(B) })), snippet(child(E), D), reset(E), append(C, E);
	}, K = (C) => {
		var T = comment();
		snippet(first_child(T), D), append(C, T);
	};
	return if_block(W, (C) => {
		F() ? C(G) : C(K, !1);
	}), append(C, U), pop(V);
}
create_custom_element(Label, {
	children: {},
	color: {},
	show: {},
	class: {}
}, [], [], !0);
const phoneInput = ce({
	slots: {
		div: "absolute inset-y-0 start-0 top-0 flex items-center ps-3.5 pointer-events-none",
		svg: "w-4 h-4 text-gray-500 dark:text-gray-400",
		input: "bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-primary-500 focus:border-primary-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-primary-500 dark:focus:border-primary-500 disabled:cursor-not-allowed disabled:opacity-50",
		span: "absolute start-0 bottom-3 text-gray-500 dark:text-gray-400",
		floatingInput: "block py-2.5 ps-6 pe-0 w-full text-sm text-gray-900 bg-transparent border-0 border-b-2 border-gray-300 appearance-none dark:text-white dark:border-gray-600 dark:focus:border-primary-500 focus:outline-none focus:ring-0 focus:border-primary-600 peer disabled:cursor-not-allowed disabled:opacity-50",
		label: "absolute text-sm text-gray-500 dark:text-gray-400 duration-300 transform -translate-y-6 scale-75 top-3 origin-[0] peer-placeholder-shown:start-6 peer-focus:start-0 peer-focus:text-primary-600 peer-focus:dark:text-primary-500 peer-placeholder-shown:scale-100 peer-placeholder-shown:translate-y-0 peer-focus:scale-75 peer-focus:-translate-y-6 rtl:peer-focus:translate-x-1/4 rtl:peer-focus:left-auto"
	},
	variants: {
		phoneType: {
			default: {},
			floating: { svg: "w-4 h-4 rtl:rotate-[270deg]" },
			countryCode: { input: "rounded-none rounded-e-lg" },
			copy: {},
			advanced: {}
		},
		phoneIcon: {
			true: { input: "ps-10" },
			false: {}
		}
	}
});
var root_1$63 = /* @__PURE__ */ from_svg("<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"currentColor\" viewBox=\"0 0 19 18\"><path d=\"M18 13.446a3.02 3.02 0 0 0-.946-1.985l-1.4-1.4a3.054 3.054 0 0 0-4.218 0l-.7.7a.983.983 0 0 1-1.39 0l-2.1-2.1a.983.983 0 0 1 0-1.389l.7-.7a2.98 2.98 0 0 0 0-4.217l-1.4-1.4a2.824 2.824 0 0 0-4.218 0c-3.619 3.619-3 8.229 1.752 12.979C6.785 16.639 9.45 18 11.912 18a7.175 7.175 0 0 0 5.139-2.325A2.9 2.9 0 0 0 18 13.446Z\"></path></svg>"), root_3$26 = /* @__PURE__ */ from_html("<div><!></div>"), root_2$30 = /* @__PURE__ */ from_html("<div class=\"relative\"><!> <input/></div>"), root_6$7 = /* @__PURE__ */ from_html("<span><!></span>"), root_5$12 = /* @__PURE__ */ from_html("<div class=\"relative\"><!> <input/> <label> </label></div>");
function PhoneInput(C, E) {
	push(E, !0);
	let D = (C) => {
		var T = root_1$63();
		template_effect((C) => set_class(T, 0, C), [() => clsx$1(get(Y)({ class: clsx_default(G == null ? void 0 : G.svg) }))]), append(C, T);
	}, O = prop(E, "children", 7), F = prop(E, "phoneIcon", 7, !0), I = prop(E, "pattern", 7, "[0-9]{3}-[0-9]{3}-[0-9]{4}"), L = prop(E, "phoneType", 7, "default"), z = prop(E, "floatingLabel", 7, "Phone number"), B = prop(E, "labelFor", 7, "floating-phone-number"), V = prop(E, "class", 7), U = prop(E, "classes", 7), W = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"phoneIcon",
		"pattern",
		"phoneType",
		"floatingLabel",
		"labelFor",
		"class",
		"classes"
	]), G = getTheme("phoneInput"), K = /* @__PURE__ */ user_derived(() => phoneInput({
		phoneType: L(),
		phoneIcon: F()
	})), J = /* @__PURE__ */ user_derived(() => get(K).div), Y = /* @__PURE__ */ user_derived(() => get(K).svg), X = /* @__PURE__ */ user_derived(() => get(K).input), Z = /* @__PURE__ */ user_derived(() => get(K).span), Q = /* @__PURE__ */ user_derived(() => get(K).floatingInput), NL = /* @__PURE__ */ user_derived(() => get(K).label);
	var PL = {
		get children() {
			return O();
		},
		set children(C) {
			O(C), flushSync();
		},
		get phoneIcon() {
			return F();
		},
		set phoneIcon(C = !0) {
			F(C), flushSync();
		},
		get pattern() {
			return I();
		},
		set pattern(C = "[0-9]{3}-[0-9]{3}-[0-9]{4}") {
			I(C), flushSync();
		},
		get phoneType() {
			return L();
		},
		set phoneType(C = "default") {
			L(C), flushSync();
		},
		get floatingLabel() {
			return z();
		},
		set floatingLabel(C = "Phone number") {
			z(C), flushSync();
		},
		get labelFor() {
			return B();
		},
		set labelFor(C = "floating-phone-number") {
			B(C), flushSync();
		},
		get class() {
			return V();
		},
		set class(C) {
			V(C), flushSync();
		},
		get classes() {
			return U();
		},
		set classes(C) {
			U(C), flushSync();
		}
	}, FL = comment(), IL = first_child(FL), LL = (C) => {
		var E = root_2$30(), O = child(E), L = (C) => {
			var T = root_3$26();
			D(child(T)), reset(T), template_effect((C) => set_class(T, 1, C), [() => {
				var C;
				return clsx$1(get(J)({ class: clsx_default(G == null ? void 0 : G.div, (C = U()) == null ? void 0 : C.div) }));
			}]), append(C, T);
		};
		if_block(O, (C) => {
			F() && C(L);
		}), attribute_effect(sibling(O, 2), (C) => _objectSpread2(_objectSpread2({
			type: "tel",
			pattern: I()
		}, W), {}, { class: C }), [() => {
			var C;
			return get(X)({ class: clsx_default(G == null ? void 0 : G.input, (C = U()) == null ? void 0 : C.input) });
		}], void 0, void 0, void 0, !0), reset(E), append(C, E);
	}, RL = (C) => {
		var E = comment(), O = first_child(E), V = (C) => {
			var E = root_5$12(), O = child(E), L = (C) => {
				var T = root_6$7();
				D(child(T)), reset(T), template_effect((C) => set_class(T, 1, C), [() => {
					var C;
					return clsx$1(get(Z)({ class: clsx_default(G == null ? void 0 : G.span, (C = U()) == null ? void 0 : C.span) }));
				}]), append(C, T);
			};
			if_block(O, (C) => {
				F() && C(L);
			});
			var V = sibling(O, 2);
			attribute_effect(V, (C) => _objectSpread2({
				type: "tel",
				class: C,
				pattern: I()
			}, W), [() => {
				var C;
				return get(Q)({ class: clsx_default(G == null ? void 0 : G.floatingInput, (C = U()) == null ? void 0 : C.floatingInput) });
			}], void 0, void 0, void 0, !0);
			var K = sibling(V, 2), J = child(K, !0);
			reset(K), reset(E), template_effect((C) => {
				set_attribute(K, "for", B()), set_class(K, 1, C), set_text(J, z());
			}, [() => {
				var C;
				return clsx$1(get(NL)({ class: clsx_default(G == null ? void 0 : G.label, (C = U()) == null ? void 0 : C.label) }));
			}]), append(C, E);
		};
		if_block(O, (C) => {
			L() === "floating" && C(V);
		}, !0), append(C, E);
	};
	return if_block(IL, (C) => {
		L() === "default" || L() === "countryCode" ? C(LL) : C(RL, !1);
	}), append(C, FL), pop(PL);
}
create_custom_element(PhoneInput, {
	children: {},
	phoneIcon: {},
	pattern: {},
	phoneType: {},
	floatingLabel: {},
	labelFor: {},
	class: {},
	classes: {}
}, [], [], !0);
const select = ce({
	slots: {
		base: "relative",
		select: "block w-full rtl:text-right",
		close: "absolute right-8 top-1/2 -translate-y-1/2 text-gray-400 hover:text-black",
		svg: ""
	},
	variants: {
		underline: {
			true: { select: "text-gray-500 bg-transparent border-0 border-b-2 border-gray-200 appearance-none dark:text-gray-400 dark:border-gray-700 focus:outline-hidden focus:ring-0 focus:border-gray-200 peer px-0!" },
			false: { select: "text-gray-900 bg-gray-50 border border-gray-300 rounded-lg focus:outline-hidden focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-primary-500 dark:focus:border-primary-500" }
		},
		size: {
			sm: { select: "text-xs px-2 py-2" },
			md: { select: "text-sm px-2.5 py-2.5" },
			lg: { select: "text-base py-3 px-4" }
		},
		disabled: {
			true: { select: "cursor-not-allowed opacity-50" },
			false: {}
		}
	},
	defaultVariants: {
		underline: !1,
		size: "md"
	}
}), multiSelect = ce({
	slots: {
		base: "relative border border-gray-300 flex items-center rounded-lg gap-2 dark:border-gray-600 ring-primary-500 dark:ring-primary-500 focus-visible:outline-hidden",
		select: "flex flex-wrap gap-2",
		dropdown: "absolute z-50 p-3 flex flex-col gap-1 max-h-64 bg-white border border-gray-300 dark:bg-gray-700 dark:border-gray-600 start-0 top-[calc(100%+1rem)] rounded-lg cursor-pointer overflow-y-scroll w-full",
		item: "py-2 px-3 rounded-lg text-gray-600 hover:text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:text-gray-300 dark:hover:bg-gray-600",
		close: "p-0 focus:ring-gray-400 dark:text-white",
		span: "",
		placeholder: "text-gray-400",
		svg: "ms-1 h-3 w-3 cursor-pointer text-gray-800 dark:text-white"
	},
	variants: {
		size: {
			sm: "px-2.5 py-2.5 min-h-[2.4rem] text-xs",
			md: "px-2.5 py-2.5 min-h-[2.7rem] text-sm",
			lg: "px-3 py-3 min-h-[3.2rem] sm:text-base"
		},
		disabled: {
			true: {
				base: "cursor-not-allowed opacity-50 pointer-events-none",
				item: "cursor-not-allowed opacity-50",
				close: "cursor-not-allowed"
			},
			false: { base: "focus-within:border-primary-500 dark:focus-within:border-primary-500 focus-within:ring-1" }
		},
		active: { true: { item: "bg-primary-100 text-primary-500 dark:bg-primary-500 dark:text-primary-100 hover:bg-primary-100 dark:hover:bg-primary-500 hover:text-primary-600 dark:hover:text-primary-100" } },
		selected: { true: { item: "bg-gray-100 text-black font-semibold hover:text-black dark:text-white dark:bg-gray-600 dark:hover:text-white" } }
	},
	compoundVariants: [{
		selected: !0,
		active: !0,
		class: { item: "bg-primary-200 dark:bg-primary-600 text-primary-700 dark:text-primary-100 font-semibold" }
	}],
	defaultVariants: {
		underline: !1,
		size: "md"
	}
});
var root_1$62 = /* @__PURE__ */ from_html("<option disabled> </option>"), root_3$25 = /* @__PURE__ */ from_html("<option> </option>"), root$48 = /* @__PURE__ */ from_html("<div><select><!><!><!></select> <!></div>");
function Select(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "items", 7), F = prop(E, "value", 15), I = prop(E, "elementRef", 15), L = prop(E, "underline", 7), z = prop(E, "size", 7, "md"), B = prop(E, "disabled", 7), V = prop(E, "placeholder", 7, ""), U = prop(E, "clearable", 7), W = prop(E, "clearableColor", 7, "none"), G = prop(E, "clearableOnClick", 7), K = prop(E, "onClear", 7), J = prop(E, "clearableSvgClass", 7), Y = prop(E, "clearableClass", 7), X = prop(E, "selectClass", 7), Z = prop(E, "class", 7), Q = prop(E, "classes", 7), NL = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"items",
		"value",
		"elementRef",
		"underline",
		"size",
		"disabled",
		"placeholder",
		"clearable",
		"clearableColor",
		"clearableOnClick",
		"onClear",
		"clearableSvgClass",
		"clearableClass",
		"selectClass",
		"class",
		"classes"
	]);
	X(), J(), Y();
	let PL = /* @__PURE__ */ user_derived(() => {
		var C;
		return (C = Q()) == null ? {
			select: X(),
			svg: J(),
			close: Y()
		} : C;
	}), FL = getTheme("select"), IL = /* @__PURE__ */ user_derived(() => select({
		underline: L(),
		size: z(),
		disabled: B()
	})), LL = /* @__PURE__ */ user_derived(() => get(IL).base), RL = /* @__PURE__ */ user_derived(() => get(IL).select), zL = /* @__PURE__ */ user_derived(() => get(IL).close);
	createDismissableContext(() => {
		I() && (I(I().value = "", !0), I().dispatchEvent(new Event("change", { bubbles: !0 }))), F(""), K() && K()(), G() && G()();
	});
	var BL = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get items() {
			return O();
		},
		set items(C) {
			O(C), flushSync();
		},
		get value() {
			return F();
		},
		set value(C) {
			F(C), flushSync();
		},
		get elementRef() {
			return I();
		},
		set elementRef(C) {
			I(C), flushSync();
		},
		get underline() {
			return L();
		},
		set underline(C) {
			L(C), flushSync();
		},
		get size() {
			return z();
		},
		set size(C = "md") {
			z(C), flushSync();
		},
		get disabled() {
			return B();
		},
		set disabled(C) {
			B(C), flushSync();
		},
		get placeholder() {
			return V();
		},
		set placeholder(C = "") {
			V(C), flushSync();
		},
		get clearable() {
			return U();
		},
		set clearable(C) {
			U(C), flushSync();
		},
		get clearableColor() {
			return W();
		},
		set clearableColor(C = "none") {
			W(C), flushSync();
		},
		get clearableOnClick() {
			return G();
		},
		set clearableOnClick(C) {
			G(C), flushSync();
		},
		get onClear() {
			return K();
		},
		set onClear(C) {
			K(C), flushSync();
		},
		get clearableSvgClass() {
			return J();
		},
		set clearableSvgClass(C) {
			J(C), flushSync();
		},
		get clearableClass() {
			return Y();
		},
		set clearableClass(C) {
			Y(C), flushSync();
		},
		get selectClass() {
			return X();
		},
		set selectClass(C) {
			X(C), flushSync();
		},
		get class() {
			return Z();
		},
		set class(C) {
			Z(C), flushSync();
		},
		get classes() {
			return Q();
		},
		set classes(C) {
			Q(C), flushSync();
		}
	}, VL = root$48(), HL = child(VL);
	attribute_effect(HL, (C) => _objectSpread2(_objectSpread2({ disabled: B() }, NL), {}, { class: C }), [() => get(RL)({ class: clsx_default(FL == null ? void 0 : FL.select, get(PL).select) })]);
	var UL = child(HL), WL = (C) => {
		var T = root_1$62(), E = child(T, !0);
		reset(T), T.value = T.__value = "", template_effect(() => {
			set_selected(T, F() === "" || F() === void 0), set_text(E, V());
		}), append(C, T);
	};
	if_block(UL, (C) => {
		V() && C(WL);
	});
	var GL = sibling(UL), KL = (C) => {
		var T = comment();
		each(first_child(T), 17, O, index, (C, T) => {
			var E = root_3$25(), D = child(E, !0);
			reset(E);
			var O = {};
			template_effect(() => {
				if (E.disabled = get(T).disabled, set_text(D, get(T).name), O !== (O = get(T).value)) {
					var C;
					E.value = (C = E.__value = get(T).value) == null ? "" : C;
				}
			}), append(C, E);
		}), append(C, T);
	};
	if_block(GL, (C) => {
		O() && C(KL);
	});
	var qL = sibling(GL), JL = (C) => {
		var T = comment();
		snippet(first_child(T), D), append(C, T);
	};
	if_block(qL, (C) => {
		D() && C(JL);
	}), reset(HL), bind_this(HL, (C) => I(C), () => I());
	var YL = sibling(HL, 2), XL = (C) => {
		{
			let T = /* @__PURE__ */ user_derived(() => get(zL)({ class: clsx_default(FL == null ? void 0 : FL.close, get(PL).close) })), E = /* @__PURE__ */ user_derived(() => clsx_default(get(PL).svg));
			CloseButton(C, {
				get class() {
					return get(T);
				},
				get color() {
					return W();
				},
				"aria-label": "Clear search value",
				get svgClass() {
					return get(E);
				},
				get disabled() {
					return B();
				}
			});
		}
	};
	return if_block(YL, (C) => {
		F() !== void 0 && F() !== "" && U() && C(XL);
	}), reset(VL), template_effect((C) => set_class(VL, 1, C), [() => clsx$1(get(LL)({ class: clsx_default(FL == null ? void 0 : FL.base, Z()) }))]), bind_select_value(HL, F), append(C, VL), pop(BL);
}
create_custom_element(Select, {
	children: {},
	items: {},
	value: {},
	elementRef: {},
	underline: {},
	size: {},
	disabled: {},
	placeholder: {},
	clearable: {},
	clearableColor: {},
	clearableOnClick: {},
	onClear: {},
	clearableSvgClass: {},
	clearableClass: {},
	selectClass: {},
	class: {},
	classes: {}
}, [], [], !0);
var root_1$61 = /* @__PURE__ */ from_html("<option> </option>"), root_2$29 = /* @__PURE__ */ from_html("<span> </span>"), root_10$4 = /* @__PURE__ */ from_html("<div role=\"presentation\"> </div>"), root_9$3 = /* @__PURE__ */ from_html("<div role=\"presentation\"></div>"), root$47 = /* @__PURE__ */ from_html("<select hidden=\"\" multiple></select> <div><!> <span><!></span> <div class=\"ms-auto flex items-center gap-2\"><!> <svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 10 6\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\"></path></svg></div> <!></div>", 1);
function MultiSelect(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "items", 23, () => []), F = prop(E, "value", 15), I = prop(E, "size", 7, "md"), L = prop(E, "dropdownClass", 7, ""), z = prop(E, "placeholder", 7, ""), B = prop(E, "disabled", 7, !1), V = prop(E, "onchange", 7), U = prop(E, "onblur", 7), W = prop(E, "class", 7), G = prop(E, "classes", 7), K = prop(E, "name", 7), J = prop(E, "form", 7), Y = prop(E, "required", 7), X = prop(E, "autocomplete", 7), Z = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"items",
		"value",
		"size",
		"dropdownClass",
		"placeholder",
		"disabled",
		"onchange",
		"onblur",
		"class",
		"classes",
		"name",
		"form",
		"required",
		"autocomplete"
	]);
	L();
	let Q = /* @__PURE__ */ user_derived(() => {
		var C;
		return (C = G()) == null ? { dropdown: L() } : C;
	}), NL = getTheme("multiSelect"), PL = /* @__PURE__ */ user_derived(() => O().filter((C) => F().includes(C.value))), FL = /* @__PURE__ */ state(!1), IL = /* @__PURE__ */ state(null), LL = /* @__PURE__ */ user_derived(() => get(IL) === null ? null : O()[(get(IL) % O().length + O().length) % O().length]), RL, zL = (C, T) => {
		if (T.stopPropagation(), B() || C.disabled) return;
		let E = [...F()];
		F().includes(C.value) ? BL(C) : F().includes(C.value) || F([...F(), C.value]), JSON.stringify(E) !== JSON.stringify(F()) && VL();
	};
	createDismissableContext((C) => {
		if (B()) return;
		C.stopPropagation();
		let T = [...F()];
		F([]), T.length > 0 && VL();
	});
	let BL = (C) => {
		if (!B() && F().includes(C.value)) {
			let T = [...F()];
			F(F().filter((T) => T !== C.value)), T.length !== F().length && VL();
		}
	}, VL = () => {
		if (V()) {
			let C = new Event("change", { bubbles: !0 });
			Object.defineProperty(C, "target", {
				value: { value: F() },
				enumerable: !0
			}), Object.defineProperty(C, "currentTarget", {
				value: { value: F() },
				enumerable: !0
			}), V()(C);
		}
	}, HL = () => !B() && set(FL, !1), UL = (C) => {
		B() || (RL && RL.contains(C.target) ? set(FL, !get(FL)) : set(FL, !1));
	}, WL = (C) => {
		C.currentTarget && C.currentTarget.contains && !C.currentTarget.contains(C.relatedTarget) && HL(), U() && U()(C);
	};
	function GL() {
		B() || (get(FL) ? get(LL) !== null && zL(get(LL), new MouseEvent("click")) : (set(FL, !0), set(IL, 0)));
	}
	function KL(C) {
		B() || (get(FL) ? get(IL) === null ? set(IL, 0) : set(IL, get(IL) + C) : (set(FL, !0), set(IL, 0)));
	}
	function qL(C) {
		if (B()) return;
		C.key !== "Tab" && C.preventDefault(), C.stopPropagation();
		let T = {
			Escape: HL,
			Enter: GL,
			" ": GL,
			ArrowDown: () => KL(1),
			ArrowUp: () => KL(-1)
		};
		if (C.key in T) {
			var E;
			(E = T[C.key]) == null || E.call(T);
		}
	}
	onMount(() => {
		let C = (C) => {
			RL && !RL.contains(C.target) && HL();
		};
		return document.addEventListener("click", C), () => {
			document.removeEventListener("click", C);
		};
	});
	let { base: JL, dropdown: YL, item: XL, close: ZL, select: QL, placeholder: $L, svg: eR } = multiSelect({ disabled: B() });
	var tR = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get items() {
			return O();
		},
		set items(C = []) {
			O(C), flushSync();
		},
		get value() {
			return F();
		},
		set value(C) {
			F(C), flushSync();
		},
		get size() {
			return I();
		},
		set size(C = "md") {
			I(C), flushSync();
		},
		get dropdownClass() {
			return L();
		},
		set dropdownClass(C = "") {
			L(C), flushSync();
		},
		get placeholder() {
			return z();
		},
		set placeholder(C = "") {
			z(C), flushSync();
		},
		get disabled() {
			return B();
		},
		set disabled(C = !1) {
			B(C), flushSync();
		},
		get onchange() {
			return V();
		},
		set onchange(C) {
			V(C), flushSync();
		},
		get onblur() {
			return U();
		},
		set onblur(C) {
			U(C), flushSync();
		},
		get class() {
			return W();
		},
		set class(C) {
			W(C), flushSync();
		},
		get classes() {
			return G();
		},
		set classes(C) {
			G(C), flushSync();
		},
		get name() {
			return K();
		},
		set name(C) {
			K(C), flushSync();
		},
		get form() {
			return J();
		},
		set form(C) {
			J(C), flushSync();
		},
		get required() {
			return Y();
		},
		set required(C) {
			Y(C), flushSync();
		},
		get autocomplete() {
			return X();
		},
		set autocomplete(C) {
			X(C), flushSync();
		}
	}, nR = root$47(), rR = first_child(nR);
	rR.__change = function(...C) {
		var T;
		(T = V()) == null || T.apply(this, C);
	}, each(rR, 21, O, index, (C, T) => {
		var E = root_1$61(), D = child(E, !0);
		reset(E);
		var O = {};
		template_effect(() => {
			if (E.disabled = get(T).disabled, set_text(D, get(T).name), O !== (O = get(T).value)) {
				var C;
				E.value = (C = E.__value = get(T).value) == null ? "" : C;
			}
		}), append(C, E);
	}), reset(rR);
	var iR;
	init_select(rR);
	var aR = sibling(rR, 2);
	attribute_effect(aR, (C) => _objectSpread2(_objectSpread2({}, Z), {}, {
		onclick: UL,
		onblur: WL,
		onkeydown: qL,
		tabindex: "0",
		role: "listbox",
		class: C
	}), [() => JL({
		size: I(),
		class: clsx_default(NL == null ? void 0 : NL.base, W())
	})]);
	var oR = child(aR), sR = (C) => {
		var T = root_2$29(), E = child(T, !0);
		reset(T), template_effect((C) => {
			set_class(T, 1, C), set_text(E, z());
		}, [() => {
			var C;
			return clsx$1($L({ class: clsx_default((C = G()) == null ? void 0 : C.placeholder) }));
		}]), append(C, T);
	};
	if_block(oR, (C) => {
		get(PL).length || C(sR);
	});
	var cR = sibling(oR, 2), lR = child(cR), uR = (C) => {
		var T = comment();
		each(first_child(T), 17, () => get(PL), (C) => C.name, (C, T) => {
			var E = comment(), O = first_child(E), F = (C) => {
				var E = comment();
				snippet(first_child(E), D, () => ({
					item: get(T),
					clear: () => BL(get(T))
				})), append(C, E);
			}, L = (C) => {
				{
					let E = /* @__PURE__ */ user_derived(() => I() === "lg"), D = /* @__PURE__ */ user_derived(() => [B() && "pointer-events-none"]);
					Badge(C, {
						color: "gray",
						get large() {
							return get(E);
						},
						dismissable: !0,
						params: { duration: 100 },
						onclose: () => BL(get(T)),
						get class() {
							return get(D);
						},
						children: (C, E) => {
							next();
							var D = text();
							template_effect(() => set_text(D, get(T).name)), append(C, D);
						},
						$$slots: { default: !0 }
					});
				}
			};
			if_block(O, (C) => {
				D() ? C(F) : C(L, !1);
			}), append(C, E);
		}), append(C, T);
	};
	if_block(lR, (C) => {
		get(PL).length && C(uR);
	}), reset(cR);
	var dR = sibling(cR, 2), fR = child(dR), pR = (C) => {
		{
			let T = /* @__PURE__ */ user_derived(() => {
				var C;
				return ZL({ class: clsx_default(NL == null ? void 0 : NL.close, (C = G()) == null ? void 0 : C.close) });
			});
			CloseButton(C, {
				get size() {
					return I();
				},
				color: "none",
				get class() {
					return get(T);
				},
				get disabled() {
					return B();
				}
			});
		}
	};
	if_block(fR, (C) => {
		get(PL).length && C(pR);
	});
	var mR = sibling(fR, 2), hR = child(mR);
	reset(mR), reset(dR);
	var gR = sibling(dR, 2), _R = (C) => {
		var T = root_9$3();
		each(T, 21, O, (C) => C.name, (C, T) => {
			var E = root_10$4();
			E.__click = (C) => zL(get(T), C);
			var D = child(E, !0);
			reset(E), template_effect((C) => {
				set_class(E, 1, C), set_text(D, get(T).name);
			}, [() => {
				var C;
				return clsx$1(XL({
					selected: get(PL).includes(get(T)),
					active: get(LL) === get(T),
					disabled: get(T).disabled,
					class: clsx_default((C = G()) == null ? void 0 : C.item)
				}));
			}]), append(C, E);
		}), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(YL({ class: clsx_default(get(Q).dropdown) }))]), append(C, T);
	};
	return if_block(gR, (C) => {
		get(FL) && C(_R);
	}), reset(aR), bind_this(aR, (C) => RL = C, () => RL), template_effect((C, T) => {
		if (set_attribute(rR, "name", K()), set_attribute(rR, "form", J()), rR.required = Y(), set_attribute(rR, "autocomplete", X()), iR !== (iR = F())) {
			var E;
			rR.value = (E = rR.__value = F()) == null ? "" : E, select_option(rR, F());
		}
		set_class(cR, 1, C), set_class(mR, 0, T), set_attribute(hR, "d", get(FL) ? "m1 5 4-4 4 4" : "m9 1-4 4-4-4");
	}, [() => {
		var C;
		return clsx$1(QL({ class: clsx_default(NL == null ? void 0 : NL.select, (C = G()) == null ? void 0 : C.span) }));
	}, () => {
		var C;
		return clsx$1(clsx_default(eR(), B() && "cursor-not-allowed", (C = G()) == null ? void 0 : C.svg));
	}]), append(C, nR), pop(tR);
}
delegate(["change", "click"]), create_custom_element(MultiSelect, {
	children: {},
	items: {},
	value: {},
	size: {},
	dropdownClass: {},
	placeholder: {},
	disabled: {},
	onchange: {},
	onblur: {},
	class: {},
	classes: {},
	name: {},
	form: {},
	required: {},
	autocomplete: {}
}, [], [], !0);
const radio = ce({
	slots: {
		input: "flex items-center w-4 h-4 bg-gray-100 border-gray-300 dark:ring-offset-gray-800 focus:ring-2 mr-2",
		label: "flex items-center"
	},
	variants: {
		color: {
			primary: { input: "text-primary-600 focus:ring-primary-500 dark:focus:ring-primary-600" },
			secondary: { input: "text-secondary-600 focus:ring-secondary-500 dark:focus:ring-secondary-600" },
			gray: { input: "text-gray-600 focus:ring-gray-500 dark:focus:ring-gray-600" },
			red: { input: "text-red-600 focus:ring-red-500 dark:focus:ring-red-600" },
			orange: { input: "text-orange-500 focus:ring-orange-500 dark:focus:ring-orange-600" },
			amber: { input: "text-amber-600 focus:ring-amber-500 dark:focus:ring-amber-600" },
			yellow: { input: "text-yellow-400 focus:ring-yellow-500 dark:focus:ring-yellow-600" },
			lime: { input: "text-lime-600 focus:ring-lime-500 dark:focus:ring-lime-600" },
			green: { input: "text-green-600 focus:ring-green-500 dark:focus:ring-green-600" },
			emerald: { input: "text-emerald-600 focus:ring-emerald-500 dark:focus:ring-emerald-600" },
			teal: { input: "text-teal-600 focus:ring-teal-500 dark:focus:ring-teal-600" },
			cyan: { input: "text-cyan-600 focus:ring-cyan-500 dark:focus:ring-cyan-600" },
			sky: { input: "text-sky-600 focus:ring-sky-500 dark:focus:ring-sky-600" },
			blue: { input: "text-blue-600 focus:ring-blue-500 dark:focus:ring-blue-600" },
			indigo: { input: "text-indigo-600 focus:ring-indigo-500 dark:focus:ring-indigo-600" },
			violet: { input: "text-violet-600 focus:ring-violet-500 dark:focus:ring-violet-600" },
			purple: { input: "text-purple-600 focus:ring-purple-500 dark:focus:ring-purple-600" },
			fuchsia: { input: "text-fuchsia-600 focus:ring-fuchsia-500 dark:focus:ring-fuchsia-600" },
			pink: { input: "text-pink-600 focus:ring-pink-500 dark:focus:ring-pink-600" },
			rose: { input: "text-rose-600 focus:ring-rose-500 dark:focus:ring-rose-600" }
		},
		tinted: {
			true: { input: "dark:bg-gray-600 dark:border-gray-500" },
			false: { input: "dark:bg-gray-700 dark:border-gray-600" }
		},
		custom: {
			true: { input: "sr-only peer" },
			false: { input: "relative" }
		},
		inline: {
			true: { label: "inline-flex" },
			false: { label: "flex" }
		}
	},
	defaultVariants: { color: "primary" }
}), radioButton = ce({
	base: "",
	variants: { inline: {
		true: "inline-flex",
		false: "flex"
	} },
	defaultVariants: { inline: !0 }
});
var root_1$60 = /* @__PURE__ */ from_html("<input/> <!>", 1);
function Radio(C, E) {
	push(E, !0);
	let D = [], O = prop(E, "children", 7), F = prop(E, "aria-describedby", 7), I = prop(E, "inline", 7, !1), L = prop(E, "labelClass", 7), z = prop(E, "color", 7, "primary"), B = prop(E, "custom", 7, !1), V = prop(E, "group", 15), U = prop(E, "value", 15), W = prop(E, "class", 7), G = prop(E, "inputClass", 7), K = prop(E, "classes", 7), J = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"aria-describedby",
		"inline",
		"labelClass",
		"color",
		"custom",
		"group",
		"value",
		"class",
		"inputClass",
		"classes"
	]);
	G(), L();
	let Y = /* @__PURE__ */ user_derived(() => {
		var C;
		return (C = K()) == null ? { label: L() } : C;
	}), X = getTheme("radio"), Z = /* @__PURE__ */ user_derived(() => radio({
		color: z(),
		tinted: !!getContext("background"),
		custom: B(),
		inline: I()
	})), Q = /* @__PURE__ */ user_derived(() => get(Z).input), PL = /* @__PURE__ */ user_derived(() => get(Z).label);
	var FL = {
		get children() {
			return O();
		},
		set children(C) {
			O(C), flushSync();
		},
		get "aria-describedby"() {
			return F();
		},
		set "aria-describedby"(C) {
			F(C), flushSync();
		},
		get inline() {
			return I();
		},
		set inline(C = !1) {
			I(C), flushSync();
		},
		get labelClass() {
			return L();
		},
		set labelClass(C) {
			L(C), flushSync();
		},
		get color() {
			return z();
		},
		set color(C = "primary") {
			z(C), flushSync();
		},
		get custom() {
			return B();
		},
		set custom(C = !1) {
			B(C), flushSync();
		},
		get group() {
			return V();
		},
		set group(C) {
			V(C), flushSync();
		},
		get value() {
			return U();
		},
		set value(C) {
			U(C), flushSync();
		},
		get class() {
			return W();
		},
		set class(C) {
			W(C), flushSync();
		},
		get inputClass() {
			return G();
		},
		set inputClass(C) {
			G(C), flushSync();
		},
		get classes() {
			return K();
		},
		set classes(C) {
			K(C), flushSync();
		}
	};
	{
		let E = /* @__PURE__ */ user_derived(() => get(PL)({ class: clsx_default(X == null ? void 0 : X.label, get(Y).label) }));
		Label(C, {
			get class() {
				return get(E);
			},
			children: (C, E) => {
				var I = root_1$60(), L = first_child(I);
				attribute_effect(L, (C) => _objectSpread2(_objectSpread2({
					type: "radio",
					value: U(),
					"aria-describedby": F()
				}, J), {}, { class: C }), [() => {
					var C;
					return get(Q)({ class: clsx_default(X == null ? void 0 : X.input, (C = W()) == null ? G() : C) });
				}], void 0, void 0, void 0, !0), snippet(sibling(L, 2), () => {
					var C;
					return (C = O()) == null ? noop : C;
				}), bind_group(D, [], L, () => (U(), V()), V), append(C, I);
			},
			$$slots: { default: !0 }
		});
	}
	return pop(FL);
}
create_custom_element(Radio, {
	children: {},
	"aria-describedby": {},
	inline: {},
	labelClass: {},
	color: {},
	custom: {},
	group: {},
	value: {},
	class: {},
	inputClass: {},
	classes: {}
}, [], [], !0);
var root_1$59 = /* @__PURE__ */ from_html("<input/> <!>", 1);
function RadioButton(C, E) {
	push(E, !0);
	let D = [], O = prop(E, "children", 7), F = prop(E, "group", 15), I = prop(E, "value", 15), L = prop(E, "inline", 7), z = prop(E, "pill", 7), B = prop(E, "outline", 7), V = prop(E, "size", 7), U = prop(E, "color", 7), W = prop(E, "shadow", 7), G = prop(E, "checkedClass", 7), K = prop(E, "class", 7), J = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"group",
		"value",
		"inline",
		"pill",
		"outline",
		"size",
		"color",
		"shadow",
		"checkedClass",
		"class"
	]), Y = getTheme("radioButton"), X = /* @__PURE__ */ user_derived(() => I() == F()), Z = /* @__PURE__ */ user_derived(() => radioButton({
		inline: L(),
		class: clsx_default(get(X) && G(), Y, K())
	}));
	return Button(C, {
		tag: "label",
		get pill() {
			return z();
		},
		get outline() {
			return B();
		},
		get size() {
			return V();
		},
		get color() {
			return U();
		},
		get shadow() {
			return W();
		},
		get class() {
			return get(Z);
		},
		children: (C, E) => {
			var L = root_1$59(), z = first_child(L);
			attribute_effect(z, () => _objectSpread2({
				type: "radio",
				class: "sr-only",
				value: I()
			}, J), void 0, void 0, void 0, void 0, !0), snippet(sibling(z, 2), () => {
				var C;
				return (C = O()) == null ? noop : C;
			}), bind_group(D, [], z, () => (I(), F()), F), append(C, L);
		},
		$$slots: { default: !0 }
	}), pop({
		get children() {
			return O();
		},
		set children(C) {
			O(C), flushSync();
		},
		get group() {
			return F();
		},
		set group(C) {
			F(C), flushSync();
		},
		get value() {
			return I();
		},
		set value(C) {
			I(C), flushSync();
		},
		get inline() {
			return L();
		},
		set inline(C) {
			L(C), flushSync();
		},
		get pill() {
			return z();
		},
		set pill(C) {
			z(C), flushSync();
		},
		get outline() {
			return B();
		},
		set outline(C) {
			B(C), flushSync();
		},
		get size() {
			return V();
		},
		set size(C) {
			V(C), flushSync();
		},
		get color() {
			return U();
		},
		set color(C) {
			U(C), flushSync();
		},
		get shadow() {
			return W();
		},
		set shadow(C) {
			W(C), flushSync();
		},
		get checkedClass() {
			return G();
		},
		set checkedClass(C) {
			G(C), flushSync();
		},
		get class() {
			return K();
		},
		set class(C) {
			K(C), flushSync();
		}
	});
}
create_custom_element(RadioButton, {
	children: {},
	group: {},
	value: {},
	inline: {},
	pill: {},
	outline: {},
	size: {},
	color: {},
	shadow: {},
	checkedClass: {},
	class: {}
}, [], [], !0);
const range$1 = ce({
	base: "w-full bg-gray-200 rounded-lg cursor-pointer dark:bg-gray-700",
	variants: {
		size: {
			sm: "h-1 range-sm",
			md: "h-2",
			lg: "h-3 range-lg"
		},
		color: {
			gray: "",
			red: "",
			blue: "",
			indigo: "",
			violet: "",
			purple: "",
			fuchsia: "",
			pink: "",
			rose: ""
		},
		appearance: {
			auto: "range accent-red-500",
			none: "appearance-none"
		}
	},
	compoundVariants: [
		{
			appearance: "auto",
			color: "gray",
			class: "accent-gray-500"
		},
		{
			appearance: "auto",
			color: "red",
			class: "accent-red-500"
		},
		{
			appearance: "auto",
			color: "blue",
			class: "accent-blue-500"
		},
		{
			appearance: "auto",
			color: "indigo",
			class: "accent-indigo-500"
		},
		{
			appearance: "auto",
			color: "violet",
			class: "accent-violet-500"
		},
		{
			appearance: "auto",
			color: "purple",
			class: "accent-purple-500"
		},
		{
			appearance: "auto",
			color: "fuchsia",
			class: "accent-fuchsia-500"
		},
		{
			appearance: "auto",
			color: "pink",
			class: "accent-pink-500"
		},
		{
			appearance: "auto",
			color: "rose",
			class: "accent-rose-500"
		}
	]
});
var root$46 = /* @__PURE__ */ from_html("<input/>");
function Range(C, E) {
	push(E, !0);
	let D = prop(E, "value", 15), O = prop(E, "appearance", 7, "none"), F = prop(E, "color", 7, "blue"), I = prop(E, "size", 7, "md"), L = prop(E, "inputClass", 7), z = prop(E, "class", 7), B = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"value",
		"appearance",
		"color",
		"size",
		"inputClass",
		"class"
	]), V = getTheme("range"), U = /* @__PURE__ */ user_derived(() => range$1({
		appearance: O(),
		color: F(),
		size: I(),
		class: clsx_default(V, L(), z())
	}));
	var W = {
		get value() {
			return D();
		},
		set value(C) {
			D(C), flushSync();
		},
		get appearance() {
			return O();
		},
		set appearance(C = "none") {
			O(C), flushSync();
		},
		get color() {
			return F();
		},
		set color(C = "blue") {
			F(C), flushSync();
		},
		get size() {
			return I();
		},
		set size(C = "md") {
			I(C), flushSync();
		},
		get inputClass() {
			return L();
		},
		set inputClass(C) {
			L(C), flushSync();
		},
		get class() {
			return z();
		},
		set class(C) {
			z(C), flushSync();
		}
	}, G = root$46();
	return attribute_effect(G, () => _objectSpread2(_objectSpread2({ type: "range" }, B), {}, { class: get(U) }), void 0, void 0, void 0, void 0, !0), bind_value(G, D), append(C, G), pop(W);
}
create_custom_element(Range, {
	value: {},
	appearance: {},
	color: {},
	size: {},
	inputClass: {},
	class: {}
}, [], [], !0);
const search = ce({
	slots: {
		base: "relative w-full",
		left: "absolute inset-y-0 start-0 flex items-center ps-3 pointer-events-none",
		icon: "text-gray-500 dark:text-gray-400",
		content: "absolute inset-y-0 end-0 flex items-center text-gray-500 dark:text-gray-400",
		input: "block w-full text-gray-900 border border-gray-300 rounded-lg bg-gray-50 focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-primary-500 dark:focus:border-primary-500 disabled:cursor-not-allowed disabled:opacity-50",
		close: "absolute right-2 top-1/2 -translate-y-1/2 text-gray-400 hover:text-black",
		svg: ""
	},
	variants: { size: {
		sm: {
			input: "text-xs p-2 ps-9 pe-9 ",
			icon: "w-3 h-3"
		},
		md: {
			input: "text-sm p-2.5 ps-10 pe-10",
			icon: "w-4 h-4"
		},
		lg: {
			input: "sm:text-base p-3 ps-11 pe-11",
			icon: "w-6 h-6"
		}
	} },
	defaultVariants: { size: "lg" }
});
var root_1$58 = /* @__PURE__ */ from_html("<div><!></div>"), root$45 = /* @__PURE__ */ from_html("<div><div><svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 20 20\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"m19 19-4-4m0-7A7 7 0 1 1 1 8a7 7 0 0 1 14 0Z\"></path></svg></div> <input/> <!> <!></div>");
function Search(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "inputClass", 7), F = prop(E, "size", 7), I = prop(E, "placeholder", 7, "Search"), L = prop(E, "value", 15), z = prop(E, "elementRef", 15), B = prop(E, "clearable", 7, !1), V = prop(E, "clearableSvgClass", 7), U = prop(E, "clearableColor", 7, "none"), W = prop(E, "clearableClass", 7), G = prop(E, "clearableOnClick", 7), K = prop(E, "class", 7), J = prop(E, "classes", 7), Y = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"inputClass",
		"size",
		"placeholder",
		"value",
		"elementRef",
		"clearable",
		"clearableSvgClass",
		"clearableColor",
		"clearableClass",
		"clearableOnClick",
		"class",
		"classes"
	]);
	O(), V(), W();
	let X = /* @__PURE__ */ user_derived(() => {
		var C;
		return (C = J()) == null ? {
			input: O(),
			svg: V(),
			close: W()
		} : C;
	}), Z = getTheme("search"), Q = /* @__PURE__ */ user_derived(() => search({ size: F() })), NL = /* @__PURE__ */ user_derived(() => get(Q).base), PL = /* @__PURE__ */ user_derived(() => get(Q).content), FL = /* @__PURE__ */ user_derived(() => get(Q).icon), IL = /* @__PURE__ */ user_derived(() => get(Q).close), LL = /* @__PURE__ */ user_derived(() => get(Q).input), RL = /* @__PURE__ */ user_derived(() => get(Q).left);
	createDismissableContext(() => {
		z() && (z(z().value = "", !0), L(void 0)), G() && G()();
	});
	var zL = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get inputClass() {
			return O();
		},
		set inputClass(C) {
			O(C), flushSync();
		},
		get size() {
			return F();
		},
		set size(C) {
			F(C), flushSync();
		},
		get placeholder() {
			return I();
		},
		set placeholder(C = "Search") {
			I(C), flushSync();
		},
		get value() {
			return L();
		},
		set value(C) {
			L(C), flushSync();
		},
		get elementRef() {
			return z();
		},
		set elementRef(C) {
			z(C), flushSync();
		},
		get clearable() {
			return B();
		},
		set clearable(C = !1) {
			B(C), flushSync();
		},
		get clearableSvgClass() {
			return V();
		},
		set clearableSvgClass(C) {
			V(C), flushSync();
		},
		get clearableColor() {
			return U();
		},
		set clearableColor(C = "none") {
			U(C), flushSync();
		},
		get clearableClass() {
			return W();
		},
		set clearableClass(C) {
			W(C), flushSync();
		},
		get clearableOnClick() {
			return G();
		},
		set clearableOnClick(C) {
			G(C), flushSync();
		},
		get class() {
			return K();
		},
		set class(C) {
			K(C), flushSync();
		},
		get classes() {
			return J();
		},
		set classes(C) {
			J(C), flushSync();
		}
	}, BL = root$45(), VL = child(BL), HL = child(VL);
	reset(VL);
	var UL = sibling(VL, 2);
	attribute_effect(UL, (C) => _objectSpread2({
		type: "search",
		class: C,
		placeholder: I(),
		required: !0
	}, Y), [() => get(LL)({ class: clsx_default(Z == null ? void 0 : Z.input, get(X).input) })], void 0, void 0, void 0, !0), bind_this(UL, (C) => z(C), () => z());
	var WL = sibling(UL, 2), GL = (C) => {
		var T = root_1$58();
		snippet(child(T), D), reset(T), template_effect((C) => set_class(T, 1, C), [() => {
			var C;
			return clsx$1(get(PL)({ class: clsx_default(Z == null ? void 0 : Z.content, (C = J()) == null ? void 0 : C.content) }));
		}]), append(C, T);
	};
	if_block(WL, (C) => {
		D() && C(GL);
	});
	var KL = sibling(WL, 2), qL = (C) => {
		{
			let T = /* @__PURE__ */ user_derived(() => get(IL)({ class: clsx_default(Z == null ? void 0 : Z.close, get(X).close) })), E = /* @__PURE__ */ user_derived(() => clsx_default(get(X).svg));
			CloseButton(C, {
				get class() {
					return get(T);
				},
				get color() {
					return U();
				},
				"aria-label": "Clear search value",
				get svgClass() {
					return get(E);
				}
			});
		}
	};
	return if_block(KL, (C) => {
		L() !== void 0 && L() !== "" && B() && C(qL);
	}), reset(BL), template_effect((C, T, E) => {
		set_class(BL, 1, C), set_class(VL, 1, T), set_class(HL, 0, E);
	}, [
		() => clsx$1(get(NL)({ class: clsx_default(Z == null ? void 0 : Z.base, K()) })),
		() => {
			var C;
			return clsx$1(get(RL)({ class: clsx_default(Z == null ? void 0 : Z.left, (C = J()) == null ? void 0 : C.left) }));
		},
		() => {
			var C;
			return clsx$1(get(FL)({ class: clsx_default(Z == null ? void 0 : Z.icon, (C = J()) == null ? void 0 : C.icon) }));
		}
	]), bind_value(UL, L), append(C, BL), pop(zL);
}
create_custom_element(Search, {
	children: {},
	inputClass: {},
	size: {},
	placeholder: {},
	value: {},
	elementRef: {},
	clearable: {},
	clearableSvgClass: {},
	clearableColor: {},
	clearableClass: {},
	clearableOnClick: {},
	class: {},
	classes: {}
}, [], [], !0);
const tags = ce({ slots: {
	base: "border border-gray-300 dark:border-gray-600 rounded-lg flex focus-within:ring-primary-500 focus-within:ring-1 focus-within:border-primary-500 scrollbar-hidden bg-gray-50 dark:bg-gray-700",
	tag: "flex items-center rounded-lg bg-gray-100 text-gray-900 border border-gray-300 my-1 ml-1 px-2 text-sm max-w-full min-w-fit",
	span: "items-center",
	close: "my-auto ml-1",
	input: "block text-sm m-2.5 p-0 bg-transparent border-none outline-none text-gray-900 h-min w-full min-w-fit focus:ring-0 placeholder-gray-400 dark:text-white disabled:cursor-not-allowed disabled:opacity-50",
	info: "mt-1 text-sm text-blue-500 dark:text-blue-400",
	warning: "mt-1 text-sm text-yellow-400 dark:text-yellow-300",
	error: "mt-1 text-sm text-red-500 dark:text-red-400"
} });
var root_9$2 = /* @__PURE__ */ from_html("<div><span> </span> <!></div>"), root_12$1 = /* @__PURE__ */ from_html("<li><button type=\"button\" class=\"block w-full cursor-pointer px-3 py-2 text-left hover:bg-gray-100\"> </button></li>"), root_11$2 = /* @__PURE__ */ from_html("<ul class=\"z-10 max-h-48 w-full overflow-auto rounded border border-gray-300 bg-white shadow\" style=\"position: absolute;\"></ul>"), root$44 = /* @__PURE__ */ from_html("<!> <!> <div><!> <div class=\"relative w-full\"><input/> <!></div></div>", 1);
function Tags(C, E) {
	push(E, !0);
	let D = prop(E, "value", 31, () => proxy([])), O = prop(E, "placeholder", 7, "Enter tags"), F = prop(E, "class", 7), I = prop(E, "classes", 7), L = prop(E, "itemClass", 7), z = prop(E, "spanClass", 7), B = prop(E, "closeClass", 7), V = prop(E, "inputClass", 7), U = prop(E, "closeBtnSize", 7, "xs"), W = prop(E, "unique", 7, !1), G = prop(E, "availableTags", 23, () => []), K = prop(E, "showHelper", 7, !1), J = prop(E, "showAvailableTags", 7, !1), Y = prop(E, "allowNewTags", 7, !0), X = prop(E, "inputProps", 23, () => ({})), Z = prop(E, "disabled", 7), Q = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"value",
		"placeholder",
		"class",
		"classes",
		"itemClass",
		"spanClass",
		"closeClass",
		"inputClass",
		"closeBtnSize",
		"unique",
		"availableTags",
		"showHelper",
		"showAvailableTags",
		"allowNewTags",
		"inputProps",
		"disabled"
	]);
	L(), z(), B(), V();
	let NL = /* @__PURE__ */ user_derived(() => {
		var C;
		return (C = I()) == null ? {
			tag: L(),
			span: z(),
			close: B(),
			input: V()
		} : C;
	}), PL = getTheme("tags"), FL = /* @__PURE__ */ user_derived(tags), IL = /* @__PURE__ */ user_derived(() => get(FL).base), LL = /* @__PURE__ */ user_derived(() => get(FL).tag), RL = /* @__PURE__ */ user_derived(() => get(FL).span), zL = /* @__PURE__ */ user_derived(() => get(FL).close), BL = /* @__PURE__ */ user_derived(() => get(FL).input), VL = /* @__PURE__ */ user_derived(() => get(FL).info), HL = /* @__PURE__ */ user_derived(() => get(FL).warning), UL = /* @__PURE__ */ user_derived(() => get(FL).error), WL = /* @__PURE__ */ state(""), GL = /* @__PURE__ */ state(""), KL, qL, JL = null, YL;
	function XL() {
		!qL || !JL || (YL == null || YL(), YL = autoUpdate(qL, JL, _asyncToGenerator(function* () {
			let { x: C, y: T } = yield computePosition(qL, JL, {
				placement: "bottom-start",
				middleware: [
					offset(4),
					flip(),
					shift()
				]
			});
			Object.assign(JL.style, {
				position: "absolute",
				left: `${C}px`,
				top: `${T}px`
			});
		})));
	}
	let ZL = () => {}, QL = (C) => {
		if (C.key === "Enter") {
			C.preventDefault();
			let T = get(WL).trim();
			if (T.length === 0) return;
			if (!Y() && G().length === 0) {
				set(GL, "No available tags provided. Please add available tags or enable allowNewTags.");
				return;
			}
			let E = G().length === 0 || G().some((C) => C.toLowerCase() === T.toLowerCase()), O = D().some((C) => C.toLowerCase() === T.toLowerCase());
			if (!Y() && !E) {
				set(GL, `"${T}" is not in the available tags.`);
				return;
			}
			if (W() && O) {
				set(GL, `"${T}" is already added.`);
				return;
			}
			D([...D(), T]), set(WL, ""), KL && (KL.value = ""), set(GL, "");
		}
		if (C.key === "Backspace" && get(WL).length === 0) {
			var T;
			C.preventDefault();
			let E = (T = D()[D().length - 1]) == null ? "" : T;
			D(D().slice(0, -1)), set(WL, E, !0), KL && (KL.value = E), set(GL, "");
		}
	}, $L = () => {}, eR = (C) => {
		D(D().filter((T, E) => E !== C)), set(GL, "");
	};
	user_effect(() => {
		let C = get(WL).trim();
		if (!(G().length > 0 && C !== "" && qL && JL)) {
			YL == null || YL();
			return;
		}
		G().filter((T) => T.toLowerCase().includes(C.toLowerCase()) && (!W() || !D().some((C) => C.toLowerCase() === T.toLowerCase()))).length > 0 ? XL() : YL == null || YL();
	}), onDestroy(() => {
		YL == null || YL();
	});
	var tR = {
		get value() {
			return D();
		},
		set value(C = []) {
			D(C), flushSync();
		},
		get placeholder() {
			return O();
		},
		set placeholder(C = "Enter tags") {
			O(C), flushSync();
		},
		get class() {
			return F();
		},
		set class(C) {
			F(C), flushSync();
		},
		get classes() {
			return I();
		},
		set classes(C) {
			I(C), flushSync();
		},
		get itemClass() {
			return L();
		},
		set itemClass(C) {
			L(C), flushSync();
		},
		get spanClass() {
			return z();
		},
		set spanClass(C) {
			z(C), flushSync();
		},
		get closeClass() {
			return B();
		},
		set closeClass(C) {
			B(C), flushSync();
		},
		get inputClass() {
			return V();
		},
		set inputClass(C) {
			V(C), flushSync();
		},
		get closeBtnSize() {
			return U();
		},
		set closeBtnSize(C = "xs") {
			U(C), flushSync();
		},
		get unique() {
			return W();
		},
		set unique(C = !1) {
			W(C), flushSync();
		},
		get availableTags() {
			return G();
		},
		set availableTags(C = []) {
			G(C), flushSync();
		},
		get showHelper() {
			return K();
		},
		set showHelper(C = !1) {
			K(C), flushSync();
		},
		get showAvailableTags() {
			return J();
		},
		set showAvailableTags(C = !1) {
			J(C), flushSync();
		},
		get allowNewTags() {
			return Y();
		},
		set allowNewTags(C = !0) {
			Y(C), flushSync();
		},
		get inputProps() {
			return X();
		},
		set inputProps(C = {}) {
			X(C), flushSync();
		},
		get disabled() {
			return Z();
		},
		set disabled(C) {
			Z(C), flushSync();
		}
	}, nR = root$44();
	event("scroll", $window, ZL), event("resize", $window, ZL);
	var rR = first_child(nR), iR = (C) => {
		{
			let T = /* @__PURE__ */ user_derived(() => {
				var C;
				return clsx_default(get(VL)(), (C = I()) == null ? void 0 : C.info);
			});
			P(C, {
				get class() {
					return get(T);
				},
				children: (C, T) => {
					next();
					var E = text();
					template_effect((C) => set_text(E, `Available tags: ${C == null ? "" : C}`), [() => G().join(", ")]), append(C, E);
				},
				$$slots: { default: !0 }
			});
		}
	};
	if_block(rR, (C) => {
		J() && G().length > 0 && C(iR);
	});
	var aR = sibling(rR, 2), oR = (C) => {
		var T = comment(), E = first_child(T), O = (C) => {
			{
				let T = /* @__PURE__ */ user_derived(() => {
					var C;
					return clsx_default(get(HL)(), (C = I()) == null ? void 0 : C.warning);
				});
				P(C, {
					get class() {
						return get(T);
					},
					children: (C, T) => {
						next();
						var E = text();
						template_effect((C) => set_text(E, `"${C == null ? "" : C}" is already added.`), [() => get(WL).trim()]), append(C, E);
					},
					$$slots: { default: !0 }
				});
			}
		}, F = (C) => {
			var T = comment(), E = first_child(T), D = (C) => {
				{
					let T = /* @__PURE__ */ user_derived(() => {
						var C;
						return clsx_default(get(UL)(), (C = I()) == null ? void 0 : C.error);
					});
					P(C, {
						get class() {
							return get(T);
						},
						children: (C, T) => {
							next();
							var E = text();
							template_effect((C) => set_text(E, `"${C == null ? "" : C}" is not in the available tags.`), [() => get(WL).trim()]), append(C, E);
						},
						$$slots: { default: !0 }
					});
				}
			};
			if_block(E, (C) => {
				G().length > 0 && !Y() && !G().some((C) => C.toLowerCase() === get(WL).trim().toLowerCase()) && C(D);
			}, !0), append(C, T);
		};
		if_block(E, (C) => {
			W() && D().some((C) => C.toLowerCase() === get(WL).trim().toLowerCase()) ? C(O) : C(F, !1);
		}), append(C, T);
	};
	if_block(aR, (C) => {
		K() && get(WL).trim().length > 0 && C(oR);
	});
	var sR = sibling(aR, 2);
	attribute_effect(sR, (C) => _objectSpread2(_objectSpread2({}, Q), {}, { class: C }), [() => get(IL)({ class: clsx_default(PL == null ? void 0 : PL.base, F()) })]);
	var cR = child(sR);
	each(cR, 17, D, index, (C, T, E) => {
		var D = root_9$2(), O = child(D), F = child(O, !0);
		reset(O);
		var I = sibling(O, 2);
		{
			let C = /* @__PURE__ */ user_derived(() => get(zL)({ class: clsx_default(PL == null ? void 0 : PL.close, get(NL).close) }));
			CloseButton(I, {
				get disabled() {
					return Z();
				},
				get size() {
					return U();
				},
				get class() {
					return get(C);
				},
				onclick: () => eR(E)
			});
		}
		reset(D), template_effect((C, E) => {
			set_class(D, 1, C), set_class(O, 1, E), set_text(F, get(T));
		}, [() => clsx$1(get(LL)({ class: clsx_default(PL == null ? void 0 : PL.tag, get(NL).tag) })), () => clsx$1(get(RL)({ class: clsx_default(PL == null ? void 0 : PL.span, get(NL).span) }))]), append(C, D);
	});
	var lR = sibling(cR, 2), uR = child(lR);
	attribute_effect(uR, (C) => _objectSpread2(_objectSpread2({}, X()), {}, {
		disabled: Z(),
		onkeydown: QL,
		oninput: $L,
		placeholder: D().length === 0 ? O() : "",
		type: "text",
		autocomplete: "off",
		class: C
	}), [() => get(BL)({ class: clsx_default(get(NL).input) })], void 0, void 0, void 0, !0), bind_this(uR, (C) => KL = C, () => KL);
	var dR = sibling(uR, 2), fR = (C) => {
		let T = /* @__PURE__ */ user_derived(() => G().filter((C) => C.toLowerCase().includes(get(WL).trim().toLowerCase()) && (!W() || !D().some((T) => T.toLowerCase() === C.toLowerCase()))));
		var E = comment(), O = first_child(E), F = (C) => {
			var E = root_11$2();
			each(E, 21, () => get(T), index, (C, T) => {
				var E = root_12$1(), O = child(E);
				O.__click = () => {
					D([...D(), get(T)]), set(WL, ""), KL && (KL.value = "");
				};
				var F = child(O, !0);
				reset(O), reset(E), template_effect(() => set_text(F, get(T))), append(C, E);
			}), reset(E), bind_this(E, (C) => JL = C, () => JL), append(C, E);
		};
		if_block(O, (C) => {
			get(T).length > 0 && C(F);
		}), append(C, E);
	};
	return if_block(dR, (C) => {
		G().length > 0 && get(WL).trim() !== "" && C(fR);
	}), reset(lR), bind_this(lR, (C) => qL = C, () => qL), reset(sR), bind_value(uR, () => get(WL), (C) => set(WL, C)), append(C, nR), pop(tR);
}
delegate(["click"]), create_custom_element(Tags, {
	value: {},
	placeholder: {},
	class: {},
	classes: {},
	itemClass: {},
	spanClass: {},
	closeClass: {},
	inputClass: {},
	closeBtnSize: {},
	unique: {},
	availableTags: {},
	showHelper: {},
	showAvailableTags: {},
	allowNewTags: {},
	inputProps: {},
	disabled: {}
}, [], [], !0);
const textarea = ce({
	slots: {
		div: "relative",
		base: "block w-full text-sm border-0 px-0 bg-inherit dark:bg-inherit focus:outline-hidden focus:ring-0 disabled:cursor-not-allowed disabled:opacity-50",
		wrapper: "text-sm rounded-lg bg-gray-50 dark:bg-gray-600 text-gray-900 dark:placeholder-gray-400 dark:text-white border border-gray-200 dark:border-gray-500 disabled:cursor-not-allowed disabled:opacity-50",
		inner: "py-2 px-4 bg-white dark:bg-gray-800",
		header: "py-2 px-3 border-gray-200 dark:border-gray-500",
		footer: "py-2 px-3 border-gray-200 dark:border-gray-500",
		addon: "absolute top-2 right-2 z-10",
		close: "absolute right-2 top-5 -translate-y-1/2 text-gray-400 hover:text-black",
		svg: ""
	},
	variants: {
		wrapped: { false: { wrapper: "p-2.5 text-sm focus:outline-hidden focus:ring-primary-500 border-gray-300 focus:border-primary-500 dark:focus:ring-primary-500 dark:focus:border-primary-500 disabled:cursor-not-allowed disabled:opacity-50" } },
		hasHeader: {
			true: { header: "border-b" },
			false: { inner: "rounded-t-lg" }
		},
		hasFooter: {
			true: { footer: "border-t" },
			false: { inner: "rounded-b-lg" }
		}
	}
});
var root_1$57 = /* @__PURE__ */ from_html("<textarea></textarea>"), root_3$24 = /* @__PURE__ */ from_html("<div><!></div>"), root_4$16 = /* @__PURE__ */ from_html("<div><!></div>"), root_5$11 = /* @__PURE__ */ from_html("<div><!></div>"), root_2$28 = /* @__PURE__ */ from_html("<div><!> <div><!> <textarea></textarea></div> <!></div>"), root$43 = /* @__PURE__ */ from_html("<div><!> <!></div>");
function Textarea(C, E) {
	push(E, !0);
	let D = prop(E, "header", 7), O = prop(E, "footer", 7), F = prop(E, "addon", 7), I = prop(E, "value", 15), L = prop(E, "elementRef", 15), z = prop(E, "divClass", 7), B = prop(E, "innerClass", 7), V = prop(E, "headerClass", 7), U = prop(E, "footerClass", 7), W = prop(E, "addonClass", 7), G = prop(E, "disabled", 7), K = prop(E, "class", 7), J = prop(E, "classes", 7), Y = prop(E, "clearable", 7), X = prop(E, "clearableSvgClass", 7), Z = prop(E, "clearableColor", 7, "none"), Q = prop(E, "clearableClass", 7), NL = prop(E, "clearableOnClick", 7), PL = prop(E, "textareaClass", 7), FL = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"header",
		"footer",
		"addon",
		"value",
		"elementRef",
		"divClass",
		"innerClass",
		"headerClass",
		"footerClass",
		"addonClass",
		"disabled",
		"class",
		"classes",
		"clearable",
		"clearableSvgClass",
		"clearableColor",
		"clearableClass",
		"clearableOnClick",
		"textareaClass"
	]);
	z(), B(), V(), U(), W(), PL(), Q(), X();
	let IL = /* @__PURE__ */ user_derived(() => {
		var C;
		return (C = J()) == null ? {
			div: z(),
			inner: B(),
			header: V(),
			footer: U(),
			addon: W(),
			textarea: PL(),
			close: Q(),
			svg: X()
		} : C;
	}), LL = getTheme("textarea"), RL = /* @__PURE__ */ user_derived(() => !!D()), zL = /* @__PURE__ */ user_derived(() => !!O()), BL = /* @__PURE__ */ user_derived(() => !!F()), VL = /* @__PURE__ */ user_derived(() => get(RL) || get(zL) || get(BL)), HL = /* @__PURE__ */ user_derived(() => textarea({
		wrapped: get(VL),
		hasHeader: get(RL),
		hasFooter: get(zL)
	})), UL = /* @__PURE__ */ user_derived(() => get(HL).div), WL = /* @__PURE__ */ user_derived(() => get(HL).base), GL = /* @__PURE__ */ user_derived(() => get(HL).wrapper), KL = /* @__PURE__ */ user_derived(() => get(HL).inner), qL = /* @__PURE__ */ user_derived(() => get(HL).header), JL = /* @__PURE__ */ user_derived(() => get(HL).footer), YL = /* @__PURE__ */ user_derived(() => get(HL).addon), XL = /* @__PURE__ */ user_derived(() => get(HL).close);
	createDismissableContext(() => {
		L() && (L(L().value = "", !0), I(void 0)), NL() && NL()();
	});
	var ZL = {
		get header() {
			return D();
		},
		set header(C) {
			D(C), flushSync();
		},
		get footer() {
			return O();
		},
		set footer(C) {
			O(C), flushSync();
		},
		get addon() {
			return F();
		},
		set addon(C) {
			F(C), flushSync();
		},
		get value() {
			return I();
		},
		set value(C) {
			I(C), flushSync();
		},
		get elementRef() {
			return L();
		},
		set elementRef(C) {
			L(C), flushSync();
		},
		get divClass() {
			return z();
		},
		set divClass(C) {
			z(C), flushSync();
		},
		get innerClass() {
			return B();
		},
		set innerClass(C) {
			B(C), flushSync();
		},
		get headerClass() {
			return V();
		},
		set headerClass(C) {
			V(C), flushSync();
		},
		get footerClass() {
			return U();
		},
		set footerClass(C) {
			U(C), flushSync();
		},
		get addonClass() {
			return W();
		},
		set addonClass(C) {
			W(C), flushSync();
		},
		get disabled() {
			return G();
		},
		set disabled(C) {
			G(C), flushSync();
		},
		get class() {
			return K();
		},
		set class(C) {
			K(C), flushSync();
		},
		get classes() {
			return J();
		},
		set classes(C) {
			J(C), flushSync();
		},
		get clearable() {
			return Y();
		},
		set clearable(C) {
			Y(C), flushSync();
		},
		get clearableSvgClass() {
			return X();
		},
		set clearableSvgClass(C) {
			X(C), flushSync();
		},
		get clearableColor() {
			return Z();
		},
		set clearableColor(C = "none") {
			Z(C), flushSync();
		},
		get clearableClass() {
			return Q();
		},
		set clearableClass(C) {
			Q(C), flushSync();
		},
		get clearableOnClick() {
			return NL();
		},
		set clearableOnClick(C) {
			NL(C), flushSync();
		},
		get textareaClass() {
			return PL();
		},
		set textareaClass(C) {
			PL(C), flushSync();
		}
	}, QL = root$43(), $L = child(QL), eR = (C) => {
		var E = root_1$57();
		remove_textarea_child(E), attribute_effect(E, (C) => _objectSpread2(_objectSpread2({ disabled: G() }, FL), {}, { class: C }), [() => {
			var C;
			return get(GL)({ class: clsx_default(K(), (C = J()) == null ? void 0 : C.wrapper) });
		}]), bind_this(E, (C) => L(C), () => L()), bind_value(E, I), append(C, E);
	}, tR = (C) => {
		var E = root_2$28(), z = child(E), B = (C) => {
			var T = root_3$24();
			snippet(child(T), D), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(qL)({ class: clsx_default(LL == null ? void 0 : LL.header, get(IL).header) }))]), append(C, T);
		};
		if_block(z, (C) => {
			D() && C(B);
		});
		var V = sibling(z, 2), U = child(V), W = (C) => {
			var T = root_4$16();
			snippet(child(T), F), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(YL)({ class: clsx_default(LL == null ? void 0 : LL.addon, get(IL).addon) }))]), append(C, T);
		};
		if_block(U, (C) => {
			F() && C(W);
		});
		var Y = sibling(U, 2);
		remove_textarea_child(Y), attribute_effect(Y, (C) => _objectSpread2(_objectSpread2({ disabled: G() }, FL), {}, { class: C }), [() => get(WL)({ class: clsx_default(LL == null ? void 0 : LL.base, K()) })]), bind_this(Y, (C) => L(C), () => L()), reset(V);
		var X = sibling(V, 2), Z = (C) => {
			var T = root_5$11();
			snippet(child(T), O), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(get(JL)({ class: clsx_default(LL == null ? void 0 : LL.footer, get(IL).footer) }))]), append(C, T);
		};
		if_block(X, (C) => {
			O() && C(Z);
		}), reset(E), template_effect((C, T) => {
			set_class(E, 1, C), set_class(V, 1, T);
		}, [() => {
			var C;
			return clsx$1(get(GL)({ class: clsx_default(LL == null ? void 0 : LL.wrapper, (C = J()) == null ? void 0 : C.wrapper) }));
		}, () => clsx$1(get(KL)({ class: clsx_default(LL == null ? void 0 : LL.inner, get(IL).inner) }))]), bind_value(Y, I), append(C, E);
	};
	if_block($L, (C) => {
		get(VL) ? C(tR, !1) : C(eR);
	});
	var nR = sibling($L, 2), rR = (C) => {
		{
			let T = /* @__PURE__ */ user_derived(() => get(XL)({ class: clsx_default(LL == null ? void 0 : LL.close, get(IL).close) })), E = /* @__PURE__ */ user_derived(() => clsx_default(get(IL).svg));
			CloseButton(C, {
				get class() {
					return get(T);
				},
				get color() {
					return Z();
				},
				"aria-label": "Clear search value",
				get svgClass() {
					return get(E);
				}
			});
		}
	};
	return if_block(nR, (C) => {
		I() !== void 0 && I() !== "" && Y() && C(rR);
	}), reset(QL), template_effect((C) => set_class(QL, 1, C), [() => clsx$1(get(UL)({ class: clsx_default(LL == null ? void 0 : LL.div, get(IL).div) }))]), append(C, QL), pop(ZL);
}
create_custom_element(Textarea, {
	header: {},
	footer: {},
	addon: {},
	value: {},
	elementRef: {},
	divClass: {},
	innerClass: {},
	headerClass: {},
	footerClass: {},
	addonClass: {},
	disabled: {},
	class: {},
	classes: {},
	clearable: {},
	clearableSvgClass: {},
	clearableColor: {},
	clearableClass: {},
	clearableOnClick: {},
	textareaClass: {}
}, [], [], !0);
const timepicker = ce({
	slots: {
		buttonGroup: "inline-flex rounded-lg shadow-sm",
		input: "block disabled:cursor-not-allowed disabled:opacity-50 rtl:text-right focus:ring-0 focus:outline-none",
		inputWithIcon: "relative px-2 pr-8",
		iconWrapper: "pointer-events-none absolute inset-y-0 end-0 top-0 flex items-center pe-3.5",
		icon: "h-4 w-4 text-gray-500 dark:text-gray-400",
		select: "text-gray-900 disabled:text-gray-400 bg-gray-50 border border-gray-300 focus:ring-0 focus:outline-none block w-full border-l-1 focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:disabled:text-gray-500 dark:focus:ring-primary-500 dark:focus:border-primary-500",
		button: "!rounded-r-lg",
		buttonIcon: "ml-2 h-4 w-4",
		rangeSeparator: "flex items-center justify-center px-2 text-gray-500 dark:text-gray-400",
		rangeInputWrapper: "relative",
		rangeInput: "relative pr-8",
		rangeButton: "pointer-events-none absolute inset-y-0 top-0 right-0 flex items-center border-0 bg-transparent pe-3.5",
		dropdownContent: "p-4 last:rounded-r-lg",
		dropdownInner: "flex flex-col space-y-4",
		dropdownTimeRow: "flex space-x-4",
		dropdownTimeCol: "flex flex-col",
		dropdownTimeInput: "w-24 rounded-l-lg !border-r px-2",
		dropdownButton: "w-full !rounded-l-lg",
		toggleWrapper: "flex w-full flex-col space-y-2",
		toggleRow: "flex items-center justify-between",
		toggleTimeRow: "flex space-x-4 p-2.5",
		toggleTimeCol: "flex flex-col",
		toggleTimeInput: "w-24 rounded-lg !border-r px-2",
		inlineGrid: "grid w-full gap-2",
		inlineButton: "rounded-lg"
	},
	variants: {
		type: {
			default: { input: "rounded-e-lg" },
			select: {
				input: "w-1/3 rounded-l-lg rounded-e-none",
				select: "rounded-r-lg rounded-l-none"
			},
			dropdown: { input: "rounded-l-lg rounded-e-none" },
			range: {},
			"timerange-dropdown": {},
			"timerange-toggle": {},
			"inline-buttons": {}
		},
		columns: {
			1: { inlineGrid: "grid-cols-1" },
			2: { inlineGrid: "grid-cols-2" },
			3: { inlineGrid: "grid-cols-3" },
			4: { inlineGrid: "grid-cols-4" }
		},
		disabled: { true: { input: "disabled:cursor-not-allowed disabled:opacity-50" } }
	},
	defaultVariants: {
		type: "default",
		columns: 2,
		disabled: !1
	}
});
Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
const millisecondsInWeek = 6048e5, secondsInDay = 3600 * 24;
secondsInDay * 7, secondsInDay * 365.2425;
const constructFromSymbol = Symbol.for("constructDateFrom");
function constructFrom(C, T) {
	return typeof C == "function" ? C(T) : C && typeof C == "object" && constructFromSymbol in C ? C[constructFromSymbol](T) : C instanceof Date ? new C.constructor(T) : new Date(T);
}
function toDate(C, T) {
	return constructFrom(T || C, C);
}
function addDays(C, T, E) {
	let D = toDate(C, E == null ? void 0 : E.in);
	return isNaN(T) ? constructFrom((E == null ? void 0 : E.in) || C, NaN) : (T && D.setDate(D.getDate() + T), D);
}
var defaultOptions = {};
function getDefaultOptions$1() {
	return defaultOptions;
}
function startOfWeek(C, T) {
	var E, D, O, F, I, L;
	let z = getDefaultOptions$1(), B = (E = (D = (O = (F = T == null ? void 0 : T.weekStartsOn) == null ? T == null || (I = T.locale) == null || (I = I.options) == null ? void 0 : I.weekStartsOn : F) == null ? z.weekStartsOn : O) == null ? (L = z.locale) == null || (L = L.options) == null ? void 0 : L.weekStartsOn : D) == null ? 0 : E, V = toDate(C, T == null ? void 0 : T.in), U = V.getDay(), W = (U < B ? 7 : 0) + U - B;
	return V.setDate(V.getDate() - W), V.setHours(0, 0, 0, 0), V;
}
function startOfISOWeek(C, E) {
	return startOfWeek(C, _objectSpread2(_objectSpread2({}, E), {}, { weekStartsOn: 1 }));
}
function getISOWeekYear(C, T) {
	let E = toDate(C, T == null ? void 0 : T.in), D = E.getFullYear(), O = constructFrom(E, 0);
	O.setFullYear(D + 1, 0, 4), O.setHours(0, 0, 0, 0);
	let F = startOfISOWeek(O), I = constructFrom(E, 0);
	I.setFullYear(D, 0, 4), I.setHours(0, 0, 0, 0);
	let L = startOfISOWeek(I);
	return E.getTime() >= F.getTime() ? D + 1 : E.getTime() >= L.getTime() ? D : D - 1;
}
function getTimezoneOffsetInMilliseconds(C) {
	let T = toDate(C), E = new Date(Date.UTC(T.getFullYear(), T.getMonth(), T.getDate(), T.getHours(), T.getMinutes(), T.getSeconds(), T.getMilliseconds()));
	return E.setUTCFullYear(T.getFullYear()), C - +E;
}
function startOfISOWeekYear(C, T) {
	let E = getISOWeekYear(C, T), D = constructFrom((T == null ? void 0 : T.in) || C, 0);
	return D.setFullYear(E, 0, 4), D.setHours(0, 0, 0, 0), startOfISOWeek(D);
}
function isDate(C) {
	return C instanceof Date || typeof C == "object" && Object.prototype.toString.call(C) === "[object Date]";
}
function isValid(C) {
	return !(!isDate(C) && typeof C != "number" || isNaN(+toDate(C)));
}
var formatDistanceLocale = {
	lessThanXSeconds: {
		one: "less than a second",
		other: "less than {{count}} seconds"
	},
	xSeconds: {
		one: "1 second",
		other: "{{count}} seconds"
	},
	halfAMinute: "half a minute",
	lessThanXMinutes: {
		one: "less than a minute",
		other: "less than {{count}} minutes"
	},
	xMinutes: {
		one: "1 minute",
		other: "{{count}} minutes"
	},
	aboutXHours: {
		one: "about 1 hour",
		other: "about {{count}} hours"
	},
	xHours: {
		one: "1 hour",
		other: "{{count}} hours"
	},
	xDays: {
		one: "1 day",
		other: "{{count}} days"
	},
	aboutXWeeks: {
		one: "about 1 week",
		other: "about {{count}} weeks"
	},
	xWeeks: {
		one: "1 week",
		other: "{{count}} weeks"
	},
	aboutXMonths: {
		one: "about 1 month",
		other: "about {{count}} months"
	},
	xMonths: {
		one: "1 month",
		other: "{{count}} months"
	},
	aboutXYears: {
		one: "about 1 year",
		other: "about {{count}} years"
	},
	xYears: {
		one: "1 year",
		other: "{{count}} years"
	},
	overXYears: {
		one: "over 1 year",
		other: "over {{count}} years"
	},
	almostXYears: {
		one: "almost 1 year",
		other: "almost {{count}} years"
	}
};
const formatDistance = (C, T, E) => {
	let D, O = formatDistanceLocale[C];
	return D = typeof O == "string" ? O : T === 1 ? O.one : O.other.replace("{{count}}", T.toString()), E != null && E.addSuffix ? E.comparison && E.comparison > 0 ? "in " + D : D + " ago" : D;
};
function buildFormatLongFn(C) {
	return (T = {}) => {
		let E = T.width ? String(T.width) : C.defaultWidth;
		return C.formats[E] || C.formats[C.defaultWidth];
	};
}
const formatLong = {
	date: buildFormatLongFn({
		formats: {
			full: "EEEE, MMMM do, y",
			long: "MMMM do, y",
			medium: "MMM d, y",
			short: "MM/dd/yyyy"
		},
		defaultWidth: "full"
	}),
	time: buildFormatLongFn({
		formats: {
			full: "h:mm:ss a zzzz",
			long: "h:mm:ss a z",
			medium: "h:mm:ss a",
			short: "h:mm a"
		},
		defaultWidth: "full"
	}),
	dateTime: buildFormatLongFn({
		formats: {
			full: "{{date}} 'at' {{time}}",
			long: "{{date}} 'at' {{time}}",
			medium: "{{date}}, {{time}}",
			short: "{{date}}, {{time}}"
		},
		defaultWidth: "full"
	})
};
var formatRelativeLocale = {
	lastWeek: "'last' eeee 'at' p",
	yesterday: "'yesterday at' p",
	today: "'today at' p",
	tomorrow: "'tomorrow at' p",
	nextWeek: "eeee 'at' p",
	other: "P"
};
const formatRelative = (C, T, E, D) => formatRelativeLocale[C];
function buildLocalizeFn(C) {
	return (T, E) => {
		let D = E != null && E.context ? String(E.context) : "standalone", O;
		if (D === "formatting" && C.formattingValues) {
			let T = C.defaultFormattingWidth || C.defaultWidth, D = E != null && E.width ? String(E.width) : T;
			O = C.formattingValues[D] || C.formattingValues[T];
		} else {
			let T = C.defaultWidth, D = E != null && E.width ? String(E.width) : C.defaultWidth;
			O = C.values[D] || C.values[T];
		}
		let F = C.argumentCallback ? C.argumentCallback(T) : T;
		return O[F];
	};
}
const localize = {
	ordinalNumber: (C, T) => {
		let E = Number(C), D = E % 100;
		if (D > 20 || D < 10) switch (D % 10) {
			case 1: return E + "st";
			case 2: return E + "nd";
			case 3: return E + "rd";
		}
		return E + "th";
	},
	era: buildLocalizeFn({
		values: {
			narrow: ["B", "A"],
			abbreviated: ["BC", "AD"],
			wide: ["Before Christ", "Anno Domini"]
		},
		defaultWidth: "wide"
	}),
	quarter: buildLocalizeFn({
		values: {
			narrow: [
				"1",
				"2",
				"3",
				"4"
			],
			abbreviated: [
				"Q1",
				"Q2",
				"Q3",
				"Q4"
			],
			wide: [
				"1st quarter",
				"2nd quarter",
				"3rd quarter",
				"4th quarter"
			]
		},
		defaultWidth: "wide",
		argumentCallback: (C) => C - 1
	}),
	month: buildLocalizeFn({
		values: {
			narrow: [
				"J",
				"F",
				"M",
				"A",
				"M",
				"J",
				"J",
				"A",
				"S",
				"O",
				"N",
				"D"
			],
			abbreviated: [
				"Jan",
				"Feb",
				"Mar",
				"Apr",
				"May",
				"Jun",
				"Jul",
				"Aug",
				"Sep",
				"Oct",
				"Nov",
				"Dec"
			],
			wide: [
				"January",
				"February",
				"March",
				"April",
				"May",
				"June",
				"July",
				"August",
				"September",
				"October",
				"November",
				"December"
			]
		},
		defaultWidth: "wide"
	}),
	day: buildLocalizeFn({
		values: {
			narrow: [
				"S",
				"M",
				"T",
				"W",
				"T",
				"F",
				"S"
			],
			short: [
				"Su",
				"Mo",
				"Tu",
				"We",
				"Th",
				"Fr",
				"Sa"
			],
			abbreviated: [
				"Sun",
				"Mon",
				"Tue",
				"Wed",
				"Thu",
				"Fri",
				"Sat"
			],
			wide: [
				"Sunday",
				"Monday",
				"Tuesday",
				"Wednesday",
				"Thursday",
				"Friday",
				"Saturday"
			]
		},
		defaultWidth: "wide"
	}),
	dayPeriod: buildLocalizeFn({
		values: {
			narrow: {
				am: "a",
				pm: "p",
				midnight: "mi",
				noon: "n",
				morning: "morning",
				afternoon: "afternoon",
				evening: "evening",
				night: "night"
			},
			abbreviated: {
				am: "AM",
				pm: "PM",
				midnight: "midnight",
				noon: "noon",
				morning: "morning",
				afternoon: "afternoon",
				evening: "evening",
				night: "night"
			},
			wide: {
				am: "a.m.",
				pm: "p.m.",
				midnight: "midnight",
				noon: "noon",
				morning: "morning",
				afternoon: "afternoon",
				evening: "evening",
				night: "night"
			}
		},
		defaultWidth: "wide",
		formattingValues: {
			narrow: {
				am: "a",
				pm: "p",
				midnight: "mi",
				noon: "n",
				morning: "in the morning",
				afternoon: "in the afternoon",
				evening: "in the evening",
				night: "at night"
			},
			abbreviated: {
				am: "AM",
				pm: "PM",
				midnight: "midnight",
				noon: "noon",
				morning: "in the morning",
				afternoon: "in the afternoon",
				evening: "in the evening",
				night: "at night"
			},
			wide: {
				am: "a.m.",
				pm: "p.m.",
				midnight: "midnight",
				noon: "noon",
				morning: "in the morning",
				afternoon: "in the afternoon",
				evening: "in the evening",
				night: "at night"
			}
		},
		defaultFormattingWidth: "wide"
	})
};
function buildMatchFn(C) {
	return (T, E = {}) => {
		let D = E.width, O = D && C.matchPatterns[D] || C.matchPatterns[C.defaultMatchWidth], F = T.match(O);
		if (!F) return null;
		let I = F[0], L = D && C.parsePatterns[D] || C.parsePatterns[C.defaultParseWidth], z = Array.isArray(L) ? findIndex(L, (C) => C.test(I)) : findKey(L, (C) => C.test(I)), B;
		B = C.valueCallback ? C.valueCallback(z) : z, B = E.valueCallback ? E.valueCallback(B) : B;
		let V = T.slice(I.length);
		return {
			value: B,
			rest: V
		};
	};
}
function findKey(C, T) {
	for (let E in C) if (Object.prototype.hasOwnProperty.call(C, E) && T(C[E])) return E;
}
function findIndex(C, T) {
	for (let E = 0; E < C.length; E++) if (T(C[E])) return E;
}
function buildMatchPatternFn(C) {
	return (T, E = {}) => {
		let D = T.match(C.matchPattern);
		if (!D) return null;
		let O = D[0], F = T.match(C.parsePattern);
		if (!F) return null;
		let I = C.valueCallback ? C.valueCallback(F[0]) : F[0];
		I = E.valueCallback ? E.valueCallback(I) : I;
		let L = T.slice(O.length);
		return {
			value: I,
			rest: L
		};
	};
}
const enUS = {
	code: "en-US",
	formatDistance,
	formatLong,
	formatRelative,
	localize,
	match: {
		ordinalNumber: buildMatchPatternFn({
			matchPattern: /^(\d+)(th|st|nd|rd)?/i,
			parsePattern: /\d+/i,
			valueCallback: (C) => parseInt(C, 10)
		}),
		era: buildMatchFn({
			matchPatterns: {
				narrow: /^(b|a)/i,
				abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
				wide: /^(before christ|before common era|anno domini|common era)/i
			},
			defaultMatchWidth: "wide",
			parsePatterns: { any: [/^b/i, /^(a|c)/i] },
			defaultParseWidth: "any"
		}),
		quarter: buildMatchFn({
			matchPatterns: {
				narrow: /^[1234]/i,
				abbreviated: /^q[1234]/i,
				wide: /^[1234](th|st|nd|rd)? quarter/i
			},
			defaultMatchWidth: "wide",
			parsePatterns: { any: [
				/1/i,
				/2/i,
				/3/i,
				/4/i
			] },
			defaultParseWidth: "any",
			valueCallback: (C) => C + 1
		}),
		month: buildMatchFn({
			matchPatterns: {
				narrow: /^[jfmasond]/i,
				abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
				wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
			},
			defaultMatchWidth: "wide",
			parsePatterns: {
				narrow: [
					/^j/i,
					/^f/i,
					/^m/i,
					/^a/i,
					/^m/i,
					/^j/i,
					/^j/i,
					/^a/i,
					/^s/i,
					/^o/i,
					/^n/i,
					/^d/i
				],
				any: [
					/^ja/i,
					/^f/i,
					/^mar/i,
					/^ap/i,
					/^may/i,
					/^jun/i,
					/^jul/i,
					/^au/i,
					/^s/i,
					/^o/i,
					/^n/i,
					/^d/i
				]
			},
			defaultParseWidth: "any"
		}),
		day: buildMatchFn({
			matchPatterns: {
				narrow: /^[smtwf]/i,
				short: /^(su|mo|tu|we|th|fr|sa)/i,
				abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
				wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
			},
			defaultMatchWidth: "wide",
			parsePatterns: {
				narrow: [
					/^s/i,
					/^m/i,
					/^t/i,
					/^w/i,
					/^t/i,
					/^f/i,
					/^s/i
				],
				any: [
					/^su/i,
					/^m/i,
					/^tu/i,
					/^w/i,
					/^th/i,
					/^f/i,
					/^sa/i
				]
			},
			defaultParseWidth: "any"
		}),
		dayPeriod: buildMatchFn({
			matchPatterns: {
				narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
				any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
			},
			defaultMatchWidth: "any",
			parsePatterns: { any: {
				am: /^a/i,
				pm: /^p/i,
				midnight: /^mi/i,
				noon: /^no/i,
				morning: /morning/i,
				afternoon: /afternoon/i,
				evening: /evening/i,
				night: /night/i
			} },
			defaultParseWidth: "any"
		})
	},
	options: {
		weekStartsOn: 0,
		firstWeekContainsDate: 1
	}
};
function getISOWeek(C, T) {
	let E = toDate(C, T == null ? void 0 : T.in), D = startOfISOWeek(E) - +startOfISOWeekYear(E);
	return Math.round(D / millisecondsInWeek) + 1;
}
function getWeekYear(C, T) {
	var E, D, O, F, I, L;
	let z = toDate(C, T == null ? void 0 : T.in), B = z.getFullYear(), V = getDefaultOptions$1(), U = (E = (D = (O = (F = T == null ? void 0 : T.firstWeekContainsDate) == null ? T == null || (I = T.locale) == null || (I = I.options) == null ? void 0 : I.firstWeekContainsDate : F) == null ? V.firstWeekContainsDate : O) == null ? (L = V.locale) == null || (L = L.options) == null ? void 0 : L.firstWeekContainsDate : D) == null ? 1 : E, W = constructFrom((T == null ? void 0 : T.in) || C, 0);
	W.setFullYear(B + 1, 0, U), W.setHours(0, 0, 0, 0);
	let G = startOfWeek(W, T), K = constructFrom((T == null ? void 0 : T.in) || C, 0);
	K.setFullYear(B, 0, U), K.setHours(0, 0, 0, 0);
	let J = startOfWeek(K, T);
	return +z >= +G ? B + 1 : +z >= +J ? B : B - 1;
}
function startOfWeekYear(C, T) {
	var E, D, O, F, I, L;
	let z = getDefaultOptions$1(), B = (E = (D = (O = (F = T == null ? void 0 : T.firstWeekContainsDate) == null ? T == null || (I = T.locale) == null || (I = I.options) == null ? void 0 : I.firstWeekContainsDate : F) == null ? z.firstWeekContainsDate : O) == null ? (L = z.locale) == null || (L = L.options) == null ? void 0 : L.firstWeekContainsDate : D) == null ? 1 : E, V = getWeekYear(C, T), U = constructFrom((T == null ? void 0 : T.in) || C, 0);
	return U.setFullYear(V, 0, B), U.setHours(0, 0, 0, 0), startOfWeek(U, T);
}
function getWeek(C, T) {
	let E = toDate(C, T == null ? void 0 : T.in), D = startOfWeek(E, T) - +startOfWeekYear(E, T);
	return Math.round(D / millisecondsInWeek) + 1;
}
var dateLongFormatter = (C, T) => {
	switch (C) {
		case "P": return T.date({ width: "short" });
		case "PP": return T.date({ width: "medium" });
		case "PPP": return T.date({ width: "long" });
		case "PPPP":
		default: return T.date({ width: "full" });
	}
}, timeLongFormatter = (C, T) => {
	switch (C) {
		case "p": return T.time({ width: "short" });
		case "pp": return T.time({ width: "medium" });
		case "ppp": return T.time({ width: "long" });
		case "pppp":
		default: return T.time({ width: "full" });
	}
};
const longFormatters = {
	p: timeLongFormatter,
	P: (C, T) => {
		let E = C.match(/(P+)(p+)?/) || [], D = E[1], O = E[2];
		if (!O) return dateLongFormatter(C, T);
		let F;
		switch (D) {
			case "P":
				F = T.dateTime({ width: "short" });
				break;
			case "PP":
				F = T.dateTime({ width: "medium" });
				break;
			case "PPP":
				F = T.dateTime({ width: "long" });
				break;
			case "PPPP":
			default:
				F = T.dateTime({ width: "full" });
				break;
		}
		return F.replace("{{date}}", dateLongFormatter(D, T)).replace("{{time}}", timeLongFormatter(O, T));
	}
};
var dayOfYearTokenRE = /^D+$/, weekYearTokenRE = /^Y+$/, throwTokens = [
	"D",
	"DD",
	"YY",
	"YYYY"
];
function isProtectedDayOfYearToken(C) {
	return dayOfYearTokenRE.test(C);
}
function isProtectedWeekYearToken(C) {
	return weekYearTokenRE.test(C);
}
function warnOrThrowProtectedError(C, T, E) {
	let D = message(C, T, E);
	if (console.warn(D), throwTokens.includes(C)) throw RangeError(D);
}
function message(C, T, E) {
	let D = C[0] === "Y" ? "years" : "days of the month";
	return `Use \`${C.toLowerCase()}\` instead of \`${C}\` (in \`${T}\`) for formatting ${D} to the input \`${E}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
function getDefaultOptions() {
	return Object.assign({}, getDefaultOptions$1());
}
function getISODay(C, T) {
	let E = toDate(C, T == null ? void 0 : T.in).getDay();
	return E === 0 ? 7 : E;
}
function isAfter(C, T) {
	return +toDate(C) > +toDate(T);
}
function isBefore(C, T) {
	return +toDate(C) < +toDate(T);
}
function transpose(C, T) {
	let E = isConstructor(T) ? new T(0) : constructFrom(T, 0);
	return E.setFullYear(C.getFullYear(), C.getMonth(), C.getDate()), E.setHours(C.getHours(), C.getMinutes(), C.getSeconds(), C.getMilliseconds()), E;
}
function isConstructor(C) {
	var T;
	return typeof C == "function" && ((T = C.prototype) == null ? void 0 : T.constructor) === C;
}
var TIMEZONE_UNIT_PRIORITY = 10, Setter = class {
	constructor() {
		_defineProperty(this, "subPriority", 0);
	}
	validate(C, T) {
		return !0;
	}
}, ValueSetter = class extends Setter {
	constructor(C, T, E, D, O) {
		super(), this.value = C, this.validateValue = T, this.setValue = E, this.priority = D, O && (this.subPriority = O);
	}
	validate(C, T) {
		return this.validateValue(C, this.value, T);
	}
	set(C, T, E) {
		return this.setValue(C, T, this.value, E);
	}
}, DateTimezoneSetter = class extends Setter {
	constructor(T, E) {
		super(), _defineProperty(this, "priority", TIMEZONE_UNIT_PRIORITY), _defineProperty(this, "subPriority", -1), this.context = T || ((C) => constructFrom(E, C));
	}
	set(C, T) {
		return T.timestampIsSet ? C : constructFrom(C, transpose(C, this.context));
	}
}, Parser = class {
	run(C, T, E, D) {
		let O = this.parse(C, T, E, D);
		return O ? {
			setter: new ValueSetter(O.value, this.validate, this.set, this.priority, this.subPriority),
			rest: O.rest
		} : null;
	}
	validate(C, T, E) {
		return !0;
	}
}, EraParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 140), _defineProperty(this, "incompatibleTokens", [
			"R",
			"u",
			"t",
			"T"
		]);
	}
	parse(C, T, E) {
		switch (T) {
			case "G":
			case "GG":
			case "GGG": return E.era(C, { width: "abbreviated" }) || E.era(C, { width: "narrow" });
			case "GGGGG": return E.era(C, { width: "narrow" });
			case "GGGG":
			default: return E.era(C, { width: "wide" }) || E.era(C, { width: "abbreviated" }) || E.era(C, { width: "narrow" });
		}
	}
	set(C, T, E) {
		return T.era = E, C.setFullYear(E, 0, 1), C.setHours(0, 0, 0, 0), C;
	}
};
const numericPatterns = {
	month: /^(1[0-2]|0?\d)/,
	date: /^(3[0-1]|[0-2]?\d)/,
	dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
	week: /^(5[0-3]|[0-4]?\d)/,
	hour23h: /^(2[0-3]|[0-1]?\d)/,
	hour24h: /^(2[0-4]|[0-1]?\d)/,
	hour11h: /^(1[0-1]|0?\d)/,
	hour12h: /^(1[0-2]|0?\d)/,
	minute: /^[0-5]?\d/,
	second: /^[0-5]?\d/,
	singleDigit: /^\d/,
	twoDigits: /^\d{1,2}/,
	threeDigits: /^\d{1,3}/,
	fourDigits: /^\d{1,4}/,
	anyDigitsSigned: /^-?\d+/,
	singleDigitSigned: /^-?\d/,
	twoDigitsSigned: /^-?\d{1,2}/,
	threeDigitsSigned: /^-?\d{1,3}/,
	fourDigitsSigned: /^-?\d{1,4}/
}, timezonePatterns = {
	basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
	basic: /^([+-])(\d{2})(\d{2})|Z/,
	basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
	extended: /^([+-])(\d{2}):(\d{2})|Z/,
	extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function mapValue(C, T) {
	return C && {
		value: T(C.value),
		rest: C.rest
	};
}
function parseNumericPattern(C, T) {
	let E = T.match(C);
	return E ? {
		value: parseInt(E[0], 10),
		rest: T.slice(E[0].length)
	} : null;
}
function parseTimezonePattern(C, T) {
	let E = T.match(C);
	if (!E) return null;
	if (E[0] === "Z") return {
		value: 0,
		rest: T.slice(1)
	};
	let D = E[1] === "+" ? 1 : -1, O = E[2] ? parseInt(E[2], 10) : 0, F = E[3] ? parseInt(E[3], 10) : 0, I = E[5] ? parseInt(E[5], 10) : 0;
	return {
		value: D * (O * 36e5 + F * 6e4 + I * 1e3),
		rest: T.slice(E[0].length)
	};
}
function parseAnyDigitsSigned(C) {
	return parseNumericPattern(numericPatterns.anyDigitsSigned, C);
}
function parseNDigits(C, T) {
	switch (C) {
		case 1: return parseNumericPattern(numericPatterns.singleDigit, T);
		case 2: return parseNumericPattern(numericPatterns.twoDigits, T);
		case 3: return parseNumericPattern(numericPatterns.threeDigits, T);
		case 4: return parseNumericPattern(numericPatterns.fourDigits, T);
		default: return parseNumericPattern(/* @__PURE__ */ RegExp("^\\d{1," + C + "}"), T);
	}
}
function parseNDigitsSigned(C, T) {
	switch (C) {
		case 1: return parseNumericPattern(numericPatterns.singleDigitSigned, T);
		case 2: return parseNumericPattern(numericPatterns.twoDigitsSigned, T);
		case 3: return parseNumericPattern(numericPatterns.threeDigitsSigned, T);
		case 4: return parseNumericPattern(numericPatterns.fourDigitsSigned, T);
		default: return parseNumericPattern(/* @__PURE__ */ RegExp("^-?\\d{1," + C + "}"), T);
	}
}
function dayPeriodEnumToHours(C) {
	switch (C) {
		case "morning": return 4;
		case "evening": return 17;
		case "pm":
		case "noon":
		case "afternoon": return 12;
		case "am":
		case "midnight":
		case "night":
		default: return 0;
	}
}
function normalizeTwoDigitYear(C, T) {
	let E = T > 0, D = E ? T : 1 - T, O;
	if (D <= 50) O = C || 100;
	else {
		let T = D + 50, E = Math.trunc(T / 100) * 100, F = C >= T % 100;
		O = C + E - (F ? 100 : 0);
	}
	return E ? O : 1 - O;
}
function isLeapYearIndex(C) {
	return C % 400 == 0 || C % 4 == 0 && C % 100 != 0;
}
var YearParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 130), _defineProperty(this, "incompatibleTokens", [
			"Y",
			"R",
			"u",
			"w",
			"I",
			"i",
			"e",
			"c",
			"t",
			"T"
		]);
	}
	parse(C, T, E) {
		let D = (C) => ({
			year: C,
			isTwoDigitYear: T === "yy"
		});
		switch (T) {
			case "y": return mapValue(parseNDigits(4, C), D);
			case "yo": return mapValue(E.ordinalNumber(C, { unit: "year" }), D);
			default: return mapValue(parseNDigits(T.length, C), D);
		}
	}
	validate(C, T) {
		return T.isTwoDigitYear || T.year > 0;
	}
	set(C, T, E) {
		let D = C.getFullYear();
		if (E.isTwoDigitYear) {
			let T = normalizeTwoDigitYear(E.year, D);
			return C.setFullYear(T, 0, 1), C.setHours(0, 0, 0, 0), C;
		}
		let O = !("era" in T) || T.era === 1 ? E.year : 1 - E.year;
		return C.setFullYear(O, 0, 1), C.setHours(0, 0, 0, 0), C;
	}
}, LocalWeekYearParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 130), _defineProperty(this, "incompatibleTokens", [
			"y",
			"R",
			"u",
			"Q",
			"q",
			"M",
			"L",
			"I",
			"d",
			"D",
			"i",
			"t",
			"T"
		]);
	}
	parse(C, T, E) {
		let D = (C) => ({
			year: C,
			isTwoDigitYear: T === "YY"
		});
		switch (T) {
			case "Y": return mapValue(parseNDigits(4, C), D);
			case "Yo": return mapValue(E.ordinalNumber(C, { unit: "year" }), D);
			default: return mapValue(parseNDigits(T.length, C), D);
		}
	}
	validate(C, T) {
		return T.isTwoDigitYear || T.year > 0;
	}
	set(C, T, E, D) {
		let O = getWeekYear(C, D);
		if (E.isTwoDigitYear) {
			let T = normalizeTwoDigitYear(E.year, O);
			return C.setFullYear(T, 0, D.firstWeekContainsDate), C.setHours(0, 0, 0, 0), startOfWeek(C, D);
		}
		let F = !("era" in T) || T.era === 1 ? E.year : 1 - E.year;
		return C.setFullYear(F, 0, D.firstWeekContainsDate), C.setHours(0, 0, 0, 0), startOfWeek(C, D);
	}
}, ISOWeekYearParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 130), _defineProperty(this, "incompatibleTokens", [
			"G",
			"y",
			"Y",
			"u",
			"Q",
			"q",
			"M",
			"L",
			"w",
			"d",
			"D",
			"e",
			"c",
			"t",
			"T"
		]);
	}
	parse(C, T) {
		return parseNDigitsSigned(T === "R" ? 4 : T.length, C);
	}
	set(C, T, E) {
		let D = constructFrom(C, 0);
		return D.setFullYear(E, 0, 4), D.setHours(0, 0, 0, 0), startOfISOWeek(D);
	}
}, ExtendedYearParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 130), _defineProperty(this, "incompatibleTokens", [
			"G",
			"y",
			"Y",
			"R",
			"w",
			"I",
			"i",
			"e",
			"c",
			"t",
			"T"
		]);
	}
	parse(C, T) {
		return parseNDigitsSigned(T === "u" ? 4 : T.length, C);
	}
	set(C, T, E) {
		return C.setFullYear(E, 0, 1), C.setHours(0, 0, 0, 0), C;
	}
}, QuarterParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 120), _defineProperty(this, "incompatibleTokens", [
			"Y",
			"R",
			"q",
			"M",
			"L",
			"w",
			"I",
			"d",
			"D",
			"i",
			"e",
			"c",
			"t",
			"T"
		]);
	}
	parse(C, T, E) {
		switch (T) {
			case "Q":
			case "QQ": return parseNDigits(T.length, C);
			case "Qo": return E.ordinalNumber(C, { unit: "quarter" });
			case "QQQ": return E.quarter(C, {
				width: "abbreviated",
				context: "formatting"
			}) || E.quarter(C, {
				width: "narrow",
				context: "formatting"
			});
			case "QQQQQ": return E.quarter(C, {
				width: "narrow",
				context: "formatting"
			});
			case "QQQQ":
			default: return E.quarter(C, {
				width: "wide",
				context: "formatting"
			}) || E.quarter(C, {
				width: "abbreviated",
				context: "formatting"
			}) || E.quarter(C, {
				width: "narrow",
				context: "formatting"
			});
		}
	}
	validate(C, T) {
		return T >= 1 && T <= 4;
	}
	set(C, T, E) {
		return C.setMonth((E - 1) * 3, 1), C.setHours(0, 0, 0, 0), C;
	}
}, StandAloneQuarterParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 120), _defineProperty(this, "incompatibleTokens", [
			"Y",
			"R",
			"Q",
			"M",
			"L",
			"w",
			"I",
			"d",
			"D",
			"i",
			"e",
			"c",
			"t",
			"T"
		]);
	}
	parse(C, T, E) {
		switch (T) {
			case "q":
			case "qq": return parseNDigits(T.length, C);
			case "qo": return E.ordinalNumber(C, { unit: "quarter" });
			case "qqq": return E.quarter(C, {
				width: "abbreviated",
				context: "standalone"
			}) || E.quarter(C, {
				width: "narrow",
				context: "standalone"
			});
			case "qqqqq": return E.quarter(C, {
				width: "narrow",
				context: "standalone"
			});
			case "qqqq":
			default: return E.quarter(C, {
				width: "wide",
				context: "standalone"
			}) || E.quarter(C, {
				width: "abbreviated",
				context: "standalone"
			}) || E.quarter(C, {
				width: "narrow",
				context: "standalone"
			});
		}
	}
	validate(C, T) {
		return T >= 1 && T <= 4;
	}
	set(C, T, E) {
		return C.setMonth((E - 1) * 3, 1), C.setHours(0, 0, 0, 0), C;
	}
}, MonthParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "incompatibleTokens", [
			"Y",
			"R",
			"q",
			"Q",
			"L",
			"w",
			"I",
			"D",
			"i",
			"e",
			"c",
			"t",
			"T"
		]), _defineProperty(this, "priority", 110);
	}
	parse(C, T, E) {
		let D = (C) => C - 1;
		switch (T) {
			case "M": return mapValue(parseNumericPattern(numericPatterns.month, C), D);
			case "MM": return mapValue(parseNDigits(2, C), D);
			case "Mo": return mapValue(E.ordinalNumber(C, { unit: "month" }), D);
			case "MMM": return E.month(C, {
				width: "abbreviated",
				context: "formatting"
			}) || E.month(C, {
				width: "narrow",
				context: "formatting"
			});
			case "MMMMM": return E.month(C, {
				width: "narrow",
				context: "formatting"
			});
			case "MMMM":
			default: return E.month(C, {
				width: "wide",
				context: "formatting"
			}) || E.month(C, {
				width: "abbreviated",
				context: "formatting"
			}) || E.month(C, {
				width: "narrow",
				context: "formatting"
			});
		}
	}
	validate(C, T) {
		return T >= 0 && T <= 11;
	}
	set(C, T, E) {
		return C.setMonth(E, 1), C.setHours(0, 0, 0, 0), C;
	}
}, StandAloneMonthParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 110), _defineProperty(this, "incompatibleTokens", [
			"Y",
			"R",
			"q",
			"Q",
			"M",
			"w",
			"I",
			"D",
			"i",
			"e",
			"c",
			"t",
			"T"
		]);
	}
	parse(C, T, E) {
		let D = (C) => C - 1;
		switch (T) {
			case "L": return mapValue(parseNumericPattern(numericPatterns.month, C), D);
			case "LL": return mapValue(parseNDigits(2, C), D);
			case "Lo": return mapValue(E.ordinalNumber(C, { unit: "month" }), D);
			case "LLL": return E.month(C, {
				width: "abbreviated",
				context: "standalone"
			}) || E.month(C, {
				width: "narrow",
				context: "standalone"
			});
			case "LLLLL": return E.month(C, {
				width: "narrow",
				context: "standalone"
			});
			case "LLLL":
			default: return E.month(C, {
				width: "wide",
				context: "standalone"
			}) || E.month(C, {
				width: "abbreviated",
				context: "standalone"
			}) || E.month(C, {
				width: "narrow",
				context: "standalone"
			});
		}
	}
	validate(C, T) {
		return T >= 0 && T <= 11;
	}
	set(C, T, E) {
		return C.setMonth(E, 1), C.setHours(0, 0, 0, 0), C;
	}
};
function setWeek(C, T, E) {
	let D = toDate(C, E == null ? void 0 : E.in), O = getWeek(D, E) - T;
	return D.setDate(D.getDate() - O * 7), toDate(D, E == null ? void 0 : E.in);
}
var LocalWeekParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 100), _defineProperty(this, "incompatibleTokens", [
			"y",
			"R",
			"u",
			"q",
			"Q",
			"M",
			"L",
			"I",
			"d",
			"D",
			"i",
			"t",
			"T"
		]);
	}
	parse(C, T, E) {
		switch (T) {
			case "w": return parseNumericPattern(numericPatterns.week, C);
			case "wo": return E.ordinalNumber(C, { unit: "week" });
			default: return parseNDigits(T.length, C);
		}
	}
	validate(C, T) {
		return T >= 1 && T <= 53;
	}
	set(C, T, E, D) {
		return startOfWeek(setWeek(C, E, D), D);
	}
};
function setISOWeek(C, T, E) {
	let D = toDate(C, E == null ? void 0 : E.in), O = getISOWeek(D, E) - T;
	return D.setDate(D.getDate() - O * 7), D;
}
var ISOWeekParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 100), _defineProperty(this, "incompatibleTokens", [
			"y",
			"Y",
			"u",
			"q",
			"Q",
			"M",
			"L",
			"w",
			"d",
			"D",
			"e",
			"c",
			"t",
			"T"
		]);
	}
	parse(C, T, E) {
		switch (T) {
			case "I": return parseNumericPattern(numericPatterns.week, C);
			case "Io": return E.ordinalNumber(C, { unit: "week" });
			default: return parseNDigits(T.length, C);
		}
	}
	validate(C, T) {
		return T >= 1 && T <= 53;
	}
	set(C, T, E) {
		return startOfISOWeek(setISOWeek(C, E));
	}
}, DAYS_IN_MONTH = [
	31,
	28,
	31,
	30,
	31,
	30,
	31,
	31,
	30,
	31,
	30,
	31
], DAYS_IN_MONTH_LEAP_YEAR = [
	31,
	29,
	31,
	30,
	31,
	30,
	31,
	31,
	30,
	31,
	30,
	31
], DateParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 90), _defineProperty(this, "subPriority", 1), _defineProperty(this, "incompatibleTokens", [
			"Y",
			"R",
			"q",
			"Q",
			"w",
			"I",
			"D",
			"i",
			"e",
			"c",
			"t",
			"T"
		]);
	}
	parse(C, T, E) {
		switch (T) {
			case "d": return parseNumericPattern(numericPatterns.date, C);
			case "do": return E.ordinalNumber(C, { unit: "date" });
			default: return parseNDigits(T.length, C);
		}
	}
	validate(C, T) {
		let E = isLeapYearIndex(C.getFullYear()), D = C.getMonth();
		return E ? T >= 1 && T <= DAYS_IN_MONTH_LEAP_YEAR[D] : T >= 1 && T <= DAYS_IN_MONTH[D];
	}
	set(C, T, E) {
		return C.setDate(E), C.setHours(0, 0, 0, 0), C;
	}
}, DayOfYearParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 90), _defineProperty(this, "subpriority", 1), _defineProperty(this, "incompatibleTokens", [
			"Y",
			"R",
			"q",
			"Q",
			"M",
			"L",
			"w",
			"I",
			"d",
			"E",
			"i",
			"e",
			"c",
			"t",
			"T"
		]);
	}
	parse(C, T, E) {
		switch (T) {
			case "D":
			case "DD": return parseNumericPattern(numericPatterns.dayOfYear, C);
			case "Do": return E.ordinalNumber(C, { unit: "date" });
			default: return parseNDigits(T.length, C);
		}
	}
	validate(C, T) {
		return isLeapYearIndex(C.getFullYear()) ? T >= 1 && T <= 366 : T >= 1 && T <= 365;
	}
	set(C, T, E) {
		return C.setMonth(0, E), C.setHours(0, 0, 0, 0), C;
	}
};
function setDay(C, T, E) {
	var D, O, F, I, L, z;
	let B = getDefaultOptions$1(), V = (D = (O = (F = (I = E == null ? void 0 : E.weekStartsOn) == null ? E == null || (L = E.locale) == null || (L = L.options) == null ? void 0 : L.weekStartsOn : I) == null ? B.weekStartsOn : F) == null ? (z = B.locale) == null || (z = z.options) == null ? void 0 : z.weekStartsOn : O) == null ? 0 : D, U = toDate(C, E == null ? void 0 : E.in), W = U.getDay(), G = (T % 7 + 7) % 7, K = 7 - V;
	return addDays(U, T < 0 || T > 6 ? T - (W + K) % 7 : (G + K) % 7 - (W + K) % 7, E);
}
var DayParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 90), _defineProperty(this, "incompatibleTokens", [
			"D",
			"i",
			"e",
			"c",
			"t",
			"T"
		]);
	}
	parse(C, T, E) {
		switch (T) {
			case "E":
			case "EE":
			case "EEE": return E.day(C, {
				width: "abbreviated",
				context: "formatting"
			}) || E.day(C, {
				width: "short",
				context: "formatting"
			}) || E.day(C, {
				width: "narrow",
				context: "formatting"
			});
			case "EEEEE": return E.day(C, {
				width: "narrow",
				context: "formatting"
			});
			case "EEEEEE": return E.day(C, {
				width: "short",
				context: "formatting"
			}) || E.day(C, {
				width: "narrow",
				context: "formatting"
			});
			case "EEEE":
			default: return E.day(C, {
				width: "wide",
				context: "formatting"
			}) || E.day(C, {
				width: "abbreviated",
				context: "formatting"
			}) || E.day(C, {
				width: "short",
				context: "formatting"
			}) || E.day(C, {
				width: "narrow",
				context: "formatting"
			});
		}
	}
	validate(C, T) {
		return T >= 0 && T <= 6;
	}
	set(C, T, E, D) {
		return C = setDay(C, E, D), C.setHours(0, 0, 0, 0), C;
	}
}, LocalDayParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 90), _defineProperty(this, "incompatibleTokens", [
			"y",
			"R",
			"u",
			"q",
			"Q",
			"M",
			"L",
			"I",
			"d",
			"D",
			"E",
			"i",
			"c",
			"t",
			"T"
		]);
	}
	parse(C, T, E, D) {
		let O = (C) => {
			let T = Math.floor((C - 1) / 7) * 7;
			return (C + D.weekStartsOn + 6) % 7 + T;
		};
		switch (T) {
			case "e":
			case "ee": return mapValue(parseNDigits(T.length, C), O);
			case "eo": return mapValue(E.ordinalNumber(C, { unit: "day" }), O);
			case "eee": return E.day(C, {
				width: "abbreviated",
				context: "formatting"
			}) || E.day(C, {
				width: "short",
				context: "formatting"
			}) || E.day(C, {
				width: "narrow",
				context: "formatting"
			});
			case "eeeee": return E.day(C, {
				width: "narrow",
				context: "formatting"
			});
			case "eeeeee": return E.day(C, {
				width: "short",
				context: "formatting"
			}) || E.day(C, {
				width: "narrow",
				context: "formatting"
			});
			case "eeee":
			default: return E.day(C, {
				width: "wide",
				context: "formatting"
			}) || E.day(C, {
				width: "abbreviated",
				context: "formatting"
			}) || E.day(C, {
				width: "short",
				context: "formatting"
			}) || E.day(C, {
				width: "narrow",
				context: "formatting"
			});
		}
	}
	validate(C, T) {
		return T >= 0 && T <= 6;
	}
	set(C, T, E, D) {
		return C = setDay(C, E, D), C.setHours(0, 0, 0, 0), C;
	}
}, StandAloneLocalDayParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 90), _defineProperty(this, "incompatibleTokens", [
			"y",
			"R",
			"u",
			"q",
			"Q",
			"M",
			"L",
			"I",
			"d",
			"D",
			"E",
			"i",
			"e",
			"t",
			"T"
		]);
	}
	parse(C, T, E, D) {
		let O = (C) => {
			let T = Math.floor((C - 1) / 7) * 7;
			return (C + D.weekStartsOn + 6) % 7 + T;
		};
		switch (T) {
			case "c":
			case "cc": return mapValue(parseNDigits(T.length, C), O);
			case "co": return mapValue(E.ordinalNumber(C, { unit: "day" }), O);
			case "ccc": return E.day(C, {
				width: "abbreviated",
				context: "standalone"
			}) || E.day(C, {
				width: "short",
				context: "standalone"
			}) || E.day(C, {
				width: "narrow",
				context: "standalone"
			});
			case "ccccc": return E.day(C, {
				width: "narrow",
				context: "standalone"
			});
			case "cccccc": return E.day(C, {
				width: "short",
				context: "standalone"
			}) || E.day(C, {
				width: "narrow",
				context: "standalone"
			});
			case "cccc":
			default: return E.day(C, {
				width: "wide",
				context: "standalone"
			}) || E.day(C, {
				width: "abbreviated",
				context: "standalone"
			}) || E.day(C, {
				width: "short",
				context: "standalone"
			}) || E.day(C, {
				width: "narrow",
				context: "standalone"
			});
		}
	}
	validate(C, T) {
		return T >= 0 && T <= 6;
	}
	set(C, T, E, D) {
		return C = setDay(C, E, D), C.setHours(0, 0, 0, 0), C;
	}
};
function setISODay(C, T, E) {
	let D = toDate(C, E == null ? void 0 : E.in);
	return addDays(D, T - getISODay(D, E), E);
}
var ISODayParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 90), _defineProperty(this, "incompatibleTokens", [
			"y",
			"Y",
			"u",
			"q",
			"Q",
			"M",
			"L",
			"w",
			"d",
			"D",
			"E",
			"e",
			"c",
			"t",
			"T"
		]);
	}
	parse(C, T, E) {
		let D = (C) => C === 0 ? 7 : C;
		switch (T) {
			case "i":
			case "ii": return parseNDigits(T.length, C);
			case "io": return E.ordinalNumber(C, { unit: "day" });
			case "iii": return mapValue(E.day(C, {
				width: "abbreviated",
				context: "formatting"
			}) || E.day(C, {
				width: "short",
				context: "formatting"
			}) || E.day(C, {
				width: "narrow",
				context: "formatting"
			}), D);
			case "iiiii": return mapValue(E.day(C, {
				width: "narrow",
				context: "formatting"
			}), D);
			case "iiiiii": return mapValue(E.day(C, {
				width: "short",
				context: "formatting"
			}) || E.day(C, {
				width: "narrow",
				context: "formatting"
			}), D);
			case "iiii":
			default: return mapValue(E.day(C, {
				width: "wide",
				context: "formatting"
			}) || E.day(C, {
				width: "abbreviated",
				context: "formatting"
			}) || E.day(C, {
				width: "short",
				context: "formatting"
			}) || E.day(C, {
				width: "narrow",
				context: "formatting"
			}), D);
		}
	}
	validate(C, T) {
		return T >= 1 && T <= 7;
	}
	set(C, T, E) {
		return C = setISODay(C, E), C.setHours(0, 0, 0, 0), C;
	}
}, AMPMParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 80), _defineProperty(this, "incompatibleTokens", [
			"b",
			"B",
			"H",
			"k",
			"t",
			"T"
		]);
	}
	parse(C, T, E) {
		switch (T) {
			case "a":
			case "aa":
			case "aaa": return E.dayPeriod(C, {
				width: "abbreviated",
				context: "formatting"
			}) || E.dayPeriod(C, {
				width: "narrow",
				context: "formatting"
			});
			case "aaaaa": return E.dayPeriod(C, {
				width: "narrow",
				context: "formatting"
			});
			case "aaaa":
			default: return E.dayPeriod(C, {
				width: "wide",
				context: "formatting"
			}) || E.dayPeriod(C, {
				width: "abbreviated",
				context: "formatting"
			}) || E.dayPeriod(C, {
				width: "narrow",
				context: "formatting"
			});
		}
	}
	set(C, T, E) {
		return C.setHours(dayPeriodEnumToHours(E), 0, 0, 0), C;
	}
}, AMPMMidnightParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 80), _defineProperty(this, "incompatibleTokens", [
			"a",
			"B",
			"H",
			"k",
			"t",
			"T"
		]);
	}
	parse(C, T, E) {
		switch (T) {
			case "b":
			case "bb":
			case "bbb": return E.dayPeriod(C, {
				width: "abbreviated",
				context: "formatting"
			}) || E.dayPeriod(C, {
				width: "narrow",
				context: "formatting"
			});
			case "bbbbb": return E.dayPeriod(C, {
				width: "narrow",
				context: "formatting"
			});
			case "bbbb":
			default: return E.dayPeriod(C, {
				width: "wide",
				context: "formatting"
			}) || E.dayPeriod(C, {
				width: "abbreviated",
				context: "formatting"
			}) || E.dayPeriod(C, {
				width: "narrow",
				context: "formatting"
			});
		}
	}
	set(C, T, E) {
		return C.setHours(dayPeriodEnumToHours(E), 0, 0, 0), C;
	}
}, DayPeriodParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 80), _defineProperty(this, "incompatibleTokens", [
			"a",
			"b",
			"t",
			"T"
		]);
	}
	parse(C, T, E) {
		switch (T) {
			case "B":
			case "BB":
			case "BBB": return E.dayPeriod(C, {
				width: "abbreviated",
				context: "formatting"
			}) || E.dayPeriod(C, {
				width: "narrow",
				context: "formatting"
			});
			case "BBBBB": return E.dayPeriod(C, {
				width: "narrow",
				context: "formatting"
			});
			case "BBBB":
			default: return E.dayPeriod(C, {
				width: "wide",
				context: "formatting"
			}) || E.dayPeriod(C, {
				width: "abbreviated",
				context: "formatting"
			}) || E.dayPeriod(C, {
				width: "narrow",
				context: "formatting"
			});
		}
	}
	set(C, T, E) {
		return C.setHours(dayPeriodEnumToHours(E), 0, 0, 0), C;
	}
}, Hour1to12Parser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 70), _defineProperty(this, "incompatibleTokens", [
			"H",
			"K",
			"k",
			"t",
			"T"
		]);
	}
	parse(C, T, E) {
		switch (T) {
			case "h": return parseNumericPattern(numericPatterns.hour12h, C);
			case "ho": return E.ordinalNumber(C, { unit: "hour" });
			default: return parseNDigits(T.length, C);
		}
	}
	validate(C, T) {
		return T >= 1 && T <= 12;
	}
	set(C, T, E) {
		let D = C.getHours() >= 12;
		return D && E < 12 ? C.setHours(E + 12, 0, 0, 0) : !D && E === 12 ? C.setHours(0, 0, 0, 0) : C.setHours(E, 0, 0, 0), C;
	}
}, Hour0to23Parser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 70), _defineProperty(this, "incompatibleTokens", [
			"a",
			"b",
			"h",
			"K",
			"k",
			"t",
			"T"
		]);
	}
	parse(C, T, E) {
		switch (T) {
			case "H": return parseNumericPattern(numericPatterns.hour23h, C);
			case "Ho": return E.ordinalNumber(C, { unit: "hour" });
			default: return parseNDigits(T.length, C);
		}
	}
	validate(C, T) {
		return T >= 0 && T <= 23;
	}
	set(C, T, E) {
		return C.setHours(E, 0, 0, 0), C;
	}
}, Hour0To11Parser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 70), _defineProperty(this, "incompatibleTokens", [
			"h",
			"H",
			"k",
			"t",
			"T"
		]);
	}
	parse(C, T, E) {
		switch (T) {
			case "K": return parseNumericPattern(numericPatterns.hour11h, C);
			case "Ko": return E.ordinalNumber(C, { unit: "hour" });
			default: return parseNDigits(T.length, C);
		}
	}
	validate(C, T) {
		return T >= 0 && T <= 11;
	}
	set(C, T, E) {
		return C.getHours() >= 12 && E < 12 ? C.setHours(E + 12, 0, 0, 0) : C.setHours(E, 0, 0, 0), C;
	}
}, Hour1To24Parser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 70), _defineProperty(this, "incompatibleTokens", [
			"a",
			"b",
			"h",
			"H",
			"K",
			"t",
			"T"
		]);
	}
	parse(C, T, E) {
		switch (T) {
			case "k": return parseNumericPattern(numericPatterns.hour24h, C);
			case "ko": return E.ordinalNumber(C, { unit: "hour" });
			default: return parseNDigits(T.length, C);
		}
	}
	validate(C, T) {
		return T >= 1 && T <= 24;
	}
	set(C, T, E) {
		let D = E <= 24 ? E % 24 : E;
		return C.setHours(D, 0, 0, 0), C;
	}
}, MinuteParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 60), _defineProperty(this, "incompatibleTokens", ["t", "T"]);
	}
	parse(C, T, E) {
		switch (T) {
			case "m": return parseNumericPattern(numericPatterns.minute, C);
			case "mo": return E.ordinalNumber(C, { unit: "minute" });
			default: return parseNDigits(T.length, C);
		}
	}
	validate(C, T) {
		return T >= 0 && T <= 59;
	}
	set(C, T, E) {
		return C.setMinutes(E, 0, 0), C;
	}
}, SecondParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 50), _defineProperty(this, "incompatibleTokens", ["t", "T"]);
	}
	parse(C, T, E) {
		switch (T) {
			case "s": return parseNumericPattern(numericPatterns.second, C);
			case "so": return E.ordinalNumber(C, { unit: "second" });
			default: return parseNDigits(T.length, C);
		}
	}
	validate(C, T) {
		return T >= 0 && T <= 59;
	}
	set(C, T, E) {
		return C.setSeconds(E, 0), C;
	}
}, FractionOfSecondParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 30), _defineProperty(this, "incompatibleTokens", ["t", "T"]);
	}
	parse(C, T) {
		return mapValue(parseNDigits(T.length, C), (C) => Math.trunc(C * Math.pow(10, -T.length + 3)));
	}
	set(C, T, E) {
		return C.setMilliseconds(E), C;
	}
}, ISOTimezoneWithZParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 10), _defineProperty(this, "incompatibleTokens", [
			"t",
			"T",
			"x"
		]);
	}
	parse(C, T) {
		switch (T) {
			case "X": return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, C);
			case "XX": return parseTimezonePattern(timezonePatterns.basic, C);
			case "XXXX": return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, C);
			case "XXXXX": return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, C);
			case "XXX":
			default: return parseTimezonePattern(timezonePatterns.extended, C);
		}
	}
	set(C, T, E) {
		return T.timestampIsSet ? C : constructFrom(C, C.getTime() - getTimezoneOffsetInMilliseconds(C) - E);
	}
}, ISOTimezoneParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 10), _defineProperty(this, "incompatibleTokens", [
			"t",
			"T",
			"X"
		]);
	}
	parse(C, T) {
		switch (T) {
			case "x": return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, C);
			case "xx": return parseTimezonePattern(timezonePatterns.basic, C);
			case "xxxx": return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, C);
			case "xxxxx": return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, C);
			case "xxx":
			default: return parseTimezonePattern(timezonePatterns.extended, C);
		}
	}
	set(C, T, E) {
		return T.timestampIsSet ? C : constructFrom(C, C.getTime() - getTimezoneOffsetInMilliseconds(C) - E);
	}
}, TimestampSecondsParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 40), _defineProperty(this, "incompatibleTokens", "*");
	}
	parse(C) {
		return parseAnyDigitsSigned(C);
	}
	set(C, T, E) {
		return [constructFrom(C, E * 1e3), { timestampIsSet: !0 }];
	}
}, TimestampMillisecondsParser = class extends Parser {
	constructor(...T) {
		super(...T), _defineProperty(this, "priority", 20), _defineProperty(this, "incompatibleTokens", "*");
	}
	parse(C) {
		return parseAnyDigitsSigned(C);
	}
	set(C, T, E) {
		return [constructFrom(C, E), { timestampIsSet: !0 }];
	}
};
const parsers = {
	G: new EraParser(),
	y: new YearParser(),
	Y: new LocalWeekYearParser(),
	R: new ISOWeekYearParser(),
	u: new ExtendedYearParser(),
	Q: new QuarterParser(),
	q: new StandAloneQuarterParser(),
	M: new MonthParser(),
	L: new StandAloneMonthParser(),
	w: new LocalWeekParser(),
	I: new ISOWeekParser(),
	d: new DateParser(),
	D: new DayOfYearParser(),
	E: new DayParser(),
	e: new LocalDayParser(),
	c: new StandAloneLocalDayParser(),
	i: new ISODayParser(),
	a: new AMPMParser(),
	b: new AMPMMidnightParser(),
	B: new DayPeriodParser(),
	h: new Hour1to12Parser(),
	H: new Hour0to23Parser(),
	K: new Hour0To11Parser(),
	k: new Hour1To24Parser(),
	m: new MinuteParser(),
	s: new SecondParser(),
	S: new FractionOfSecondParser(),
	X: new ISOTimezoneWithZParser(),
	x: new ISOTimezoneParser(),
	t: new TimestampSecondsParser(),
	T: new TimestampMillisecondsParser()
};
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, escapedStringRegExp = /^'([^]*?)'?$/, doubleQuoteRegExp = /''/g, notWhitespaceRegExp = /\S/, unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse(C, T, E, D) {
	var O, F, I, L, z, B, V, U, W, G, K, J, Y, X;
	let Z = () => constructFrom((D == null ? void 0 : D.in) || E, NaN), Q = getDefaultOptions(), NL = (O = (F = D == null ? void 0 : D.locale) == null ? Q.locale : F) == null ? enUS : O, PL = (I = (L = (z = (B = D == null ? void 0 : D.firstWeekContainsDate) == null ? D == null || (V = D.locale) == null || (V = V.options) == null ? void 0 : V.firstWeekContainsDate : B) == null ? Q.firstWeekContainsDate : z) == null ? (U = Q.locale) == null || (U = U.options) == null ? void 0 : U.firstWeekContainsDate : L) == null ? 1 : I, FL = (W = (G = (K = (J = D == null ? void 0 : D.weekStartsOn) == null ? D == null || (Y = D.locale) == null || (Y = Y.options) == null ? void 0 : Y.weekStartsOn : J) == null ? Q.weekStartsOn : K) == null ? (X = Q.locale) == null || (X = X.options) == null ? void 0 : X.weekStartsOn : G) == null ? 0 : W;
	if (!T) return C ? Z() : toDate(E, D == null ? void 0 : D.in);
	let IL = {
		firstWeekContainsDate: PL,
		weekStartsOn: FL,
		locale: NL
	}, LL = [new DateTimezoneSetter(D == null ? void 0 : D.in, E)], RL = T.match(longFormattingTokensRegExp).map((C) => {
		let T = C[0];
		if (T in longFormatters) {
			let E = longFormatters[T];
			return E(C, NL.formatLong);
		}
		return C;
	}).join("").match(formattingTokensRegExp), zL = [];
	for (let E of RL) {
		!(D != null && D.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(E) && warnOrThrowProtectedError(E, T, C), !(D != null && D.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(E) && warnOrThrowProtectedError(E, T, C);
		let O = E[0], F = parsers[O];
		if (F) {
			let { incompatibleTokens: T } = F;
			if (Array.isArray(T)) {
				let C = zL.find((C) => T.includes(C.token) || C.token === O);
				if (C) throw RangeError(`The format string mustn't contain \`${C.fullToken}\` and \`${E}\` at the same time`);
			} else if (F.incompatibleTokens === "*" && zL.length > 0) throw RangeError(`The format string mustn't contain \`${E}\` and any other token at the same time`);
			zL.push({
				token: O,
				fullToken: E
			});
			let D = F.run(C, E, NL.match, IL);
			if (!D) return Z();
			LL.push(D.setter), C = D.rest;
		} else {
			if (O.match(unescapedLatinCharacterRegExp)) throw RangeError("Format string contains an unescaped latin alphabet character `" + O + "`");
			if (E === "''" ? E = "'" : O === "'" && (E = cleanEscapedString(E)), C.indexOf(E) === 0) C = C.slice(E.length);
			else return Z();
		}
	}
	if (C.length > 0 && notWhitespaceRegExp.test(C)) return Z();
	let BL = LL.map((C) => C.priority).sort((C, T) => T - C).filter((C, T, E) => E.indexOf(C) === T).map((C) => LL.filter((T) => T.priority === C).sort((C, T) => T.subPriority - C.subPriority)).map((C) => C[0]), VL = toDate(E, D == null ? void 0 : D.in);
	if (isNaN(+VL)) return Z();
	let HL = {};
	for (let C of BL) {
		if (!C.validate(VL, IL)) return Z();
		let T = C.set(VL, HL, IL);
		Array.isArray(T) ? (VL = T[0], Object.assign(HL, T[1])) : VL = T;
	}
	return VL;
}
function cleanEscapedString(C) {
	return C.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
var root_5$10 = /* @__PURE__ */ from_svg("<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 20 20\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M10 6v4l3.276 3.276M19 10a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z\"></path></svg>"), root_3$23 = /* @__PURE__ */ from_html("<!> <div><!></div>", 1), root_7$4 = /* @__PURE__ */ from_html("<!> <!>", 1), root_10$3 = /* @__PURE__ */ from_svg(" <svg aria-hidden=\"true\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M19 9l-7 7-7-7\"></path></svg>", 1), root_9$1 = /* @__PURE__ */ from_html("<!> <!> <!>", 1), root_17 = /* @__PURE__ */ from_svg("<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 20 20\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M10 6v4l3.276 3.276M19 10a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z\"></path></svg>"), root_19 = /* @__PURE__ */ from_svg("<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 20 20\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M10 6v4l3.276 3.276M19 10a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z\"></path></svg>"), root_15$1 = /* @__PURE__ */ from_html("<div><!> <button type=\"button\" aria-label=\"Open time picker\"><!></button></div> <span>-</span> <div><!> <button type=\"button\" aria-label=\"Open end time picker\"><!></button></div>", 1), root_22$1 = /* @__PURE__ */ from_svg(" <svg aria-hidden=\"true\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M19 9l-7 7-7-7\"></path></svg>", 1), root_23$1 = /* @__PURE__ */ from_html("<div><div><div><!> <!></div> <div><!> <!></div></div> <!></div>"), root_21$1 = /* @__PURE__ */ from_html("<!> <!>", 1), root_29 = /* @__PURE__ */ from_html("<div><div><!> <!></div> <div><!> <!></div></div>"), root_28$1 = /* @__PURE__ */ from_html("<div><div><!></div> <!></div>"), root_32 = /* @__PURE__ */ from_html("<div></div>");
function Timepicker(C, T) {
	push(T, !0);
	let E = prop(T, "id", 7, "time"), D = prop(T, "endId", 7, "end-time"), O = prop(T, "value", 15, "00:00"), F = prop(T, "endValue", 15, "00:00"), I = prop(T, "min", 7, ""), L = prop(T, "max", 7, ""), z = prop(T, "required", 7, !0), B = prop(T, "disabled", 7, !1), V = prop(T, "inputColor", 7), U = prop(T, "buttonColor", 7, "primary"), W = prop(T, "Icon", 7), G = prop(T, "iconClass", 7, "h-5 w-5 text-gray-500 dark:text-gray-400"), K = prop(T, "type", 7, "default"), J = prop(T, "optionLabel", 7, "Options"), Y = prop(T, "options", 23, () => []), X = prop(T, "size", 7, "md"), Z = prop(T, "divClass", 7), Q = prop(T, "inputClass", 7), NL = prop(T, "selectClass", 7), PL = prop(T, "timerangeLabel", 7, "Choose time range"), FL = prop(T, "timerangeButtonLabel", 7, "Save time"), IL = prop(T, "timeIntervals", 23, () => []), LL = prop(T, "columns", 7, 2), RL = prop(T, "onselect", 7), zL = getTheme("timepicker"), BL = timepicker({
		type: K(),
		columns: LL(),
		disabled: B()
	}), VL = /* @__PURE__ */ state(""), HL = /* @__PURE__ */ state(!1), UL = /* @__PURE__ */ state(!1);
	function WL(C) {
		if (!C) return null;
		let T = parse(C, "HH:mm", /* @__PURE__ */ new Date());
		return isValid(T) ? T : null;
	}
	function GL(C) {
		let T = WL(C);
		return T ? T.getHours() * 60 + T.getMinutes() : 0;
	}
	function KL(C) {
		return WL(C) !== null;
	}
	function qL(C, T, E) {
		let D = WL(C);
		if (!D) return !1;
		if (T) {
			let C = WL(T);
			if (C && isBefore(D, C)) return !1;
		}
		if (E) {
			let C = WL(E);
			if (C && isAfter(D, C)) return !1;
		}
		return !0;
	}
	function JL(C, T = !1) {
		let E = C.target, D = E.value;
		if (!KL(D)) {
			E.value = T ? F() : O();
			return;
		}
		if (!qL(D, I(), L())) {
			E.value = T ? F() : O();
			return;
		}
		let z = GL(D), B = GL(O()), V = GL(F());
		if (T) if (z < B) if (qL(D, I(), L())) O(D);
		else {
			E.value = F();
			return;
		}
		else F(D);
		else if (z > V) if (qL(D, I(), L())) F(D);
		else {
			E.value = O();
			return;
		}
		else O(D);
		K() !== "timerange-dropdown" && ZL();
	}
	function YL(C) {
		let T = C.target;
		set(VL, T.value, !0), ZL();
	}
	function XL(C) {
		set(HL, !1), set(VL, C.value, !0), ZL();
	}
	function ZL() {
		if (RL()) {
			var C;
			RL()({
				time: O(),
				endTime: F(),
				[J() ? J().toLowerCase() : "options"]: get(VL) || ((C = Y()[0]) == null ? void 0 : C.value) || ""
			});
		}
	}
	function QL() {
		set(HL, !1), ZL();
	}
	function $L() {
		set(UL, !get(UL)), get(UL) || ZL();
	}
	function eR(C) {
		KL(C) && qL(C, I(), L()) && (O(C), ZL());
	}
	user_effect(() => {
		KL(O()) || O("00:00"), KL(F()) || F("00:00");
	});
	var tR = {
		get id() {
			return E();
		},
		set id(C = "time") {
			E(C), flushSync();
		},
		get endId() {
			return D();
		},
		set endId(C = "end-time") {
			D(C), flushSync();
		},
		get value() {
			return O();
		},
		set value(C = "00:00") {
			O(C), flushSync();
		},
		get endValue() {
			return F();
		},
		set endValue(C = "00:00") {
			F(C), flushSync();
		},
		get min() {
			return I();
		},
		set min(C = "") {
			I(C), flushSync();
		},
		get max() {
			return L();
		},
		set max(C = "") {
			L(C), flushSync();
		},
		get required() {
			return z();
		},
		set required(C = !0) {
			z(C), flushSync();
		},
		get disabled() {
			return B();
		},
		set disabled(C = !1) {
			B(C), flushSync();
		},
		get inputColor() {
			return V();
		},
		set inputColor(C) {
			V(C), flushSync();
		},
		get buttonColor() {
			return U();
		},
		set buttonColor(C = "primary") {
			U(C), flushSync();
		},
		get Icon() {
			return W();
		},
		set Icon(C) {
			W(C), flushSync();
		},
		get iconClass() {
			return G();
		},
		set iconClass(C = "h-5 w-5 text-gray-500 dark:text-gray-400") {
			G(C), flushSync();
		},
		get type() {
			return K();
		},
		set type(C = "default") {
			K(C), flushSync();
		},
		get optionLabel() {
			return J();
		},
		set optionLabel(C = "Options") {
			J(C), flushSync();
		},
		get options() {
			return Y();
		},
		set options(C = []) {
			Y(C), flushSync();
		},
		get size() {
			return X();
		},
		set size(C = "md") {
			X(C), flushSync();
		},
		get divClass() {
			return Z();
		},
		set divClass(C) {
			Z(C), flushSync();
		},
		get inputClass() {
			return Q();
		},
		set inputClass(C) {
			Q(C), flushSync();
		},
		get selectClass() {
			return NL();
		},
		set selectClass(C) {
			NL(C), flushSync();
		},
		get timerangeLabel() {
			return PL();
		},
		set timerangeLabel(C = "Choose time range") {
			PL(C), flushSync();
		},
		get timerangeButtonLabel() {
			return FL();
		},
		set timerangeButtonLabel(C = "Save time") {
			FL(C), flushSync();
		},
		get timeIntervals() {
			return IL();
		},
		set timeIntervals(C = []) {
			IL(C), flushSync();
		},
		get columns() {
			return LL();
		},
		set columns(C = 2) {
			LL(C), flushSync();
		},
		get onselect() {
			return RL();
		},
		set onselect(C) {
			RL(C), flushSync();
		}
	}, nR = comment(), rR = first_child(nR), iR = (C) => {
		{
			let T = /* @__PURE__ */ user_derived(() => BL.buttonGroup({ class: clsx_default(zL == null ? void 0 : zL.buttonGroup, Z()) }));
			ButtonGroup(C, {
				get size() {
					return X();
				},
				get class() {
					return get(T);
				},
				children: (C, T) => {
					var Z = comment(), IL = first_child(Z), LL = (C) => {
						var T = root_3$23(), D = first_child(T);
						{
							let C = /* @__PURE__ */ user_derived(() => BL.input({ class: clsx_default(BL.inputWithIcon(), zL == null ? void 0 : zL.input, Q()) }));
							Input(D, {
								get id() {
									return E();
								},
								get color() {
									return V();
								},
								type: "time",
								get min() {
									return I();
								},
								get max() {
									return L();
								},
								get required() {
									return z();
								},
								get disabled() {
									return B();
								},
								get class() {
									return get(C);
								},
								oninput: (C) => JL(C),
								onchange: (C) => JL(C),
								get value() {
									return O();
								},
								set value(C) {
									O(C);
								}
							});
						}
						var F = sibling(D, 2), U = child(F), K = (C) => {
							var T = comment();
							component(first_child(T), W, (C, T) => {
								T(C, { get class() {
									return G();
								} });
							}), append(C, T);
						}, J = (C) => {
							var T = root_5$10();
							template_effect((C) => set_class(T, 0, C), [() => clsx$1(BL.icon())]), append(C, T);
						};
						if_block(U, (C) => {
							W() ? C(K) : C(J, !1);
						}), reset(F), template_effect((C) => set_class(F, 1, C), [() => clsx$1(BL.iconWrapper({ class: clsx_default(zL == null ? void 0 : zL.iconWrapper) }))]), append(C, T);
					}, RL = (C) => {
						var T = comment(), Z = first_child(T), IL = (C) => {
							var T = root_7$4(), D = first_child(T);
							{
								let C = /* @__PURE__ */ user_derived(() => BL.input({ class: clsx_default(zL == null ? void 0 : zL.input, Q()) }));
								Input(D, {
									get id() {
										return E();
									},
									get color() {
										return V();
									},
									type: "time",
									get min() {
										return I();
									},
									get max() {
										return L();
									},
									get required() {
										return z();
									},
									get disabled() {
										return B();
									},
									get class() {
										return get(C);
									},
									oninput: (C) => JL(C),
									onchange: (C) => JL(C),
									get value() {
										return O();
									},
									set value(C) {
										O(C);
									}
								});
							}
							var F = sibling(D, 2);
							{
								let C = /* @__PURE__ */ user_derived(() => BL.select({ class: clsx_default(zL == null ? void 0 : zL.select, NL()) }));
								Select(F, {
									get selectClass() {
										return get(C);
									},
									onchange: YL,
									get items() {
										return Y();
									},
									get value() {
										return get(VL);
									}
								});
							}
							append(C, T);
						}, LL = (C) => {
							var T = comment(), Z = first_child(T), NL = (C) => {
								var T = root_9$1(), D = first_child(T);
								{
									let C = /* @__PURE__ */ user_derived(() => BL.input({ class: clsx_default(zL == null ? void 0 : zL.input, Q()) }));
									Input(D, {
										get id() {
											return E();
										},
										get color() {
											return V();
										},
										type: "time",
										get min() {
											return I();
										},
										get max() {
											return L();
										},
										get required() {
											return z();
										},
										get disabled() {
											return B();
										},
										get class() {
											return get(C);
										},
										oninput: (C) => JL(C),
										onchange: (C) => JL(C),
										get value() {
											return O();
										},
										set value(C) {
											O(C);
										}
									});
								}
								var F = sibling(D, 2);
								{
									let C = /* @__PURE__ */ user_derived(() => BL.button({ class: clsx_default(zL == null ? void 0 : zL.button) }));
									Button(F, {
										get color() {
											return U();
										},
										get class() {
											return get(C);
										},
										children: (C, T) => {
											next();
											var E = root_10$3(), D = first_child(E, !0), O = sibling(D);
											template_effect((C) => {
												set_text(D, J()), set_class(O, 0, C);
											}, [() => clsx$1(BL.buttonIcon({ class: clsx_default(zL == null ? void 0 : zL.buttonIcon) }))]), append(C, E);
										},
										$$slots: { default: !0 }
									});
								}
								Dropdown$1(sibling(F, 2), {
									simple: !0,
									children: (C, T) => {
										var E = comment();
										each(first_child(E), 17, Y, index, (C, T) => {
											DropdownItem(C, {
												onclick: () => XL(get(T)),
												children: (C, E) => {
													next();
													var D = text();
													template_effect(() => set_text(D, get(T).name)), append(C, D);
												},
												$$slots: { default: !0 }
											});
										}), append(C, E);
									},
									$$slots: { default: !0 }
								}), append(C, T);
							}, IL = (C) => {
								var T = comment(), J = first_child(T), Y = (C) => {
									var T = root_15$1(), U = first_child(T), K = child(U);
									{
										let C = /* @__PURE__ */ user_derived(() => BL.input({ class: clsx_default(zL == null ? void 0 : zL.rangeInput, BL.rangeInput(), Q()) }));
										Input(K, {
											get id() {
												return E();
											},
											get color() {
												return V();
											},
											type: "time",
											get min() {
												return I();
											},
											get max() {
												return L();
											},
											get required() {
												return z();
											},
											get disabled() {
												return B();
											},
											get class() {
												return get(C);
											},
											oninput: (C) => JL(C),
											onchange: (C) => JL(C),
											get value() {
												return O();
											},
											set value(C) {
												O(C);
											}
										});
									}
									var J = sibling(K, 2);
									J.__click = () => {
										var C;
										return (C = document.getElementById(E())) == null ? void 0 : C.click();
									};
									var Y = child(J), X = (C) => {
										var T = comment();
										component(first_child(T), W, (C, T) => {
											T(C, { get class() {
												return G();
											} });
										}), append(C, T);
									}, Z = (C) => {
										var T = root_17();
										template_effect((C) => set_class(T, 0, C), [() => clsx$1(BL.icon({ class: clsx_default(zL == null ? void 0 : zL.icon) }))]), append(C, T);
									};
									if_block(Y, (C) => {
										W() ? C(X) : C(Z, !1);
									}), reset(J), reset(U);
									var NL = sibling(U, 2), PL = sibling(NL, 2), FL = child(PL);
									{
										let C = /* @__PURE__ */ user_derived(() => BL.input({ class: clsx_default(BL.rangeInput(), zL == null ? void 0 : zL.rangeInput, Q()) }));
										Input(FL, {
											get id() {
												return D();
											},
											get color() {
												return V();
											},
											type: "time",
											get min() {
												return I();
											},
											get max() {
												return L();
											},
											get required() {
												return z();
											},
											get disabled() {
												return B();
											},
											get class() {
												return get(C);
											},
											oninput: (C) => JL(C, !0),
											onchange: (C) => JL(C, !0),
											get value() {
												return F();
											},
											set value(C) {
												F(C);
											}
										});
									}
									var IL = sibling(FL, 2);
									IL.__click = () => {
										var C;
										return (C = document.getElementById(D())) == null ? void 0 : C.click();
									};
									var LL = child(IL), RL = (C) => {
										var T = comment();
										component(first_child(T), W, (C, T) => {
											T(C, { get class() {
												return G();
											} });
										}), append(C, T);
									}, VL = (C) => {
										var T = root_19();
										template_effect((C) => set_class(T, 0, C), [() => clsx$1(BL.icon({ class: clsx_default(zL == null ? void 0 : zL.icon) }))]), append(C, T);
									};
									if_block(LL, (C) => {
										W() ? C(RL) : C(VL, !1);
									}), reset(IL), reset(PL), template_effect((C, T, E, D, O) => {
										set_class(U, 1, C), set_class(J, 1, T), set_class(NL, 1, E), set_class(PL, 1, D), set_class(IL, 1, O);
									}, [
										() => clsx$1(BL.rangeInputWrapper({ class: clsx_default(zL == null ? void 0 : zL.rangeInputWrapper) })),
										() => clsx$1(BL.rangeButton({ class: clsx_default(zL == null ? void 0 : zL.rangeButton) })),
										() => clsx$1(BL.rangeSeparator({ class: clsx_default(zL == null ? void 0 : zL.rangeSeparator) })),
										() => clsx$1(BL.rangeInputWrapper({ class: clsx_default(zL == null ? void 0 : zL.rangeInputWrapper) })),
										() => clsx$1(BL.rangeButton({ class: clsx_default(zL == null ? void 0 : zL.rangeButton) }))
									]), append(C, T);
								}, Z = (C) => {
									var T = comment(), W = first_child(T), G = (C) => {
										var T = root_21$1(), W = first_child(T);
										{
											let C = /* @__PURE__ */ user_derived(() => BL.button({ class: clsx_default(zL == null ? void 0 : zL.button) }));
											Button(W, {
												get color() {
													return U();
												},
												get size() {
													return X();
												},
												get class() {
													return get(C);
												},
												children: (C, T) => {
													next();
													var E = root_22$1(), D = first_child(E, !0), O = sibling(D);
													template_effect((C) => {
														set_text(D, PL()), set_class(O, 0, C);
													}, [() => clsx$1(BL.buttonIcon({ class: clsx_default(zL == null ? void 0 : zL.buttonIcon) }))]), append(C, E);
												},
												$$slots: { default: !0 }
											});
										}
										var G = sibling(W, 2);
										{
											let C = /* @__PURE__ */ user_derived(() => BL.dropdownContent({ class: clsx_default(zL == null ? void 0 : zL.dropdownContent) }));
											Dropdown$1(G, {
												simple: !0,
												get class() {
													return get(C);
												},
												children: (C, T) => {
													var W = root_23$1(), G = child(W), K = child(G), J = child(K);
													Label(J, {
														get for() {
															return E();
														},
														children: (C, T) => {
															next(), append(C, text("Start time:"));
														},
														$$slots: { default: !0 }
													});
													var Y = sibling(J, 2);
													{
														let C = /* @__PURE__ */ user_derived(() => BL.dropdownTimeInput({ class: clsx_default(zL == null ? void 0 : zL.dropdownTimeInput, Q()) }));
														Input(Y, {
															get id() {
																return E();
															},
															get color() {
																return V();
															},
															type: "time",
															get min() {
																return I();
															},
															get max() {
																return L();
															},
															get required() {
																return z();
															},
															get disabled() {
																return B();
															},
															get class() {
																return get(C);
															},
															oninput: (C) => JL(C),
															onchange: (C) => JL(C),
															get value() {
																return O();
															},
															set value(C) {
																O(C);
															}
														});
													}
													reset(K);
													var X = sibling(K, 2), Z = child(X);
													Label(Z, {
														get for() {
															return D();
														},
														children: (C, T) => {
															next(), append(C, text("End time:"));
														},
														$$slots: { default: !0 }
													});
													var NL = sibling(Z, 2);
													{
														let C = /* @__PURE__ */ user_derived(() => BL.dropdownTimeInput({ class: clsx_default(zL == null ? void 0 : zL.dropdownTimeInput, Q()) }));
														Input(NL, {
															get id() {
																return D();
															},
															get color() {
																return V();
															},
															type: "time",
															get min() {
																return I();
															},
															get max() {
																return L();
															},
															get required() {
																return z();
															},
															get disabled() {
																return B();
															},
															get class() {
																return get(C);
															},
															oninput: (C) => JL(C, !0),
															onchange: (C) => JL(C, !0),
															get value() {
																return F();
															},
															set value(C) {
																F(C);
															}
														});
													}
													reset(X), reset(G);
													var PL = sibling(G, 2);
													{
														let C = /* @__PURE__ */ user_derived(() => BL.dropdownButton({ class: clsx_default(zL == null ? void 0 : zL.dropdownButton) }));
														Button(PL, {
															get color() {
																return U();
															},
															get class() {
																return get(C);
															},
															onclick: QL,
															children: (C, T) => {
																next();
																var E = text();
																template_effect(() => set_text(E, FL())), append(C, E);
															},
															$$slots: { default: !0 }
														});
													}
													reset(W), template_effect((C, T, E, D) => {
														set_class(W, 1, C), set_class(G, 1, T), set_class(K, 1, E), set_class(X, 1, D);
													}, [
														() => clsx$1(BL.dropdownInner({ class: clsx_default(zL == null ? void 0 : zL.dropdownInner) })),
														() => clsx$1(BL.dropdownTimeRow({ class: clsx_default(zL == null ? void 0 : zL.dropdownTimeRow) })),
														() => clsx$1(BL.dropdownTimeCol({ class: clsx_default(zL == null ? void 0 : zL.dropdownTimeCol) })),
														() => clsx$1(BL.dropdownTimeCol({ class: clsx_default(zL == null ? void 0 : zL.dropdownTimeCol) }))
													]), append(C, W);
												},
												$$slots: { default: !0 }
											});
										}
										append(C, T);
									}, J = (C) => {
										var T = comment(), U = first_child(T), W = (C) => {
											var T = root_28$1(), U = child(T), W = child(U);
											{
												let C = /* @__PURE__ */ user_derived(() => `${E()}-timerange-toggle`);
												Toggle(W, {
													get id() {
														return get(C);
													},
													get checked() {
														return get(UL);
													},
													onchange: $L,
													spanClass: "me-0 rounded-lg"
												});
											}
											reset(U);
											var G = sibling(U, 2), K = (C) => {
												var T = root_29(), U = child(T), W = child(U);
												Label(W, {
													get for() {
														return E();
													},
													children: (C, T) => {
														next(), append(C, text("Start time:"));
													},
													$$slots: { default: !0 }
												});
												var G = sibling(W, 2);
												{
													let C = /* @__PURE__ */ user_derived(() => BL.toggleTimeInput({ class: clsx_default(zL == null ? void 0 : zL.toggleTimeInput, Q()) }));
													Input(G, {
														get id() {
															return E();
														},
														get color() {
															return V();
														},
														type: "time",
														get min() {
															return I();
														},
														get max() {
															return L();
														},
														get required() {
															return z();
														},
														get disabled() {
															return B();
														},
														get class() {
															return get(C);
														},
														oninput: (C) => JL(C),
														onchange: (C) => JL(C),
														get value() {
															return O();
														},
														set value(C) {
															O(C);
														}
													});
												}
												reset(U);
												var K = sibling(U, 2), J = child(K);
												Label(J, {
													get for() {
														return D();
													},
													children: (C, T) => {
														next(), append(C, text("End time:"));
													},
													$$slots: { default: !0 }
												});
												var Y = sibling(J, 2);
												{
													let C = /* @__PURE__ */ user_derived(() => BL.toggleTimeInput({ class: clsx_default(zL == null ? void 0 : zL.toggleTimeInput, Q()) }));
													Input(Y, {
														get id() {
															return D();
														},
														get color() {
															return V();
														},
														type: "time",
														get min() {
															return I();
														},
														get max() {
															return L();
														},
														get required() {
															return z();
														},
														get disabled() {
															return B();
														},
														get class() {
															return get(C);
														},
														oninput: (C) => JL(C, !0),
														onchange: (C) => JL(C, !0),
														get value() {
															return F();
														},
														set value(C) {
															F(C);
														}
													});
												}
												reset(K), reset(T), template_effect((C, E, D) => {
													set_class(T, 1, C), set_class(U, 1, E), set_class(K, 1, D);
												}, [
													() => clsx$1(BL.toggleTimeRow({ class: clsx_default(zL == null ? void 0 : zL.toggleTimeRow) })),
													() => clsx$1(BL.toggleTimeCol({ class: clsx_default(zL == null ? void 0 : zL.toggleTimeCol) })),
													() => clsx$1(BL.toggleTimeCol({ class: clsx_default(zL == null ? void 0 : zL.toggleTimeCol) }))
												]), append(C, T);
											};
											if_block(G, (C) => {
												get(UL) && C(K);
											}), reset(T), template_effect((C, E) => {
												set_class(T, 1, C), set_class(U, 1, E);
											}, [() => clsx$1(BL.toggleWrapper({ class: clsx_default(zL == null ? void 0 : zL.toggleWrapper) })), () => clsx$1(BL.toggleRow({ class: clsx_default(zL == null ? void 0 : zL.toggleRow) }))]), append(C, T);
										};
										if_block(U, (C) => {
											K() === "timerange-toggle" && C(W);
										}, !0), append(C, T);
									};
									if_block(W, (C) => {
										K() === "timerange-dropdown" ? C(G) : C(J, !1);
									}, !0), append(C, T);
								};
								if_block(J, (C) => {
									K() === "range" ? C(Y) : C(Z, !1);
								}, !0), append(C, T);
							};
							if_block(Z, (C) => {
								K() === "dropdown" ? C(NL) : C(IL, !1);
							}, !0), append(C, T);
						};
						if_block(Z, (C) => {
							K() === "select" ? C(IL) : C(LL, !1);
						}, !0), append(C, T);
					};
					if_block(IL, (C) => {
						K() === "default" ? C(LL) : C(RL, !1);
					}), append(C, Z);
				},
				$$slots: { default: !0 }
			});
		}
	}, aR = (C) => {
		var T = root_32();
		each(T, 21, IL, index, (C, T) => {
			{
				let E = /* @__PURE__ */ user_derived(() => O() === get(T) ? U() : "light"), D = /* @__PURE__ */ user_derived(() => BL.inlineButton({ class: clsx_default(zL == null ? void 0 : zL.inlineButton) }));
				Button(C, {
					get size() {
						return X();
					},
					get color() {
						return get(E);
					},
					get class() {
						return get(D);
					},
					onclick: () => eR(get(T)),
					children: (C, E) => {
						next();
						var D = text();
						template_effect(() => set_text(D, get(T))), append(C, D);
					},
					$$slots: { default: !0 }
				});
			}
		}), reset(T), template_effect((C) => set_class(T, 1, C), [() => clsx$1(BL.inlineGrid({ class: clsx_default(zL == null ? void 0 : zL.inlineGrid) }))]), append(C, T);
	};
	return if_block(rR, (C) => {
		K() === "inline-buttons" ? C(aR, !1) : C(iR);
	}), append(C, nR), pop(tR);
}
delegate(["click"]), create_custom_element(Timepicker, {
	id: {},
	endId: {},
	value: {},
	endValue: {},
	min: {},
	max: {},
	required: {},
	disabled: {},
	inputColor: {},
	buttonColor: {},
	Icon: {},
	iconClass: {},
	type: {},
	optionLabel: {},
	options: {},
	size: {},
	divClass: {},
	inputClass: {},
	selectClass: {},
	timerangeLabel: {},
	timerangeButtonLabel: {},
	timeIntervals: {},
	columns: {},
	onselect: {}
}, [], [], !0);
var root_1$56 = /* @__PURE__ */ from_html("<!> <input/> <span></span> <!>", 1);
function Toggle(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "size", 7, "default"), F = prop(E, "value", 7), I = prop(E, "checked", 15), L = prop(E, "disabled", 7), z = prop(E, "color", 7, "primary"), B = prop(E, "class", 7), V = prop(E, "classes", 7), U = prop(E, "inputClass", 7), W = prop(E, "spanClass", 7), G = prop(E, "offLabel", 7), K = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"size",
		"value",
		"checked",
		"disabled",
		"color",
		"class",
		"classes",
		"inputClass",
		"spanClass",
		"offLabel"
	]);
	U(), W();
	let J = /* @__PURE__ */ user_derived(() => {
		var C;
		return (C = V()) == null ? {
			input: U(),
			span: W()
		} : C;
	}), Y = getTheme("toggle"), X = /* @__PURE__ */ user_derived(() => toggle({
		color: z(),
		checked: I(),
		size: O(),
		disabled: L(),
		off_state_label: !!G()
	})), Z = /* @__PURE__ */ user_derived(() => get(X).input), Q = /* @__PURE__ */ user_derived(() => get(X).label), NL = /* @__PURE__ */ user_derived(() => get(X).span);
	var PL = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get size() {
			return O();
		},
		set size(C = "default") {
			O(C), flushSync();
		},
		get value() {
			return F();
		},
		set value(C) {
			F(C), flushSync();
		},
		get checked() {
			return I();
		},
		set checked(C) {
			I(C), flushSync();
		},
		get disabled() {
			return L();
		},
		set disabled(C) {
			L(C), flushSync();
		},
		get color() {
			return z();
		},
		set color(C = "primary") {
			z(C), flushSync();
		},
		get class() {
			return B();
		},
		set class(C) {
			B(C), flushSync();
		},
		get classes() {
			return V();
		},
		set classes(C) {
			V(C), flushSync();
		},
		get inputClass() {
			return U();
		},
		set inputClass(C) {
			U(C), flushSync();
		},
		get spanClass() {
			return W();
		},
		set spanClass(C) {
			W(C), flushSync();
		},
		get offLabel() {
			return G();
		},
		set offLabel(C) {
			G(C), flushSync();
		}
	};
	{
		let E = /* @__PURE__ */ user_derived(() => get(Q)({ class: clsx_default(Y == null ? void 0 : Y.label, B()) }));
		Label(C, {
			get class() {
				return get(E);
			},
			children: (C, E) => {
				var O = root_1$56(), z = first_child(O), B = (C) => {
					var T = comment();
					snippet(first_child(T), G), append(C, T);
				};
				if_block(z, (C) => {
					G() && C(B);
				});
				var V = sibling(z, 2);
				attribute_effect(V, (C) => _objectSpread2(_objectSpread2({
					type: "checkbox",
					value: F()
				}, K), {}, {
					disabled: L(),
					class: C
				}), [() => get(Z)({ class: clsx_default(Y == null ? void 0 : Y.input, get(J).input) })], void 0, void 0, void 0, !0);
				var U = sibling(V, 2), W = sibling(U, 2), X = (C) => {
					var T = comment();
					snippet(first_child(T), D), append(C, T);
				};
				if_block(W, (C) => {
					D() && C(X);
				}), template_effect((C) => set_class(U, 1, C), [() => clsx$1(get(NL)({ class: clsx_default(Y == null ? void 0 : Y.span, get(J).span) }))]), bind_checked(V, I), append(C, O);
			},
			$$slots: { default: !0 }
		});
	}
	return pop(PL);
}
create_custom_element(Toggle, {
	children: {},
	size: {},
	value: {},
	checked: {},
	disabled: {},
	color: {},
	class: {},
	classes: {},
	inputClass: {},
	spanClass: {},
	offLabel: {}
}, [], [], !0);
const toggle = ce({
	slots: {
		span: "me-3 shrink-0 bg-gray-200 rounded-full peer-focus:ring-4 peer-checked:after:translate-x-full peer-checked:rtl:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:bg-white after:border-gray-300 after:border after:rounded-full after:transition-all dark:bg-gray-600 dark:border-gray-500 relative ",
		label: "flex items-center",
		input: "w-4 h-4 bg-gray-100 border-gray-300 dark:ring-offset-gray-800 focus:ring-2 rounded-sm dark:bg-gray-700 dark:border-gray-600 sr-only peer"
	},
	variants: {
		disabled: { true: { label: "cursor-not-allowed opacity-50" } },
		checked: {
			true: "",
			false: ""
		},
		off_state_label: { true: { span: "ms-3" } },
		color: {
			primary: { span: "peer-focus:ring-primary-300 dark:peer-focus:ring-primary-800 peer-checked:bg-primary-600" },
			secondary: { span: "peer-focus:ring-secondary-300 dark:peer-focus:ring-secondary-800 peer-checked:bg-secondary-600" },
			gray: { span: "peer-focus:ring-gray-300 dark:peer-focus:ring-gray-800 peer-checked:bg-gray-500" },
			red: { span: "peer-focus:ring-red-300 dark:peer-focus:ring-red-800 peer-checked:bg-red-600" },
			orange: { span: "peer-focus:ring-orange-300 dark:peer-focus:ring-orange-800 peer-checked:bg-orange-500" },
			amber: { span: "peer-focus:ring-amber-300 dark:peer-focus:ring-amber-800 peer-checked:bg-amber-600" },
			yellow: { span: "peer-focus:ring-yellow-300 dark:peer-focus:ring-yellow-800 peer-checked:bg-yellow-400" },
			lime: { span: "peer-focus:ring-lime-300 dark:peer-focus:ring-lime-800 peer-checked:bg-lime-500" },
			green: { span: "peer-focus:ring-green-300 dark:peer-focus:ring-green-800 peer-checked:bg-green-600" },
			emerald: { span: "peer-focus:ring-emerald-300 dark:peer-focus:ring-emerald-800 peer-checked:bg-emerald-600" },
			teal: { span: "peer-focus:ring-teal-300 dark:peer-focus:ring-teal-800 peer-checked:bg-teal-600" },
			cyan: { span: "peer-focus:ring-cyan-300 dark:peer-focus:ring-cyan-800 peer-checked:bg-cyan-600" },
			sky: { span: "peer-focus:ring-sky-300 dark:peer-focus:ring-sky-800 peer-checked:bg-sky-600" },
			blue: { span: "peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 peer-checked:bg-blue-600" },
			indigo: { span: "peer-focus:ring-indigo-300 dark:peer-focus:ring-indigo-800 peer-checked:bg-indigo-600" },
			violet: { span: "peer-focus:ring-violet-300 dark:peer-focus:ring-violet-800 peer-checked:bg-violet-600" },
			purple: { span: "peer-focus:ring-purple-300 dark:peer-focus:ring-purple-800 peer-checked:bg-purple-600" },
			fuchsia: { span: "peer-focus:ring-fuchsia-300 dark:peer-focus:ring-fuchsia-800 peer-checked:bg-fuchsia-600" },
			pink: { span: "peer-focus:ring-pink-300 dark:peer-focus:ring-pink-800 peer-checked:bg-pink-600" },
			rose: { span: "peer-focus:ring-rose-300 dark:peer-focus:ring-rose-800 peer-checked:bg-rose-600" }
		},
		size: {
			small: { span: "w-9 h-5 after:top-[2px] after:start-[2px] after:h-4 after:w-4" },
			default: { span: "w-11 h-6 after:top-0.5 after:start-[2px] after:h-5 after:w-5" },
			large: { span: "w-14 h-7 after:top-0.5 after:start-[4px]  after:h-6 after:w-6" }
		}
	},
	defaultVariants: { color: "primary" }
});
var root$42 = /* @__PURE__ */ from_html("<a><!></a>");
function A(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "color", 7, "primary"), F = prop(E, "class", 7), I = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"color",
		"class"
	]), L = /* @__PURE__ */ user_derived(() => anchor({
		color: O(),
		className: F()
	}));
	var z = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get color() {
			return O();
		},
		set color(C = "primary") {
			O(C), flushSync();
		},
		get class() {
			return F();
		},
		set class(C) {
			F(C), flushSync();
		}
	}, B = root$42();
	return attribute_effect(B, () => _objectSpread2(_objectSpread2({}, I), {}, { class: get(L) })), snippet(child(B), D), reset(B), append(C, B), pop(z);
}
create_custom_element(A, {
	children: {},
	color: {},
	class: {}
}, [], [], !0);
const anchor = ce({
	base: "inline-flex items-center hover:underline",
	variants: { color: {
		primary: "text-primary-600 dark:text-primary-500",
		secondary: "text-secondary-600 dark:text-secondary-500",
		gray: "text-gray-600 dark:text-gray-500",
		red: "text-red-600 dark:text-red-500",
		orange: "text-orange-600 dark:text-orange-500",
		amber: "text-amber-600 dark:text-amber-500",
		yellow: "text-yellow-600 dark:text-yellow-500",
		lime: "text-lime-600 dark:text-lime-500",
		green: "text-green-600 dark:text-green-500",
		emerald: "text-emerald-600 dark:text-emerald-500",
		teal: "text-teal-600 dark:text-teal-500",
		cyan: "text-cyan-600 dark:text-cyan-500",
		sky: "text-sky-600 dark:text-sky-500",
		blue: "text-blue-600 dark:text-blue-500",
		indigo: "text-indigo-600 dark:text-indigo-500",
		violet: "text-violet-600 dark:text-violet-500",
		purple: "text-purple-600 dark:text-purple-500",
		fuchsia: "text-fuchsia-600 dark:text-fuchsia-500",
		pink: "text-pink-600 dark:text-pink-500",
		rose: "text-rose-600 dark:text-rose-500"
	} }
});
var root$41 = /* @__PURE__ */ from_html("<blockquote><!></blockquote>");
function Blockquote(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "class", 7), F = prop(E, "border", 7), I = prop(E, "italic", 7, !0), L = prop(E, "bg", 7), z = prop(E, "alignment", 7, "left"), B = prop(E, "size", 7, "lg"), V = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"class",
		"border",
		"italic",
		"bg",
		"alignment",
		"size"
	]), U = /* @__PURE__ */ user_derived(() => blockquote({
		border: F(),
		italic: I(),
		bg: L(),
		alignment: z(),
		size: B(),
		className: O()
	}));
	var W = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get class() {
			return O();
		},
		set class(C) {
			O(C), flushSync();
		},
		get border() {
			return F();
		},
		set border(C) {
			F(C), flushSync();
		},
		get italic() {
			return I();
		},
		set italic(C = !0) {
			I(C), flushSync();
		},
		get bg() {
			return L();
		},
		set bg(C) {
			L(C), flushSync();
		},
		get alignment() {
			return z();
		},
		set alignment(C = "left") {
			z(C), flushSync();
		},
		get size() {
			return B();
		},
		set size(C = "lg") {
			B(C), flushSync();
		}
	}, G = root$41();
	return attribute_effect(G, () => _objectSpread2(_objectSpread2({}, V), {}, { class: get(U) })), snippet(child(G), D), reset(G), append(C, G), pop(W);
}
create_custom_element(Blockquote, {
	children: {},
	class: {},
	border: {},
	italic: {},
	bg: {},
	alignment: {},
	size: {}
}, [], [], !0);
const blockquote = ce({
	base: "font-semibold text-gray-900 dark:text-white",
	variants: {
		border: {
			true: "border-s-4 border-gray-300 dark:border-gray-500",
			false: ""
		},
		italic: {
			true: "italic",
			false: ""
		},
		bg: {
			true: "bg-gray-50 dark:bg-gray-800",
			false: ""
		},
		alignment: {
			left: "text-left",
			center: "text-center",
			right: "text-right"
		},
		size: {
			xs: "text-xs",
			sm: "text-sm",
			base: "text-base",
			lg: "text-lg",
			xl: "text-xl",
			"2xl": "text-2xl",
			"3xl": "text-3xl",
			"4xl": "text-4xl",
			"5xl": "text-5xl",
			"6xl": "text-6xl",
			"7xl": "text-7xl",
			"8xl": "text-8xl",
			"9xl": "text-9xl"
		}
	},
	defaultVariants: {
		border: !1,
		italic: !0,
		bg: !1,
		alignment: "left",
		size: "lg"
	}
});
function DescriptionList(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "tag", 7), F = prop(E, "class", 7), I = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"tag",
		"class"
	]), L = /* @__PURE__ */ user_derived(() => descriptionList({
		tag: O(),
		class: F()
	}));
	var z = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get tag() {
			return O();
		},
		set tag(C) {
			O(C), flushSync();
		},
		get class() {
			return F();
		},
		set class(C) {
			F(C), flushSync();
		}
	}, B = comment();
	return element(first_child(B), O, !1, (C, E) => {
		attribute_effect(C, () => _objectSpread2(_objectSpread2({}, I), {}, { class: get(L) }));
		var O = comment();
		snippet(first_child(O), D), append(E, O);
	}), append(C, B), pop(z);
}
create_custom_element(DescriptionList, {
	children: {},
	tag: {},
	class: {}
}, [], [], !0);
const descriptionList = ce({
	variants: { tag: {
		dt: "text-gray-500 md:text-lg dark:text-gray-400",
		dd: "text-lg font-semibold"
	} },
	defaultVariants: { tag: "dt" }
});
function Heading(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "tag", 7, "h1"), F = prop(E, "class", 7), I = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"tag",
		"class"
	]), L = /* @__PURE__ */ user_derived(() => heading({
		tag: O(),
		className: F()
	}));
	var z = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get tag() {
			return O();
		},
		set tag(C = "h1") {
			O(C), flushSync();
		},
		get class() {
			return F();
		},
		set class(C) {
			F(C), flushSync();
		}
	}, B = comment();
	return element(first_child(B), O, !1, (C, E) => {
		attribute_effect(C, () => _objectSpread2(_objectSpread2({}, I), {}, { class: get(L) }));
		var O = comment();
		snippet(first_child(O), D), append(E, O);
	}), append(C, B), pop(z);
}
create_custom_element(Heading, {
	children: {},
	tag: {},
	class: {}
}, [], [], !0);
const heading = ce({
	base: "font-bold text-gray-900 dark:text-white",
	variants: { tag: {
		h1: "text-5xl font-extrabold",
		h2: "text-4xl",
		h3: "text-3xl",
		h4: "text-2xl",
		h5: "text-xl",
		h6: "text-lg"
	} },
	defaultVariants: { tag: "h1" }
});
var root_1$55 = /* @__PURE__ */ from_html("<div><hr/> <div><!></div></div>"), root_2$27 = /* @__PURE__ */ from_html("<hr/>");
function Hr(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "divClass", 7), F = prop(E, "hrClass", 7), I = prop(E, "innerDivClass", 7), L = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"divClass",
		"hrClass",
		"innerDivClass"
	]), z = getContext("themeConfig");
	z != null && z.hr;
	let B = /* @__PURE__ */ user_derived(() => hr({ withChildren: !!D() })), V = /* @__PURE__ */ user_derived(() => get(B).base), U = /* @__PURE__ */ user_derived(() => get(B).container), W = /* @__PURE__ */ user_derived(() => get(B).content);
	var G = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get divClass() {
			return O();
		},
		set divClass(C) {
			O(C), flushSync();
		},
		get hrClass() {
			return F();
		},
		set hrClass(C) {
			F(C), flushSync();
		},
		get innerDivClass() {
			return I();
		},
		set innerDivClass(C) {
			I(C), flushSync();
		}
	}, K = comment(), J = first_child(K), Y = (C) => {
		var E = root_1$55();
		attribute_effect(E, (C) => _objectSpread2(_objectSpread2({}, L), {}, { class: C }), [() => get(U)({ class: O() })]);
		var z = child(E), B = sibling(z, 2);
		snippet(child(B), D), reset(B), reset(E), template_effect((C, T) => {
			set_class(z, 1, C), set_class(B, 1, T);
		}, [() => clsx$1(get(V)({ class: F() })), () => clsx$1(get(W)({ class: I() }))]), append(C, E);
	}, X = (C) => {
		var E = root_2$27();
		attribute_effect(E, (C) => _objectSpread2({ class: C }, L), [() => get(V)({ class: F() })]), append(C, E);
	};
	return if_block(J, (C) => {
		D() ? C(Y) : C(X, !1);
	}), append(C, K), pop(G);
}
create_custom_element(Hr, {
	children: {},
	divClass: {},
	hrClass: {},
	innerDivClass: {}
}, [], [], !0);
const hr = ce({
	slots: {
		base: "h-px my-8 bg-gray-200 border-0 dark:bg-gray-700",
		container: "inline-flex items-center justify-center w-full",
		content: "absolute px-4 -translate-x-1/2 rtl:translate-x-1/2 bg-white start-1/2 dark:bg-gray-900"
	},
	variants: { withChildren: { true: {
		base: "w-full",
		container: "relative"
	} } },
	defaultVariants: { withChildren: !1 }
});
var root_2$26 = /* @__PURE__ */ from_html("<figure><img/> <figcaption><!></figcaption></figure>"), root_3$22 = /* @__PURE__ */ from_html("<img/>"), root_4$15 = /* @__PURE__ */ from_html("<a><!></a>");
function Img(C, E) {
	push(E, !0);
	let D = (C) => {
		var E = comment(), D = first_child(E), O = (C) => {
			var E = root_2$26(), D = child(E);
			attribute_effect(D, (C) => _objectSpread2(_objectSpread2({}, K), {}, { class: C }), [() => get(Y)({ class: V() })]);
			var O = sibling(D, 2);
			html(child(O), B), reset(O), reset(E), template_effect((C, T) => {
				set_class(E, 1, C), set_class(O, 1, T);
			}, [() => clsx$1(get(X)({ class: U() })), () => clsx$1(get(Z)({ class: W() }))]), replay_events(D), append(C, E);
		}, F = (C) => {
			var E = root_3$22();
			attribute_effect(E, (C) => _objectSpread2(_objectSpread2({}, K), {}, { class: C }), [() => get(Y)({ class: V() })]), replay_events(E), append(C, E);
		};
		if_block(D, (C) => {
			B() ? C(O) : C(F, !1);
		}), append(C, E);
	}, O = prop(E, "size", 7, "none"), F = prop(E, "alignment", 7, "left"), I = prop(E, "effect", 7, "none"), L = prop(E, "shadow", 7, "none"), z = prop(E, "rounded", 7, "none"), B = prop(E, "caption", 7), V = prop(E, "imgClass", 7), U = prop(E, "figClass", 7), W = prop(E, "captionClass", 7), G = prop(E, "href", 7), K = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"size",
		"alignment",
		"effect",
		"shadow",
		"rounded",
		"caption",
		"imgClass",
		"figClass",
		"captionClass",
		"href"
	]), J = /* @__PURE__ */ user_derived(() => img({
		size: O(),
		alignment: F(),
		effect: I(),
		shadow: L(),
		rounded: z()
	})), Y = /* @__PURE__ */ user_derived(() => get(J).base), X = /* @__PURE__ */ user_derived(() => get(J).figure), Z = /* @__PURE__ */ user_derived(() => get(J).figureCaption);
	var Q = {
		get size() {
			return O();
		},
		set size(C = "none") {
			O(C), flushSync();
		},
		get alignment() {
			return F();
		},
		set alignment(C = "left") {
			F(C), flushSync();
		},
		get effect() {
			return I();
		},
		set effect(C = "none") {
			I(C), flushSync();
		},
		get shadow() {
			return L();
		},
		set shadow(C = "none") {
			L(C), flushSync();
		},
		get rounded() {
			return z();
		},
		set rounded(C = "none") {
			z(C), flushSync();
		},
		get caption() {
			return B();
		},
		set caption(C) {
			B(C), flushSync();
		},
		get imgClass() {
			return V();
		},
		set imgClass(C) {
			V(C), flushSync();
		},
		get figClass() {
			return U();
		},
		set figClass(C) {
			U(C), flushSync();
		},
		get captionClass() {
			return W();
		},
		set captionClass(C) {
			W(C), flushSync();
		},
		get href() {
			return G();
		},
		set href(C) {
			G(C), flushSync();
		}
	}, NL = comment(), PL = first_child(NL), FL = (C) => {
		var T = root_4$15();
		D(child(T)), reset(T), template_effect(() => set_attribute(T, "href", G())), append(C, T);
	}, IL = (C) => {
		D(C);
	};
	return if_block(PL, (C) => {
		G() ? C(FL) : C(IL, !1);
	}), append(C, NL), pop(Q);
}
create_custom_element(Img, {
	size: {},
	alignment: {},
	effect: {},
	shadow: {},
	rounded: {},
	caption: {},
	imgClass: {},
	figClass: {},
	captionClass: {},
	href: {}
}, [], [], !0);
var root_2$25 = /* @__PURE__ */ from_html("<figure><enhanced:img></enhanced:img> <figcaption><!></figcaption></figure>"), root_3$21 = /* @__PURE__ */ from_html("<enhanced:img></enhanced:img>"), root_4$14 = /* @__PURE__ */ from_html("<a><!></a>");
function EnhancedImg(C, E) {
	push(E, !0);
	let D = (C) => {
		var E = comment(), D = first_child(E), F = (C) => {
			var E = root_2$25(), D = child(E);
			attribute_effect(D, (C) => _objectSpread2(_objectSpread2({ src: O() }, K), {}, { class: C }), [() => get(Y)({ class: W() })]);
			var F = sibling(D, 2);
			html(child(F), I), reset(F), reset(E), template_effect((C, T) => {
				set_class(E, 1, C), set_class(F, 1, T);
			}, [() => clsx$1(get(X)({ class: U() })), () => clsx$1(get(Z)({ class: G() }))]), append(C, E);
		}, L = (C) => {
			var E = root_3$21();
			attribute_effect(E, (C) => _objectSpread2(_objectSpread2({ src: O() }, K), {}, { class: C }), [() => get(Y)({ class: W() })]), append(C, E);
		};
		if_block(D, (C) => {
			I() ? C(F) : C(L, !1);
		}), append(C, E);
	}, O = prop(E, "src", 7), F = prop(E, "href", 7), I = prop(E, "caption", 7), L = prop(E, "size", 7), z = prop(E, "alignment", 7), B = prop(E, "shadow", 7), V = prop(E, "rounded", 7), U = prop(E, "figClass", 7), W = prop(E, "imgClass", 7), G = prop(E, "captionClass", 7), K = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"src",
		"href",
		"caption",
		"size",
		"alignment",
		"shadow",
		"rounded",
		"figClass",
		"imgClass",
		"captionClass"
	]), J = /* @__PURE__ */ user_derived(() => img({
		size: L(),
		alignment: z(),
		shadow: B(),
		rounded: V()
	})), Y = /* @__PURE__ */ user_derived(() => get(J).base), X = /* @__PURE__ */ user_derived(() => get(J).figure), Z = /* @__PURE__ */ user_derived(() => get(J).figureCaption);
	var Q = {
		get src() {
			return O();
		},
		set src(C) {
			O(C), flushSync();
		},
		get href() {
			return F();
		},
		set href(C) {
			F(C), flushSync();
		},
		get caption() {
			return I();
		},
		set caption(C) {
			I(C), flushSync();
		},
		get size() {
			return L();
		},
		set size(C) {
			L(C), flushSync();
		},
		get alignment() {
			return z();
		},
		set alignment(C) {
			z(C), flushSync();
		},
		get shadow() {
			return B();
		},
		set shadow(C) {
			B(C), flushSync();
		},
		get rounded() {
			return V();
		},
		set rounded(C) {
			V(C), flushSync();
		},
		get figClass() {
			return U();
		},
		set figClass(C) {
			U(C), flushSync();
		},
		get imgClass() {
			return W();
		},
		set imgClass(C) {
			W(C), flushSync();
		},
		get captionClass() {
			return G();
		},
		set captionClass(C) {
			G(C), flushSync();
		}
	}, NL = comment(), PL = first_child(NL), FL = (C) => {
		var T = root_4$14();
		D(child(T)), reset(T), template_effect(() => set_attribute(T, "href", F())), append(C, T);
	}, IL = (C) => {
		D(C);
	};
	return if_block(PL, (C) => {
		F() ? C(FL) : C(IL, !1);
	}), append(C, NL), pop(Q);
}
create_custom_element(EnhancedImg, {
	src: {},
	href: {},
	caption: {},
	size: {},
	alignment: {},
	shadow: {},
	rounded: {},
	figClass: {},
	imgClass: {},
	captionClass: {}
}, [], [], !0);
var root_2$24 = /* @__PURE__ */ from_html("<figure><enhanced:img></enhanced:img> <figcaption><!></figcaption></figure>"), root_3$20 = /* @__PURE__ */ from_html("<enhanced:img></enhanced:img>"), root_4$13 = /* @__PURE__ */ from_html("<a><!></a>");
function ImgEnhanced(C, E) {
	push(E, !0);
	let D = (C) => {
		var E = comment(), D = first_child(E), F = (C) => {
			var E = root_2$24(), D = child(E);
			attribute_effect(D, (C) => _objectSpread2(_objectSpread2({}, J), {}, {
				src: O(),
				class: C
			}), [() => get(X)({ class: U() })]);
			var F = sibling(D, 2);
			html(child(F), V), reset(F), reset(E), template_effect((C, T) => {
				set_class(E, 1, C), set_class(F, 1, T);
			}, [() => clsx$1(get(Z)({ class: W() })), () => clsx$1(get(Q)({ class: G() }))]), append(C, E);
		}, I = (C) => {
			var E = root_3$20();
			attribute_effect(E, (C) => _objectSpread2(_objectSpread2({}, J), {}, {
				src: O(),
				class: C
			}), [() => get(X)({ class: U() })]), append(C, E);
		};
		if_block(D, (C) => {
			V() ? C(F) : C(I, !1);
		}), append(C, E);
	}, O = prop(E, "src", 7), F = prop(E, "size", 7, "none"), I = prop(E, "alignment", 7, "left"), L = prop(E, "effect", 7, "none"), z = prop(E, "shadow", 7, "none"), B = prop(E, "rounded", 7, "none"), V = prop(E, "caption", 7), U = prop(E, "imgClass", 7), W = prop(E, "figClass", 7), G = prop(E, "captionClass", 7), K = prop(E, "href", 7), J = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"src",
		"size",
		"alignment",
		"effect",
		"shadow",
		"rounded",
		"caption",
		"imgClass",
		"figClass",
		"captionClass",
		"href"
	]), Y = /* @__PURE__ */ user_derived(() => img({
		size: F(),
		alignment: I(),
		effect: L(),
		shadow: z(),
		rounded: B()
	})), X = /* @__PURE__ */ user_derived(() => get(Y).base), Z = /* @__PURE__ */ user_derived(() => get(Y).figure), Q = /* @__PURE__ */ user_derived(() => get(Y).figureCaption);
	var NL = {
		get src() {
			return O();
		},
		set src(C) {
			O(C), flushSync();
		},
		get size() {
			return F();
		},
		set size(C = "none") {
			F(C), flushSync();
		},
		get alignment() {
			return I();
		},
		set alignment(C = "left") {
			I(C), flushSync();
		},
		get effect() {
			return L();
		},
		set effect(C = "none") {
			L(C), flushSync();
		},
		get shadow() {
			return z();
		},
		set shadow(C = "none") {
			z(C), flushSync();
		},
		get rounded() {
			return B();
		},
		set rounded(C = "none") {
			B(C), flushSync();
		},
		get caption() {
			return V();
		},
		set caption(C) {
			V(C), flushSync();
		},
		get imgClass() {
			return U();
		},
		set imgClass(C) {
			U(C), flushSync();
		},
		get figClass() {
			return W();
		},
		set figClass(C) {
			W(C), flushSync();
		},
		get captionClass() {
			return G();
		},
		set captionClass(C) {
			G(C), flushSync();
		},
		get href() {
			return K();
		},
		set href(C) {
			K(C), flushSync();
		}
	}, PL = comment(), FL = first_child(PL), IL = (C) => {
		var T = root_4$13();
		D(child(T)), reset(T), template_effect(() => set_attribute(T, "href", K())), append(C, T);
	}, LL = (C) => {
		D(C);
	};
	return if_block(FL, (C) => {
		K() ? C(IL) : C(LL, !1);
	}), append(C, PL), pop(NL);
}
create_custom_element(ImgEnhanced, {
	src: {},
	size: {},
	alignment: {},
	effect: {},
	shadow: {},
	rounded: {},
	caption: {},
	imgClass: {},
	figClass: {},
	captionClass: {},
	href: {}
}, [], [], !0);
const img = ce({
	slots: {
		base: "max-w-full h-auto",
		figure: "",
		figureCaption: "mt-2 text-sm text-center text-gray-500 dark:text-gray-400"
	},
	variants: {
		size: {
			xs: {
				base: "max-w-xs",
				figure: "max-w-xs"
			},
			sm: {
				base: "max-w-sm",
				figure: "max-w-sm"
			},
			md: {
				base: "max-w-md",
				figure: "max-w-md"
			},
			lg: {
				base: "max-w-lg",
				figure: "max-w-lg"
			},
			xl: {
				base: "max-w-xl",
				figure: "max-w-xl"
			},
			"2xl": {
				base: "max-w-2xl",
				figure: "max-w-2xl"
			},
			full: {
				base: "max-w-full",
				figure: "max-w-full"
			},
			none: {
				base: "",
				figure: ""
			}
		},
		alignment: {
			left: {},
			center: {
				base: "mx-auto",
				figure: "mx-auto"
			},
			right: {
				base: "ms-auto",
				figure: "ms-auto"
			}
		},
		effect: {
			grayscale: { base: "cursor-pointer rounded-lg grayscale filter transition-all duration-300 hover:grayscale-0" },
			blur: { base: "blur-sm transition-all duration-300 hover:blur-none" },
			invert: { base: "invert filter transition-all duration-300 hover:invert-0" },
			sepia: { base: "sepia filter transition-all duration-300 hover:sepia-0" },
			saturate: { base: "saturate-50 filter transition-all duration-300 hover:saturate-100" },
			"hue-rotate": { base: "hue-rotate-60 filter transition-all duration-300 hover:hue-rotate-0" },
			none: { base: "transition-all duration-300" }
		},
		shadow: {
			sm: { base: "shadow-sm" },
			regular: { base: "shadow" },
			md: { base: "shadow-md" },
			lg: { base: "shadow-lg" },
			xl: { base: "shadow-xl" },
			"2xl": { base: "shadow-2xl" },
			inner: { base: "shadow-inner" },
			none: { base: "shadow-none" }
		},
		rounded: {
			sm: { base: "rounded-sm" },
			regular: { base: "rounded" },
			md: { base: "rounded-md" },
			lg: { base: "rounded-lg" },
			xl: { base: "rounded-xl" },
			"2xl": { base: "rounded-2xl" },
			"3xl": { base: "rounded-3xl" },
			full: { base: "rounded-full" },
			none: { base: "rounded-none" }
		}
	}
});
var root$40 = /* @__PURE__ */ from_html("<div><!></div>");
function Layout$1(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "class", 7), F = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"class"
	]), I = /* @__PURE__ */ user_derived(() => layout({ className: O() }));
	var L = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get class() {
			return O();
		},
		set class(C) {
			O(C), flushSync();
		}
	}, z = root$40();
	return attribute_effect(z, () => _objectSpread2(_objectSpread2({}, F), {}, { class: get(I) })), snippet(child(z), D), reset(z), append(C, z), pop(L);
}
create_custom_element(Layout$1, {
	children: {},
	class: {}
}, [], [], !0);
const layout = ce({ base: "grid grid-cols-1 sm:grid-cols-2" });
function List$1(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "tag", 7, "ul"), F = prop(E, "isContenteditable", 7, !1), I = prop(E, "position", 7, "inside"), L = prop(E, "ctxClass", 7), z = prop(E, "class", 7), B = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"tag",
		"isContenteditable",
		"position",
		"ctxClass",
		"class"
	]), V = /* @__PURE__ */ state(proxy(L() || ""));
	setContext("ctxClass", () => get(V)), user_effect(() => {
		set(V, L() || "", !0);
	});
	let U = /* @__PURE__ */ user_derived(() => list({
		position: I(),
		tag: O(),
		className: z()
	}));
	var W = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get tag() {
			return O();
		},
		set tag(C = "ul") {
			O(C), flushSync();
		},
		get isContenteditable() {
			return F();
		},
		set isContenteditable(C = !1) {
			F(C), flushSync();
		},
		get position() {
			return I();
		},
		set position(C = "inside") {
			I(C), flushSync();
		},
		get ctxClass() {
			return L();
		},
		set ctxClass(C) {
			L(C), flushSync();
		},
		get class() {
			return z();
		},
		set class(C) {
			z(C), flushSync();
		}
	}, G = comment();
	return element(first_child(G), O, !1, (C, E) => {
		attribute_effect(C, () => _objectSpread2(_objectSpread2({}, B), {}, {
			class: get(U),
			contenteditable: F()
		}));
		var O = comment();
		snippet(first_child(O), D), append(E, O);
	}), append(C, G), pop(W);
}
create_custom_element(List$1, {
	children: {},
	tag: {},
	isContenteditable: {},
	position: {},
	ctxClass: {},
	class: {}
}, [], [], !0);
var root$39 = /* @__PURE__ */ from_html("<li><!></li>");
function Li(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "icon", 7), F = prop(E, "class", 7), I = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"icon",
		"class"
	]), L = getContext("ctxClass"), z = /* @__PURE__ */ user_derived(() => twMerge(L(), O() && "flex items-center", F()));
	var B = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get icon() {
			return O();
		},
		set icon(C) {
			O(C), flushSync();
		},
		get class() {
			return F();
		},
		set class(C) {
			F(C), flushSync();
		}
	}, V = root$39();
	return attribute_effect(V, () => _objectSpread2(_objectSpread2({}, I), {}, { class: get(z) })), snippet(child(V), D), reset(V), append(C, V), pop(B);
}
create_custom_element(Li, {
	children: {},
	icon: {},
	class: {}
}, [], [], !0);
const list = ce({
	base: "",
	variants: {
		tag: {
			ul: "list-disc",
			dl: "list-none",
			ol: "list-decimal"
		},
		position: {
			inside: "list-inside",
			outside: "list-outside"
		}
	},
	defaultVariants: {
		position: "inside",
		tag: "ul"
	}
});
var root$38 = /* @__PURE__ */ from_html("<mark><!></mark>");
function Mark(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "class", 7), F = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"class"
	]);
	var I = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get class() {
			return O();
		},
		set class(C) {
			O(C), flushSync();
		}
	}, L = root$38();
	return attribute_effect(L, (C) => _objectSpread2(_objectSpread2({}, F), {}, { class: C }), [() => twMerge(mark(), O())]), snippet(child(L), D), reset(L), append(C, L), pop(I);
}
create_custom_element(Mark, {
	children: {},
	class: {}
}, [], [], !0);
const mark = ce({ base: "text-white dark:bg-blue-500 bg-blue-600 px-2 rounded" });
var root$37 = /* @__PURE__ */ from_html("<p><!></p>");
function P(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "class", 7, "text-gray-900 dark:text-white"), F = prop(E, "height", 7, "normal"), I = prop(E, "align", 7, "left"), L = prop(E, "justify", 7, !1), z = prop(E, "italic", 7), B = prop(E, "firstUpper", 7, !1), V = prop(E, "whitespace", 7, "normal"), U = prop(E, "size", 7, "base"), W = prop(E, "space", 7, "normal"), G = prop(E, "weight", 7, "normal"), K = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"class",
		"height",
		"align",
		"justify",
		"italic",
		"firstUpper",
		"whitespace",
		"size",
		"space",
		"weight"
	]), J = /* @__PURE__ */ user_derived(() => paragraph({
		height: F(),
		size: U(),
		weight: G(),
		space: W(),
		align: I(),
		justify: L(),
		italic: z(),
		firstUpper: B(),
		whitespace: V(),
		className: O()
	}));
	var Y = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get class() {
			return O();
		},
		set class(C = "text-gray-900 dark:text-white") {
			O(C), flushSync();
		},
		get height() {
			return F();
		},
		set height(C = "normal") {
			F(C), flushSync();
		},
		get align() {
			return I();
		},
		set align(C = "left") {
			I(C), flushSync();
		},
		get justify() {
			return L();
		},
		set justify(C = !1) {
			L(C), flushSync();
		},
		get italic() {
			return z();
		},
		set italic(C) {
			z(C), flushSync();
		},
		get firstUpper() {
			return B();
		},
		set firstUpper(C = !1) {
			B(C), flushSync();
		},
		get whitespace() {
			return V();
		},
		set whitespace(C = "normal") {
			V(C), flushSync();
		},
		get size() {
			return U();
		},
		set size(C = "base") {
			U(C), flushSync();
		},
		get space() {
			return W();
		},
		set space(C = "normal") {
			W(C), flushSync();
		},
		get weight() {
			return G();
		},
		set weight(C = "normal") {
			G(C), flushSync();
		}
	}, X = root$37();
	return attribute_effect(X, () => _objectSpread2(_objectSpread2({}, K), {}, { class: get(J) })), snippet(child(X), D), reset(X), append(C, X), pop(Y);
}
create_custom_element(P, {
	children: {},
	class: {},
	height: {},
	align: {},
	justify: {},
	italic: {},
	firstUpper: {},
	whitespace: {},
	size: {},
	space: {},
	weight: {}
}, [], [], !0);
const paragraph = ce({
	base: "text-gray-900 dark:text-white",
	variants: {
		size: {
			xs: "text-xs",
			sm: "text-sm",
			base: "text-base",
			lg: "text-lg",
			xl: "text-xl",
			"2xl": "text-2xl",
			"3xl": "text-3xl",
			"4xl": "text-4xl",
			"5xl": "text-5xl",
			"6xl": "text-6xl",
			"7xl": "text-7xl",
			"8xl": "text-8xl",
			"9xl": "text-9xl"
		},
		weight: {
			thin: "font-thin",
			extralight: "font-extralight",
			light: "font-light",
			normal: "font-normal",
			medium: "font-medium",
			semibold: "font-semibold",
			bold: "font-bold",
			extrabold: "font-extrabold",
			black: "font-black"
		},
		space: {
			tighter: "tracking-tighter",
			tight: "tracking-tight",
			normal: "tracking-normal",
			wide: "tracking-wide",
			wider: "tracking-wider",
			widest: "tracking-widest"
		},
		height: {
			none: "leading-none",
			tight: "leading-tight",
			snug: "leading-snug",
			normal: "leading-normal",
			relaxed: "leading-relaxed",
			loose: "leading-loose",
			3: "leading-3",
			4: "leading-4",
			5: "leading-5",
			6: "leading-6",
			7: "leading-7",
			8: "leading-8",
			9: "leading-9",
			10: "leading-10"
		},
		align: {
			left: "text-left",
			center: "text-center",
			right: "text-right"
		},
		whitespace: {
			normal: "whitespace-normal",
			nowrap: "whitespace-nowrap",
			pre: "whitespace-pre",
			preline: "whitespace-pre-line",
			prewrap: "whitespace-pre-wrap"
		},
		italic: { true: "italic" },
		firstUpper: {
			true: "first-line:uppercase first-line:tracking-widest first-letter:text-7xl first-letter:font-bold first-letter:text-gray-900 dark:first-letter:text-gray-100 first-letter:me-3 first-letter:float-left",
			false: ""
		},
		justify: {
			true: "text-justify",
			false: ""
		}
	}
});
var root$36 = /* @__PURE__ */ from_html("<small><!></small>");
function Secondary(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "class", 7), F = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"class"
	]);
	var I = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get class() {
			return O();
		},
		set class(C) {
			O(C), flushSync();
		}
	}, L = root$36();
	return attribute_effect(L, (C) => _objectSpread2(_objectSpread2({}, F), {}, { class: C }), [() => twMerge(secondary(), O())]), snippet(child(L), D), reset(L), append(C, L), pop(I);
}
create_custom_element(Secondary, {
	children: {},
	class: {}
}, [], [], !0);
const secondary = ce({ base: "text-gray-500 dark:text-gray-400 font-semibold" });
var root$35 = /* @__PURE__ */ from_html("<span><!></span>");
function Span$1(C, E) {
	push(E, !0);
	let D = prop(E, "children", 7), O = prop(E, "class", 7), F = prop(E, "italic", 7), I = prop(E, "underline", 7), L = prop(E, "linethrough", 7), z = prop(E, "uppercase", 7), B = prop(E, "gradient", 7), V = prop(E, "highlight", 7), U = prop(E, "decoration", 7), W = prop(E, "decorationColor", 7), G = prop(E, "decorationThickness", 7), K = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"children",
		"class",
		"italic",
		"underline",
		"linethrough",
		"uppercase",
		"gradient",
		"highlight",
		"decoration",
		"decorationColor",
		"decorationThickness"
	]), J = /* @__PURE__ */ user_derived(() => span({
		italic: F(),
		underline: I(),
		linethrough: L(),
		uppercase: z(),
		gradient: B(),
		highlight: V(),
		decoration: U(),
		decorationColor: W(),
		decorationThickness: G(),
		className: O()
	}));
	var Y = {
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		},
		get class() {
			return O();
		},
		set class(C) {
			O(C), flushSync();
		},
		get italic() {
			return F();
		},
		set italic(C) {
			F(C), flushSync();
		},
		get underline() {
			return I();
		},
		set underline(C) {
			I(C), flushSync();
		},
		get linethrough() {
			return L();
		},
		set linethrough(C) {
			L(C), flushSync();
		},
		get uppercase() {
			return z();
		},
		set uppercase(C) {
			z(C), flushSync();
		},
		get gradient() {
			return B();
		},
		set gradient(C) {
			B(C), flushSync();
		},
		get highlight() {
			return V();
		},
		set highlight(C) {
			V(C), flushSync();
		},
		get decoration() {
			return U();
		},
		set decoration(C) {
			U(C), flushSync();
		},
		get decorationColor() {
			return W();
		},
		set decorationColor(C) {
			W(C), flushSync();
		},
		get decorationThickness() {
			return G();
		},
		set decorationThickness(C) {
			G(C), flushSync();
		}
	}, X = root$35();
	attribute_effect(X, () => _objectSpread2(_objectSpread2({}, K), {}, { class: get(J) }));
	var Z = child(X), Q = (C) => {
		var T = comment();
		snippet(first_child(T), D), append(C, T);
	};
	return if_block(Z, (C) => {
		D() && C(Q);
	}), reset(X), append(C, X), pop(Y);
}
create_custom_element(Span$1, {
	children: {},
	class: {},
	italic: {},
	underline: {},
	linethrough: {},
	uppercase: {},
	gradient: {},
	highlight: {},
	decoration: {},
	decorationColor: {},
	decorationThickness: {}
}, [], [], !0);
const span = ce({ variants: {
	italic: { true: "italic" },
	underline: { true: "underline decoration-2 decoration-blue-400 dark:decoration-blue-600" },
	linethrough: { true: "line-through" },
	uppercase: { true: "uppercase" },
	gradient: {
		skyToEmerald: "text-transparent bg-clip-text bg-gradient-to-r to-emerald-600 from-sky-400",
		purpleToBlue: "text-transparent bg-clip-text bg-gradient-to-r from-purple-500 to-blue-500",
		pinkToOrange: "text-transparent bg-clip-text bg-gradient-to-r from-pink-500 to-orange-400",
		tealToLime: "text-transparent bg-clip-text bg-gradient-to-r from-teal-400 to-lime-300",
		redToYellow: "text-transparent bg-clip-text bg-gradient-to-r from-red-600 to-yellow-500",
		indigoToCyan: "text-transparent bg-clip-text bg-gradient-to-r from-indigo-600 to-cyan-400",
		fuchsiaToRose: "text-transparent bg-clip-text bg-gradient-to-r from-fuchsia-500 to-rose-500",
		amberToEmerald: "text-transparent bg-clip-text bg-gradient-to-r from-amber-400 to-emerald-500",
		violetToRed: "text-transparent bg-clip-text bg-gradient-to-r from-violet-600 to-red-500",
		blueToGreen: "text-transparent bg-clip-text bg-gradient-to-r from-blue-400 via-teal-500 to-green-400",
		orangeToPurple: "text-transparent bg-clip-text bg-gradient-to-r from-orange-400 via-pink-500 to-purple-500",
		yellowToRed: "text-transparent bg-clip-text bg-gradient-to-r from-yellow-200 via-indigo-400 to-red-600",
		none: ""
	},
	highlight: {
		blue: "text-blue-600 dark:text-blue-500",
		green: "text-green-600 dark:text-green-500",
		red: "text-red-600 dark:text-red-500",
		yellow: "text-yellow-600 dark:text-yellow-500",
		purple: "text-purple-600 dark:text-purple-500",
		pink: "text-pink-600 dark:text-pink-500",
		indigo: "text-indigo-600 dark:text-indigo-500",
		teal: "text-teal-600 dark:text-teal-500",
		orange: "text-orange-600 dark:text-orange-500",
		cyan: "text-cyan-600 dark:text-cyan-500",
		fuchsia: "text-fuchsia-600 dark:text-fuchsia-500",
		amber: "text-amber-600 dark:text-amber-500",
		lime: "text-lime-600 dark:text-lime-500",
		none: ""
	},
	decoration: {
		solid: "underline decoratio-solid",
		double: "underline decoration-double",
		dotted: "underline decoration-dotted",
		dashed: "underline decoration-dashed",
		wavy: "underline decoration-wavy",
		none: "decoration-none"
	},
	decorationColor: {
		primary: "underline decoration-primary-400 dark:decoration-primary-600",
		secondary: "underline decoration-secondary-400 dark:decoration-secondary-600",
		gray: "underline decoration-gray-400 dark:decoration-gray-600",
		orange: "underline decoration-orange-400 dark:decoration-orange-600",
		red: "underline decoration-red-400 dark:decoration-red-600",
		yellow: "underline decoration-yellow-400 dark:decoration-yellow-600",
		lime: "underline decoration-lime-400 dark:decoration-lime-600",
		green: "underline decoration-green-400 dark:decoration-green-600",
		emerald: "underline decoration-emerald-400 dark:decoration-emerald-600",
		teal: "underline decoration-teal-400 dark:decoration-teal-600",
		cyan: "underline decoration-cyan-400 dark:decoration-cyan-600",
		sky: "underline decoration-sky-400 dark:decoration-sky-600",
		blue: "underline decoration-blue-400 dark:decoration-blue-600",
		indigo: "underline decoration-indigo-400 dark:decoration-indigo-600",
		violet: "underline decoration-violet-400 dark:decoration-violet-600",
		purple: "underline decoration-purple-400 dark:decoration-purple-600",
		fuchsia: "underline decoration-fuchsia-400 dark:decoration-fuchsia-600",
		pink: "underline decoration-pink-400 dark:decoration-pink-600",
		rose: "underline decoration-rose-400 dark:decoration-rose-600",
		none: "decoration-none"
	},
	decorationThickness: {
		1: "underline decoration-1",
		2: "underline decoration-2",
		4: "underline decoration-4",
		8: "underline decoration-8",
		0: "decoration-0"
	}
} });
function ThemeProvider(C, T) {
	push(T, !0);
	let E = prop(T, "children", 7), D = prop(T, "theme", 7);
	D() ? setContext("theme", D()) : console.log("ThemeProvider: No theme provided");
	var O = {
		get children() {
			return E();
		},
		set children(C) {
			E(C), flushSync();
		},
		get theme() {
			return D();
		},
		set theme(C) {
			D(C), flushSync();
		}
	}, F = comment();
	return snippet(first_child(F), E), append(C, F), pop(O);
}
create_custom_element(ThemeProvider, {
	children: {},
	theme: {}
}, [], [], !0);
var TransferObject = class {}, PanelTransfer = class extends TransferObject {
	constructor(C, T, E) {
		super(), this.viewId = C, this.groupId = T, this.panelId = E;
	}
}, PaneTransfer = class extends TransferObject {
	constructor(C, T) {
		super(), this.viewId = C, this.paneId = T;
	}
}, LocalSelectionTransfer = class C {
	constructor() {}
	static getInstance() {
		return C.INSTANCE;
	}
	hasData(C) {
		return C && C === this.proto;
	}
	clearData(C) {
		this.hasData(C) && (this.proto = void 0, this.data = void 0);
	}
	getData(C) {
		if (this.hasData(C)) return this.data;
	}
	setData(C, T) {
		T && (this.data = C, this.proto = T);
	}
};
LocalSelectionTransfer.INSTANCE = new LocalSelectionTransfer();
function getPanelData() {
	let C = LocalSelectionTransfer.getInstance();
	if (C.hasData(PanelTransfer.prototype)) return C.getData(PanelTransfer.prototype)[0];
}
function getPaneData() {
	let C = LocalSelectionTransfer.getInstance();
	if (C.hasData(PaneTransfer.prototype)) return C.getData(PaneTransfer.prototype)[0];
}
var Event$2;
(function(C) {
	C.any = (...C) => (T) => {
		let E = C.map((C) => C(T));
		return { dispose: () => {
			E.forEach((C) => {
				C.dispose();
			});
		} };
	};
})(Event$2 || (Event$2 = {}));
var DockviewEvent = class {
	constructor() {
		this._defaultPrevented = !1;
	}
	get defaultPrevented() {
		return this._defaultPrevented;
	}
	preventDefault() {
		this._defaultPrevented = !0;
	}
}, AcceptableEvent = class {
	constructor() {
		this._isAccepted = !1;
	}
	get isAccepted() {
		return this._isAccepted;
	}
	accept() {
		this._isAccepted = !0;
	}
}, LeakageMonitor = class {
	constructor() {
		this.events = /* @__PURE__ */ new Map();
	}
	get size() {
		return this.events.size;
	}
	add(C, T) {
		this.events.set(C, T);
	}
	delete(C) {
		this.events.delete(C);
	}
	clear() {
		this.events.clear();
	}
}, Stacktrace = class C {
	static create() {
		var T;
		return new C((T = (/* @__PURE__ */ Error()).stack) == null ? "" : T);
	}
	constructor(C) {
		this.value = C;
	}
	print() {
		console.warn("dockview: stacktrace", this.value);
	}
}, Listener = class {
	constructor(C, T) {
		this.callback = C, this.stacktrace = T;
	}
}, Emitter = class C {
	static setLeakageMonitorEnabled(T) {
		T !== C.ENABLE_TRACKING && C.MEMORY_LEAK_WATCHER.clear(), C.ENABLE_TRACKING = T;
	}
	get value() {
		return this._last;
	}
	constructor(C) {
		this.options = C, this._listeners = [], this._disposed = !1;
	}
	get event() {
		return this._event || (this._event = (T) => {
			var E;
			(E = this.options) != null && E.replay && this._last !== void 0 && T(this._last);
			let D = new Listener(T, C.ENABLE_TRACKING ? Stacktrace.create() : void 0);
			return this._listeners.push(D), { dispose: () => {
				let T = this._listeners.indexOf(D);
				T > -1 ? this._listeners.splice(T, 1) : C.ENABLE_TRACKING;
			} };
		}, C.ENABLE_TRACKING && C.MEMORY_LEAK_WATCHER.add(this._event, Stacktrace.create())), this._event;
	}
	fire(C) {
		var T;
		(T = this.options) != null && T.replay && (this._last = C);
		for (let T of this._listeners) T.callback(C);
	}
	dispose() {
		this._disposed || (this._disposed = !0, this._listeners.length > 0 && (C.ENABLE_TRACKING && queueMicrotask(() => {
			var C;
			for (let T of this._listeners) console.warn("dockview: stacktrace", (C = T.stacktrace) == null ? void 0 : C.print());
		}), this._listeners = []), C.ENABLE_TRACKING && this._event && C.MEMORY_LEAK_WATCHER.delete(this._event));
	}
};
Emitter.ENABLE_TRACKING = !1, Emitter.MEMORY_LEAK_WATCHER = new LeakageMonitor();
function addDisposableListener(C, T, E, D) {
	return C.addEventListener(T, E, D), { dispose: () => {
		C.removeEventListener(T, E, D);
	} };
}
var AsapEvent = class {
	constructor() {
		this._onFired = new Emitter(), this._currentFireCount = 0, this._queued = !1, this.onEvent = (C) => {
			let T = this._currentFireCount;
			return this._onFired.event(() => {
				this._currentFireCount > T && C();
			});
		};
	}
	fire() {
		this._currentFireCount++, !this._queued && (this._queued = !0, queueMicrotask(() => {
			this._queued = !1, this._onFired.fire();
		}));
	}
	dispose() {
		this._onFired.dispose();
	}
}, Disposable;
(function(C) {
	C.NONE = { dispose: () => {} };
	function T(C) {
		return { dispose: () => {
			C();
		} };
	}
	C.from = T;
})(Disposable || (Disposable = {}));
var CompositeDisposable = class {
	get isDisposed() {
		return this._isDisposed;
	}
	constructor(...C) {
		this._isDisposed = !1, this._disposables = C;
	}
	addDisposables(...C) {
		C.forEach((C) => this._disposables.push(C));
	}
	dispose() {
		this._isDisposed || (this._isDisposed = !0, this._disposables.forEach((C) => C.dispose()), this._disposables = []);
	}
}, MutableDisposable = class {
	constructor() {
		this._disposable = Disposable.NONE;
	}
	set value(C) {
		this._disposable && this._disposable.dispose(), this._disposable = C;
	}
	dispose() {
		this._disposable && (this._disposable.dispose(), this._disposable = Disposable.NONE);
	}
}, OverflowObserver = class extends CompositeDisposable {
	constructor(C) {
		super(), this._onDidChange = new Emitter(), this.onDidChange = this._onDidChange.event, this._value = null, this.addDisposables(this._onDidChange, watchElementResize(C, (C) => {
			this._value = {
				hasScrollX: C.target.scrollWidth > C.target.clientWidth,
				hasScrollY: C.target.scrollHeight > C.target.clientHeight
			}, this._onDidChange.fire(this._value);
		}));
	}
};
function watchElementResize(C, T) {
	let E = new ResizeObserver((C) => {
		requestAnimationFrame(() => {
			let E = C[0];
			T(E);
		});
	});
	return E.observe(C), { dispose: () => {
		E.unobserve(C), E.disconnect();
	} };
}
const removeClasses = (C, ...T) => {
	for (let E of T) C.classList.contains(E) && C.classList.remove(E);
}, addClasses = (C, ...T) => {
	for (let E of T) C.classList.contains(E) || C.classList.add(E);
}, toggleClass = (C, T, E) => {
	let D = C.classList.contains(T);
	E && !D && C.classList.add(T), !E && D && C.classList.remove(T);
};
function isAncestor(C, T) {
	for (; C;) {
		if (C === T) return !0;
		C = C.parentNode;
	}
	return !1;
}
function trackFocus(C) {
	return new FocusTracker(C);
}
var FocusTracker = class extends CompositeDisposable {
	constructor(C) {
		super(), this._onDidFocus = new Emitter(), this.onDidFocus = this._onDidFocus.event, this._onDidBlur = new Emitter(), this.onDidBlur = this._onDidBlur.event, this.addDisposables(this._onDidFocus, this._onDidBlur);
		let T = isAncestor(document.activeElement, C), E = !1, D = () => {
			E = !1, T || (T = !0, this._onDidFocus.fire());
		}, O = () => {
			T && (E = !0, window.setTimeout(() => {
				E && (E = !1, T = !1, this._onDidBlur.fire());
			}, 0));
		};
		this._refreshStateHandler = () => {
			isAncestor(document.activeElement, C) !== T && (T ? O() : D());
		}, this.addDisposables(addDisposableListener(C, "focus", D, !0)), this.addDisposables(addDisposableListener(C, "blur", O, !0));
	}
	refreshState() {
		this._refreshStateHandler();
	}
}, QUASI_PREVENT_DEFAULT_KEY = "dv-quasiPreventDefault";
function quasiPreventDefault(C) {
	C[QUASI_PREVENT_DEFAULT_KEY] = !0;
}
function quasiDefaultPrevented(C) {
	return C[QUASI_PREVENT_DEFAULT_KEY];
}
function addStyles(C, T) {
	let E = Array.from(T);
	for (let T of E) {
		if (T.href) {
			let E = C.createElement("link");
			E.href = T.href, E.type = T.type, E.rel = "stylesheet", C.head.appendChild(E);
		}
		let E = [];
		try {
			T.cssRules && (E = Array.from(T.cssRules).map((C) => C.cssText));
		} catch (C) {}
		for (let T of E) {
			let E = C.createElement("style");
			E.appendChild(C.createTextNode(T)), C.head.appendChild(E);
		}
	}
}
function getDomNodePagePosition(C) {
	let { left: T, top: E, width: D, height: O } = C.getBoundingClientRect();
	return {
		left: T + window.scrollX,
		top: E + window.scrollY,
		width: D,
		height: O
	};
}
function isInDocument(C) {
	let T = C;
	for (; T != null && T.parentNode;) if (T.parentNode === document) return !0;
	else T = T.parentNode instanceof DocumentFragment ? T.parentNode.host : T.parentNode;
	return !1;
}
function addTestId(C, T) {
	C.setAttribute("data-testid", T);
}
function allTagsNamesInclusiveOfShadowDoms(C) {
	let T = [];
	function E(D) {
		if (D.nodeType === Node.ELEMENT_NODE) {
			C.includes(D.tagName) && T.push(D), D.shadowRoot && E(D.shadowRoot);
			for (let C of D.children) E(C);
		}
	}
	return E(document.documentElement), T;
}
function disableIframePointEvents(C = document) {
	let T = allTagsNamesInclusiveOfShadowDoms(["IFRAME", "WEBVIEW"]), E = /* @__PURE__ */ new WeakMap();
	for (let C of T) E.set(C, C.style.pointerEvents), C.style.pointerEvents = "none";
	return { release: () => {
		var C;
		for (let D of T) D.style.pointerEvents = (C = E.get(D)) == null ? "auto" : C;
		T.splice(0, T.length);
	} };
}
function getDockviewTheme(C) {
	function T(C) {
		let T = [];
		for (let E = 0; E < C.classList.length; E++) T.push(C.classList.item(E));
		return T;
	}
	let E, D = C;
	for (; D !== null && (E = T(D).find((C) => C.startsWith("dockview-theme-")), typeof E != "string");) D = D.parentElement;
	return E;
}
var Classnames = class {
	constructor(C) {
		this.element = C, this._classNames = [];
	}
	setClassNames(C) {
		for (let C of this._classNames) toggleClass(this.element, C, !1);
		this._classNames = C.split(" ").filter((C) => C.trim().length > 0);
		for (let C of this._classNames) toggleClass(this.element, C, !0);
	}
}, DEBOUCE_DELAY = 100;
function isChildEntirelyVisibleWithinParent(C, T) {
	let E = getDomNodePagePosition(C), D = getDomNodePagePosition(T);
	return !(E.left < D.left || E.left + E.width > D.left + D.width);
}
function onDidWindowMoveEnd(C) {
	let T = new Emitter(), E = C.screenX, D = C.screenY, O, F = () => {
		if (C.closed) return;
		let I = C.screenX, L = C.screenY;
		(I !== E || L !== D) && (clearTimeout(O), O = setTimeout(() => {
			T.fire();
		}, DEBOUCE_DELAY), E = I, D = L), requestAnimationFrame(F);
	};
	return F(), T;
}
function onDidWindowResizeEnd(C, T) {
	let E;
	return new CompositeDisposable(addDisposableListener(C, "resize", () => {
		clearTimeout(E), E = setTimeout(() => {
			T();
		}, DEBOUCE_DELAY);
	}));
}
function shiftAbsoluteElementIntoView(C, T, E = { buffer: 10 }) {
	let D = E.buffer, O = C.getBoundingClientRect(), F = T.getBoundingClientRect(), I = 0, L = 0, z = O.left - F.left, B = O.top - F.top, V = O.bottom - F.bottom, U = O.right - F.right;
	z < D ? I = D - z : U > D && (I = -D - U), B < D ? L = D - B : V > D && (L = -V - D), (I !== 0 || L !== 0) && (C.style.transform = `translate(${I}px, ${L}px)`);
}
function findRelativeZIndexParent(C) {
	let T = C;
	for (; T && (T.style.zIndex === "auto" || T.style.zIndex === "");) T = T.parentElement;
	return T;
}
function tail(C) {
	if (C.length === 0) throw Error("Invalid tail call");
	return [C.slice(0, C.length - 1), C[C.length - 1]];
}
function sequenceEquals(C, T) {
	if (C.length !== T.length) return !1;
	for (let E = 0; E < C.length; E++) if (C[E] !== T[E]) return !1;
	return !0;
}
function pushToStart(C, T) {
	let E = C.indexOf(T);
	E > -1 && (C.splice(E, 1), C.unshift(T));
}
function pushToEnd(C, T) {
	let E = C.indexOf(T);
	E > -1 && (C.splice(E, 1), C.push(T));
}
function firstIndex(C, T) {
	for (let E = 0; E < C.length; E++) {
		let D = C[E];
		if (T(D)) return E;
	}
	return -1;
}
function remove(C, T) {
	let E = C.findIndex((C) => C === T);
	return E > -1 ? (C.splice(E, 1), !0) : !1;
}
const clamp = (C, T, E) => T > E ? T : Math.min(E, Math.max(C, T)), sequentialNumberGenerator = () => {
	let C = 1;
	return { next: () => (C++).toString() };
}, range = (C, T) => {
	let E = [];
	if (typeof T != "number" && (T = C, C = 0), C <= T) for (let D = C; D < T; D++) E.push(D);
	else for (let D = C; D > T; D--) E.push(D);
	return E;
};
var ViewItem = class {
	set size(C) {
		this._size = C;
	}
	get size() {
		return this._size;
	}
	get cachedVisibleSize() {
		return this._cachedVisibleSize;
	}
	get visible() {
		return this._cachedVisibleSize === void 0;
	}
	get minimumSize() {
		return this.visible ? this.view.minimumSize : 0;
	}
	get viewMinimumSize() {
		return this.view.minimumSize;
	}
	get maximumSize() {
		return this.visible ? this.view.maximumSize : 0;
	}
	get viewMaximumSize() {
		return this.view.maximumSize;
	}
	get priority() {
		return this.view.priority;
	}
	get snap() {
		return !!this.view.snap;
	}
	set enabled(C) {
		this.container.style.pointerEvents = C ? "" : "none";
	}
	constructor(C, T, E, D) {
		this.container = C, this.view = T, this.disposable = D, this._cachedVisibleSize = void 0, typeof E == "number" ? (this._size = E, this._cachedVisibleSize = void 0, C.classList.add("visible")) : (this._size = 0, this._cachedVisibleSize = E.cachedVisibleSize);
	}
	setVisible(C, T) {
		var E;
		C !== this.visible && (C ? (this.size = clamp((E = this._cachedVisibleSize) == null ? 0 : E, this.viewMinimumSize, this.viewMaximumSize), this._cachedVisibleSize = void 0) : (this._cachedVisibleSize = typeof T == "number" ? T : this.size, this.size = 0), this.container.classList.toggle("visible", C), this.view.setVisible && this.view.setVisible(C));
	}
	dispose() {
		return this.disposable.dispose(), this.view;
	}
}, Orientation;
(function(C) {
	C.HORIZONTAL = "HORIZONTAL", C.VERTICAL = "VERTICAL";
})(Orientation || (Orientation = {}));
var SashState;
(function(C) {
	C[C.MAXIMUM = 0] = "MAXIMUM", C[C.MINIMUM = 1] = "MINIMUM", C[C.DISABLED = 2] = "DISABLED", C[C.ENABLED = 3] = "ENABLED";
})(SashState || (SashState = {}));
var LayoutPriority;
(function(C) {
	C.Low = "low", C.High = "high", C.Normal = "normal";
})(LayoutPriority || (LayoutPriority = {}));
var Sizing;
(function(C) {
	C.Distribute = { type: "distribute" };
	function T(C) {
		return {
			type: "split",
			index: C
		};
	}
	C.Split = T;
	function E(C) {
		return {
			type: "invisible",
			cachedVisibleSize: C
		};
	}
	C.Invisible = E;
})(Sizing || (Sizing = {}));
var Splitview = class {
	get contentSize() {
		return this._contentSize;
	}
	get size() {
		return this._size;
	}
	set size(C) {
		this._size = C;
	}
	get orthogonalSize() {
		return this._orthogonalSize;
	}
	set orthogonalSize(C) {
		this._orthogonalSize = C;
	}
	get length() {
		return this.viewItems.length;
	}
	get proportions() {
		return this._proportions ? [...this._proportions] : void 0;
	}
	get orientation() {
		return this._orientation;
	}
	set orientation(C) {
		this._orientation = C;
		let T = this.size;
		this.size = this.orthogonalSize, this.orthogonalSize = T, removeClasses(this.element, "dv-horizontal", "dv-vertical"), this.element.classList.add(this.orientation == Orientation.HORIZONTAL ? "dv-horizontal" : "dv-vertical");
	}
	get minimumSize() {
		return this.viewItems.reduce((C, T) => C + T.minimumSize, 0);
	}
	get maximumSize() {
		return this.length === 0 ? Infinity : this.viewItems.reduce((C, T) => C + T.maximumSize, 0);
	}
	get startSnappingEnabled() {
		return this._startSnappingEnabled;
	}
	set startSnappingEnabled(C) {
		this._startSnappingEnabled !== C && (this._startSnappingEnabled = C, this.updateSashEnablement());
	}
	get endSnappingEnabled() {
		return this._endSnappingEnabled;
	}
	set endSnappingEnabled(C) {
		this._endSnappingEnabled !== C && (this._endSnappingEnabled = C, this.updateSashEnablement());
	}
	get disabled() {
		return this._disabled;
	}
	set disabled(C) {
		this._disabled = C, toggleClass(this.element, "dv-splitview-disabled", C);
	}
	get margin() {
		return this._margin;
	}
	set margin(C) {
		this._margin = C, toggleClass(this.element, "dv-splitview-has-margin", C !== 0);
	}
	constructor(C, T) {
		var E, D;
		this.container = C, this.viewItems = [], this.sashes = [], this._size = 0, this._orthogonalSize = 0, this._contentSize = 0, this._proportions = void 0, this._startSnappingEnabled = !0, this._endSnappingEnabled = !0, this._disabled = !1, this._margin = 0, this._onDidSashEnd = new Emitter(), this.onDidSashEnd = this._onDidSashEnd.event, this._onDidAddView = new Emitter(), this.onDidAddView = this._onDidAddView.event, this._onDidRemoveView = new Emitter(), this.onDidRemoveView = this._onDidRemoveView.event, this.resize = (C, T, E = this.viewItems.map((C) => C.size), D, O, F = -Infinity, I = Infinity, L, z) => {
			if (C < 0 || C > this.viewItems.length) return 0;
			let B = range(C, -1), V = range(C + 1, this.viewItems.length);
			if (O) for (let C of O) pushToStart(B, C), pushToStart(V, C);
			if (D) for (let C of D) pushToEnd(B, C), pushToEnd(V, C);
			let U = B.map((C) => this.viewItems[C]), W = B.map((C) => E[C]), G = V.map((C) => this.viewItems[C]), K = V.map((C) => E[C]), J = B.reduce((C, T) => C + this.viewItems[T].minimumSize - E[T], 0), Y = B.reduce((C, T) => C + this.viewItems[T].maximumSize - E[T], 0), X = V.length === 0 ? Infinity : V.reduce((C, T) => C + E[T] - this.viewItems[T].minimumSize, 0), Z = V.length === 0 ? -Infinity : V.reduce((C, T) => C + E[T] - this.viewItems[T].maximumSize, 0), Q = Math.max(J, Z), NL = Math.min(X, Y), PL = !1;
			if (L) {
				let C = this.viewItems[L.index], E = T >= L.limitDelta;
				PL = E !== C.visible, C.setVisible(E, L.size);
			}
			if (!PL && z) {
				let C = this.viewItems[z.index], E = T < z.limitDelta;
				PL = E !== C.visible, C.setVisible(E, z.size);
			}
			if (PL) return this.resize(C, T, E, D, O, F, I);
			let FL = clamp(T, Q, NL), IL = 0, LL = FL;
			for (let C = 0; C < U.length; C++) {
				let T = U[C], E = clamp(W[C] + LL, T.minimumSize, T.maximumSize), D = E - W[C];
				IL += D, LL -= D, T.size = E;
			}
			let RL = IL;
			for (let C = 0; C < G.length; C++) {
				let T = G[C], E = clamp(K[C] - RL, T.minimumSize, T.maximumSize), D = E - K[C];
				RL += D, T.size = E;
			}
			return T;
		}, this._orientation = (E = T.orientation) == null ? Orientation.VERTICAL : E, this.element = this.createContainer(), this.margin = (D = T.margin) == null ? 0 : D, this.proportionalLayout = T.proportionalLayout === void 0 ? !0 : !!T.proportionalLayout, this.viewContainer = this.createViewContainer(), this.sashContainer = this.createSashContainer(), this.element.appendChild(this.sashContainer), this.element.appendChild(this.viewContainer), this.container.appendChild(this.element), this.style(T.styles), T.descriptor && (this._size = T.descriptor.size, T.descriptor.views.forEach((C, T) => {
			let E = C.visible === void 0 || C.visible ? C.size : {
				type: "invisible",
				cachedVisibleSize: C.size
			}, D = C.view;
			this.addView(D, E, T, !0);
		}), this._contentSize = this.viewItems.reduce((C, T) => C + T.size, 0), this.saveProportions());
	}
	style(C) {
		(C == null ? void 0 : C.separatorBorder) === "transparent" ? (removeClasses(this.element, "dv-separator-border"), this.element.style.removeProperty("--dv-separator-border")) : (addClasses(this.element, "dv-separator-border"), C != null && C.separatorBorder && this.element.style.setProperty("--dv-separator-border", C.separatorBorder));
	}
	isViewVisible(C) {
		if (C < 0 || C >= this.viewItems.length) throw Error("Index out of bounds");
		return this.viewItems[C].visible;
	}
	setViewVisible(C, T) {
		if (C < 0 || C >= this.viewItems.length) throw Error("Index out of bounds");
		let E = this.viewItems[C];
		E.setVisible(T, E.size), this.distributeEmptySpace(C), this.layoutViews(), this.saveProportions();
	}
	getViewSize(C) {
		return C < 0 || C >= this.viewItems.length ? -1 : this.viewItems[C].size;
	}
	resizeView(C, T) {
		if (C < 0 || C >= this.viewItems.length) return;
		let E = range(this.viewItems.length).filter((T) => T !== C), D = [...E.filter((C) => this.viewItems[C].priority === LayoutPriority.Low), C], O = E.filter((C) => this.viewItems[C].priority === LayoutPriority.High), F = this.viewItems[C];
		T = Math.round(T), T = clamp(T, F.minimumSize, Math.min(F.maximumSize, this._size)), F.size = T, this.relayout(D, O);
	}
	getViews() {
		return this.viewItems.map((C) => C.view);
	}
	onDidChange(C, T) {
		let E = this.viewItems.indexOf(C);
		if (E < 0 || E >= this.viewItems.length) return;
		T = typeof T == "number" ? T : C.size, T = clamp(T, C.minimumSize, C.maximumSize), C.size = T;
		let D = range(this.viewItems.length).filter((C) => C !== E), O = [...D.filter((C) => this.viewItems[C].priority === LayoutPriority.Low), E], F = D.filter((C) => this.viewItems[C].priority === LayoutPriority.High);
		this.relayout([...O, E], F);
	}
	addView(C, T = { type: "distribute" }, E = this.viewItems.length, D) {
		let O = document.createElement("div");
		O.className = "dv-view", O.appendChild(C.element);
		let F;
		F = typeof T == "number" ? T : T.type === "split" ? this.getViewSize(T.index) / 2 : T.type === "invisible" ? { cachedVisibleSize: T.cachedVisibleSize } : C.minimumSize;
		let I = C.onDidChange((C) => this.onDidChange(L, C.size)), L = new ViewItem(O, C, F, { dispose: () => {
			I.dispose(), this.viewContainer.removeChild(O);
		} });
		if (E === this.viewItems.length ? this.viewContainer.appendChild(O) : this.viewContainer.insertBefore(O, this.viewContainer.children.item(E)), this.viewItems.splice(E, 0, L), this.viewItems.length > 1) {
			let C = document.createElement("div");
			C.className = "dv-sash";
			let T = (T) => {
				for (let C of this.viewItems) C.enabled = !1;
				let E = disableIframePointEvents(), D = this._orientation === Orientation.HORIZONTAL ? T.clientX : T.clientY, O = firstIndex(this.sashes, (T) => T.container === C), F = this.viewItems.map((C) => C.size), I, L, z = range(O, -1), B = range(O + 1, this.viewItems.length), V = z.reduce((C, T) => C + (this.viewItems[T].minimumSize - F[T]), 0), U = z.reduce((C, T) => C + (this.viewItems[T].viewMaximumSize - F[T]), 0), W = B.length === 0 ? Infinity : B.reduce((C, T) => C + (F[T] - this.viewItems[T].minimumSize), 0), G = B.length === 0 ? -Infinity : B.reduce((C, T) => C + (F[T] - this.viewItems[T].viewMaximumSize), 0), K = Math.max(V, G), J = Math.min(W, U), Y = this.findFirstSnapIndex(z), X = this.findFirstSnapIndex(B);
				if (typeof Y == "number") {
					let C = this.viewItems[Y], T = Math.floor(C.viewMinimumSize / 2);
					I = {
						index: Y,
						limitDelta: C.visible ? K - T : K + T,
						size: C.size
					};
				}
				if (typeof X == "number") {
					let C = this.viewItems[X], T = Math.floor(C.viewMinimumSize / 2);
					L = {
						index: X,
						limitDelta: C.visible ? J + T : J - T,
						size: C.size
					};
				}
				let Z = (C) => {
					let T = (this._orientation === Orientation.HORIZONTAL ? C.clientX : C.clientY) - D;
					this.resize(O, T, F, void 0, void 0, K, J, I, L), this.distributeEmptySpace(), this.layoutViews();
				}, Q = () => {
					for (let C of this.viewItems) C.enabled = !0;
					E.release(), this.saveProportions(), document.removeEventListener("pointermove", Z), document.removeEventListener("pointerup", Q), document.removeEventListener("pointercancel", Q), this._onDidSashEnd.fire(void 0);
				};
				document.addEventListener("pointermove", Z), document.addEventListener("pointerup", Q), document.addEventListener("pointercancel", Q);
			};
			C.addEventListener("pointerdown", T);
			let E = {
				container: C,
				disposable: () => {
					C.removeEventListener("pointerdown", T), this.sashContainer.removeChild(C);
				}
			};
			this.sashContainer.appendChild(C), this.sashes.push(E);
		}
		D || this.relayout([E]), !D && typeof T != "number" && T.type === "distribute" && this.distributeViewSizes(), this._onDidAddView.fire(C);
	}
	distributeViewSizes() {
		let C = [], T = 0;
		for (let E of this.viewItems) E.maximumSize - E.minimumSize > 0 && (C.push(E), T += E.size);
		let E = Math.floor(T / C.length);
		for (let T of C) T.size = clamp(E, T.minimumSize, T.maximumSize);
		let D = range(this.viewItems.length), O = D.filter((C) => this.viewItems[C].priority === LayoutPriority.Low), F = D.filter((C) => this.viewItems[C].priority === LayoutPriority.High);
		this.relayout(O, F);
	}
	removeView(C, T, E = !1) {
		let D = this.viewItems.splice(C, 1)[0];
		if (D.dispose(), this.viewItems.length >= 1) {
			let T = Math.max(C - 1, 0);
			this.sashes.splice(T, 1)[0].disposable();
		}
		return E || this.relayout(), T && T.type === "distribute" && this.distributeViewSizes(), this._onDidRemoveView.fire(D.view), D.view;
	}
	getViewCachedVisibleSize(C) {
		if (C < 0 || C >= this.viewItems.length) throw Error("Index out of bounds");
		return this.viewItems[C].cachedVisibleSize;
	}
	moveView(C, T) {
		let E = this.getViewCachedVisibleSize(C), D = E === void 0 ? this.getViewSize(C) : Sizing.Invisible(E), O = this.removeView(C, void 0, !0);
		this.addView(O, D, T);
	}
	layout(C, T) {
		let E = Math.max(this.size, this._contentSize);
		if (this.size = C, this.orthogonalSize = T, this.proportions) {
			let T = 0;
			for (let E = 0; E < this.viewItems.length; E++) {
				let D = this.viewItems[E], O = this.proportions[E];
				typeof O == "number" ? T += O : C -= D.size;
			}
			for (let E = 0; E < this.viewItems.length; E++) {
				let D = this.viewItems[E], O = this.proportions[E];
				typeof O == "number" && T > 0 && (D.size = clamp(Math.round(O * C / T), D.minimumSize, D.maximumSize));
			}
		} else {
			let T = range(this.viewItems.length), D = T.filter((C) => this.viewItems[C].priority === LayoutPriority.Low), O = T.filter((C) => this.viewItems[C].priority === LayoutPriority.High);
			this.resize(this.viewItems.length - 1, C - E, void 0, D, O);
		}
		this.distributeEmptySpace(), this.layoutViews();
	}
	relayout(C, T) {
		let E = this.viewItems.reduce((C, T) => C + T.size, 0);
		this.resize(this.viewItems.length - 1, this._size - E, void 0, C, T), this.distributeEmptySpace(), this.layoutViews(), this.saveProportions();
	}
	distributeEmptySpace(C) {
		let T = this.viewItems.reduce((C, T) => C + T.size, 0), E = this.size - T, D = range(this.viewItems.length - 1, -1), O = D.filter((C) => this.viewItems[C].priority === LayoutPriority.Low), F = D.filter((C) => this.viewItems[C].priority === LayoutPriority.High);
		for (let C of F) pushToStart(D, C);
		for (let C of O) pushToEnd(D, C);
		typeof C == "number" && pushToEnd(D, C);
		for (let C = 0; E !== 0 && C < D.length; C++) {
			let T = this.viewItems[D[C]], O = clamp(T.size + E, T.minimumSize, T.maximumSize), F = O - T.size;
			E -= F, T.size = O;
		}
	}
	saveProportions() {
		this.proportionalLayout && this._contentSize > 0 && (this._proportions = this.viewItems.map((C) => C.visible ? C.size / this._contentSize : void 0));
	}
	layoutViews() {
		if (this._contentSize = this.viewItems.reduce((C, T) => C + T.size, 0), this.updateSashEnablement(), this.viewItems.length === 0) return;
		let C = this.viewItems.filter((C) => C.visible), T = Math.max(0, C.length - 1), E = this.margin * T / Math.max(1, C.length), D = 0, O = [], F = this.viewItems.reduce((C, T, E) => {
			let D = T.visible ? 1 : 0;
			return E === 0 ? C.push(D) : C.push(C[E - 1] + D), C;
		}, []);
		this.viewItems.forEach((C, I) => {
			D += this.viewItems[I].size, O.push(D);
			let L = C.visible ? C.size - E : 0, z = Math.max(0, F[I] - 1), B = I === 0 || z === 0 ? 0 : O[I - 1] + z / T * E;
			if (I < this.viewItems.length - 1) {
				let T = C.visible ? B + L - 4 / 2 + this.margin / 2 : B;
				this._orientation === Orientation.HORIZONTAL && (this.sashes[I].container.style.left = `${T}px`, this.sashes[I].container.style.top = "0px"), this._orientation === Orientation.VERTICAL && (this.sashes[I].container.style.left = "0px", this.sashes[I].container.style.top = `${T}px`);
			}
			this._orientation === Orientation.HORIZONTAL && (C.container.style.width = `${L}px`, C.container.style.left = `${B}px`, C.container.style.top = "", C.container.style.height = ""), this._orientation === Orientation.VERTICAL && (C.container.style.height = `${L}px`, C.container.style.top = `${B}px`, C.container.style.width = "", C.container.style.left = ""), C.view.layout(C.size - E, this._orthogonalSize);
		});
	}
	findFirstSnapIndex(C) {
		for (let T of C) {
			let C = this.viewItems[T];
			if (C.visible && C.snap) return T;
		}
		for (let T of C) {
			let C = this.viewItems[T];
			if (C.visible && C.maximumSize - C.minimumSize > 0) return;
			if (!C.visible && C.snap) return T;
		}
	}
	updateSashEnablement() {
		let C = !1, T = this.viewItems.map((T) => C = T.size - T.minimumSize > 0 || C);
		C = !1;
		let E = this.viewItems.map((T) => C = T.maximumSize - T.size > 0 || C), D = [...this.viewItems].reverse();
		C = !1;
		let O = D.map((T) => C = T.size - T.minimumSize > 0 || C).reverse();
		C = !1;
		let F = D.map((T) => C = T.maximumSize - T.size > 0 || C).reverse(), I = 0;
		for (let C = 0; C < this.sashes.length; C++) {
			let D = this.sashes[C], L = this.viewItems[C];
			I += L.size;
			let z = !(T[C] && F[C + 1]), B = !(E[C] && O[C + 1]);
			if (z && B) {
				let E = range(C, -1), F = range(C + 1, this.viewItems.length), L = this.findFirstSnapIndex(E), z = this.findFirstSnapIndex(F), B = typeof L == "number" && !this.viewItems[L].visible, V = typeof z == "number" && !this.viewItems[z].visible;
				B && O[C] && (I > 0 || this.startSnappingEnabled) ? this.updateSash(D, SashState.MINIMUM) : V && T[C] && (I < this._contentSize || this.endSnappingEnabled) ? this.updateSash(D, SashState.MAXIMUM) : this.updateSash(D, SashState.DISABLED);
			} else z && !B ? this.updateSash(D, SashState.MINIMUM) : !z && B ? this.updateSash(D, SashState.MAXIMUM) : this.updateSash(D, SashState.ENABLED);
		}
	}
	updateSash(C, T) {
		toggleClass(C.container, "dv-disabled", T === SashState.DISABLED), toggleClass(C.container, "dv-enabled", T === SashState.ENABLED), toggleClass(C.container, "dv-maximum", T === SashState.MAXIMUM), toggleClass(C.container, "dv-minimum", T === SashState.MINIMUM);
	}
	createViewContainer() {
		let C = document.createElement("div");
		return C.className = "dv-view-container", C;
	}
	createSashContainer() {
		let C = document.createElement("div");
		return C.className = "dv-sash-container", C;
	}
	createContainer() {
		let C = document.createElement("div");
		return C.className = `dv-split-view-container ${this._orientation === Orientation.HORIZONTAL ? "dv-horizontal" : "dv-vertical"}`, C;
	}
	dispose() {
		this._onDidSashEnd.dispose(), this._onDidAddView.dispose(), this._onDidRemoveView.dispose();
		for (let C = 0; C < this.element.children.length; C++) if (this.element.children.item(C) === this.element) {
			this.element.removeChild(this.element);
			break;
		}
		for (let C of this.viewItems) C.dispose();
		this.element.remove();
	}
};
const PROPERTY_KEYS_SPLITVIEW = (() => Object.keys({
	orientation: void 0,
	descriptor: void 0,
	proportionalLayout: void 0,
	styles: void 0,
	margin: void 0,
	disableAutoResizing: void 0,
	className: void 0
}))();
var Paneview = class extends CompositeDisposable {
	get onDidAddView() {
		return this.splitview.onDidAddView;
	}
	get onDidRemoveView() {
		return this.splitview.onDidRemoveView;
	}
	get minimumSize() {
		return this.splitview.minimumSize;
	}
	get maximumSize() {
		return this.splitview.maximumSize;
	}
	get orientation() {
		return this.splitview.orientation;
	}
	get size() {
		return this.splitview.size;
	}
	get orthogonalSize() {
		return this.splitview.orthogonalSize;
	}
	constructor(C, T) {
		var E;
		super(), this.paneItems = [], this.skipAnimation = !1, this._onDidChange = new Emitter(), this.onDidChange = this._onDidChange.event, this._orientation = (E = T.orientation) == null ? Orientation.VERTICAL : E, this.element = document.createElement("div"), this.element.className = "dv-pane-container", C.appendChild(this.element), this.splitview = new Splitview(this.element, {
			orientation: this._orientation,
			proportionalLayout: !1,
			descriptor: T.descriptor
		}), this.getPanes().forEach((C) => {
			let T = new CompositeDisposable(C.onDidChangeExpansionState(() => {
				this.setupAnimation(), this._onDidChange.fire(void 0);
			})), E = {
				pane: C,
				disposable: { dispose: () => {
					T.dispose();
				} }
			};
			this.paneItems.push(E), C.orthogonalSize = this.splitview.orthogonalSize;
		}), this.addDisposables(this._onDidChange, this.splitview.onDidSashEnd(() => {
			this._onDidChange.fire(void 0);
		}), this.splitview.onDidAddView(() => {
			this._onDidChange.fire();
		}), this.splitview.onDidRemoveView(() => {
			this._onDidChange.fire();
		}));
	}
	setViewVisible(C, T) {
		this.splitview.setViewVisible(C, T);
	}
	addPane(C, T, E = this.splitview.length, D = !1) {
		let O = C.onDidChangeExpansionState(() => {
			this.setupAnimation(), this._onDidChange.fire(void 0);
		}), F = {
			pane: C,
			disposable: { dispose: () => {
				O.dispose();
			} }
		};
		this.paneItems.splice(E, 0, F), C.orthogonalSize = this.splitview.orthogonalSize, this.splitview.addView(C, T, E, D);
	}
	getViewSize(C) {
		return this.splitview.getViewSize(C);
	}
	getPanes() {
		return this.splitview.getViews();
	}
	removePane(C, T = { skipDispose: !1 }) {
		let E = this.paneItems.splice(C, 1)[0];
		return this.splitview.removeView(C), T.skipDispose || (E.disposable.dispose(), E.pane.dispose()), E;
	}
	moveView(C, T) {
		if (C === T) return;
		let E = this.removePane(C, { skipDispose: !0 });
		this.skipAnimation = !0;
		try {
			this.addPane(E.pane, E.pane.size, T, !1);
		} finally {
			this.skipAnimation = !1;
		}
	}
	layout(C, T) {
		this.splitview.layout(C, T);
	}
	setupAnimation() {
		this.skipAnimation || (this.animationTimer && (clearTimeout(this.animationTimer), this.animationTimer = void 0), addClasses(this.element, "dv-animated"), this.animationTimer = setTimeout(() => {
			this.animationTimer = void 0, removeClasses(this.element, "dv-animated");
		}, 200));
	}
	dispose() {
		super.dispose(), this.animationTimer && (clearTimeout(this.animationTimer), this.animationTimer = void 0), this.paneItems.forEach((C) => {
			C.disposable.dispose(), C.pane.dispose();
		}), this.paneItems = [], this.splitview.dispose(), this.element.remove();
	}
}, LeafNode = class {
	get minimumWidth() {
		return this.view.minimumWidth;
	}
	get maximumWidth() {
		return this.view.maximumWidth;
	}
	get minimumHeight() {
		return this.view.minimumHeight;
	}
	get maximumHeight() {
		return this.view.maximumHeight;
	}
	get priority() {
		return this.view.priority;
	}
	get snap() {
		return this.view.snap;
	}
	get minimumSize() {
		return this.orientation === Orientation.HORIZONTAL ? this.minimumHeight : this.minimumWidth;
	}
	get maximumSize() {
		return this.orientation === Orientation.HORIZONTAL ? this.maximumHeight : this.maximumWidth;
	}
	get minimumOrthogonalSize() {
		return this.orientation === Orientation.HORIZONTAL ? this.minimumWidth : this.minimumHeight;
	}
	get maximumOrthogonalSize() {
		return this.orientation === Orientation.HORIZONTAL ? this.maximumWidth : this.maximumHeight;
	}
	get orthogonalSize() {
		return this._orthogonalSize;
	}
	get size() {
		return this._size;
	}
	get element() {
		return this.view.element;
	}
	get width() {
		return this.orientation === Orientation.HORIZONTAL ? this.orthogonalSize : this.size;
	}
	get height() {
		return this.orientation === Orientation.HORIZONTAL ? this.size : this.orthogonalSize;
	}
	constructor(C, T, E, D = 0) {
		this.view = C, this.orientation = T, this._onDidChange = new Emitter(), this.onDidChange = this._onDidChange.event, this._orthogonalSize = E, this._size = D, this._disposable = this.view.onDidChange((C) => {
			C ? this._onDidChange.fire({
				size: this.orientation === Orientation.VERTICAL ? C.width : C.height,
				orthogonalSize: this.orientation === Orientation.VERTICAL ? C.height : C.width
			}) : this._onDidChange.fire({});
		});
	}
	setVisible(C) {
		this.view.setVisible && this.view.setVisible(C);
	}
	layout(C, T) {
		this._size = C, this._orthogonalSize = T, this.view.layout(this.width, this.height);
	}
	dispose() {
		this._onDidChange.dispose(), this._disposable.dispose();
	}
}, BranchNode = class C extends CompositeDisposable {
	get width() {
		return this.orientation === Orientation.HORIZONTAL ? this.size : this.orthogonalSize;
	}
	get height() {
		return this.orientation === Orientation.HORIZONTAL ? this.orthogonalSize : this.size;
	}
	get minimumSize() {
		return this.children.length === 0 ? 0 : Math.max(...this.children.map((C, T) => this.splitview.isViewVisible(T) ? C.minimumOrthogonalSize : 0));
	}
	get maximumSize() {
		return Math.min(...this.children.map((C, T) => this.splitview.isViewVisible(T) ? C.maximumOrthogonalSize : Infinity));
	}
	get minimumOrthogonalSize() {
		return this.splitview.minimumSize;
	}
	get maximumOrthogonalSize() {
		return this.splitview.maximumSize;
	}
	get orthogonalSize() {
		return this._orthogonalSize;
	}
	get size() {
		return this._size;
	}
	get minimumWidth() {
		return this.orientation === Orientation.HORIZONTAL ? this.minimumOrthogonalSize : this.minimumSize;
	}
	get minimumHeight() {
		return this.orientation === Orientation.HORIZONTAL ? this.minimumSize : this.minimumOrthogonalSize;
	}
	get maximumWidth() {
		return this.orientation === Orientation.HORIZONTAL ? this.maximumOrthogonalSize : this.maximumSize;
	}
	get maximumHeight() {
		return this.orientation === Orientation.HORIZONTAL ? this.maximumSize : this.maximumOrthogonalSize;
	}
	get priority() {
		if (this.children.length === 0) return LayoutPriority.Normal;
		let C = this.children.map((C) => C.priority === void 0 ? LayoutPriority.Normal : C.priority);
		return C.some((C) => C === LayoutPriority.High) ? LayoutPriority.High : C.some((C) => C === LayoutPriority.Low) ? LayoutPriority.Low : LayoutPriority.Normal;
	}
	get disabled() {
		return this.splitview.disabled;
	}
	set disabled(C) {
		this.splitview.disabled = C;
	}
	get margin() {
		return this.splitview.margin;
	}
	set margin(T) {
		this.splitview.margin = T, this.children.forEach((E) => {
			E instanceof C && (E.margin = T);
		});
	}
	constructor(C, T, E, D, O, F, I, L) {
		if (super(), this.orientation = C, this.proportionalLayout = T, this.styles = E, this._childrenDisposable = Disposable.NONE, this.children = [], this._onDidChange = new Emitter(), this.onDidChange = this._onDidChange.event, this._onDidVisibilityChange = new Emitter(), this.onDidVisibilityChange = this._onDidVisibilityChange.event, this._orthogonalSize = O, this._size = D, this.element = document.createElement("div"), this.element.className = "dv-branch-node", !L) this.splitview = new Splitview(this.element, {
			orientation: this.orientation,
			proportionalLayout: T,
			styles: E,
			margin: I
		}), this.splitview.layout(this.size, this.orthogonalSize);
		else {
			let C = {
				views: L.map((C) => ({
					view: C.node,
					size: C.node.size,
					visible: C.node instanceof LeafNode && C.visible !== void 0 ? C.visible : !0
				})),
				size: this.orthogonalSize
			};
			this.children = L.map((C) => C.node), this.splitview = new Splitview(this.element, {
				orientation: this.orientation,
				descriptor: C,
				proportionalLayout: T,
				styles: E,
				margin: I
			});
		}
		this.disabled = F, this.addDisposables(this._onDidChange, this._onDidVisibilityChange, this.splitview.onDidSashEnd(() => {
			this._onDidChange.fire({});
		})), this.setupChildrenEvents();
	}
	setVisible(C) {}
	isChildVisible(C) {
		if (C < 0 || C >= this.children.length) throw Error("Invalid index");
		return this.splitview.isViewVisible(C);
	}
	setChildVisible(C, T) {
		if (C < 0 || C >= this.children.length) throw Error("Invalid index");
		if (this.splitview.isViewVisible(C) === T) return;
		let E = this.splitview.contentSize === 0;
		this.splitview.setViewVisible(C, T);
		let D = this.splitview.contentSize === 0;
		(T && E || !T && D) && this._onDidVisibilityChange.fire({ visible: T });
	}
	moveChild(C, T) {
		if (C === T) return;
		if (C < 0 || C >= this.children.length) throw Error("Invalid from index");
		C < T && T--, this.splitview.moveView(C, T);
		let E = this._removeChild(C);
		this._addChild(E, T);
	}
	getChildSize(C) {
		if (C < 0 || C >= this.children.length) throw Error("Invalid index");
		return this.splitview.getViewSize(C);
	}
	resizeChild(C, T) {
		if (C < 0 || C >= this.children.length) throw Error("Invalid index");
		this.splitview.resizeView(C, T);
	}
	layout(C, T) {
		this._size = T, this._orthogonalSize = C, this.splitview.layout(T, C);
	}
	addChild(C, T, E, D) {
		if (E < 0 || E > this.children.length) throw Error("Invalid index");
		this.splitview.addView(C, T, E, D), this._addChild(C, E);
	}
	getChildCachedVisibleSize(C) {
		if (C < 0 || C >= this.children.length) throw Error("Invalid index");
		return this.splitview.getViewCachedVisibleSize(C);
	}
	removeChild(C, T) {
		if (C < 0 || C >= this.children.length) throw Error("Invalid index");
		return this.splitview.removeView(C, T), this._removeChild(C);
	}
	_addChild(C, T) {
		this.children.splice(T, 0, C), this.setupChildrenEvents();
	}
	_removeChild(C) {
		let [T] = this.children.splice(C, 1);
		return this.setupChildrenEvents(), T;
	}
	setupChildrenEvents() {
		this._childrenDisposable.dispose(), this._childrenDisposable = new CompositeDisposable(Event$2.any(...this.children.map((C) => C.onDidChange))((C) => {
			this._onDidChange.fire({ size: C.orthogonalSize });
		}), ...this.children.map((T, E) => T instanceof C ? T.onDidVisibilityChange(({ visible: C }) => {
			this.setChildVisible(E, C);
		}) : Disposable.NONE));
	}
	dispose() {
		this._childrenDisposable.dispose(), this.splitview.dispose(), this.children.forEach((C) => C.dispose()), super.dispose();
	}
};
function findLeaf(C, T) {
	if (C instanceof LeafNode) return C;
	if (C instanceof BranchNode) return findLeaf(C.children[T ? C.children.length - 1 : 0], T);
	throw Error("invalid node");
}
function cloneNode(C, T, E) {
	if (C instanceof BranchNode) {
		let D = new BranchNode(C.orientation, C.proportionalLayout, C.styles, T, E, C.disabled, C.margin);
		for (let T = C.children.length - 1; T >= 0; T--) {
			let E = C.children[T];
			D.addChild(cloneNode(E, E.size, E.orthogonalSize), E.size, 0, !0);
		}
		return D;
	} else return new LeafNode(C.view, C.orientation, E);
}
function flipNode(C, T, E) {
	if (C instanceof BranchNode) {
		let D = new BranchNode(orthogonal(C.orientation), C.proportionalLayout, C.styles, T, E, C.disabled, C.margin), O = 0;
		for (let F = C.children.length - 1; F >= 0; F--) {
			let I = C.children[F], L = I instanceof BranchNode ? I.orthogonalSize : I.size, z = C.size === 0 ? 0 : Math.round(T * L / C.size);
			O += z, F === 0 && (z += T - O), D.addChild(flipNode(I, E, z), z, 0, !0);
		}
		return D;
	} else return new LeafNode(C.view, orthogonal(C.orientation), E);
}
function indexInParent(C) {
	let T = C.parentElement;
	if (!T) throw Error("Invalid grid element");
	let E = T.firstElementChild, D = 0;
	for (; E !== C && E !== T.lastElementChild && E;) E = E.nextElementSibling, D++;
	return D;
}
function getGridLocation(C) {
	let T = C.parentElement;
	if (!T) throw Error("Invalid grid element");
	if (/\bdv-grid-view\b/.test(T.className)) return [];
	let E = indexInParent(T), D = T.parentElement.parentElement.parentElement;
	return [...getGridLocation(D), E];
}
function getRelativeLocation(C, T, E) {
	if (getLocationOrientation(C, T) === getDirectionOrientation(E)) {
		let [C, D] = tail(T), O = D;
		return (E === "right" || E === "bottom") && (O += 1), [...C, O];
	} else {
		let C = E === "right" || E === "bottom" ? 1 : 0;
		return [...T, C];
	}
}
function getDirectionOrientation(C) {
	return C === "top" || C === "bottom" ? Orientation.VERTICAL : Orientation.HORIZONTAL;
}
function getLocationOrientation(C, T) {
	return T.length % 2 == 0 ? orthogonal(C) : C;
}
const orthogonal = (C) => C === Orientation.HORIZONTAL ? Orientation.VERTICAL : Orientation.HORIZONTAL;
function isGridBranchNode(C) {
	return !!C.children;
}
var serializeBranchNode = (C, T) => {
	let E = T === Orientation.VERTICAL ? C.box.width : C.box.height;
	return isGridBranchNode(C) ? {
		type: "branch",
		data: C.children.map((C) => serializeBranchNode(C, orthogonal(T))),
		size: E
	} : typeof C.cachedVisibleSize == "number" ? {
		type: "leaf",
		data: C.view.toJSON(),
		size: C.cachedVisibleSize,
		visible: !1
	} : {
		type: "leaf",
		data: C.view.toJSON(),
		size: E
	};
}, Gridview = class {
	get length() {
		return this._root ? this._root.children.length : 0;
	}
	get orientation() {
		return this.root.orientation;
	}
	set orientation(C) {
		if (this.root.orientation === C) return;
		let { size: T, orthogonalSize: E } = this.root;
		this.root = flipNode(this.root, E, T), this.root.layout(T, E);
	}
	get width() {
		return this.root.width;
	}
	get height() {
		return this.root.height;
	}
	get minimumWidth() {
		return this.root.minimumWidth;
	}
	get minimumHeight() {
		return this.root.minimumHeight;
	}
	get maximumWidth() {
		return this.root.maximumHeight;
	}
	get maximumHeight() {
		return this.root.maximumHeight;
	}
	get locked() {
		return this._locked;
	}
	set locked(C) {
		this._locked = C;
		let T = [this.root];
		for (; T.length > 0;) {
			let E = T.pop();
			E instanceof BranchNode && (E.disabled = C, T.push(...E.children));
		}
	}
	get margin() {
		return this._margin;
	}
	set margin(C) {
		this._margin = C, this.root.margin = C;
	}
	maximizedView() {
		var C;
		return (C = this._maximizedNode) == null ? void 0 : C.leaf.view;
	}
	hasMaximizedView() {
		return this._maximizedNode !== void 0;
	}
	maximizeView(C) {
		var T;
		let E = getGridLocation(C.element), [D, O] = this.getNode(E);
		if (!(O instanceof LeafNode) || ((T = this._maximizedNode) == null ? void 0 : T.leaf) === O) return;
		this.hasMaximizedView() && this.exitMaximizedView(), serializeBranchNode(this.getView(), this.orientation);
		let F = [];
		function I(C, T) {
			for (let E = 0; E < C.children.length; E++) {
				let D = C.children[E];
				D instanceof LeafNode ? D !== T && (C.isChildVisible(E) ? C.setChildVisible(E, !1) : F.push(D)) : I(D, T);
			}
		}
		I(this.root, O), this._maximizedNode = {
			leaf: O,
			hiddenOnMaximize: F
		}, this._onDidMaximizedNodeChange.fire({
			view: O.view,
			isMaximized: !0
		});
	}
	exitMaximizedView() {
		if (!this._maximizedNode) return;
		let C = this._maximizedNode.hiddenOnMaximize;
		function T(E) {
			for (let D = E.children.length - 1; D >= 0; D--) {
				let O = E.children[D];
				O instanceof LeafNode ? C.includes(O) || E.setChildVisible(D, !0) : T(O);
			}
		}
		T(this.root);
		let E = this._maximizedNode.leaf;
		this._maximizedNode = void 0, this._onDidMaximizedNodeChange.fire({
			view: E.view,
			isMaximized: !1
		});
	}
	serialize() {
		let C = this.maximizedView(), T;
		C && (T = getGridLocation(C.element)), this.hasMaximizedView() && this.exitMaximizedView();
		let E = {
			root: serializeBranchNode(this.getView(), this.orientation),
			width: this.width,
			height: this.height,
			orientation: this.orientation
		};
		return T && (E.maximizedNode = { location: T }), C && this.maximizeView(C), E;
	}
	dispose() {
		this.disposable.dispose(), this._onDidChange.dispose(), this._onDidMaximizedNodeChange.dispose(), this._onDidViewVisibilityChange.dispose(), this.root.dispose(), this._maximizedNode = void 0, this.element.remove();
	}
	clear() {
		let C = this.root.orientation;
		this.root = new BranchNode(C, this.proportionalLayout, this.styles, this.root.size, this.root.orthogonalSize, this.locked, this.margin);
	}
	deserialize(C, T) {
		let E = C.orientation, D = E === Orientation.VERTICAL ? C.height : C.width;
		if (this._deserialize(C.root, E, T, D), this.layout(C.width, C.height), C.maximizedNode) {
			let T = C.maximizedNode.location, [E, D] = this.getNode(T);
			if (!(D instanceof LeafNode)) return;
			this.maximizeView(D.view);
		}
	}
	_deserialize(C, T, E, D) {
		this.root = this._deserializeNode(C, T, E, D);
	}
	_deserializeNode(C, T, E, D) {
		var O;
		let F;
		if (C.type === "branch") {
			let O = C.data.map((D) => ({
				node: this._deserializeNode(D, orthogonal(T), E, C.size),
				visible: D.visible
			}));
			F = new BranchNode(T, this.proportionalLayout, this.styles, C.size, D, this.locked, this.margin, O);
		} else {
			let I = E.fromJSON(C);
			typeof C.visible == "boolean" && ((O = I.setVisible) == null || O.call(I, C.visible)), F = new LeafNode(I, T, D, C.size);
		}
		return F;
	}
	get root() {
		return this._root;
	}
	set root(C) {
		let T = this._root;
		T && (T.dispose(), this._maximizedNode = void 0, this.element.removeChild(T.element)), this._root = C, this.element.appendChild(this._root.element), this.disposable.value = this._root.onDidChange((C) => {
			this._onDidChange.fire(C);
		});
	}
	normalize() {
		if (!this._root || this._root.children.length !== 1) return;
		let C = this.root, T = C.children[0];
		if (T instanceof LeafNode) return;
		C.element.remove();
		let E = C.removeChild(0);
		C.dispose(), E.dispose(), this._root = cloneNode(T, T.size, T.orthogonalSize), this.element.appendChild(this._root.element), this.disposable.value = this._root.onDidChange((C) => {
			this._onDidChange.fire(C);
		});
	}
	insertOrthogonalSplitviewAtRoot() {
		if (!this._root) return;
		let C = this.root;
		if (C.element.remove(), this._root = new BranchNode(orthogonal(C.orientation), this.proportionalLayout, this.styles, this.root.orthogonalSize, this.root.size, this.locked, this.margin), C.children.length !== 0) if (C.children.length === 1) {
			let T = C.children[0];
			C.removeChild(0).dispose(), C.dispose(), this._root.addChild(flipNode(T, T.orthogonalSize, T.size), Sizing.Distribute, 0);
		} else this._root.addChild(C, Sizing.Distribute, 0);
		this.element.appendChild(this._root.element), this.disposable.value = this._root.onDidChange((C) => {
			this._onDidChange.fire(C);
		});
	}
	next(C) {
		return this.progmaticSelect(C);
	}
	previous(C) {
		return this.progmaticSelect(C, !0);
	}
	getView(C) {
		let T = C ? this.getNode(C)[1] : this.root;
		return this._getViews(T, this.orientation);
	}
	_getViews(C, T, E) {
		let D = {
			height: C.height,
			width: C.width
		};
		if (C instanceof LeafNode) return {
			box: D,
			view: C.view,
			cachedVisibleSize: E
		};
		let O = [];
		for (let E = 0; E < C.children.length; E++) {
			let D = C.children[E], F = C.getChildCachedVisibleSize(E);
			O.push(this._getViews(D, orthogonal(T), F));
		}
		return {
			box: D,
			children: O
		};
	}
	progmaticSelect(C, T = !1) {
		let [E, D] = this.getNode(C);
		if (!(D instanceof LeafNode)) throw Error("invalid location");
		for (let D = E.length - 1; D > -1; D--) {
			let O = E[D], F = C[D] || 0;
			if (T ? F - 1 > -1 : F + 1 < O.children.length) return findLeaf(O.children[T ? F - 1 : F + 1], T);
		}
		return findLeaf(this.root, T);
	}
	constructor(C, T, E, D, O) {
		this.proportionalLayout = C, this.styles = T, this._locked = !1, this._margin = 0, this._maximizedNode = void 0, this.disposable = new MutableDisposable(), this._onDidChange = new Emitter(), this.onDidChange = this._onDidChange.event, this._onDidViewVisibilityChange = new Emitter(), this.onDidViewVisibilityChange = this._onDidViewVisibilityChange.event, this._onDidMaximizedNodeChange = new Emitter(), this.onDidMaximizedNodeChange = this._onDidMaximizedNodeChange.event, this.element = document.createElement("div"), this.element.className = "dv-grid-view", this._locked = D == null ? !1 : D, this._margin = O == null ? 0 : O, this.root = new BranchNode(E, C, T, 0, 0, this.locked, this.margin);
	}
	isViewVisible(C) {
		let [T, E] = tail(C), [, D] = this.getNode(T);
		if (!(D instanceof BranchNode)) throw Error("Invalid from location");
		return D.isChildVisible(E);
	}
	setViewVisible(C, T) {
		this.hasMaximizedView() && this.exitMaximizedView();
		let [E, D] = tail(C), [, O] = this.getNode(E);
		if (!(O instanceof BranchNode)) throw Error("Invalid from location");
		this._onDidViewVisibilityChange.fire(), O.setChildVisible(D, T);
	}
	moveView(C, T, E) {
		this.hasMaximizedView() && this.exitMaximizedView();
		let [, D] = this.getNode(C);
		if (!(D instanceof BranchNode)) throw Error("Invalid location");
		D.moveChild(T, E);
	}
	addView(C, T, E) {
		this.hasMaximizedView() && this.exitMaximizedView();
		let [D, O] = tail(E), [F, I] = this.getNode(D);
		if (I instanceof BranchNode) {
			let E = new LeafNode(C, orthogonal(I.orientation), I.orthogonalSize);
			I.addChild(E, T, O);
		} else {
			let [E, ...L] = [...F].reverse(), [z, ...B] = [...D].reverse(), V = 0, U = E.getChildCachedVisibleSize(z);
			typeof U == "number" && (V = Sizing.Invisible(U)), E.removeChild(z).dispose();
			let W = new BranchNode(I.orientation, this.proportionalLayout, this.styles, I.size, I.orthogonalSize, this.locked, this.margin);
			E.addChild(W, I.size, z);
			let G = new LeafNode(I.view, E.orientation, I.size);
			W.addChild(G, V, 0), typeof T != "number" && T.type === "split" && (T = {
				type: "split",
				index: 0
			});
			let K = new LeafNode(C, E.orientation, I.size);
			W.addChild(K, T, O);
		}
	}
	remove(C, T) {
		let E = getGridLocation(C.element);
		return this.removeView(E, T);
	}
	removeView(C, T) {
		this.hasMaximizedView() && this.exitMaximizedView();
		let [E, D] = tail(C), [O, F] = this.getNode(E);
		if (!(F instanceof BranchNode)) throw Error("Invalid location");
		let I = F.children[D];
		if (!(I instanceof LeafNode)) throw Error("Invalid location");
		if (F.removeChild(D, T), I.dispose(), F.children.length !== 1) return I.view;
		let L = F.children[0];
		if (O.length === 0) return L instanceof LeafNode ? I.view : (F.removeChild(0, T), this.root = L, I.view);
		let [z, ...B] = [...O].reverse(), [V, ...U] = [...E].reverse(), W = F.isChildVisible(0);
		F.removeChild(0, T);
		let G = z.children.map((C, T) => z.getChildSize(T));
		if (z.removeChild(V, T).dispose(), L instanceof BranchNode) {
			G.splice(V, 1, ...L.children.map((C) => C.size));
			for (let C = 0; C < L.children.length; C++) {
				let T = L.children[C];
				z.addChild(T, T.size, V + C);
			}
			for (; L.children.length > 0;) L.removeChild(0);
		} else {
			let C = new LeafNode(L.view, orthogonal(L.orientation), L.size), T = W ? L.orthogonalSize : Sizing.Invisible(L.orthogonalSize);
			z.addChild(C, T, V);
		}
		L.dispose();
		for (let C = 0; C < G.length; C++) z.resizeChild(C, G[C]);
		return I.view;
	}
	layout(C, T) {
		let [E, D] = this.root.orientation === Orientation.HORIZONTAL ? [T, C] : [C, T];
		this.root.layout(E, D);
	}
	getNode(C, T = this.root, E = []) {
		if (C.length === 0) return [E, T];
		if (!(T instanceof BranchNode)) throw Error("Invalid location");
		let [D, ...O] = C;
		if (D < 0 || D >= T.children.length) throw Error("Invalid location");
		let F = T.children[D];
		return E.push(T), this.getNode(O, F, E);
	}
};
const PROPERTY_KEYS_GRIDVIEW = (() => Object.keys({
	disableAutoResizing: void 0,
	proportionalLayout: void 0,
	orientation: void 0,
	hideBorders: void 0,
	className: void 0
}))();
var Resizable = class extends CompositeDisposable {
	get element() {
		return this._element;
	}
	get disableResizing() {
		return this._disableResizing;
	}
	set disableResizing(C) {
		this._disableResizing = C;
	}
	constructor(C, T = !1) {
		super(), this._disableResizing = T, this._element = C, this.addDisposables(watchElementResize(this._element, (C) => {
			if (this.isDisposed || this.disableResizing || !this._element.offsetParent || !isInDocument(this._element)) return;
			let { width: T, height: E } = C.contentRect;
			this.layout(T, E);
		}));
	}
}, nextLayoutId$1 = sequentialNumberGenerator();
function toTarget(C) {
	switch (C) {
		case "left": return "left";
		case "right": return "right";
		case "above": return "top";
		case "below": return "bottom";
		case "within":
		default: return "center";
	}
}
var BaseGrid = class extends Resizable {
	get id() {
		return this._id;
	}
	get size() {
		return this._groups.size;
	}
	get groups() {
		return Array.from(this._groups.values()).map((C) => C.value);
	}
	get width() {
		return this.gridview.width;
	}
	get height() {
		return this.gridview.height;
	}
	get minimumHeight() {
		return this.gridview.minimumHeight;
	}
	get maximumHeight() {
		return this.gridview.maximumHeight;
	}
	get minimumWidth() {
		return this.gridview.minimumWidth;
	}
	get maximumWidth() {
		return this.gridview.maximumWidth;
	}
	get activeGroup() {
		return this._activeGroup;
	}
	get locked() {
		return this.gridview.locked;
	}
	set locked(C) {
		this.gridview.locked = C;
	}
	constructor(C, T) {
		var E;
		super(document.createElement("div"), T.disableAutoResizing), this._id = nextLayoutId$1.next(), this._groups = /* @__PURE__ */ new Map(), this._onDidRemove = new Emitter(), this.onDidRemove = this._onDidRemove.event, this._onDidAdd = new Emitter(), this.onDidAdd = this._onDidAdd.event, this._onDidMaximizedChange = new Emitter(), this.onDidMaximizedChange = this._onDidMaximizedChange.event, this._onDidActiveChange = new Emitter(), this.onDidActiveChange = this._onDidActiveChange.event, this._bufferOnDidLayoutChange = new AsapEvent(), this.onDidLayoutChange = this._bufferOnDidLayoutChange.onEvent, this._onDidViewVisibilityChangeMicroTaskQueue = new AsapEvent(), this.onDidViewVisibilityChangeMicroTaskQueue = this._onDidViewVisibilityChangeMicroTaskQueue.onEvent, this.element.style.height = "100%", this.element.style.width = "100%", this._classNames = new Classnames(this.element), this._classNames.setClassNames((E = T.className) == null ? "" : E), C.appendChild(this.element), this.gridview = new Gridview(!!T.proportionalLayout, T.styles, T.orientation, T.locked, T.margin), this.gridview.locked = !!T.locked, this.element.appendChild(this.gridview.element), this.layout(0, 0, !0), this.addDisposables(this.gridview.onDidMaximizedNodeChange((C) => {
			this._onDidMaximizedChange.fire({
				panel: C.view,
				isMaximized: C.isMaximized
			});
		}), this.gridview.onDidViewVisibilityChange(() => this._onDidViewVisibilityChangeMicroTaskQueue.fire()), this.onDidViewVisibilityChangeMicroTaskQueue(() => {
			this.layout(this.width, this.height, !0);
		}), Disposable.from(() => {
			var C;
			(C = this.element.parentElement) == null || C.removeChild(this.element);
		}), this.gridview.onDidChange(() => {
			this._bufferOnDidLayoutChange.fire();
		}), Event$2.any(this.onDidAdd, this.onDidRemove, this.onDidActiveChange)(() => {
			this._bufferOnDidLayoutChange.fire();
		}), this._onDidMaximizedChange, this._onDidViewVisibilityChangeMicroTaskQueue, this._bufferOnDidLayoutChange);
	}
	setVisible(C, T) {
		this.gridview.setViewVisible(getGridLocation(C.element), T), this._bufferOnDidLayoutChange.fire();
	}
	isVisible(C) {
		return this.gridview.isViewVisible(getGridLocation(C.element));
	}
	updateOptions(C) {
		var T, E, D, O;
		C.proportionalLayout, C.orientation && (this.gridview.orientation = C.orientation), "styles" in C, "disableResizing" in C && (this.disableResizing = (T = C.disableAutoResizing) == null ? !1 : T), "locked" in C && (this.locked = (E = C.locked) == null ? !1 : E), "margin" in C && (this.gridview.margin = (D = C.margin) == null ? 0 : D), "className" in C && this._classNames.setClassNames((O = C.className) == null ? "" : O);
	}
	maximizeGroup(C) {
		this.gridview.maximizeView(C), this.doSetGroupActive(C);
	}
	isMaximizedGroup(C) {
		return this.gridview.maximizedView() === C;
	}
	exitMaximizedGroup() {
		this.gridview.exitMaximizedView();
	}
	hasMaximizedGroup() {
		return this.gridview.hasMaximizedView();
	}
	doAddGroup(C, T = [0], E) {
		this.gridview.addView(C, E == null ? Sizing.Distribute : E, T), this._onDidAdd.fire(C);
	}
	doRemoveGroup(C, T) {
		if (!this._groups.has(C.id)) throw Error("invalid operation");
		let E = this._groups.get(C.id), D = this.gridview.remove(C, Sizing.Distribute);
		if (E && !(T != null && T.skipDispose) && (E.disposable.dispose(), E.value.dispose(), this._groups.delete(C.id), this._onDidRemove.fire(C)), !(T != null && T.skipActive) && this._activeGroup === C) {
			let C = Array.from(this._groups.values());
			this.doSetGroupActive(C.length > 0 ? C[0].value : void 0);
		}
		return D;
	}
	getPanel(C) {
		var T;
		return (T = this._groups.get(C)) == null ? void 0 : T.value;
	}
	doSetGroupActive(C) {
		this._activeGroup !== C && (this._activeGroup && this._activeGroup.setActive(!1), C && C.setActive(!0), this._activeGroup = C, this._onDidActiveChange.fire(C));
	}
	removeGroup(C) {
		this.doRemoveGroup(C);
	}
	moveToNext(C) {
		var T;
		if (C || (C = {}), !C.group) {
			if (!this.activeGroup) return;
			C.group = this.activeGroup;
		}
		let E = getGridLocation(C.group.element), D = (T = this.gridview.next(E)) == null ? void 0 : T.view;
		this.doSetGroupActive(D);
	}
	moveToPrevious(C) {
		var T;
		if (C || (C = {}), !C.group) {
			if (!this.activeGroup) return;
			C.group = this.activeGroup;
		}
		let E = getGridLocation(C.group.element), D = (T = this.gridview.previous(E)) == null ? void 0 : T.view;
		this.doSetGroupActive(D);
	}
	layout(C, T, E) {
		(E || C !== this.width || T !== this.height) && (this.gridview.element.style.height = `${T}px`, this.gridview.element.style.width = `${C}px`, this.gridview.layout(C, T));
	}
	dispose() {
		this._onDidActiveChange.dispose(), this._onDidAdd.dispose(), this._onDidRemove.dispose();
		for (let C of this.groups) C.dispose();
		this.gridview.dispose(), super.dispose();
	}
}, SplitviewApi = class {
	get minimumSize() {
		return this.component.minimumSize;
	}
	get maximumSize() {
		return this.component.maximumSize;
	}
	get width() {
		return this.component.width;
	}
	get height() {
		return this.component.height;
	}
	get length() {
		return this.component.length;
	}
	get orientation() {
		return this.component.orientation;
	}
	get panels() {
		return this.component.panels;
	}
	get onDidLayoutFromJSON() {
		return this.component.onDidLayoutFromJSON;
	}
	get onDidLayoutChange() {
		return this.component.onDidLayoutChange;
	}
	get onDidAddView() {
		return this.component.onDidAddView;
	}
	get onDidRemoveView() {
		return this.component.onDidRemoveView;
	}
	constructor(C) {
		this.component = C;
	}
	removePanel(C, T) {
		this.component.removePanel(C, T);
	}
	focus() {
		this.component.focus();
	}
	getPanel(C) {
		return this.component.getPanel(C);
	}
	layout(C, T) {
		return this.component.layout(C, T);
	}
	addPanel(C) {
		return this.component.addPanel(C);
	}
	movePanel(C, T) {
		this.component.movePanel(C, T);
	}
	fromJSON(C) {
		this.component.fromJSON(C);
	}
	toJSON() {
		return this.component.toJSON();
	}
	clear() {
		this.component.clear();
	}
	updateOptions(C) {
		this.component.updateOptions(C);
	}
	dispose() {
		this.component.dispose();
	}
}, PaneviewApi = class {
	get minimumSize() {
		return this.component.minimumSize;
	}
	get maximumSize() {
		return this.component.maximumSize;
	}
	get width() {
		return this.component.width;
	}
	get height() {
		return this.component.height;
	}
	get panels() {
		return this.component.panels;
	}
	get onDidLayoutChange() {
		return this.component.onDidLayoutChange;
	}
	get onDidLayoutFromJSON() {
		return this.component.onDidLayoutFromJSON;
	}
	get onDidAddView() {
		return this.component.onDidAddView;
	}
	get onDidRemoveView() {
		return this.component.onDidRemoveView;
	}
	get onDidDrop() {
		return this.component.onDidDrop;
	}
	get onUnhandledDragOverEvent() {
		return this.component.onUnhandledDragOverEvent;
	}
	constructor(C) {
		this.component = C;
	}
	removePanel(C) {
		this.component.removePanel(C);
	}
	getPanel(C) {
		return this.component.getPanel(C);
	}
	movePanel(C, T) {
		this.component.movePanel(C, T);
	}
	focus() {
		this.component.focus();
	}
	layout(C, T) {
		this.component.layout(C, T);
	}
	addPanel(C) {
		return this.component.addPanel(C);
	}
	fromJSON(C) {
		this.component.fromJSON(C);
	}
	toJSON() {
		return this.component.toJSON();
	}
	clear() {
		this.component.clear();
	}
	updateOptions(C) {
		this.component.updateOptions(C);
	}
	dispose() {
		this.component.dispose();
	}
}, GridviewApi = class {
	get width() {
		return this.component.width;
	}
	get height() {
		return this.component.height;
	}
	get minimumHeight() {
		return this.component.minimumHeight;
	}
	get maximumHeight() {
		return this.component.maximumHeight;
	}
	get minimumWidth() {
		return this.component.minimumWidth;
	}
	get maximumWidth() {
		return this.component.maximumWidth;
	}
	get onDidLayoutChange() {
		return this.component.onDidLayoutChange;
	}
	get onDidAddPanel() {
		return this.component.onDidAddGroup;
	}
	get onDidRemovePanel() {
		return this.component.onDidRemoveGroup;
	}
	get onDidActivePanelChange() {
		return this.component.onDidActiveGroupChange;
	}
	get onDidLayoutFromJSON() {
		return this.component.onDidLayoutFromJSON;
	}
	get panels() {
		return this.component.groups;
	}
	get orientation() {
		return this.component.orientation;
	}
	set orientation(C) {
		this.component.updateOptions({ orientation: C });
	}
	constructor(C) {
		this.component = C;
	}
	focus() {
		this.component.focus();
	}
	layout(C, T, E = !1) {
		this.component.layout(C, T, E);
	}
	addPanel(C) {
		return this.component.addPanel(C);
	}
	removePanel(C, T) {
		this.component.removePanel(C, T);
	}
	movePanel(C, T) {
		this.component.movePanel(C, T);
	}
	getPanel(C) {
		return this.component.getPanel(C);
	}
	fromJSON(C) {
		return this.component.fromJSON(C);
	}
	toJSON() {
		return this.component.toJSON();
	}
	clear() {
		this.component.clear();
	}
	updateOptions(C) {
		this.component.updateOptions(C);
	}
	dispose() {
		this.component.dispose();
	}
}, DockviewApi = class {
	get id() {
		return this.component.id;
	}
	get width() {
		return this.component.width;
	}
	get height() {
		return this.component.height;
	}
	get minimumHeight() {
		return this.component.minimumHeight;
	}
	get maximumHeight() {
		return this.component.maximumHeight;
	}
	get minimumWidth() {
		return this.component.minimumWidth;
	}
	get maximumWidth() {
		return this.component.maximumWidth;
	}
	get size() {
		return this.component.size;
	}
	get totalPanels() {
		return this.component.totalPanels;
	}
	get onDidActiveGroupChange() {
		return this.component.onDidActiveGroupChange;
	}
	get onDidAddGroup() {
		return this.component.onDidAddGroup;
	}
	get onDidRemoveGroup() {
		return this.component.onDidRemoveGroup;
	}
	get onDidActivePanelChange() {
		return this.component.onDidActivePanelChange;
	}
	get onDidAddPanel() {
		return this.component.onDidAddPanel;
	}
	get onDidRemovePanel() {
		return this.component.onDidRemovePanel;
	}
	get onDidMovePanel() {
		return this.component.onDidMovePanel;
	}
	get onDidLayoutFromJSON() {
		return this.component.onDidLayoutFromJSON;
	}
	get onDidLayoutChange() {
		return this.component.onDidLayoutChange;
	}
	get onDidDrop() {
		return this.component.onDidDrop;
	}
	get onWillDrop() {
		return this.component.onWillDrop;
	}
	get onWillShowOverlay() {
		return this.component.onWillShowOverlay;
	}
	get onWillDragGroup() {
		return this.component.onWillDragGroup;
	}
	get onWillDragPanel() {
		return this.component.onWillDragPanel;
	}
	get onUnhandledDragOverEvent() {
		return this.component.onUnhandledDragOverEvent;
	}
	get onDidPopoutGroupSizeChange() {
		return this.component.onDidPopoutGroupSizeChange;
	}
	get onDidPopoutGroupPositionChange() {
		return this.component.onDidPopoutGroupPositionChange;
	}
	get onDidOpenPopoutWindowFail() {
		return this.component.onDidOpenPopoutWindowFail;
	}
	get panels() {
		return this.component.panels;
	}
	get groups() {
		return this.component.groups;
	}
	get activePanel() {
		return this.component.activePanel;
	}
	get activeGroup() {
		return this.component.activeGroup;
	}
	constructor(C) {
		this.component = C;
	}
	focus() {
		this.component.focus();
	}
	getPanel(C) {
		return this.component.getGroupPanel(C);
	}
	layout(C, T, E = !1) {
		this.component.layout(C, T, E);
	}
	addPanel(C) {
		return this.component.addPanel(C);
	}
	removePanel(C) {
		this.component.removePanel(C);
	}
	addGroup(C) {
		return this.component.addGroup(C);
	}
	closeAllGroups() {
		return this.component.closeAllGroups();
	}
	removeGroup(C) {
		this.component.removeGroup(C);
	}
	getGroup(C) {
		return this.component.getPanel(C);
	}
	addFloatingGroup(C, T) {
		return this.component.addFloatingGroup(C, T);
	}
	fromJSON(C) {
		this.component.fromJSON(C);
	}
	toJSON() {
		return this.component.toJSON();
	}
	clear() {
		this.component.clear();
	}
	moveToNext(C) {
		this.component.moveToNext(C);
	}
	moveToPrevious(C) {
		this.component.moveToPrevious(C);
	}
	maximizeGroup(C) {
		this.component.maximizeGroup(C.group);
	}
	hasMaximizedGroup() {
		return this.component.hasMaximizedGroup();
	}
	exitMaximizedGroup() {
		this.component.exitMaximizedGroup();
	}
	get onDidMaximizedGroupChange() {
		return this.component.onDidMaximizedGroupChange;
	}
	addPopoutGroup(C, T) {
		return this.component.addPopoutGroup(C, T);
	}
	updateOptions(C) {
		this.component.updateOptions(C);
	}
	dispose() {
		this.component.dispose();
	}
}, DragHandler = class extends CompositeDisposable {
	constructor(C, T) {
		super(), this.el = C, this.disabled = T, this.dataDisposable = new MutableDisposable(), this.pointerEventsDisposable = new MutableDisposable(), this._onDragStart = new Emitter(), this.onDragStart = this._onDragStart.event, this.addDisposables(this._onDragStart, this.dataDisposable, this.pointerEventsDisposable), this.configure();
	}
	setDisabled(C) {
		this.disabled = C;
	}
	isCancelled(C) {
		return !1;
	}
	configure() {
		this.addDisposables(this._onDragStart, addDisposableListener(this.el, "dragstart", (C) => {
			if (C.defaultPrevented || this.isCancelled(C) || this.disabled) {
				C.preventDefault();
				return;
			}
			let T = disableIframePointEvents();
			this.pointerEventsDisposable.value = { dispose: () => {
				T.release();
			} }, this.el.classList.add("dv-dragged"), setTimeout(() => this.el.classList.remove("dv-dragged"), 0), this.dataDisposable.value = this.getData(C), this._onDragStart.fire(C), C.dataTransfer && (C.dataTransfer.effectAllowed = "move", C.dataTransfer.items.length > 0 || C.dataTransfer.setData("text/plain", ""));
		}), addDisposableListener(this.el, "dragend", () => {
			this.pointerEventsDisposable.dispose(), setTimeout(() => {
				this.dataDisposable.dispose();
			}, 0);
		}));
	}
}, DragAndDropObserver = class extends CompositeDisposable {
	constructor(C, T) {
		super(), this.element = C, this.callbacks = T, this.target = null, this.registerListeners();
	}
	onDragEnter(C) {
		this.target = C.target, this.callbacks.onDragEnter(C);
	}
	onDragOver(C) {
		C.preventDefault(), this.callbacks.onDragOver && this.callbacks.onDragOver(C);
	}
	onDragLeave(C) {
		this.target === C.target && (this.target = null, this.callbacks.onDragLeave(C));
	}
	onDragEnd(C) {
		this.target = null, this.callbacks.onDragEnd(C);
	}
	onDrop(C) {
		this.callbacks.onDrop(C);
	}
	registerListeners() {
		this.addDisposables(addDisposableListener(this.element, "dragenter", (C) => {
			this.onDragEnter(C);
		}, !0)), this.addDisposables(addDisposableListener(this.element, "dragover", (C) => {
			this.onDragOver(C);
		}, !0)), this.addDisposables(addDisposableListener(this.element, "dragleave", (C) => {
			this.onDragLeave(C);
		})), this.addDisposables(addDisposableListener(this.element, "dragend", (C) => {
			this.onDragEnd(C);
		})), this.addDisposables(addDisposableListener(this.element, "drop", (C) => {
			this.onDrop(C);
		}));
	}
};
function setGPUOptimizedBounds(C, T) {
	let { top: E, left: D, width: O, height: F } = T, I = `${Math.round(E)}px`, L = `${Math.round(D)}px`, z = `${Math.round(O)}px`, B = `${Math.round(F)}px`;
	C.style.top = I, C.style.left = L, C.style.width = z, C.style.height = B, C.style.visibility = "visible", (!C.style.transform || C.style.transform === "") && (C.style.transform = "translate3d(0, 0, 0)");
}
function setGPUOptimizedBoundsFromStrings(C, T) {
	let { top: E, left: D, width: O, height: F } = T;
	C.style.top = E, C.style.left = D, C.style.width = O, C.style.height = F, C.style.visibility = "visible", (!C.style.transform || C.style.transform === "") && (C.style.transform = "translate3d(0, 0, 0)");
}
function checkBoundsChanged(C, T) {
	let { top: E, left: D, width: O, height: F } = T, I = `${Math.round(E)}px`, L = `${Math.round(D)}px`, z = `${Math.round(O)}px`, B = `${Math.round(F)}px`;
	return C.style.top !== I || C.style.left !== L || C.style.width !== z || C.style.height !== B;
}
var WillShowOverlayEvent = class extends DockviewEvent {
	get nativeEvent() {
		return this.options.nativeEvent;
	}
	get position() {
		return this.options.position;
	}
	constructor(C) {
		super(), this.options = C;
	}
};
function directionToPosition(C) {
	switch (C) {
		case "above": return "top";
		case "below": return "bottom";
		case "left": return "left";
		case "right": return "right";
		case "within": return "center";
		default: throw Error(`invalid direction '${C}'`);
	}
}
function positionToDirection(C) {
	switch (C) {
		case "top": return "above";
		case "bottom": return "below";
		case "left": return "left";
		case "right": return "right";
		case "center": return "within";
		default: throw Error(`invalid position '${C}'`);
	}
}
var DEFAULT_ACTIVATION_SIZE = {
	value: 20,
	type: "percentage"
}, DEFAULT_SIZE = {
	value: 50,
	type: "percentage"
}, SMALL_WIDTH_BOUNDARY = 100, SMALL_HEIGHT_BOUNDARY = 100, Droptarget = class C extends CompositeDisposable {
	get disabled() {
		return this._disabled;
	}
	set disabled(C) {
		this._disabled = C;
	}
	get state() {
		return this._state;
	}
	constructor(T, E) {
		super(), this.element = T, this.options = E, this._onDrop = new Emitter(), this.onDrop = this._onDrop.event, this._onWillShowOverlay = new Emitter(), this.onWillShowOverlay = this._onWillShowOverlay.event, this._disabled = !1, this._acceptedTargetZonesSet = new Set(this.options.acceptedTargetZones), this.dnd = new DragAndDropObserver(this.element, {
			onDragEnter: () => {
				var C, T, E;
				(E = (T = (C = this.options).getOverrideTarget) == null ? void 0 : T.call(C)) == null || E.getElements();
			},
			onDragOver: (T) => {
				var E, D, O, F, I, L, z;
				C.ACTUAL_TARGET = this;
				let B = (D = (E = this.options).getOverrideTarget) == null ? void 0 : D.call(E);
				if (this._acceptedTargetZonesSet.size === 0) {
					if (B) return;
					this.removeDropTarget();
					return;
				}
				let V = (I = (F = (O = this.options).getOverlayOutline) == null ? void 0 : F.call(O)) == null ? this.element : I, U = V.offsetWidth, W = V.offsetHeight;
				if (U === 0 || W === 0) return;
				let G = T.currentTarget.getBoundingClientRect(), K = ((L = T.clientX) == null ? 0 : L) - G.left, J = ((z = T.clientY) == null ? 0 : z) - G.top, Y = this.calculateQuadrant(this._acceptedTargetZonesSet, K, J, U, W);
				if (this.isAlreadyUsed(T) || Y === null) {
					this.removeDropTarget();
					return;
				}
				if (!this.options.canDisplayOverlay(T, Y)) {
					if (B) return;
					this.removeDropTarget();
					return;
				}
				let X = new WillShowOverlayEvent({
					nativeEvent: T,
					position: Y
				});
				if (this._onWillShowOverlay.fire(X), X.defaultPrevented) {
					this.removeDropTarget();
					return;
				}
				this.markAsUsed(T), B || this.targetElement || (this.targetElement = document.createElement("div"), this.targetElement.className = "dv-drop-target-dropzone", this.overlayElement = document.createElement("div"), this.overlayElement.className = "dv-drop-target-selection", this._state = "center", this.targetElement.appendChild(this.overlayElement), V.classList.add("dv-drop-target"), V.append(this.targetElement)), this.toggleClasses(Y, U, W), this._state = Y;
			},
			onDragLeave: () => {
				var C, T;
				(T = (C = this.options).getOverrideTarget) != null && T.call(C) || this.removeDropTarget();
			},
			onDragEnd: (T) => {
				var E, D;
				let O = (D = (E = this.options).getOverrideTarget) == null ? void 0 : D.call(E);
				O && C.ACTUAL_TARGET === this && this._state && (T.stopPropagation(), this._onDrop.fire({
					position: this._state,
					nativeEvent: T
				})), this.removeDropTarget(), O == null || O.clear();
			},
			onDrop: (C) => {
				var T, E, D;
				C.preventDefault();
				let O = this._state;
				this.removeDropTarget(), (D = (E = (T = this.options).getOverrideTarget) == null ? void 0 : E.call(T)) == null || D.clear(), O && (C.stopPropagation(), this._onDrop.fire({
					position: O,
					nativeEvent: C
				}));
			}
		}), this.addDisposables(this._onDrop, this._onWillShowOverlay, this.dnd);
	}
	setTargetZones(C) {
		this._acceptedTargetZonesSet = new Set(C);
	}
	setOverlayModel(C) {
		this.options.overlayModel = C;
	}
	dispose() {
		this.removeDropTarget(), super.dispose();
	}
	markAsUsed(T) {
		T[C.USED_EVENT_ID] = !0;
	}
	isAlreadyUsed(T) {
		let E = T[C.USED_EVENT_ID];
		return typeof E == "boolean" && E;
	}
	toggleClasses(C, T, E) {
		var D, O, F, I, L, z, B;
		let V = (O = (D = this.options).getOverrideTarget) == null ? void 0 : O.call(D);
		if (!V && !this.overlayElement) return;
		let U = T < SMALL_WIDTH_BOUNDARY, W = E < SMALL_HEIGHT_BOUNDARY, G = C === "left", K = C === "right", J = C === "top", Y = C === "bottom", X = !U && K, Z = !U && G, Q = !W && J, NL = !W && Y, PL = 1, FL = (I = (F = this.options.overlayModel) == null ? void 0 : F.size) == null ? DEFAULT_SIZE : I;
		if (FL.type === "percentage" ? PL = clamp(FL.value, 0, 100) / 100 : ((X || Z) && (PL = clamp(0, FL.value, T) / T), (Q || NL) && (PL = clamp(0, FL.value, E) / E)), V) {
			let D = (B = (z = (L = this.options).getOverlayOutline) == null ? void 0 : z.call(L)) == null ? this.element : B, O = D.getBoundingClientRect(), F = V.getElements(void 0, D), I = F.root, W = F.overlay, FL = I.getBoundingClientRect(), IL = O.top - FL.top, LL = O.left - FL.left, RL = {
				top: IL,
				left: LL,
				width: T,
				height: E
			};
			if (X ? (RL.left = LL + T * (1 - PL), RL.width = T * PL) : Z ? RL.width = T * PL : Q ? RL.height = E * PL : NL && (RL.top = IL + E * (1 - PL), RL.height = E * PL), U && G && (RL.width = 4), U && K && (RL.left = LL + T - 4, RL.width = 4), !checkBoundsChanged(W, RL)) return;
			setGPUOptimizedBounds(W, RL), W.className = `dv-drop-target-anchor${this.options.className ? ` ${this.options.className}` : ""}`, toggleClass(W, "dv-drop-target-left", G), toggleClass(W, "dv-drop-target-right", K), toggleClass(W, "dv-drop-target-top", J), toggleClass(W, "dv-drop-target-bottom", Y), toggleClass(W, "dv-drop-target-center", C === "center"), F.changed && (toggleClass(W, "dv-drop-target-anchor-container-changed", !0), setTimeout(() => {
				toggleClass(W, "dv-drop-target-anchor-container-changed", !1);
			}, 10));
			return;
		}
		if (!this.overlayElement) return;
		let IL = {
			top: "0px",
			left: "0px",
			width: "100%",
			height: "100%"
		};
		X ? (IL.left = `${100 * (1 - PL)}%`, IL.width = `${100 * PL}%`) : Z ? IL.width = `${100 * PL}%` : Q ? IL.height = `${100 * PL}%` : NL && (IL.top = `${100 * (1 - PL)}%`, IL.height = `${100 * PL}%`), setGPUOptimizedBoundsFromStrings(this.overlayElement, IL), toggleClass(this.overlayElement, "dv-drop-target-small-vertical", W), toggleClass(this.overlayElement, "dv-drop-target-small-horizontal", U), toggleClass(this.overlayElement, "dv-drop-target-left", G), toggleClass(this.overlayElement, "dv-drop-target-right", K), toggleClass(this.overlayElement, "dv-drop-target-top", J), toggleClass(this.overlayElement, "dv-drop-target-bottom", Y), toggleClass(this.overlayElement, "dv-drop-target-center", C === "center");
	}
	calculateQuadrant(C, T, E, D, O) {
		var F, I;
		let L = (I = (F = this.options.overlayModel) == null ? void 0 : F.activationSize) == null ? DEFAULT_ACTIVATION_SIZE : I;
		return L.type === "percentage" ? calculateQuadrantAsPercentage(C, T, E, D, O, L.value) : calculateQuadrantAsPixels(C, T, E, D, O, L.value);
	}
	removeDropTarget() {
		var C;
		this.targetElement && (this._state = void 0, (C = this.targetElement.parentElement) == null || C.classList.remove("dv-drop-target"), this.targetElement.remove(), this.targetElement = void 0, this.overlayElement = void 0);
	}
};
Droptarget.USED_EVENT_ID = "__dockview_droptarget_event_is_used__";
function calculateQuadrantAsPercentage(C, T, E, D, O, F) {
	let I = 100 * T / D, L = 100 * E / O;
	return C.has("left") && I < F ? "left" : C.has("right") && I > 100 - F ? "right" : C.has("top") && L < F ? "top" : C.has("bottom") && L > 100 - F ? "bottom" : C.has("center") ? "center" : null;
}
function calculateQuadrantAsPixels(C, T, E, D, O, F) {
	return C.has("left") && T < F ? "left" : C.has("right") && T > D - F ? "right" : C.has("top") && E < F ? "top" : C.has("bottom") && E > O - F ? "bottom" : C.has("center") ? "center" : null;
}
const PROPERTY_KEYS_PANEVIEW = (() => Object.keys({
	disableAutoResizing: void 0,
	disableDnd: void 0,
	className: void 0
}))();
var PaneviewUnhandledDragOverEvent = class extends AcceptableEvent {
	constructor(C, T, E, D) {
		super(), this.nativeEvent = C, this.position = T, this.getData = E, this.panel = D;
	}
}, WillFocusEvent = class extends DockviewEvent {
	constructor() {
		super();
	}
}, PanelApiImpl = class extends CompositeDisposable {
	get isFocused() {
		return this._isFocused;
	}
	get isActive() {
		return this._isActive;
	}
	get isVisible() {
		return this._isVisible;
	}
	get width() {
		return this._width;
	}
	get height() {
		return this._height;
	}
	constructor(C, T) {
		super(), this.id = C, this.component = T, this._isFocused = !1, this._isActive = !1, this._isVisible = !0, this._width = 0, this._height = 0, this._parameters = {}, this.panelUpdatesDisposable = new MutableDisposable(), this._onDidDimensionChange = new Emitter(), this.onDidDimensionsChange = this._onDidDimensionChange.event, this._onDidChangeFocus = new Emitter(), this.onDidFocusChange = this._onDidChangeFocus.event, this._onWillFocus = new Emitter(), this.onWillFocus = this._onWillFocus.event, this._onDidVisibilityChange = new Emitter(), this.onDidVisibilityChange = this._onDidVisibilityChange.event, this._onWillVisibilityChange = new Emitter(), this.onWillVisibilityChange = this._onWillVisibilityChange.event, this._onDidActiveChange = new Emitter(), this.onDidActiveChange = this._onDidActiveChange.event, this._onActiveChange = new Emitter(), this.onActiveChange = this._onActiveChange.event, this._onDidParametersChange = new Emitter(), this.onDidParametersChange = this._onDidParametersChange.event, this.addDisposables(this.onDidFocusChange((C) => {
			this._isFocused = C.isFocused;
		}), this.onDidActiveChange((C) => {
			this._isActive = C.isActive;
		}), this.onDidVisibilityChange((C) => {
			this._isVisible = C.isVisible;
		}), this.onDidDimensionsChange((C) => {
			this._width = C.width, this._height = C.height;
		}), this.panelUpdatesDisposable, this._onDidDimensionChange, this._onDidChangeFocus, this._onDidVisibilityChange, this._onDidActiveChange, this._onWillFocus, this._onActiveChange, this._onWillFocus, this._onWillVisibilityChange, this._onDidParametersChange);
	}
	getParameters() {
		return this._parameters;
	}
	initialize(C) {
		this.panelUpdatesDisposable.value = this._onDidParametersChange.event((T) => {
			this._parameters = T, C.update({ params: T });
		});
	}
	setVisible(C) {
		this._onWillVisibilityChange.fire({ isVisible: C });
	}
	setActive() {
		this._onActiveChange.fire();
	}
	updateParameters(C) {
		this._onDidParametersChange.fire(C);
	}
}, SplitviewPanelApiImpl = class extends PanelApiImpl {
	constructor(C, T) {
		super(C, T), this._onDidConstraintsChangeInternal = new Emitter(), this.onDidConstraintsChangeInternal = this._onDidConstraintsChangeInternal.event, this._onDidConstraintsChange = new Emitter({ replay: !0 }), this.onDidConstraintsChange = this._onDidConstraintsChange.event, this._onDidSizeChange = new Emitter(), this.onDidSizeChange = this._onDidSizeChange.event, this.addDisposables(this._onDidConstraintsChangeInternal, this._onDidConstraintsChange, this._onDidSizeChange);
	}
	setConstraints(C) {
		this._onDidConstraintsChangeInternal.fire(C);
	}
	setSize(C) {
		this._onDidSizeChange.fire(C);
	}
}, PaneviewPanelApiImpl = class extends SplitviewPanelApiImpl {
	set pane(C) {
		this._pane = C;
	}
	constructor(C, T) {
		super(C, T), this._onDidExpansionChange = new Emitter({ replay: !0 }), this.onDidExpansionChange = this._onDidExpansionChange.event, this._onMouseEnter = new Emitter({}), this.onMouseEnter = this._onMouseEnter.event, this._onMouseLeave = new Emitter({}), this.onMouseLeave = this._onMouseLeave.event, this.addDisposables(this._onDidExpansionChange, this._onMouseEnter, this._onMouseLeave);
	}
	setExpanded(C) {
		var T;
		(T = this._pane) == null || T.setExpanded(C);
	}
	get isExpanded() {
		var C;
		return !!((C = this._pane) != null && C.isExpanded());
	}
}, BasePanelView = class extends CompositeDisposable {
	get element() {
		return this._element;
	}
	get width() {
		return this._width;
	}
	get height() {
		return this._height;
	}
	get params() {
		var C;
		return (C = this._params) == null ? void 0 : C.params;
	}
	constructor(C, T, E) {
		super(), this.id = C, this.component = T, this.api = E, this._height = 0, this._width = 0, this._element = document.createElement("div"), this._element.tabIndex = -1, this._element.style.outline = "none", this._element.style.height = "100%", this._element.style.width = "100%", this._element.style.overflow = "hidden";
		let D = trackFocus(this._element);
		this.addDisposables(this.api, D.onDidFocus(() => {
			this.api._onDidChangeFocus.fire({ isFocused: !0 });
		}), D.onDidBlur(() => {
			this.api._onDidChangeFocus.fire({ isFocused: !1 });
		}), D);
	}
	focus() {
		let C = new WillFocusEvent();
		this.api._onWillFocus.fire(C), !C.defaultPrevented && this._element.focus();
	}
	layout(C, T) {
		this._width = C, this._height = T, this.api._onDidDimensionChange.fire({
			width: C,
			height: T
		}), this.part && this._params && this.part.update(this._params.params);
	}
	init(C) {
		this._params = C, this.part = this.getComponent();
	}
	update(C) {
		var T, E;
		this._params = Object.assign(Object.assign({}, this._params), { params: Object.assign(Object.assign({}, (T = this._params) == null ? void 0 : T.params), C.params) });
		for (let T of Object.keys(C.params)) C.params[T] === void 0 && delete this._params.params[T];
		(E = this.part) == null || E.update({ params: this._params.params });
	}
	toJSON() {
		var C, T;
		let E = (T = (C = this._params) == null ? void 0 : C.params) == null ? {} : T;
		return {
			id: this.id,
			component: this.component,
			params: Object.keys(E).length > 0 ? E : void 0
		};
	}
	dispose() {
		var C;
		this.api.dispose(), (C = this.part) == null || C.dispose(), super.dispose();
	}
}, PaneviewPanel = class extends BasePanelView {
	set orientation(C) {
		this._orientation = C;
	}
	get orientation() {
		return this._orientation;
	}
	get minimumSize() {
		return this.headerSize + (this.isExpanded() ? this._minimumBodySize : 0);
	}
	get maximumSize() {
		return this.headerSize + (this.isExpanded() ? this._maximumBodySize : 0);
	}
	get size() {
		return this._size;
	}
	get orthogonalSize() {
		return this._orthogonalSize;
	}
	set orthogonalSize(C) {
		this._orthogonalSize = C;
	}
	get minimumBodySize() {
		return this._minimumBodySize;
	}
	set minimumBodySize(C) {
		this._minimumBodySize = typeof C == "number" ? C : 0;
	}
	get maximumBodySize() {
		return this._maximumBodySize;
	}
	set maximumBodySize(C) {
		this._maximumBodySize = typeof C == "number" ? C : Infinity;
	}
	get headerVisible() {
		return this._headerVisible;
	}
	set headerVisible(C) {
		this._headerVisible = C, this.header.style.display = C ? "" : "none";
	}
	constructor(C) {
		super(C.id, C.component, new PaneviewPanelApiImpl(C.id, C.component)), this._onDidChangeExpansionState = new Emitter({ replay: !0 }), this.onDidChangeExpansionState = this._onDidChangeExpansionState.event, this._onDidChange = new Emitter(), this.onDidChange = this._onDidChange.event, this._orthogonalSize = 0, this._size = 0, this._isExpanded = !1, this.api.pane = this, this.api.initialize(this), this.headerSize = C.headerSize, this.headerComponent = C.headerComponent, this._minimumBodySize = C.minimumBodySize, this._maximumBodySize = C.maximumBodySize, this._isExpanded = C.isExpanded, this._headerVisible = C.isHeaderVisible, this._onDidChangeExpansionState.fire(this.isExpanded()), this._orientation = C.orientation, this.element.classList.add("dv-pane"), this.addDisposables(this.api.onWillVisibilityChange((C) => {
			let { isVisible: T } = C, { accessor: E } = this._params;
			E.setVisible(this, T);
		}), this.api.onDidSizeChange((C) => {
			this._onDidChange.fire({ size: C.size });
		}), addDisposableListener(this.element, "mouseenter", (C) => {
			this.api._onMouseEnter.fire(C);
		}), addDisposableListener(this.element, "mouseleave", (C) => {
			this.api._onMouseLeave.fire(C);
		})), this.addDisposables(this._onDidChangeExpansionState, this.onDidChangeExpansionState((C) => {
			this.api._onDidExpansionChange.fire({ isExpanded: C });
		}), this.api.onDidFocusChange((C) => {
			this.header && (C.isFocused ? addClasses(this.header, "focused") : removeClasses(this.header, "focused"));
		})), this.renderOnce();
	}
	setVisible(C) {
		this.api._onDidVisibilityChange.fire({ isVisible: C });
	}
	setActive(C) {
		this.api._onDidActiveChange.fire({ isActive: C });
	}
	isExpanded() {
		return this._isExpanded;
	}
	setExpanded(C) {
		this._isExpanded !== C && (this._isExpanded = C, C ? (this.animationTimer && clearTimeout(this.animationTimer), this.body && this.element.appendChild(this.body)) : this.animationTimer = setTimeout(() => {
			var C;
			(C = this.body) == null || C.remove();
		}, 200), this._onDidChange.fire(C ? { size: this.width } : {}), this._onDidChangeExpansionState.fire(C));
	}
	layout(C, T) {
		this._size = C, this._orthogonalSize = T;
		let [E, D] = this.orientation === Orientation.HORIZONTAL ? [C, T] : [T, C];
		super.layout(E, D);
	}
	init(C) {
		var T, E;
		super.init(C), typeof C.minimumBodySize == "number" && (this.minimumBodySize = C.minimumBodySize), typeof C.maximumBodySize == "number" && (this.maximumBodySize = C.maximumBodySize), this.bodyPart = this.getBodyComponent(), this.headerPart = this.getHeaderComponent(), this.bodyPart.init(Object.assign(Object.assign({}, C), { api: this.api })), this.headerPart.init(Object.assign(Object.assign({}, C), { api: this.api })), (T = this.body) == null || T.append(this.bodyPart.element), (E = this.header) == null || E.append(this.headerPart.element), typeof C.isExpanded == "boolean" && this.setExpanded(C.isExpanded);
	}
	toJSON() {
		let C = this._params;
		return Object.assign(Object.assign({}, super.toJSON()), {
			headerComponent: this.headerComponent,
			title: C.title
		});
	}
	renderOnce() {
		this.header = document.createElement("div"), this.header.tabIndex = 0, this.header.className = "dv-pane-header", this.header.style.height = `${this.headerSize}px`, this.header.style.lineHeight = `${this.headerSize}px`, this.header.style.minHeight = `${this.headerSize}px`, this.header.style.maxHeight = `${this.headerSize}px`, this.element.appendChild(this.header), this.body = document.createElement("div"), this.body.className = "dv-pane-body", this.element.appendChild(this.body);
	}
	getComponent() {
		return {
			update: (C) => {
				var T, E;
				(T = this.bodyPart) == null || T.update({ params: C }), (E = this.headerPart) == null || E.update({ params: C });
			},
			dispose: () => {
				var C, T;
				(C = this.bodyPart) == null || C.dispose(), (T = this.headerPart) == null || T.dispose();
			}
		};
	}
}, DraggablePaneviewPanel = class extends PaneviewPanel {
	constructor(C) {
		super({
			id: C.id,
			component: C.component,
			headerComponent: C.headerComponent,
			orientation: C.orientation,
			isExpanded: C.isExpanded,
			isHeaderVisible: !0,
			headerSize: C.headerSize,
			minimumBodySize: C.minimumBodySize,
			maximumBodySize: C.maximumBodySize
		}), this._onDidDrop = new Emitter(), this.onDidDrop = this._onDidDrop.event, this._onUnhandledDragOverEvent = new Emitter(), this.onUnhandledDragOverEvent = this._onUnhandledDragOverEvent.event, this.accessor = C.accessor, this.addDisposables(this._onDidDrop, this._onUnhandledDragOverEvent), C.disableDnd || this.initDragFeatures();
	}
	initDragFeatures() {
		if (!this.header) return;
		let C = this.id, T = this.accessor.id;
		this.header.draggable = !0, this.handler = new class extends DragHandler {
			getData() {
				return LocalSelectionTransfer.getInstance().setData([new PaneTransfer(T, C)], PaneTransfer.prototype), { dispose: () => {
					LocalSelectionTransfer.getInstance().clearData(PaneTransfer.prototype);
				} };
			}
		}(this.header), this.target = new Droptarget(this.element, {
			acceptedTargetZones: ["top", "bottom"],
			overlayModel: { activationSize: {
				type: "percentage",
				value: 50
			} },
			canDisplayOverlay: (C, T) => {
				let E = getPaneData();
				if (E && E.paneId !== this.id && E.viewId === this.accessor.id) return !0;
				let D = new PaneviewUnhandledDragOverEvent(C, T, getPaneData, this);
				return this._onUnhandledDragOverEvent.fire(D), D.isAccepted;
			}
		}), this.addDisposables(this._onDidDrop, this.handler, this.target, this.target.onDrop((C) => {
			this.onDrop(C);
		}));
	}
	onDrop(C) {
		let T = getPaneData();
		if (!T || T.viewId !== this.accessor.id) {
			this._onDidDrop.fire(Object.assign(Object.assign({}, C), {
				panel: this,
				api: new PaneviewApi(this.accessor),
				getData: getPaneData
			}));
			return;
		}
		let E = this._params.containerApi, D = T.paneId, O = E.getPanel(D);
		if (!O) {
			this._onDidDrop.fire(Object.assign(Object.assign({}, C), {
				panel: this,
				getData: getPaneData,
				api: new PaneviewApi(this.accessor)
			}));
			return;
		}
		let F = E.panels, I = F.indexOf(O), L = E.panels.indexOf(this);
		(C.position === "left" || C.position === "top") && (L = Math.max(0, L - 1)), (C.position === "right" || C.position === "bottom") && (I > L && L++, L = Math.min(F.length - 1, L)), E.movePanel(I, L);
	}
}, ContentContainer = class extends CompositeDisposable {
	get element() {
		return this._element;
	}
	constructor(C, T) {
		super(), this.accessor = C, this.group = T, this.disposable = new MutableDisposable(), this._onDidFocus = new Emitter(), this.onDidFocus = this._onDidFocus.event, this._onDidBlur = new Emitter(), this.onDidBlur = this._onDidBlur.event, this._element = document.createElement("div"), this._element.className = "dv-content-container", this._element.tabIndex = -1, this.addDisposables(this._onDidFocus, this._onDidBlur);
		let E = T.dropTargetContainer;
		this.dropTarget = new Droptarget(this.element, {
			getOverlayOutline: () => {
				var T;
				return ((T = C.options.theme) == null ? void 0 : T.dndPanelOverlay) === "group" ? this.element.parentElement : null;
			},
			className: "dv-drop-target-content",
			acceptedTargetZones: [
				"top",
				"bottom",
				"left",
				"right",
				"center"
			],
			canDisplayOverlay: (C, T) => {
				if (this.group.locked === "no-drop-target" || this.group.locked && T === "center") return !1;
				let E = getPanelData();
				return !E && C.shiftKey && this.group.location.type !== "floating" ? !1 : E && E.viewId === this.accessor.id ? !0 : this.group.canDisplayOverlay(C, T, "content");
			},
			getOverrideTarget: E ? () => E.model : void 0
		}), this.addDisposables(this.dropTarget);
	}
	show() {
		this.element.style.display = "";
	}
	hide() {
		this.element.style.display = "none";
	}
	renderPanel(C, T = { asActive: !0 }) {
		let E = T.asActive || this.panel && this.group.isPanelActive(this.panel);
		this.panel && this.panel.view.content.element.parentElement === this._element && this._element.removeChild(this.panel.view.content.element), this.panel = C;
		let D;
		switch (C.api.renderer) {
			case "onlyWhenVisible":
				this.group.renderContainer.detatch(C), this.panel && E && this._element.appendChild(this.panel.view.content.element), D = this._element;
				break;
			case "always":
				C.view.content.element.parentElement === this._element && this._element.removeChild(C.view.content.element), D = this.group.renderContainer.attach({
					panel: C,
					referenceContainer: this
				});
				break;
			default: throw Error(`dockview: invalid renderer type '${C.api.renderer}'`);
		}
		if (E) {
			let C = trackFocus(D), T = new CompositeDisposable();
			T.addDisposables(C, C.onDidFocus(() => this._onDidFocus.fire()), C.onDidBlur(() => this._onDidBlur.fire())), this.disposable.value = T;
		}
	}
	openPanel(C) {
		this.panel !== C && this.renderPanel(C);
	}
	layout(C, T) {}
	closePanel() {
		var C;
		this.panel && this.panel.api.renderer === "onlyWhenVisible" && ((C = this.panel.view.content.element.parentElement) == null || C.removeChild(this.panel.view.content.element)), this.panel = void 0;
	}
	dispose() {
		this.disposable.dispose(), super.dispose();
	}
};
function addGhostImage(C, T, E) {
	var D, O;
	addClasses(T, "dv-dragged"), T.style.top = "-9999px", document.body.appendChild(T), C.setDragImage(T, (D = E == null ? void 0 : E.x) == null ? 0 : D, (O = E == null ? void 0 : E.y) == null ? 0 : O), setTimeout(() => {
		removeClasses(T, "dv-dragged"), T.remove();
	}, 0);
}
var TabDragHandler = class extends DragHandler {
	constructor(C, T, E, D, O) {
		super(C, O), this.accessor = T, this.group = E, this.panel = D, this.panelTransfer = LocalSelectionTransfer.getInstance();
	}
	getData(C) {
		return this.panelTransfer.setData([new PanelTransfer(this.accessor.id, this.group.id, this.panel.id)], PanelTransfer.prototype), { dispose: () => {
			this.panelTransfer.clearData(PanelTransfer.prototype);
		} };
	}
}, Tab = class extends CompositeDisposable {
	get element() {
		return this._element;
	}
	constructor(C, T, E) {
		super(), this.panel = C, this.accessor = T, this.group = E, this.content = void 0, this._onPointDown = new Emitter(), this.onPointerDown = this._onPointDown.event, this._onDropped = new Emitter(), this.onDrop = this._onDropped.event, this._onDragStart = new Emitter(), this.onDragStart = this._onDragStart.event, this._element = document.createElement("div"), this._element.className = "dv-tab", this._element.tabIndex = 0, this._element.draggable = !this.accessor.options.disableDnd, toggleClass(this.element, "dv-inactive-tab", !0), this.dragHandler = new TabDragHandler(this._element, this.accessor, this.group, this.panel, !!this.accessor.options.disableDnd), this.dropTarget = new Droptarget(this._element, {
			acceptedTargetZones: ["left", "right"],
			overlayModel: { activationSize: {
				value: 50,
				type: "percentage"
			} },
			canDisplayOverlay: (C, T) => {
				if (this.group.locked) return !1;
				let E = getPanelData();
				return E && this.accessor.id === E.viewId ? !0 : this.group.model.canDisplayOverlay(C, T, "tab");
			},
			getOverrideTarget: () => {
				var C;
				return (C = E.model.dropTargetContainer) == null ? void 0 : C.model;
			}
		}), this.onWillShowOverlay = this.dropTarget.onWillShowOverlay, this.addDisposables(this._onPointDown, this._onDropped, this._onDragStart, this.dragHandler.onDragStart((C) => {
			if (C.dataTransfer) {
				let T = getComputedStyle(this.element), E = this.element.cloneNode(!0);
				Array.from(T).forEach((C) => E.style.setProperty(C, T.getPropertyValue(C), T.getPropertyPriority(C))), E.style.position = "absolute", addGhostImage(C.dataTransfer, E, {
					y: -10,
					x: 30
				});
			}
			this._onDragStart.fire(C);
		}), this.dragHandler, addDisposableListener(this._element, "pointerdown", (C) => {
			this._onPointDown.fire(C);
		}), this.dropTarget.onDrop((C) => {
			this._onDropped.fire(C);
		}), this.dropTarget);
	}
	setActive(C) {
		toggleClass(this.element, "dv-active-tab", C), toggleClass(this.element, "dv-inactive-tab", !C);
	}
	setContent(C) {
		this.content && this._element.removeChild(this.content.element), this.content = C, this._element.appendChild(this.content.element);
	}
	updateDragAndDropState() {
		this._element.draggable = !this.accessor.options.disableDnd, this.dragHandler.setDisabled(!!this.accessor.options.disableDnd);
	}
	dispose() {
		super.dispose();
	}
}, WillShowOverlayLocationEvent = class {
	get kind() {
		return this.options.kind;
	}
	get nativeEvent() {
		return this.event.nativeEvent;
	}
	get position() {
		return this.event.position;
	}
	get defaultPrevented() {
		return this.event.defaultPrevented;
	}
	get panel() {
		return this.options.panel;
	}
	get api() {
		return this.options.api;
	}
	get group() {
		return this.options.group;
	}
	preventDefault() {
		this.event.preventDefault();
	}
	getData() {
		return this.options.getData();
	}
	constructor(C, T) {
		this.event = C, this.options = T;
	}
}, GroupDragHandler = class extends DragHandler {
	constructor(C, T, E, D) {
		super(C, D), this.accessor = T, this.group = E, this.panelTransfer = LocalSelectionTransfer.getInstance(), this.addDisposables(addDisposableListener(C, "pointerdown", (C) => {
			C.shiftKey && quasiPreventDefault(C);
		}, !0));
	}
	isCancelled(C) {
		return this.group.api.location.type === "floating" && !C.shiftKey;
	}
	getData(C) {
		let T = C.dataTransfer;
		this.panelTransfer.setData([new PanelTransfer(this.accessor.id, this.group.id, null)], PanelTransfer.prototype);
		let E = window.getComputedStyle(this.el), D = E.getPropertyValue("--dv-activegroup-visiblepanel-tab-background-color"), O = E.getPropertyValue("--dv-activegroup-visiblepanel-tab-color");
		if (T) {
			let C = document.createElement("div");
			C.style.backgroundColor = D, C.style.color = O, C.style.padding = "2px 8px", C.style.height = "24px", C.style.fontSize = "11px", C.style.lineHeight = "20px", C.style.borderRadius = "12px", C.style.position = "absolute", C.style.pointerEvents = "none", C.style.top = "-9999px", C.textContent = `Multiple Panels (${this.group.size})`, addGhostImage(T, C, {
				y: -10,
				x: 30
			});
		}
		return { dispose: () => {
			this.panelTransfer.clearData(PanelTransfer.prototype);
		} };
	}
}, VoidContainer = class extends CompositeDisposable {
	get element() {
		return this._element;
	}
	constructor(C, T) {
		super(), this.accessor = C, this.group = T, this._onDrop = new Emitter(), this.onDrop = this._onDrop.event, this._onDragStart = new Emitter(), this.onDragStart = this._onDragStart.event, this._element = document.createElement("div"), this._element.className = "dv-void-container", this._element.draggable = !this.accessor.options.disableDnd, toggleClass(this._element, "dv-draggable", !this.accessor.options.disableDnd), this.addDisposables(this._onDrop, this._onDragStart, addDisposableListener(this._element, "pointerdown", () => {
			this.accessor.doSetGroupActive(this.group);
		})), this.handler = new GroupDragHandler(this._element, C, T, !!this.accessor.options.disableDnd), this.dropTarget = new Droptarget(this._element, {
			acceptedTargetZones: ["center"],
			canDisplayOverlay: (C, E) => {
				let D = getPanelData();
				return D && this.accessor.id === D.viewId ? !0 : T.model.canDisplayOverlay(C, E, "header_space");
			},
			getOverrideTarget: () => {
				var C;
				return (C = T.model.dropTargetContainer) == null ? void 0 : C.model;
			}
		}), this.onWillShowOverlay = this.dropTarget.onWillShowOverlay, this.addDisposables(this.handler, this.handler.onDragStart((C) => {
			this._onDragStart.fire(C);
		}), this.dropTarget.onDrop((C) => {
			this._onDrop.fire(C);
		}), this.dropTarget);
	}
	updateDragAndDropState() {
		this._element.draggable = !this.accessor.options.disableDnd, toggleClass(this._element, "dv-draggable", !this.accessor.options.disableDnd), this.handler.setDisabled(!!this.accessor.options.disableDnd);
	}
}, Scrollbar = class C extends CompositeDisposable {
	get element() {
		return this._element;
	}
	constructor(T) {
		super(), this.scrollableElement = T, this._scrollLeft = 0, this._element = document.createElement("div"), this._element.className = "dv-scrollable", this._horizontalScrollbar = document.createElement("div"), this._horizontalScrollbar.className = "dv-scrollbar-horizontal", this.element.appendChild(T), this.element.appendChild(this._horizontalScrollbar), this.addDisposables(addDisposableListener(this.element, "wheel", (T) => {
			this._scrollLeft += T.deltaY * C.MouseWheelSpeed, this.calculateScrollbarStyles();
		}), addDisposableListener(this._horizontalScrollbar, "pointerdown", (C) => {
			C.preventDefault(), toggleClass(this.element, "dv-scrollable-scrolling", !0);
			let T = C.clientX, E = this._scrollLeft, D = (C) => {
				let D = C.clientX - T, { clientWidth: O } = this.element, { scrollWidth: F } = this.scrollableElement;
				this._scrollLeft = E + D / (O / F), this.calculateScrollbarStyles();
			}, O = () => {
				toggleClass(this.element, "dv-scrollable-scrolling", !1), document.removeEventListener("pointermove", D), document.removeEventListener("pointerup", O), document.removeEventListener("pointercancel", O);
			};
			document.addEventListener("pointermove", D), document.addEventListener("pointerup", O), document.addEventListener("pointercancel", O);
		}), addDisposableListener(this.element, "scroll", () => {
			this.calculateScrollbarStyles();
		}), addDisposableListener(this.scrollableElement, "scroll", () => {
			this._scrollLeft = this.scrollableElement.scrollLeft, this.calculateScrollbarStyles();
		}), watchElementResize(this.element, () => {
			toggleClass(this.element, "dv-scrollable-resizing", !0), this._animationTimer && clearTimeout(this._animationTimer), this._animationTimer = setTimeout(() => {
				clearTimeout(this._animationTimer), toggleClass(this.element, "dv-scrollable-resizing", !1);
			}, 500), this.calculateScrollbarStyles();
		}));
	}
	calculateScrollbarStyles() {
		let { clientWidth: C } = this.element, { scrollWidth: T } = this.scrollableElement;
		if (T > C) {
			let E = C * (C / T);
			this._horizontalScrollbar.style.width = `${E}px`, this._scrollLeft = clamp(this._scrollLeft, 0, this.scrollableElement.scrollWidth - C), this.scrollableElement.scrollLeft = this._scrollLeft;
			let D = this._scrollLeft / (T - C);
			this._horizontalScrollbar.style.left = `${(C - E) * D}px`;
		} else this._horizontalScrollbar.style.width = "0px", this._horizontalScrollbar.style.left = "0px", this._scrollLeft = 0;
	}
};
Scrollbar.MouseWheelSpeed = 1;
var Tabs = class extends CompositeDisposable {
	get showTabsOverflowControl() {
		return this._showTabsOverflowControl;
	}
	set showTabsOverflowControl(C) {
		if (this._showTabsOverflowControl != C && (this._showTabsOverflowControl = C, C)) {
			let C = new OverflowObserver(this._tabsList);
			this._observerDisposable.value = new CompositeDisposable(C, C.onDidChange((C) => {
				let T = C.hasScrollX || C.hasScrollY;
				this.toggleDropdown({ reset: !T });
			}), addDisposableListener(this._tabsList, "scroll", () => {
				this.toggleDropdown({ reset: !1 });
			}));
		}
	}
	get element() {
		return this._element;
	}
	get panels() {
		return this._tabs.map((C) => C.value.panel.id);
	}
	get size() {
		return this._tabs.length;
	}
	get tabs() {
		return this._tabs.map((C) => C.value);
	}
	constructor(C, T, E) {
		if (super(), this.group = C, this.accessor = T, this._observerDisposable = new MutableDisposable(), this._tabs = [], this.selectedIndex = -1, this._showTabsOverflowControl = !1, this._onTabDragStart = new Emitter(), this.onTabDragStart = this._onTabDragStart.event, this._onDrop = new Emitter(), this.onDrop = this._onDrop.event, this._onWillShowOverlay = new Emitter(), this.onWillShowOverlay = this._onWillShowOverlay.event, this._onOverflowTabsChange = new Emitter(), this.onOverflowTabsChange = this._onOverflowTabsChange.event, this._tabsList = document.createElement("div"), this._tabsList.className = "dv-tabs-container dv-horizontal", this.showTabsOverflowControl = E.showTabsOverflowControl, T.options.scrollbars === "native") this._element = this._tabsList;
		else {
			let C = new Scrollbar(this._tabsList);
			this._element = C.element, this.addDisposables(C);
		}
		this.addDisposables(this._onOverflowTabsChange, this._observerDisposable, this._onWillShowOverlay, this._onDrop, this._onTabDragStart, addDisposableListener(this.element, "pointerdown", (C) => {
			C.defaultPrevented || C.button === 0 && this.accessor.doSetGroupActive(this.group);
		}), Disposable.from(() => {
			for (let { value: C, disposable: T } of this._tabs) T.dispose(), C.dispose();
			this._tabs = [];
		}));
	}
	indexOf(C) {
		return this._tabs.findIndex((T) => T.value.panel.id === C);
	}
	isActive(C) {
		return this.selectedIndex > -1 && this._tabs[this.selectedIndex].value === C;
	}
	setActivePanel(C) {
		let T = 0;
		for (let E of this._tabs) {
			let D = C.id === E.value.panel.id;
			if (E.value.setActive(D), D) {
				let C = E.value.element, D = C.parentElement;
				(T < D.scrollLeft || T + C.clientWidth > D.scrollLeft + D.clientWidth) && (D.scrollLeft = T);
			}
			T += E.value.element.clientWidth;
		}
	}
	openPanel(C, T = this._tabs.length) {
		if (this._tabs.find((T) => T.value.panel.id === C.id)) return;
		let E = new Tab(C, this.accessor, this.group);
		E.setContent(C.view.tab);
		let D = {
			value: E,
			disposable: new CompositeDisposable(E.onDragStart((T) => {
				this._onTabDragStart.fire({
					nativeEvent: T,
					panel: C
				});
			}), E.onPointerDown((T) => {
				if (T.defaultPrevented) return;
				let D = !this.accessor.options.disableFloatingGroups, O = this.group.api.location.type === "floating" && this.size === 1;
				if (D && !O && T.shiftKey) {
					T.preventDefault();
					let C = this.accessor.getGroupPanel(E.panel.id), { top: D, left: O } = E.element.getBoundingClientRect(), { top: F, left: I } = this.accessor.element.getBoundingClientRect();
					this.accessor.addFloatingGroup(C, {
						x: O - I,
						y: D - F,
						inDragMode: !0
					});
					return;
				}
				switch (T.button) {
					case 0:
						this.group.activePanel !== C && this.group.model.openPanel(C);
						break;
				}
			}), E.onDrop((C) => {
				this._onDrop.fire({
					event: C.nativeEvent,
					index: this._tabs.findIndex((C) => C.value === E)
				});
			}), E.onWillShowOverlay((C) => {
				this._onWillShowOverlay.fire(new WillShowOverlayLocationEvent(C, {
					kind: "tab",
					panel: this.group.activePanel,
					api: this.accessor.api,
					group: this.group,
					getData: getPanelData
				}));
			}))
		};
		this.addTab(D, T);
	}
	delete(C) {
		let T = this.indexOf(C), { value: E, disposable: D } = this._tabs.splice(T, 1)[0];
		D.dispose(), E.dispose(), E.element.remove();
	}
	addTab(C, T = this._tabs.length) {
		if (T < 0 || T > this._tabs.length) throw Error("invalid location");
		this._tabsList.insertBefore(C.value.element, this._tabsList.children[T]), this._tabs = [
			...this._tabs.slice(0, T),
			C,
			...this._tabs.slice(T)
		], this.selectedIndex < 0 && (this.selectedIndex = T);
	}
	toggleDropdown(C) {
		let T = C.reset ? [] : this._tabs.filter((C) => !isChildEntirelyVisibleWithinParent(C.value.element, this._tabsList)).map((C) => C.value.panel.id);
		this._onOverflowTabsChange.fire({
			tabs: T,
			reset: C.reset
		});
	}
	updateDragAndDropState() {
		for (let C of this._tabs) C.value.updateDragAndDropState();
	}
}, createSvgElementFromPath = (C) => {
	let T = document.createElementNS("http://www.w3.org/2000/svg", "svg");
	T.setAttributeNS(null, "height", C.height), T.setAttributeNS(null, "width", C.width), T.setAttributeNS(null, "viewBox", C.viewbox), T.setAttributeNS(null, "aria-hidden", "false"), T.setAttributeNS(null, "focusable", "false"), T.classList.add("dv-svg");
	let E = document.createElementNS("http://www.w3.org/2000/svg", "path");
	return E.setAttributeNS(null, "d", C.path), T.appendChild(E), T;
};
const createCloseButton = () => createSvgElementFromPath({
	width: "11",
	height: "11",
	viewbox: "0 0 28 28",
	path: "M2.1 27.3L0 25.2L11.55 13.65L0 2.1L2.1 0L13.65 11.55L25.2 0L27.3 2.1L15.75 13.65L27.3 25.2L25.2 27.3L13.65 15.75L2.1 27.3Z"
}), createExpandMoreButton = () => createSvgElementFromPath({
	width: "11",
	height: "11",
	viewbox: "0 0 24 15",
	path: "M12 14.15L0 2.15L2.15 0L12 9.9L21.85 0.0499992L24 2.2L12 14.15Z"
}), createChevronRightButton = () => createSvgElementFromPath({
	width: "11",
	height: "11",
	viewbox: "0 0 15 25",
	path: "M2.15 24.1L0 21.95L9.9 12.05L0 2.15L2.15 0L14.2 12.05L2.15 24.1Z"
});
function createDropdownElementHandle() {
	let C = document.createElement("div");
	C.className = "dv-tabs-overflow-dropdown-default";
	let T = document.createElement("span");
	T.textContent = "";
	let E = createChevronRightButton();
	return C.appendChild(E), C.appendChild(T), {
		element: C,
		update: (C) => {
			T.textContent = `${C.tabs}`;
		}
	};
}
var TabsContainer = class extends CompositeDisposable {
	get onTabDragStart() {
		return this.tabs.onTabDragStart;
	}
	get panels() {
		return this.tabs.panels;
	}
	get size() {
		return this.tabs.size;
	}
	get hidden() {
		return this._hidden;
	}
	set hidden(C) {
		this._hidden = C, this.element.style.display = C ? "none" : "";
	}
	get element() {
		return this._element;
	}
	constructor(C, T) {
		super(), this.accessor = C, this.group = T, this._hidden = !1, this.dropdownPart = null, this._overflowTabs = [], this._dropdownDisposable = new MutableDisposable(), this._onDrop = new Emitter(), this.onDrop = this._onDrop.event, this._onGroupDragStart = new Emitter(), this.onGroupDragStart = this._onGroupDragStart.event, this._onWillShowOverlay = new Emitter(), this.onWillShowOverlay = this._onWillShowOverlay.event, this._element = document.createElement("div"), this._element.className = "dv-tabs-and-actions-container", toggleClass(this._element, "dv-full-width-single-tab", this.accessor.options.singleTabMode === "fullwidth"), this.rightActionsContainer = document.createElement("div"), this.rightActionsContainer.className = "dv-right-actions-container", this.leftActionsContainer = document.createElement("div"), this.leftActionsContainer.className = "dv-left-actions-container", this.preActionsContainer = document.createElement("div"), this.preActionsContainer.className = "dv-pre-actions-container", this.tabs = new Tabs(T, C, { showTabsOverflowControl: !C.options.disableTabsOverflowList }), this.voidContainer = new VoidContainer(this.accessor, this.group), this._element.appendChild(this.preActionsContainer), this._element.appendChild(this.tabs.element), this._element.appendChild(this.leftActionsContainer), this._element.appendChild(this.voidContainer.element), this._element.appendChild(this.rightActionsContainer), this.addDisposables(this.tabs.onDrop((C) => this._onDrop.fire(C)), this.tabs.onWillShowOverlay((C) => this._onWillShowOverlay.fire(C)), C.onDidOptionsChange(() => {
			this.tabs.showTabsOverflowControl = !C.options.disableTabsOverflowList;
		}), this.tabs.onOverflowTabsChange((C) => {
			this.toggleDropdown(C);
		}), this.tabs, this._onWillShowOverlay, this._onDrop, this._onGroupDragStart, this.voidContainer, this.voidContainer.onDragStart((C) => {
			this._onGroupDragStart.fire({
				nativeEvent: C,
				group: this.group
			});
		}), this.voidContainer.onDrop((C) => {
			this._onDrop.fire({
				event: C.nativeEvent,
				index: this.tabs.size
			});
		}), this.voidContainer.onWillShowOverlay((C) => {
			this._onWillShowOverlay.fire(new WillShowOverlayLocationEvent(C, {
				kind: "header_space",
				panel: this.group.activePanel,
				api: this.accessor.api,
				group: this.group,
				getData: getPanelData
			}));
		}), addDisposableListener(this.voidContainer.element, "pointerdown", (C) => {
			if (!C.defaultPrevented && !this.accessor.options.disableFloatingGroups && C.shiftKey && this.group.api.location.type !== "floating") {
				C.preventDefault();
				let { top: T, left: E } = this.element.getBoundingClientRect(), { top: D, left: O } = this.accessor.element.getBoundingClientRect();
				this.accessor.addFloatingGroup(this.group, {
					x: E - O + 20,
					y: T - D + 20,
					inDragMode: !0
				});
			}
		}));
	}
	show() {
		this.hidden || (this.element.style.display = "");
	}
	hide() {
		this._element.style.display = "none";
	}
	setRightActionsElement(C) {
		this.rightActions !== C && (this.rightActions && (this.rightActions.remove(), this.rightActions = void 0), C && (this.rightActionsContainer.appendChild(C), this.rightActions = C));
	}
	setLeftActionsElement(C) {
		this.leftActions !== C && (this.leftActions && (this.leftActions.remove(), this.leftActions = void 0), C && (this.leftActionsContainer.appendChild(C), this.leftActions = C));
	}
	setPrefixActionsElement(C) {
		this.preActions !== C && (this.preActions && (this.preActions.remove(), this.preActions = void 0), C && (this.preActionsContainer.appendChild(C), this.preActions = C));
	}
	isActive(C) {
		return this.tabs.isActive(C);
	}
	indexOf(C) {
		return this.tabs.indexOf(C);
	}
	setActive(C) {}
	delete(C) {
		this.tabs.delete(C), this.updateClassnames();
	}
	setActivePanel(C) {
		this.tabs.setActivePanel(C);
	}
	openPanel(C, T = this.tabs.size) {
		this.tabs.openPanel(C, T), this.updateClassnames();
	}
	closePanel(C) {
		this.delete(C.id);
	}
	updateClassnames() {
		toggleClass(this._element, "dv-single-tab", this.size === 1);
	}
	toggleDropdown(C) {
		let T = C.reset ? [] : C.tabs;
		if (this._overflowTabs = T, this._overflowTabs.length > 0 && this.dropdownPart) {
			this.dropdownPart.update({ tabs: T.length });
			return;
		}
		if (this._overflowTabs.length === 0) {
			this._dropdownDisposable.dispose();
			return;
		}
		let E = document.createElement("div");
		E.className = "dv-tabs-overflow-dropdown-root";
		let D = createDropdownElementHandle();
		D.update({ tabs: T.length }), this.dropdownPart = D, E.appendChild(D.element), this.rightActionsContainer.prepend(E), this._dropdownDisposable.value = new CompositeDisposable(Disposable.from(() => {
			var C, T;
			E.remove(), (T = (C = this.dropdownPart) == null ? void 0 : C.dispose) == null || T.call(C), this.dropdownPart = null;
		}), addDisposableListener(E, "pointerdown", (C) => {
			C.preventDefault();
		}, { capture: !0 }), addDisposableListener(E, "click", (C) => {
			let T = document.createElement("div");
			T.style.overflow = "auto", T.className = "dv-tabs-overflow-container";
			for (let C of this.tabs.tabs.filter((C) => this._overflowTabs.includes(C.panel.id))) {
				let E = this.group.panels.find((T) => T === C.panel), D = E.view.createTabRenderer("headerOverflow").element, O = document.createElement("div");
				toggleClass(O, "dv-tab", !0), toggleClass(O, "dv-active-tab", E.api.isActive), toggleClass(O, "dv-inactive-tab", !E.api.isActive), O.addEventListener("click", (T) => {
					this.accessor.popupService.close(), !T.defaultPrevented && (C.element.scrollIntoView(), C.panel.api.setActive());
				}), O.appendChild(D), T.appendChild(O);
			}
			let D = findRelativeZIndexParent(E);
			this.accessor.popupService.openPopover(T, {
				x: C.clientX,
				y: C.clientY,
				zIndex: D != null && D.style.zIndex ? `calc(${D.style.zIndex} * 2)` : void 0
			});
		}));
	}
	updateDragAndDropState() {
		this.tabs.updateDragAndDropState(), this.voidContainer.updateDragAndDropState();
	}
}, DockviewUnhandledDragOverEvent = class extends AcceptableEvent {
	constructor(C, T, E, D, O) {
		super(), this.nativeEvent = C, this.target = T, this.position = E, this.getData = D, this.group = O;
	}
};
const PROPERTY_KEYS_DOCKVIEW = (() => Object.keys({
	disableAutoResizing: void 0,
	hideBorders: void 0,
	singleTabMode: void 0,
	disableFloatingGroups: void 0,
	floatingGroupBounds: void 0,
	popoutUrl: void 0,
	defaultRenderer: void 0,
	debug: void 0,
	rootOverlayModel: void 0,
	locked: void 0,
	disableDnd: void 0,
	className: void 0,
	noPanelsOverlay: void 0,
	dndEdges: void 0,
	theme: void 0,
	disableTabsOverflowList: void 0,
	scrollbars: void 0
}))();
function isPanelOptionsWithPanel(C) {
	return !!C.referencePanel;
}
function isPanelOptionsWithGroup(C) {
	return !!C.referenceGroup;
}
function isGroupOptionsWithPanel(C) {
	return !!C.referencePanel;
}
function isGroupOptionsWithGroup(C) {
	return !!C.referenceGroup;
}
var DockviewDidDropEvent = class extends DockviewEvent {
	get nativeEvent() {
		return this.options.nativeEvent;
	}
	get position() {
		return this.options.position;
	}
	get panel() {
		return this.options.panel;
	}
	get group() {
		return this.options.group;
	}
	get api() {
		return this.options.api;
	}
	constructor(C) {
		super(), this.options = C;
	}
	getData() {
		return this.options.getData();
	}
}, DockviewWillDropEvent = class extends DockviewDidDropEvent {
	get kind() {
		return this._kind;
	}
	constructor(C) {
		super(C), this._kind = C.kind;
	}
}, DockviewGroupPanelModel = class extends CompositeDisposable {
	get element() {
		throw Error("dockview: not supported");
	}
	get activePanel() {
		return this._activePanel;
	}
	get locked() {
		return this._locked;
	}
	set locked(C) {
		this._locked = C, toggleClass(this.container, "dv-locked-groupview", C === "no-drop-target" || C);
	}
	get isActive() {
		return this._isGroupActive;
	}
	get panels() {
		return this._panels;
	}
	get size() {
		return this._panels.length;
	}
	get isEmpty() {
		return this._panels.length === 0;
	}
	get hasWatermark() {
		return !!(this.watermark && this.container.contains(this.watermark.element));
	}
	get header() {
		return this.tabsContainer;
	}
	get isContentFocused() {
		return document.activeElement ? isAncestor(document.activeElement, this.contentContainer.element) : !1;
	}
	get location() {
		return this._location;
	}
	set location(C) {
		switch (this._location = C, toggleClass(this.container, "dv-groupview-floating", !1), toggleClass(this.container, "dv-groupview-popout", !1), C.type) {
			case "grid":
				this.contentContainer.dropTarget.setTargetZones([
					"top",
					"bottom",
					"left",
					"right",
					"center"
				]);
				break;
			case "floating":
				this.contentContainer.dropTarget.setTargetZones(["center"]), this.contentContainer.dropTarget.setTargetZones(C ? ["center"] : [
					"top",
					"bottom",
					"left",
					"right",
					"center"
				]), toggleClass(this.container, "dv-groupview-floating", !0);
				break;
			case "popout":
				this.contentContainer.dropTarget.setTargetZones(["center"]), toggleClass(this.container, "dv-groupview-popout", !0);
				break;
		}
		this.groupPanel.api._onDidLocationChange.fire({ location: this.location });
	}
	constructor(C, T, E, D, O) {
		var F;
		super(), this.container = C, this.accessor = T, this.id = E, this.options = D, this.groupPanel = O, this._isGroupActive = !1, this._locked = !1, this._location = { type: "grid" }, this.mostRecentlyUsed = [], this._overwriteRenderContainer = null, this._overwriteDropTargetContainer = null, this._onDidChange = new Emitter(), this.onDidChange = this._onDidChange.event, this._width = 0, this._height = 0, this._panels = [], this._panelDisposables = /* @__PURE__ */ new Map(), this._onMove = new Emitter(), this.onMove = this._onMove.event, this._onDidDrop = new Emitter(), this.onDidDrop = this._onDidDrop.event, this._onWillDrop = new Emitter(), this.onWillDrop = this._onWillDrop.event, this._onWillShowOverlay = new Emitter(), this.onWillShowOverlay = this._onWillShowOverlay.event, this._onTabDragStart = new Emitter(), this.onTabDragStart = this._onTabDragStart.event, this._onGroupDragStart = new Emitter(), this.onGroupDragStart = this._onGroupDragStart.event, this._onDidAddPanel = new Emitter(), this.onDidAddPanel = this._onDidAddPanel.event, this._onDidPanelTitleChange = new Emitter(), this.onDidPanelTitleChange = this._onDidPanelTitleChange.event, this._onDidPanelParametersChange = new Emitter(), this.onDidPanelParametersChange = this._onDidPanelParametersChange.event, this._onDidRemovePanel = new Emitter(), this.onDidRemovePanel = this._onDidRemovePanel.event, this._onDidActivePanelChange = new Emitter(), this.onDidActivePanelChange = this._onDidActivePanelChange.event, this._onUnhandledDragOverEvent = new Emitter(), this.onUnhandledDragOverEvent = this._onUnhandledDragOverEvent.event, toggleClass(this.container, "dv-groupview", !0), this._api = new DockviewApi(this.accessor), this.tabsContainer = new TabsContainer(this.accessor, this.groupPanel), this.contentContainer = new ContentContainer(this.accessor, this), C.append(this.tabsContainer.element, this.contentContainer.element), this.header.hidden = !!D.hideHeader, this.locked = (F = D.locked) == null ? !1 : F, this.addDisposables(this._onTabDragStart, this._onGroupDragStart, this._onWillShowOverlay, this.tabsContainer.onTabDragStart((C) => {
			this._onTabDragStart.fire(C);
		}), this.tabsContainer.onGroupDragStart((C) => {
			this._onGroupDragStart.fire(C);
		}), this.tabsContainer.onDrop((C) => {
			this.handleDropEvent("header", C.event, "center", C.index);
		}), this.contentContainer.onDidFocus(() => {
			this.accessor.doSetGroupActive(this.groupPanel);
		}), this.contentContainer.onDidBlur(() => {}), this.contentContainer.dropTarget.onDrop((C) => {
			this.handleDropEvent("content", C.nativeEvent, C.position);
		}), this.tabsContainer.onWillShowOverlay((C) => {
			this._onWillShowOverlay.fire(C);
		}), this.contentContainer.dropTarget.onWillShowOverlay((C) => {
			this._onWillShowOverlay.fire(new WillShowOverlayLocationEvent(C, {
				kind: "content",
				panel: this.activePanel,
				api: this._api,
				group: this.groupPanel,
				getData: getPanelData
			}));
		}), this._onMove, this._onDidChange, this._onDidDrop, this._onWillDrop, this._onDidAddPanel, this._onDidRemovePanel, this._onDidActivePanelChange, this._onUnhandledDragOverEvent, this._onDidPanelTitleChange, this._onDidPanelParametersChange);
	}
	focusContent() {
		this.contentContainer.element.focus();
	}
	set renderContainer(C) {
		this.panels.forEach((C) => {
			this.renderContainer.detatch(C);
		}), this._overwriteRenderContainer = C, this.panels.forEach((C) => {
			this.rerender(C);
		});
	}
	get renderContainer() {
		var C;
		return (C = this._overwriteRenderContainer) == null ? this.accessor.overlayRenderContainer : C;
	}
	set dropTargetContainer(C) {
		this._overwriteDropTargetContainer = C;
	}
	get dropTargetContainer() {
		var C;
		return (C = this._overwriteDropTargetContainer) == null ? this.accessor.rootDropTargetContainer : C;
	}
	initialize() {
		this.options.panels && this.options.panels.forEach((C) => {
			this.doAddPanel(C);
		}), this.options.activePanel && this.openPanel(this.options.activePanel), this.setActive(this.isActive, !0), this.updateContainer(), this.accessor.options.createRightHeaderActionComponent && (this._rightHeaderActions = this.accessor.options.createRightHeaderActionComponent(this.groupPanel), this.addDisposables(this._rightHeaderActions), this._rightHeaderActions.init({
			containerApi: this._api,
			api: this.groupPanel.api,
			group: this.groupPanel
		}), this.tabsContainer.setRightActionsElement(this._rightHeaderActions.element)), this.accessor.options.createLeftHeaderActionComponent && (this._leftHeaderActions = this.accessor.options.createLeftHeaderActionComponent(this.groupPanel), this.addDisposables(this._leftHeaderActions), this._leftHeaderActions.init({
			containerApi: this._api,
			api: this.groupPanel.api,
			group: this.groupPanel
		}), this.tabsContainer.setLeftActionsElement(this._leftHeaderActions.element)), this.accessor.options.createPrefixHeaderActionComponent && (this._prefixHeaderActions = this.accessor.options.createPrefixHeaderActionComponent(this.groupPanel), this.addDisposables(this._prefixHeaderActions), this._prefixHeaderActions.init({
			containerApi: this._api,
			api: this.groupPanel.api,
			group: this.groupPanel
		}), this.tabsContainer.setPrefixActionsElement(this._prefixHeaderActions.element));
	}
	rerender(C) {
		this.contentContainer.renderPanel(C, { asActive: !1 });
	}
	indexOf(C) {
		return this.tabsContainer.indexOf(C.id);
	}
	toJSON() {
		var C;
		let T = {
			views: this.tabsContainer.panels,
			activeView: (C = this._activePanel) == null ? void 0 : C.id,
			id: this.id
		};
		return this.locked !== !1 && (T.locked = this.locked), this.header.hidden && (T.hideHeader = !0), T;
	}
	moveToNext(C) {
		C || (C = {}), C.panel || (C.panel = this.activePanel);
		let T = C.panel ? this.panels.indexOf(C.panel) : -1, E;
		if (T < this.panels.length - 1) E = T + 1;
		else if (!C.suppressRoll) E = 0;
		else return;
		this.openPanel(this.panels[E]);
	}
	moveToPrevious(C) {
		if (C || (C = {}), C.panel || (C.panel = this.activePanel), !C.panel) return;
		let T = this.panels.indexOf(C.panel), E;
		if (T > 0) E = T - 1;
		else if (!C.suppressRoll) E = this.panels.length - 1;
		else return;
		this.openPanel(this.panels[E]);
	}
	containsPanel(C) {
		return this.panels.includes(C);
	}
	init(C) {}
	update(C) {}
	focus() {
		var C;
		(C = this._activePanel) == null || C.focus();
	}
	openPanel(C, T = {}) {
		(typeof T.index != "number" || T.index > this.panels.length) && (T.index = this.panels.length);
		let E = !!T.skipSetActive;
		if (C.updateParentGroup(this.groupPanel, { skipSetActive: T.skipSetActive }), this.doAddPanel(C, T.index, { skipSetActive: E }), this._activePanel === C) {
			this.contentContainer.renderPanel(C, { asActive: !0 });
			return;
		}
		E || this.doSetActivePanel(C), T.skipSetGroupActive || this.accessor.doSetGroupActive(this.groupPanel), T.skipSetActive || this.updateContainer();
	}
	removePanel(C, T = { skipSetActive: !1 }) {
		let E = typeof C == "string" ? C : C.id, D = this._panels.find((C) => C.id === E);
		if (!D) throw Error("invalid operation");
		return this._removePanel(D, T);
	}
	closeAllPanels() {
		if (this.panels.length > 0) {
			let C = [...this.panels];
			for (let T of C) this.doClose(T);
		} else this.accessor.removeGroup(this.groupPanel);
	}
	closePanel(C) {
		this.doClose(C);
	}
	doClose(C) {
		let T = this.panels.length === 1 && this.accessor.groups.length === 1;
		this.accessor.removePanel(C, T && this.accessor.options.noPanelsOverlay === "emptyGroup" ? { removeEmptyGroup: !1 } : void 0);
	}
	isPanelActive(C) {
		return this._activePanel === C;
	}
	updateActions(C) {
		this.tabsContainer.setRightActionsElement(C);
	}
	setActive(C, T = !1) {
		!T && this.isActive === C || (this._isGroupActive = C, toggleClass(this.container, "dv-active-group", C), toggleClass(this.container, "dv-inactive-group", !C), this.tabsContainer.setActive(this.isActive), !this._activePanel && this.panels.length > 0 && this.doSetActivePanel(this.panels[0]), this.updateContainer());
	}
	layout(C, T) {
		var E;
		this._width = C, this._height = T, this.contentContainer.layout(this._width, this._height), (E = this._activePanel) != null && E.layout && this._activePanel.layout(this._width, this._height);
	}
	_removePanel(C, T) {
		let E = this._activePanel === C;
		if (this.doRemovePanel(C), E && this.panels.length > 0) {
			let C = this.mostRecentlyUsed[0];
			this.openPanel(C, {
				skipSetActive: T.skipSetActive,
				skipSetGroupActive: T.skipSetActiveGroup
			});
		}
		return this._activePanel && this.panels.length === 0 && this.doSetActivePanel(void 0), T.skipSetActive || this.updateContainer(), C;
	}
	doRemovePanel(C) {
		let T = this.panels.indexOf(C);
		if (this._activePanel === C && this.contentContainer.closePanel(), this.tabsContainer.delete(C.id), this._panels.splice(T, 1), this.mostRecentlyUsed.includes(C)) {
			let T = this.mostRecentlyUsed.indexOf(C);
			this.mostRecentlyUsed.splice(T, 1);
		}
		let E = this._panelDisposables.get(C.id);
		E && (E.dispose(), this._panelDisposables.delete(C.id)), this._onDidRemovePanel.fire({ panel: C });
	}
	doAddPanel(C, T = this.panels.length, E = { skipSetActive: !1 }) {
		let D = this._panels.indexOf(C) > -1;
		this.tabsContainer.show(), this.contentContainer.show(), this.tabsContainer.openPanel(C, T), E.skipSetActive || this.contentContainer.openPanel(C), !D && (this.updateMru(C), this.panels.splice(T, 0, C), this._panelDisposables.set(C.id, new CompositeDisposable(C.api.onDidTitleChange((C) => this._onDidPanelTitleChange.fire(C)), C.api.onDidParametersChange((C) => this._onDidPanelParametersChange.fire(C)))), this._onDidAddPanel.fire({ panel: C }));
	}
	doSetActivePanel(C) {
		this._activePanel !== C && (this._activePanel = C, C && (this.tabsContainer.setActivePanel(C), C.layout(this._width, this._height), this.updateMru(C), this._onDidActivePanelChange.fire({ panel: C })));
	}
	updateMru(C) {
		this.mostRecentlyUsed.includes(C) && this.mostRecentlyUsed.splice(this.mostRecentlyUsed.indexOf(C), 1), this.mostRecentlyUsed = [C, ...this.mostRecentlyUsed];
	}
	updateContainer() {
		var C, T;
		if (this.panels.forEach((C) => C.runEvents()), this.isEmpty && !this.watermark) {
			let C = this.accessor.createWatermarkComponent();
			C.init({
				containerApi: this._api,
				group: this.groupPanel
			}), this.watermark = C, addDisposableListener(this.watermark.element, "pointerdown", () => {
				this.isActive || this.accessor.doSetGroupActive(this.groupPanel);
			}), this.contentContainer.element.appendChild(this.watermark.element);
		}
		!this.isEmpty && this.watermark && (this.watermark.element.remove(), (T = (C = this.watermark).dispose) == null || T.call(C), this.watermark = void 0);
	}
	canDisplayOverlay(C, T, E) {
		let D = new DockviewUnhandledDragOverEvent(C, E, T, getPanelData, this.accessor.getPanel(this.id));
		return this._onUnhandledDragOverEvent.fire(D), D.isAccepted;
	}
	handleDropEvent(C, T, E, D) {
		if (this.locked === "no-drop-target") return;
		function O() {
			switch (C) {
				case "header": return typeof D == "number" ? "tab" : "header_space";
				case "content": return "content";
			}
		}
		let F = typeof D == "number" ? this.panels[D] : void 0, I = new DockviewWillDropEvent({
			nativeEvent: T,
			position: E,
			panel: F,
			getData: () => getPanelData(),
			kind: O(),
			group: this.groupPanel,
			api: this._api
		});
		if (this._onWillDrop.fire(I), I.defaultPrevented) return;
		let L = getPanelData();
		if (L && L.viewId === this.accessor.id) {
			if (C === "content" && L.groupId === this.id && (E === "center" || L.panelId === null) || C === "header" && L.groupId === this.id && L.panelId === null) return;
			if (L.panelId === null) {
				let { groupId: C } = L;
				this._onMove.fire({
					target: E,
					groupId: C,
					index: D
				});
				return;
			}
			if (this.tabsContainer.indexOf(L.panelId) !== -1 && this.tabsContainer.size === 1) return;
			let { groupId: T, panelId: O } = L;
			if (this.id === T && !E && this.tabsContainer.indexOf(O) === D) return;
			this._onMove.fire({
				target: E,
				groupId: L.groupId,
				itemId: L.panelId,
				index: D
			});
		} else this._onDidDrop.fire(new DockviewDidDropEvent({
			nativeEvent: T,
			position: E,
			panel: F,
			getData: () => getPanelData(),
			group: this.groupPanel,
			api: this._api
		}));
	}
	updateDragAndDropState() {
		this.tabsContainer.updateDragAndDropState();
	}
	dispose() {
		var C, T, E;
		super.dispose(), (C = this.watermark) == null || C.element.remove(), (E = (T = this.watermark) == null ? void 0 : T.dispose) == null || E.call(T), this.watermark = void 0;
		for (let C of this.panels) C.dispose();
		this.tabsContainer.dispose(), this.contentContainer.dispose();
	}
}, GridviewPanelApiImpl = class extends PanelApiImpl {
	constructor(C, T, E) {
		super(C, T), this._onDidConstraintsChangeInternal = new Emitter(), this.onDidConstraintsChangeInternal = this._onDidConstraintsChangeInternal.event, this._onDidConstraintsChange = new Emitter(), this.onDidConstraintsChange = this._onDidConstraintsChange.event, this._onDidSizeChange = new Emitter(), this.onDidSizeChange = this._onDidSizeChange.event, this.addDisposables(this._onDidConstraintsChangeInternal, this._onDidConstraintsChange, this._onDidSizeChange), E && this.initialize(E);
	}
	setConstraints(C) {
		this._onDidConstraintsChangeInternal.fire(C);
	}
	setSize(C) {
		this._onDidSizeChange.fire(C);
	}
}, GridviewPanel = class extends BasePanelView {
	get priority() {
		return this._priority;
	}
	get snap() {
		return this._snap;
	}
	get minimumWidth() {
		return this.__minimumWidth();
	}
	get minimumHeight() {
		return this.__minimumHeight();
	}
	get maximumHeight() {
		return this.__maximumHeight();
	}
	get maximumWidth() {
		return this.__maximumWidth();
	}
	__minimumWidth() {
		let C = typeof this._minimumWidth == "function" ? this._minimumWidth() : this._minimumWidth;
		return C !== this._evaluatedMinimumWidth && (this._evaluatedMinimumWidth = C, this.updateConstraints()), C;
	}
	__maximumWidth() {
		let C = typeof this._maximumWidth == "function" ? this._maximumWidth() : this._maximumWidth;
		return C !== this._evaluatedMaximumWidth && (this._evaluatedMaximumWidth = C, this.updateConstraints()), C;
	}
	__minimumHeight() {
		let C = typeof this._minimumHeight == "function" ? this._minimumHeight() : this._minimumHeight;
		return C !== this._evaluatedMinimumHeight && (this._evaluatedMinimumHeight = C, this.updateConstraints()), C;
	}
	__maximumHeight() {
		let C = typeof this._maximumHeight == "function" ? this._maximumHeight() : this._maximumHeight;
		return C !== this._evaluatedMaximumHeight && (this._evaluatedMaximumHeight = C, this.updateConstraints()), C;
	}
	get isActive() {
		return this.api.isActive;
	}
	get isVisible() {
		return this.api.isVisible;
	}
	constructor(C, T, E, D) {
		super(C, T, D == null ? new GridviewPanelApiImpl(C, T) : D), this._evaluatedMinimumWidth = 0, this._evaluatedMaximumWidth = 9007199254740991, this._evaluatedMinimumHeight = 0, this._evaluatedMaximumHeight = 9007199254740991, this._minimumWidth = 0, this._minimumHeight = 0, this._maximumWidth = 9007199254740991, this._maximumHeight = 9007199254740991, this._snap = !1, this._onDidChange = new Emitter(), this.onDidChange = this._onDidChange.event, typeof (E == null ? void 0 : E.minimumWidth) == "number" && (this._minimumWidth = E.minimumWidth), typeof (E == null ? void 0 : E.maximumWidth) == "number" && (this._maximumWidth = E.maximumWidth), typeof (E == null ? void 0 : E.minimumHeight) == "number" && (this._minimumHeight = E.minimumHeight), typeof (E == null ? void 0 : E.maximumHeight) == "number" && (this._maximumHeight = E.maximumHeight), this.api.initialize(this), this.addDisposables(this.api.onWillVisibilityChange((C) => {
			let { isVisible: T } = C, { accessor: E } = this._params;
			E.setVisible(this, T);
		}), this.api.onActiveChange(() => {
			let { accessor: C } = this._params;
			C.doSetGroupActive(this);
		}), this.api.onDidConstraintsChangeInternal((C) => {
			(typeof C.minimumWidth == "number" || typeof C.minimumWidth == "function") && (this._minimumWidth = C.minimumWidth), (typeof C.minimumHeight == "number" || typeof C.minimumHeight == "function") && (this._minimumHeight = C.minimumHeight), (typeof C.maximumWidth == "number" || typeof C.maximumWidth == "function") && (this._maximumWidth = C.maximumWidth), (typeof C.maximumHeight == "number" || typeof C.maximumHeight == "function") && (this._maximumHeight = C.maximumHeight);
		}), this.api.onDidSizeChange((C) => {
			this._onDidChange.fire({
				height: C.height,
				width: C.width
			});
		}), this._onDidChange);
	}
	setVisible(C) {
		this.api._onDidVisibilityChange.fire({ isVisible: C });
	}
	setActive(C) {
		this.api._onDidActiveChange.fire({ isActive: C });
	}
	init(C) {
		C.maximumHeight && (this._maximumHeight = C.maximumHeight), C.minimumHeight && (this._minimumHeight = C.minimumHeight), C.maximumWidth && (this._maximumWidth = C.maximumWidth), C.minimumWidth && (this._minimumWidth = C.minimumWidth), this._priority = C.priority, this._snap = !!C.snap, super.init(C), typeof C.isVisible == "boolean" && this.setVisible(C.isVisible);
	}
	updateConstraints() {
		this.api._onDidConstraintsChange.fire({
			minimumWidth: this._evaluatedMinimumWidth,
			maximumWidth: this._evaluatedMaximumWidth,
			minimumHeight: this._evaluatedMinimumHeight,
			maximumHeight: this._evaluatedMaximumHeight
		});
	}
	toJSON() {
		let C = super.toJSON(), T = (C) => C === 9007199254740991 ? void 0 : C, E = (C) => C <= 0 ? void 0 : C;
		return Object.assign(Object.assign({}, C), {
			minimumHeight: E(this.minimumHeight),
			maximumHeight: T(this.maximumHeight),
			minimumWidth: E(this.minimumWidth),
			maximumWidth: T(this.maximumWidth),
			snap: this.snap,
			priority: this.priority
		});
	}
}, NOT_INITIALIZED_MESSAGE = "dockview: DockviewGroupPanelApiImpl not initialized", DockviewGroupPanelApiImpl = class extends GridviewPanelApiImpl {
	get location() {
		if (!this._group) throw Error(NOT_INITIALIZED_MESSAGE);
		return this._group.model.location;
	}
	constructor(C, T) {
		super(C, "__dockviewgroup__"), this.accessor = T, this._onDidLocationChange = new Emitter(), this.onDidLocationChange = this._onDidLocationChange.event, this._onDidActivePanelChange = new Emitter(), this.onDidActivePanelChange = this._onDidActivePanelChange.event, this.addDisposables(this._onDidLocationChange, this._onDidActivePanelChange);
	}
	close() {
		if (this._group) return this.accessor.removeGroup(this._group);
	}
	getWindow() {
		return this.location.type === "popout" ? this.location.getWindow() : window;
	}
	moveTo(C) {
		var T, E, D, O;
		if (!this._group) throw Error(NOT_INITIALIZED_MESSAGE);
		let F = (T = C.group) == null ? this.accessor.addGroup({
			direction: positionToDirection((E = C.position) == null ? "right" : E),
			skipSetActive: (D = C.skipSetActive) == null ? !1 : D
		}) : T;
		this.accessor.moveGroupOrPanel({
			from: { groupId: this._group.id },
			to: {
				group: F,
				position: C.group ? (O = C.position) == null ? "center" : O : "center",
				index: C.index
			},
			skipSetActive: C.skipSetActive
		});
	}
	maximize() {
		if (!this._group) throw Error(NOT_INITIALIZED_MESSAGE);
		this.location.type === "grid" && this.accessor.maximizeGroup(this._group);
	}
	isMaximized() {
		if (!this._group) throw Error(NOT_INITIALIZED_MESSAGE);
		return this.accessor.isMaximizedGroup(this._group);
	}
	exitMaximized() {
		if (!this._group) throw Error(NOT_INITIALIZED_MESSAGE);
		this.isMaximized() && this.accessor.exitMaximizedGroup();
	}
	initialize(C) {
		this._group = C;
	}
}, MINIMUM_DOCKVIEW_GROUP_PANEL_WIDTH = 100, MINIMUM_DOCKVIEW_GROUP_PANEL_HEIGHT = 100, DockviewGroupPanel = class extends GridviewPanel {
	get minimumWidth() {
		var C;
		if (typeof this._explicitConstraints.minimumWidth == "number") return this._explicitConstraints.minimumWidth;
		let T = (C = this.activePanel) == null ? void 0 : C.minimumWidth;
		return typeof T == "number" ? T : super.__minimumWidth();
	}
	get minimumHeight() {
		var C;
		if (typeof this._explicitConstraints.minimumHeight == "number") return this._explicitConstraints.minimumHeight;
		let T = (C = this.activePanel) == null ? void 0 : C.minimumHeight;
		return typeof T == "number" ? T : super.__minimumHeight();
	}
	get maximumWidth() {
		var C;
		if (typeof this._explicitConstraints.maximumWidth == "number") return this._explicitConstraints.maximumWidth;
		let T = (C = this.activePanel) == null ? void 0 : C.maximumWidth;
		return typeof T == "number" ? T : super.__maximumWidth();
	}
	get maximumHeight() {
		var C;
		if (typeof this._explicitConstraints.maximumHeight == "number") return this._explicitConstraints.maximumHeight;
		let T = (C = this.activePanel) == null ? void 0 : C.maximumHeight;
		return typeof T == "number" ? T : super.__maximumHeight();
	}
	get panels() {
		return this._model.panels;
	}
	get activePanel() {
		return this._model.activePanel;
	}
	get size() {
		return this._model.size;
	}
	get model() {
		return this._model;
	}
	get locked() {
		return this._model.locked;
	}
	set locked(C) {
		this._model.locked = C;
	}
	get header() {
		return this._model.header;
	}
	constructor(C, T, E) {
		var D, O, F, I, L, z;
		super(T, "groupview_default", {
			minimumHeight: (O = (D = E.constraints) == null ? void 0 : D.minimumHeight) == null ? MINIMUM_DOCKVIEW_GROUP_PANEL_HEIGHT : O,
			minimumWidth: (I = (F = E.constraints) == null ? void 0 : F.minimumWidth) == null ? MINIMUM_DOCKVIEW_GROUP_PANEL_WIDTH : I,
			maximumHeight: (L = E.constraints) == null ? void 0 : L.maximumHeight,
			maximumWidth: (z = E.constraints) == null ? void 0 : z.maximumWidth
		}, new DockviewGroupPanelApiImpl(T, C)), this._explicitConstraints = {}, this.api.initialize(this), this._model = new DockviewGroupPanelModel(this.element, C, T, E, this), this.addDisposables(this.model.onDidActivePanelChange((C) => {
			this.api._onDidActivePanelChange.fire(C);
		}), this.api.onDidConstraintsChangeInternal((C) => {
			C.minimumWidth !== void 0 && (this._explicitConstraints.minimumWidth = typeof C.minimumWidth == "function" ? C.minimumWidth() : C.minimumWidth), C.minimumHeight !== void 0 && (this._explicitConstraints.minimumHeight = typeof C.minimumHeight == "function" ? C.minimumHeight() : C.minimumHeight), C.maximumWidth !== void 0 && (this._explicitConstraints.maximumWidth = typeof C.maximumWidth == "function" ? C.maximumWidth() : C.maximumWidth), C.maximumHeight !== void 0 && (this._explicitConstraints.maximumHeight = typeof C.maximumHeight == "function" ? C.maximumHeight() : C.maximumHeight);
		}));
	}
	focus() {
		this.api.isActive || this.api.setActive(), super.focus();
	}
	initialize() {
		this._model.initialize();
	}
	setActive(C) {
		super.setActive(C), this.model.setActive(C);
	}
	layout(C, T) {
		super.layout(C, T), this.model.layout(C, T);
	}
	getComponent() {
		return this._model;
	}
	toJSON() {
		return this.model.toJSON();
	}
};
const themeAbyss = {
	name: "abyss",
	className: "dockview-theme-abyss"
};
var DockviewPanelApiImpl = class extends GridviewPanelApiImpl {
	get location() {
		return this.group.api.location;
	}
	get title() {
		return this.panel.title;
	}
	get isGroupActive() {
		return this.group.isActive;
	}
	get renderer() {
		return this.panel.renderer;
	}
	set group(C) {
		let T = this._group;
		this._group !== C && (this._group = C, this._onDidGroupChange.fire({}), this.setupGroupEventListeners(T), this._onDidLocationChange.fire({ location: this.group.api.location }));
	}
	get group() {
		return this._group;
	}
	get tabComponent() {
		return this._tabComponent;
	}
	constructor(C, T, E, D, O) {
		super(C.id, D), this.panel = C, this.accessor = E, this._onDidTitleChange = new Emitter(), this.onDidTitleChange = this._onDidTitleChange.event, this._onDidActiveGroupChange = new Emitter(), this.onDidActiveGroupChange = this._onDidActiveGroupChange.event, this._onDidGroupChange = new Emitter(), this.onDidGroupChange = this._onDidGroupChange.event, this._onDidRendererChange = new Emitter(), this.onDidRendererChange = this._onDidRendererChange.event, this._onDidLocationChange = new Emitter(), this.onDidLocationChange = this._onDidLocationChange.event, this.groupEventsDisposable = new MutableDisposable(), this._tabComponent = O, this.initialize(C), this._group = T, this.setupGroupEventListeners(), this.addDisposables(this.groupEventsDisposable, this._onDidRendererChange, this._onDidTitleChange, this._onDidGroupChange, this._onDidActiveGroupChange, this._onDidLocationChange);
	}
	getWindow() {
		return this.group.api.getWindow();
	}
	moveTo(C) {
		var T, E;
		this.accessor.moveGroupOrPanel({
			from: {
				groupId: this._group.id,
				panelId: this.panel.id
			},
			to: {
				group: (T = C.group) == null ? this._group : T,
				position: C.group ? (E = C.position) == null ? "center" : E : "center",
				index: C.index
			},
			skipSetActive: C.skipSetActive
		});
	}
	setTitle(C) {
		this.panel.setTitle(C);
	}
	setRenderer(C) {
		this.panel.setRenderer(C);
	}
	close() {
		this.group.model.closePanel(this.panel);
	}
	maximize() {
		this.group.api.maximize();
	}
	isMaximized() {
		return this.group.api.isMaximized();
	}
	exitMaximized() {
		this.group.api.exitMaximized();
	}
	setupGroupEventListeners(C) {
		var T;
		let E = (T = C == null ? void 0 : C.isActive) == null ? !1 : T;
		this.groupEventsDisposable.value = new CompositeDisposable(this.group.api.onDidVisibilityChange((C) => {
			let T = !C.isVisible && this.isVisible, E = C.isVisible && !this.isVisible, D = this.group.model.isPanelActive(this.panel);
			(T || E && D) && this._onDidVisibilityChange.fire(C);
		}), this.group.api.onDidLocationChange((C) => {
			this.group === this.panel.group && this._onDidLocationChange.fire(C);
		}), this.group.api.onDidActiveChange(() => {
			this.group === this.panel.group && E !== this.isGroupActive && (E = this.isGroupActive, this._onDidActiveGroupChange.fire({ isActive: this.isGroupActive }));
		}));
	}
}, DockviewPanel = class extends CompositeDisposable {
	get params() {
		return this._params;
	}
	get title() {
		return this._title;
	}
	get group() {
		return this._group;
	}
	get renderer() {
		var C;
		return (C = this._renderer) == null ? this.accessor.renderer : C;
	}
	get minimumWidth() {
		return this._minimumWidth;
	}
	get minimumHeight() {
		return this._minimumHeight;
	}
	get maximumWidth() {
		return this._maximumWidth;
	}
	get maximumHeight() {
		return this._maximumHeight;
	}
	constructor(C, T, E, D, O, F, I, L) {
		super(), this.id = C, this.accessor = D, this.containerApi = O, this.view = I, this._renderer = L.renderer, this._group = F, this._minimumWidth = L.minimumWidth, this._minimumHeight = L.minimumHeight, this._maximumWidth = L.maximumWidth, this._maximumHeight = L.maximumHeight, this.api = new DockviewPanelApiImpl(this, this._group, D, T, E), this.addDisposables(this.api.onActiveChange(() => {
			D.setActivePanel(this);
		}), this.api.onDidSizeChange((C) => {
			this.group.api.setSize(C);
		}), this.api.onDidRendererChange(() => {
			this.group.model.rerender(this);
		}));
	}
	init(C) {
		this._params = C.params, this.view.init(Object.assign(Object.assign({}, C), {
			api: this.api,
			containerApi: this.containerApi
		})), this.setTitle(C.title);
	}
	focus() {
		let C = new WillFocusEvent();
		this.api._onWillFocus.fire(C), !C.defaultPrevented && (this.api.isActive || this.api.setActive());
	}
	toJSON() {
		return {
			id: this.id,
			contentComponent: this.view.contentComponent,
			tabComponent: this.view.tabComponent,
			params: Object.keys(this._params || {}).length > 0 ? this._params : void 0,
			title: this.title,
			renderer: this._renderer,
			minimumHeight: this._minimumHeight,
			maximumHeight: this._maximumHeight,
			minimumWidth: this._minimumWidth,
			maximumWidth: this._maximumWidth
		};
	}
	setTitle(C) {
		C !== this.title && (this._title = C, this.api._onDidTitleChange.fire({ title: C }));
	}
	setRenderer(C) {
		C !== this.renderer && (this._renderer = C, this.api._onDidRendererChange.fire({ renderer: C }));
	}
	update(C) {
		var T;
		this._params = Object.assign(Object.assign({}, (T = this._params) == null ? {} : T), C.params);
		for (let T of Object.keys(C.params)) C.params[T] === void 0 && delete this._params[T];
		this.view.update({ params: this._params });
	}
	updateParentGroup(C, T) {
		this._group = C, this.api.group = this._group;
		let E = this._group.model.isPanelActive(this), D = this.group.api.isActive && E;
		T != null && T.skipSetActive || this.api.isActive !== D && this.api._onDidActiveChange.fire({ isActive: this.group.api.isActive && E }), this.api.isVisible !== E && this.api._onDidVisibilityChange.fire({ isVisible: E });
	}
	runEvents() {
		let C = this._group.model.isPanelActive(this), T = this.group.api.isActive && C;
		this.api.isActive !== T && this.api._onDidActiveChange.fire({ isActive: this.group.api.isActive && C }), this.api.isVisible !== C && this.api._onDidVisibilityChange.fire({ isVisible: C });
	}
	layout(C, T) {
		this.api._onDidDimensionChange.fire({
			width: C,
			height: T
		}), this.view.layout(C, T);
	}
	dispose() {
		this.api.dispose(), this.view.dispose();
	}
}, DefaultTab = class extends CompositeDisposable {
	get element() {
		return this._element;
	}
	constructor() {
		super(), this._element = document.createElement("div"), this._element.className = "dv-default-tab", this._content = document.createElement("div"), this._content.className = "dv-default-tab-content", this.action = document.createElement("div"), this.action.className = "dv-default-tab-action", this.action.appendChild(createCloseButton()), this._element.appendChild(this._content), this._element.appendChild(this.action), this.render();
	}
	init(C) {
		this._title = C.title, this.addDisposables(C.api.onDidTitleChange((C) => {
			this._title = C.title, this.render();
		}), addDisposableListener(this.action, "pointerdown", (C) => {
			C.preventDefault();
		}), addDisposableListener(this.action, "click", (T) => {
			T.defaultPrevented || (T.preventDefault(), C.api.close());
		})), this.render();
	}
	render() {
		var C;
		this._content.textContent !== this._title && (this._content.textContent = (C = this._title) == null ? "" : C);
	}
}, DockviewPanelModel = class {
	get content() {
		return this._content;
	}
	get tab() {
		return this._tab;
	}
	constructor(C, T, E, D) {
		this.accessor = C, this.id = T, this.contentComponent = E, this.tabComponent = D, this._content = this.createContentComponent(this.id, E), this._tab = this.createTabComponent(this.id, D);
	}
	createTabRenderer(C) {
		var T;
		let E = this.createTabComponent(this.id, this.tabComponent);
		return this._params && E.init(Object.assign(Object.assign({}, this._params), { tabLocation: C })), this._updateEvent && ((T = E.update) == null || T.call(E, this._updateEvent)), E;
	}
	init(C) {
		this._params = C, this.content.init(C), this.tab.init(Object.assign(Object.assign({}, C), { tabLocation: "header" }));
	}
	layout(C, T) {
		var E, D;
		(D = (E = this.content).layout) == null || D.call(E, C, T);
	}
	update(C) {
		var T, E, D, O;
		this._updateEvent = C, (E = (T = this.content).update) == null || E.call(T, C), (O = (D = this.tab).update) == null || O.call(D, C);
	}
	dispose() {
		var C, T, E, D;
		(T = (C = this.content).dispose) == null || T.call(C), (D = (E = this.tab).dispose) == null || D.call(E);
	}
	createContentComponent(C, T) {
		return this.accessor.options.createComponent({
			id: C,
			name: T
		});
	}
	createTabComponent(C, T) {
		let E = T == null ? this.accessor.options.defaultTabComponent : T;
		if (E) {
			if (this.accessor.options.createTabComponent) return this.accessor.options.createTabComponent({
				id: C,
				name: E
			}) || new DefaultTab();
			console.warn(`dockview: tabComponent '${T}' was not found. falling back to the default tab.`);
		}
		return new DefaultTab();
	}
}, DefaultDockviewDeserialzier = class {
	constructor(C) {
		this.accessor = C;
	}
	fromJSON(C, T) {
		var E, D;
		let O = C.id, F = C.params, I = C.title, L = C.view, z = L ? L.content.id : (E = C.contentComponent) == null ? "unknown" : E, B = L ? (D = L.tab) == null ? void 0 : D.id : C.tabComponent, V = new DockviewPanelModel(this.accessor, O, z, B), U = new DockviewPanel(O, z, B, this.accessor, new DockviewApi(this.accessor), T, V, {
			renderer: C.renderer,
			minimumWidth: C.minimumWidth,
			minimumHeight: C.minimumHeight,
			maximumWidth: C.maximumWidth,
			maximumHeight: C.maximumHeight
		});
		return U.init({
			title: I == null ? O : I,
			params: F == null ? {} : F
		}), U;
	}
}, Watermark = class extends CompositeDisposable {
	get element() {
		return this._element;
	}
	constructor() {
		super(), this._element = document.createElement("div"), this._element.className = "dv-watermark";
	}
	init(C) {}
}, arialLevelTracker = new class {
	constructor() {
		this._orderedList = [];
	}
	push(C) {
		this._orderedList = [...this._orderedList.filter((T) => T !== C), C], this.update();
	}
	destroy(C) {
		this._orderedList = this._orderedList.filter((T) => T !== C), this.update();
	}
	update() {
		for (let C = 0; C < this._orderedList.length; C++) this._orderedList[C].setAttribute("aria-level", `${C}`), this._orderedList[C].style.zIndex = `calc(var(--dv-overlay-z-index, 999) + ${C * 2})`;
	}
}(), Overlay = class C extends CompositeDisposable {
	set minimumInViewportWidth(C) {
		this.options.minimumInViewportWidth = C;
	}
	set minimumInViewportHeight(C) {
		this.options.minimumInViewportHeight = C;
	}
	get element() {
		return this._element;
	}
	get isVisible() {
		return this._isVisible;
	}
	constructor(C) {
		super(), this.options = C, this._element = document.createElement("div"), this._onDidChange = new Emitter(), this.onDidChange = this._onDidChange.event, this._onDidChangeEnd = new Emitter(), this.onDidChangeEnd = this._onDidChangeEnd.event, this.addDisposables(this._onDidChange, this._onDidChangeEnd), this._element.className = "dv-resize-container", this._isVisible = !0, this.setupResize("top"), this.setupResize("bottom"), this.setupResize("left"), this.setupResize("right"), this.setupResize("topleft"), this.setupResize("topright"), this.setupResize("bottomleft"), this.setupResize("bottomright"), this._element.appendChild(this.options.content), this.options.container.appendChild(this._element), this.setBounds(Object.assign(Object.assign(Object.assign(Object.assign({
			height: this.options.height,
			width: this.options.width
		}, "top" in this.options && { top: this.options.top }), "bottom" in this.options && { bottom: this.options.bottom }), "left" in this.options && { left: this.options.left }), "right" in this.options && { right: this.options.right })), arialLevelTracker.push(this._element);
	}
	setVisible(C) {
		C !== this.isVisible && (this._isVisible = C, toggleClass(this.element, "dv-hidden", !this.isVisible));
	}
	bringToFront() {
		arialLevelTracker.push(this._element);
	}
	setBounds(C = {}) {
		typeof C.height == "number" && (this._element.style.height = `${C.height}px`), typeof C.width == "number" && (this._element.style.width = `${C.width}px`), "top" in C && typeof C.top == "number" && (this._element.style.top = `${C.top}px`, this._element.style.bottom = "auto", this.verticalAlignment = "top"), "bottom" in C && typeof C.bottom == "number" && (this._element.style.bottom = `${C.bottom}px`, this._element.style.top = "auto", this.verticalAlignment = "bottom"), "left" in C && typeof C.left == "number" && (this._element.style.left = `${C.left}px`, this._element.style.right = "auto", this.horiziontalAlignment = "left"), "right" in C && typeof C.right == "number" && (this._element.style.right = `${C.right}px`, this._element.style.left = "auto", this.horiziontalAlignment = "right");
		let T = this.options.container.getBoundingClientRect(), E = this._element.getBoundingClientRect(), D = Math.max(0, this.getMinimumWidth(E.width)), O = Math.max(0, this.getMinimumHeight(E.height));
		if (this.verticalAlignment === "top") {
			let C = clamp(E.top - T.top, -O, Math.max(0, T.height - E.height + O));
			this._element.style.top = `${C}px`, this._element.style.bottom = "auto";
		}
		if (this.verticalAlignment === "bottom") {
			let C = clamp(T.bottom - E.bottom, -O, Math.max(0, T.height - E.height + O));
			this._element.style.bottom = `${C}px`, this._element.style.top = "auto";
		}
		if (this.horiziontalAlignment === "left") {
			let C = clamp(E.left - T.left, -D, Math.max(0, T.width - E.width + D));
			this._element.style.left = `${C}px`, this._element.style.right = "auto";
		}
		if (this.horiziontalAlignment === "right") {
			let C = clamp(T.right - E.right, -D, Math.max(0, T.width - E.width + D));
			this._element.style.right = `${C}px`, this._element.style.left = "auto";
		}
		this._onDidChange.fire();
	}
	toJSON() {
		let C = this.options.container.getBoundingClientRect(), T = this._element.getBoundingClientRect(), E = {};
		return this.verticalAlignment === "top" ? E.top = parseFloat(this._element.style.top) : this.verticalAlignment === "bottom" ? E.bottom = parseFloat(this._element.style.bottom) : E.top = T.top - C.top, this.horiziontalAlignment === "left" ? E.left = parseFloat(this._element.style.left) : this.horiziontalAlignment === "right" ? E.right = parseFloat(this._element.style.right) : E.left = T.left - C.left, E.width = T.width, E.height = T.height, E;
	}
	setupDrag(C, T = { inDragMode: !1 }) {
		let E = new MutableDisposable(), D = () => {
			let C = null, T = disableIframePointEvents();
			E.value = new CompositeDisposable({ dispose: () => {
				T.release();
			} }, addDisposableListener(window, "pointermove", (T) => {
				let E = this.options.container.getBoundingClientRect(), D = T.clientX - E.left, O = T.clientY - E.top;
				toggleClass(this._element, "dv-resize-container-dragging", !0);
				let F = this._element.getBoundingClientRect();
				C === null && (C = {
					x: T.clientX - F.left,
					y: T.clientY - F.top
				});
				let I = Math.max(0, this.getMinimumWidth(F.width)), L = Math.max(0, this.getMinimumHeight(F.height)), z = clamp(O - C.y, -L, Math.max(0, E.height - F.height + L)), B = clamp(C.y - O + E.height - F.height, -L, Math.max(0, E.height - F.height + L)), V = clamp(D - C.x, -I, Math.max(0, E.width - F.width + I)), U = clamp(C.x - D + E.width - F.width, -I, Math.max(0, E.width - F.width + I)), W = {};
				z <= B ? W.top = z : W.bottom = B, V <= U ? W.left = V : W.right = U, this.setBounds(W);
			}), addDisposableListener(window, "pointerup", () => {
				toggleClass(this._element, "dv-resize-container-dragging", !1), E.dispose(), this._onDidChangeEnd.fire();
			}));
		};
		this.addDisposables(E, addDisposableListener(C, "pointerdown", (C) => {
			if (C.defaultPrevented) {
				C.preventDefault();
				return;
			}
			quasiDefaultPrevented(C) || D();
		}), addDisposableListener(this.options.content, "pointerdown", (C) => {
			C.defaultPrevented || quasiDefaultPrevented(C) || C.shiftKey && D();
		}), addDisposableListener(this.options.content, "pointerdown", () => {
			arialLevelTracker.push(this._element);
		}, !0)), T.inDragMode && D();
	}
	setupResize(T) {
		let E = document.createElement("div");
		E.className = `dv-resize-handle-${T}`, this._element.appendChild(E);
		let D = new MutableDisposable();
		this.addDisposables(D, addDisposableListener(E, "pointerdown", (E) => {
			E.preventDefault();
			let O = null, F = disableIframePointEvents();
			D.value = new CompositeDisposable(addDisposableListener(window, "pointermove", (E) => {
				let D = this.options.container.getBoundingClientRect(), F = this._element.getBoundingClientRect(), I = E.clientY - D.top, L = E.clientX - D.left;
				O === null && (O = {
					originalY: I,
					originalHeight: F.height,
					originalX: L,
					originalWidth: F.width
				});
				let z, B, V, U, W, G, K = () => {
					z = clamp(I, -Number.MAX_VALUE, O.originalY + O.originalHeight > D.height ? this.getMinimumHeight(D.height) : Math.max(0, O.originalY + O.originalHeight - C.MINIMUM_HEIGHT)), V = O.originalY + O.originalHeight - z, B = D.height - z - V;
				}, J = () => {
					z = O.originalY - O.originalHeight, V = clamp(I - z, z < 0 && typeof this.options.minimumInViewportHeight == "number" ? -z + this.options.minimumInViewportHeight : C.MINIMUM_HEIGHT, Number.MAX_VALUE), B = D.height - z - V;
				}, Y = () => {
					U = clamp(L, -Number.MAX_VALUE, O.originalX + O.originalWidth > D.width ? this.getMinimumWidth(D.width) : Math.max(0, O.originalX + O.originalWidth - C.MINIMUM_WIDTH)), G = O.originalX + O.originalWidth - U, W = D.width - U - G;
				}, X = () => {
					U = O.originalX - O.originalWidth, G = clamp(L - U, U < 0 && typeof this.options.minimumInViewportWidth == "number" ? -U + this.options.minimumInViewportWidth : C.MINIMUM_WIDTH, Number.MAX_VALUE), W = D.width - U - G;
				};
				switch (T) {
					case "top":
						K();
						break;
					case "bottom":
						J();
						break;
					case "left":
						Y();
						break;
					case "right":
						X();
						break;
					case "topleft":
						K(), Y();
						break;
					case "topright":
						K(), X();
						break;
					case "bottomleft":
						J(), Y();
						break;
					case "bottomright":
						J(), X();
						break;
				}
				let Z = {};
				z <= B ? Z.top = z : Z.bottom = B, U <= W ? Z.left = U : Z.right = W, Z.height = V, Z.width = G, this.setBounds(Z);
			}), { dispose: () => {
				F.release();
			} }, addDisposableListener(window, "pointerup", () => {
				D.dispose(), this._onDidChangeEnd.fire();
			}));
		}));
	}
	getMinimumWidth(C) {
		return typeof this.options.minimumInViewportWidth == "number" ? C - this.options.minimumInViewportWidth : 0;
	}
	getMinimumHeight(C) {
		return typeof this.options.minimumInViewportHeight == "number" ? C - this.options.minimumInViewportHeight : 0;
	}
	dispose() {
		arialLevelTracker.destroy(this._element), this._element.remove(), super.dispose();
	}
};
Overlay.MINIMUM_HEIGHT = 20, Overlay.MINIMUM_WIDTH = 20;
var DockviewFloatingGroupPanel = class extends CompositeDisposable {
	constructor(C, T) {
		super(), this.group = C, this.overlay = T, this.addDisposables(T);
	}
	position(C) {
		this.overlay.setBounds(C);
	}
};
const DEFAULT_FLOATING_GROUP_POSITION = {
	left: 100,
	top: 100,
	width: 300,
	height: 300
};
var PositionCache = class {
	constructor() {
		this.cache = /* @__PURE__ */ new Map(), this.currentFrameId = 0, this.rafId = null;
	}
	getPosition(C) {
		let T = this.cache.get(C);
		if (T && T.frameId === this.currentFrameId) return T.rect;
		this.scheduleFrameUpdate();
		let E = getDomNodePagePosition(C);
		return this.cache.set(C, {
			rect: E,
			frameId: this.currentFrameId
		}), E;
	}
	invalidate() {
		this.currentFrameId++;
	}
	scheduleFrameUpdate() {
		this.rafId || (this.rafId = requestAnimationFrame(() => {
			this.currentFrameId++, this.rafId = null;
		}));
	}
};
function createFocusableElement() {
	let C = document.createElement("div");
	return C.tabIndex = -1, C;
}
var OverlayRenderContainer = class extends CompositeDisposable {
	constructor(C, T) {
		super(), this.element = C, this.accessor = T, this.map = {}, this._disposed = !1, this.positionCache = new PositionCache(), this.pendingUpdates = /* @__PURE__ */ new Set(), this.addDisposables(Disposable.from(() => {
			for (let C of Object.values(this.map)) C.disposable.dispose(), C.destroy.dispose();
			this._disposed = !0;
		}));
	}
	updateAllPositions() {
		if (!this._disposed) {
			this.positionCache.invalidate();
			for (let C of Object.values(this.map)) C.panel.api.isVisible && C.resize && C.resize();
		}
	}
	detatch(C) {
		if (this.map[C.api.id]) {
			let { disposable: T, destroy: E } = this.map[C.api.id];
			return T.dispose(), E.dispose(), delete this.map[C.api.id], !0;
		}
		return !1;
	}
	attach(C) {
		let { panel: T, referenceContainer: E } = C;
		if (!this.map[T.api.id]) {
			let C = createFocusableElement();
			C.className = "dv-render-overlay", this.map[T.api.id] = {
				panel: T,
				disposable: Disposable.NONE,
				destroy: Disposable.NONE,
				element: C
			};
		}
		let D = this.map[T.api.id].element;
		T.view.content.element.parentElement !== D && D.appendChild(T.view.content.element), D.parentElement !== this.element && this.element.appendChild(D);
		let O = () => {
			let C = T.api.id;
			this.pendingUpdates.has(C) || (this.pendingUpdates.add(C), requestAnimationFrame(() => {
				if (this.pendingUpdates.delete(C), this.isDisposed || !this.map[C]) return;
				let O = this.positionCache.getPosition(E.element), F = this.positionCache.getPosition(this.element), I = O.left - F.left, L = O.top - F.top, z = O.width, B = O.height;
				D.style.left = `${I}px`, D.style.top = `${L}px`, D.style.width = `${z}px`, D.style.height = `${B}px`, toggleClass(D, "dv-render-overlay-float", T.group.api.location.type === "floating");
			}));
		}, F = () => {
			T.api.isVisible && (this.positionCache.invalidate(), O()), D.style.display = T.api.isVisible ? "" : "none";
		}, I = new MutableDisposable(), L = () => {
			T.api.location.type === "floating" ? queueMicrotask(() => {
				let C = this.accessor.floatingGroups.find((C) => C.group === T.api.group);
				if (!C) return;
				let E = C.overlay.element, O = () => {
					let C = Number(E.getAttribute("aria-level"));
					D.style.zIndex = `calc(var(--dv-overlay-z-index, 999) + ${C * 2 + 1})`;
				}, F = new MutationObserver(() => {
					O();
				});
				I.value = Disposable.from(() => F.disconnect()), F.observe(E, {
					attributeFilter: ["aria-level"],
					attributes: !0
				}), O();
			}) : D.style.zIndex = "";
		}, z = new CompositeDisposable(I, new DragAndDropObserver(D, {
			onDragEnd: (C) => {
				E.dropTarget.dnd.onDragEnd(C);
			},
			onDragEnter: (C) => {
				E.dropTarget.dnd.onDragEnter(C);
			},
			onDragLeave: (C) => {
				E.dropTarget.dnd.onDragLeave(C);
			},
			onDrop: (C) => {
				E.dropTarget.dnd.onDrop(C);
			},
			onDragOver: (C) => {
				E.dropTarget.dnd.onDragOver(C);
			}
		}), T.api.onDidVisibilityChange(() => {
			F();
		}), T.api.onDidDimensionsChange(() => {
			T.api.isVisible && O();
		}), T.api.onDidLocationChange(() => {
			L();
		}));
		return this.map[T.api.id].destroy = Disposable.from(() => {
			var C;
			T.view.content.element.parentElement === D && D.removeChild(T.view.content.element), (C = D.parentElement) == null || C.removeChild(D);
		}), L(), queueMicrotask(() => {
			this.isDisposed || F();
		}), this.map[T.api.id].disposable.dispose(), this.map[T.api.id].disposable = z, this.map[T.api.id].resize = O, D;
	}
}, __awaiter = function(C, T, E, D) {
	function O(C) {
		return C instanceof E ? C : new E(function(T) {
			T(C);
		});
	}
	return new (E || (E = Promise))(function(E, F) {
		function I(C) {
			try {
				z(D.next(C));
			} catch (C) {
				F(C);
			}
		}
		function L(C) {
			try {
				z(D.throw(C));
			} catch (C) {
				F(C);
			}
		}
		function z(C) {
			C.done ? E(C.value) : O(C.value).then(I, L);
		}
		z((D = D.apply(C, T || [])).next());
	});
}, PopoutWindow = class extends CompositeDisposable {
	get window() {
		var C, T;
		return (T = (C = this._window) == null ? void 0 : C.value) == null ? null : T;
	}
	constructor(C, T, E) {
		super(), this.target = C, this.className = T, this.options = E, this._onWillClose = new Emitter(), this.onWillClose = this._onWillClose.event, this._onDidClose = new Emitter(), this.onDidClose = this._onDidClose.event, this._window = null, this.addDisposables(this._onWillClose, this._onDidClose, { dispose: () => {
			this.close();
		} });
	}
	dimensions() {
		if (!this._window) return null;
		let C = this._window.value.screenX;
		return {
			top: this._window.value.screenY,
			left: C,
			width: this._window.value.innerWidth,
			height: this._window.value.innerHeight
		};
	}
	close() {
		var C, T;
		this._window && (this._onWillClose.fire(), (T = (C = this.options).onWillClose) == null || T.call(C, {
			id: this.target,
			window: this._window.value
		}), this._window.disposable.dispose(), this._window = null, this._onDidClose.fire());
	}
	open() {
		var C, T;
		return __awaiter(this, void 0, void 0, function* () {
			if (this._window) throw Error("instance of popout window is already open");
			let E = `${this.options.url}`, D = Object.entries({
				top: this.options.top,
				left: this.options.left,
				width: this.options.width,
				height: this.options.height
			}).map(([C, T]) => `${C}=${T}`).join(","), O = window.open(E, this.target, D);
			if (!O) return null;
			let F = new CompositeDisposable();
			this._window = {
				value: O,
				disposable: F
			}, F.addDisposables(Disposable.from(() => {
				O.close();
			}), addDisposableListener(window, "beforeunload", () => {
				this.close();
			}));
			let I = this.createPopoutWindowContainer();
			return this.className && I.classList.add(this.className), (T = (C = this.options).onDidOpen) == null || T.call(C, {
				id: this.target,
				window: O
			}), new Promise((C, T) => {
				O.addEventListener("unload", (C) => {}), O.addEventListener("load", () => {
					try {
						let T = O.document;
						T.title = document.title, T.body.appendChild(I), addStyles(T, window.document.styleSheets), addDisposableListener(O, "beforeunload", () => {
							this.close();
						}), C(I);
					} catch (C) {
						T(C);
					}
				});
			});
		});
	}
	createPopoutWindowContainer() {
		let C = document.createElement("div");
		return C.classList.add("dv-popout-window"), C.id = "dv-popout-window", C.style.position = "absolute", C.style.width = "100%", C.style.height = "100%", C.style.top = "0px", C.style.left = "0px", C;
	}
}, StrictEventsSequencing = class extends CompositeDisposable {
	constructor(C) {
		super(), this.accessor = C, this.init();
	}
	init() {
		let C = /* @__PURE__ */ new Set(), T = /* @__PURE__ */ new Set();
		this.addDisposables(this.accessor.onDidAddPanel((T) => {
			if (C.has(T.api.id)) throw Error(`dockview: Invalid event sequence. [onDidAddPanel] called for panel ${T.api.id} but panel already exists`);
			C.add(T.api.id);
		}), this.accessor.onDidRemovePanel((T) => {
			if (C.has(T.api.id)) C.delete(T.api.id);
			else throw Error(`dockview: Invalid event sequence. [onDidRemovePanel] called for panel ${T.api.id} but panel does not exists`);
		}), this.accessor.onDidAddGroup((C) => {
			if (T.has(C.api.id)) throw Error(`dockview: Invalid event sequence. [onDidAddGroup] called for group ${C.api.id} but group already exists`);
			T.add(C.api.id);
		}), this.accessor.onDidRemoveGroup((C) => {
			if (T.has(C.api.id)) T.delete(C.api.id);
			else throw Error(`dockview: Invalid event sequence. [onDidRemoveGroup] called for group ${C.api.id} but group does not exists`);
		}));
	}
}, PopupService = class extends CompositeDisposable {
	constructor(C) {
		super(), this.root = C, this._active = null, this._activeDisposable = new MutableDisposable(), this._element = document.createElement("div"), this._element.className = "dv-popover-anchor", this._element.style.position = "relative", this.root.prepend(this._element), this.addDisposables(Disposable.from(() => {
			this.close();
		}), this._activeDisposable);
	}
	openPopover(C, T) {
		var E;
		this.close();
		let D = document.createElement("div");
		D.style.position = "absolute", D.style.zIndex = (E = T.zIndex) == null ? "var(--dv-overlay-z-index)" : E, D.appendChild(C);
		let O = this._element.getBoundingClientRect(), F = O.left, I = O.top;
		D.style.top = `${T.y - I}px`, D.style.left = `${T.x - F}px`, this._element.appendChild(D), this._active = D, this._activeDisposable.value = new CompositeDisposable(addDisposableListener(window, "pointerdown", (C) => {
			var T;
			let E = C.target;
			if (!(E instanceof HTMLElement)) return;
			let O = E;
			for (; O && O !== D;) O = (T = O == null ? void 0 : O.parentElement) == null ? null : T;
			O || this.close();
		})), requestAnimationFrame(() => {
			shiftAbsoluteElementIntoView(D, this.root);
		});
	}
	close() {
		this._active && (this._active.remove(), this._activeDisposable.dispose(), this._active = null);
	}
}, DropTargetAnchorContainer = class extends CompositeDisposable {
	get disabled() {
		return this._disabled;
	}
	set disabled(C) {
		var T;
		this.disabled !== C && (this._disabled = C, C && ((T = this.model) == null || T.clear()));
	}
	get model() {
		if (!this.disabled) return {
			clear: () => {
				var C;
				this._model && ((C = this._model.root.parentElement) == null || C.removeChild(this._model.root)), this._model = void 0;
			},
			exists: () => !!this._model,
			getElements: (C, T) => {
				let E = this._outline !== T;
				if (this._outline = T, this._model) return this._model.changed = E, this._model;
				let D = this.createContainer(), O = this.createAnchor();
				if (this._model = {
					root: D,
					overlay: O,
					changed: E
				}, D.appendChild(O), this.element.appendChild(D), (C == null ? void 0 : C.target) instanceof HTMLElement) {
					let T = C.target.getBoundingClientRect(), E = this.element.getBoundingClientRect();
					O.style.left = `${T.left - E.left}px`, O.style.top = `${T.top - E.top}px`;
				}
				return this._model;
			}
		};
	}
	constructor(C, T) {
		super(), this.element = C, this._disabled = !1, this._disabled = T.disabled, this.addDisposables(Disposable.from(() => {
			var C;
			(C = this.model) == null || C.clear();
		}));
	}
	createContainer() {
		let C = document.createElement("div");
		return C.className = "dv-drop-target-container", C;
	}
	createAnchor() {
		let C = document.createElement("div");
		return C.className = "dv-drop-target-anchor", C.style.visibility = "hidden", C;
	}
}, DEFAULT_ROOT_OVERLAY_MODEL = {
	activationSize: {
		type: "pixels",
		value: 10
	},
	size: {
		type: "pixels",
		value: 20
	}
};
function moveGroupWithoutDestroying(C) {
	let T = C.from.activePanel;
	[...C.from.panels].map((T) => {
		let E = C.from.model.removePanel(T);
		return C.from.model.renderContainer.detatch(T), E;
	}).forEach((E) => {
		C.to.model.openPanel(E, {
			skipSetActive: T !== E,
			skipSetGroupActive: !0
		});
	});
}
var DockviewComponent = class extends BaseGrid {
	get orientation() {
		return this.gridview.orientation;
	}
	get totalPanels() {
		return this.panels.length;
	}
	get panels() {
		return this.groups.flatMap((C) => C.panels);
	}
	get options() {
		return this._options;
	}
	get activePanel() {
		let C = this.activeGroup;
		if (C) return C.activePanel;
	}
	get renderer() {
		var C;
		return (C = this.options.defaultRenderer) == null ? "onlyWhenVisible" : C;
	}
	get api() {
		return this._api;
	}
	get floatingGroups() {
		return this._floatingGroups;
	}
	get popoutRestorationPromise() {
		return this._popoutRestorationPromise;
	}
	constructor(C, T) {
		var E, D, O;
		super(C, {
			proportionalLayout: !0,
			orientation: Orientation.HORIZONTAL,
			styles: T.hideBorders ? { separatorBorder: "transparent" } : void 0,
			disableAutoResizing: T.disableAutoResizing,
			locked: T.locked,
			margin: (D = (E = T.theme) == null ? void 0 : E.gap) == null ? 0 : D,
			className: T.className
		}), this.nextGroupId = sequentialNumberGenerator(), this._deserializer = new DefaultDockviewDeserialzier(this), this._watermark = null, this._onWillDragPanel = new Emitter(), this.onWillDragPanel = this._onWillDragPanel.event, this._onWillDragGroup = new Emitter(), this.onWillDragGroup = this._onWillDragGroup.event, this._onDidDrop = new Emitter(), this.onDidDrop = this._onDidDrop.event, this._onWillDrop = new Emitter(), this.onWillDrop = this._onWillDrop.event, this._onWillShowOverlay = new Emitter(), this.onWillShowOverlay = this._onWillShowOverlay.event, this._onUnhandledDragOverEvent = new Emitter(), this.onUnhandledDragOverEvent = this._onUnhandledDragOverEvent.event, this._onDidRemovePanel = new Emitter(), this.onDidRemovePanel = this._onDidRemovePanel.event, this._onDidAddPanel = new Emitter(), this.onDidAddPanel = this._onDidAddPanel.event, this._onDidPopoutGroupSizeChange = new Emitter(), this.onDidPopoutGroupSizeChange = this._onDidPopoutGroupSizeChange.event, this._onDidPopoutGroupPositionChange = new Emitter(), this.onDidPopoutGroupPositionChange = this._onDidPopoutGroupPositionChange.event, this._onDidOpenPopoutWindowFail = new Emitter(), this.onDidOpenPopoutWindowFail = this._onDidOpenPopoutWindowFail.event, this._onDidLayoutFromJSON = new Emitter(), this.onDidLayoutFromJSON = this._onDidLayoutFromJSON.event, this._onDidActivePanelChange = new Emitter({ replay: !0 }), this.onDidActivePanelChange = this._onDidActivePanelChange.event, this._onDidMovePanel = new Emitter(), this.onDidMovePanel = this._onDidMovePanel.event, this._onDidMaximizedGroupChange = new Emitter(), this.onDidMaximizedGroupChange = this._onDidMaximizedGroupChange.event, this._floatingGroups = [], this._popoutGroups = [], this._popoutRestorationPromise = Promise.resolve(), this._onDidRemoveGroup = new Emitter(), this.onDidRemoveGroup = this._onDidRemoveGroup.event, this._onDidAddGroup = new Emitter(), this.onDidAddGroup = this._onDidAddGroup.event, this._onDidOptionsChange = new Emitter(), this.onDidOptionsChange = this._onDidOptionsChange.event, this._onDidActiveGroupChange = new Emitter(), this.onDidActiveGroupChange = this._onDidActiveGroupChange.event, this._moving = !1, this._options = T, this.popupService = new PopupService(this.element), this._themeClassnames = new Classnames(this.element), this._api = new DockviewApi(this), this.rootDropTargetContainer = new DropTargetAnchorContainer(this.element, { disabled: !0 }), this.overlayRenderContainer = new OverlayRenderContainer(this.gridview.element, this), this._rootDropTarget = new Droptarget(this.element, {
			className: "dv-drop-target-edge",
			canDisplayOverlay: (C, T) => {
				let E = getPanelData();
				if (E) return E.viewId === this.id ? T === "center" ? this.gridview.length === 0 : !0 : !1;
				if (T === "center" && this.gridview.length !== 0) return !1;
				let D = new DockviewUnhandledDragOverEvent(C, "edge", T, getPanelData);
				return this._onUnhandledDragOverEvent.fire(D), D.isAccepted;
			},
			acceptedTargetZones: [
				"top",
				"bottom",
				"left",
				"right",
				"center"
			],
			overlayModel: (O = T.rootOverlayModel) == null ? DEFAULT_ROOT_OVERLAY_MODEL : O,
			getOverrideTarget: () => {
				var C;
				return (C = this.rootDropTargetContainer) == null ? void 0 : C.model;
			}
		}), this.updateDropTargetModel(T), toggleClass(this.gridview.element, "dv-dockview", !0), toggleClass(this.element, "dv-debug", !!T.debug), this.updateTheme(), this.updateWatermark(), T.debug && this.addDisposables(new StrictEventsSequencing(this)), this.addDisposables(this.rootDropTargetContainer, this.overlayRenderContainer, this._onWillDragPanel, this._onWillDragGroup, this._onWillShowOverlay, this._onDidActivePanelChange, this._onDidAddPanel, this._onDidRemovePanel, this._onDidLayoutFromJSON, this._onDidDrop, this._onWillDrop, this._onDidMovePanel, this._onDidAddGroup, this._onDidRemoveGroup, this._onDidActiveGroupChange, this._onUnhandledDragOverEvent, this._onDidMaximizedGroupChange, this._onDidOptionsChange, this._onDidPopoutGroupSizeChange, this._onDidPopoutGroupPositionChange, this._onDidOpenPopoutWindowFail, this.onDidViewVisibilityChangeMicroTaskQueue(() => {
			this.updateWatermark();
		}), this.onDidAdd((C) => {
			this._moving || this._onDidAddGroup.fire(C);
		}), this.onDidRemove((C) => {
			this._moving || this._onDidRemoveGroup.fire(C);
		}), this.onDidActiveChange((C) => {
			this._moving || this._onDidActiveGroupChange.fire(C);
		}), this.onDidMaximizedChange((C) => {
			this._onDidMaximizedGroupChange.fire({
				group: C.panel,
				isMaximized: C.isMaximized
			});
		}), Event$2.any(this.onDidAdd, this.onDidRemove)(() => {
			this.updateWatermark();
		}), Event$2.any(this.onDidAddPanel, this.onDidRemovePanel, this.onDidAddGroup, this.onDidRemove, this.onDidMovePanel, this.onDidActivePanelChange, this.onDidPopoutGroupPositionChange, this.onDidPopoutGroupSizeChange)(() => {
			this._bufferOnDidLayoutChange.fire();
		}), Disposable.from(() => {
			for (let C of [...this._floatingGroups]) C.dispose();
			for (let C of [...this._popoutGroups]) C.disposable.dispose();
		}), this._rootDropTarget, this._rootDropTarget.onWillShowOverlay((C) => {
			this.gridview.length > 0 && C.position === "center" || this._onWillShowOverlay.fire(new WillShowOverlayLocationEvent(C, {
				kind: "edge",
				panel: void 0,
				api: this._api,
				group: void 0,
				getData: getPanelData
			}));
		}), this._rootDropTarget.onDrop((C) => {
			var T;
			let E = new DockviewWillDropEvent({
				nativeEvent: C.nativeEvent,
				position: C.position,
				panel: void 0,
				api: this._api,
				group: void 0,
				getData: getPanelData,
				kind: "edge"
			});
			if (this._onWillDrop.fire(E), E.defaultPrevented) return;
			let D = getPanelData();
			D ? this.moveGroupOrPanel({
				from: {
					groupId: D.groupId,
					panelId: (T = D.panelId) == null ? void 0 : T
				},
				to: {
					group: this.orthogonalize(C.position),
					position: "center"
				}
			}) : this._onDidDrop.fire(new DockviewDidDropEvent({
				nativeEvent: C.nativeEvent,
				position: C.position,
				panel: void 0,
				api: this._api,
				group: void 0,
				getData: getPanelData
			}));
		}), this._rootDropTarget);
	}
	setVisible(C, T) {
		switch (C.api.location.type) {
			case "grid":
				super.setVisible(C, T);
				break;
			case "floating": {
				let E = this.floatingGroups.find((T) => T.group === C);
				E && (E.overlay.setVisible(T), C.api._onDidVisibilityChange.fire({ isVisible: T }));
				break;
			}
			case "popout":
				console.warn("dockview: You cannot hide a group that is in a popout window");
				break;
		}
	}
	addPopoutGroup(C, T) {
		var E, D, O, F, I;
		if (C instanceof DockviewPanel && C.group.size === 1) return this.addPopoutGroup(C.group, T);
		let L = getDockviewTheme(this.gridview.element), z = this.element;
		function B() {
			return T != null && T.position ? T.position : C instanceof DockviewGroupPanel ? C.element.getBoundingClientRect() : C.group ? C.group.element.getBoundingClientRect() : z.getBoundingClientRect();
		}
		let V = B(), U = (D = (E = T == null ? void 0 : T.overridePopoutGroup) == null ? void 0 : E.id) == null ? this.getNextGroupId() : D, W = new PopoutWindow(`${this.id}-${U}`, L == null ? "" : L, {
			url: (I = (O = T == null ? void 0 : T.popoutUrl) == null ? (F = this.options) == null ? void 0 : F.popoutUrl : O) == null ? "/popout.html" : I,
			left: window.screenX + V.left,
			top: window.screenY + V.top,
			width: V.width,
			height: V.height,
			onDidOpen: T == null ? void 0 : T.onDidOpen,
			onWillClose: T == null ? void 0 : T.onWillClose
		}), G = new CompositeDisposable(W, W.onDidClose(() => {
			G.dispose();
		}));
		return W.open().then((E) => {
			var D;
			if (W.isDisposed) return !1;
			let O = T != null && T.referenceGroup ? T.referenceGroup : C instanceof DockviewPanel ? C.group : C, F = C.api.location.type, I = O.element.parentElement !== null, L;
			if (I ? T != null && T.overridePopoutGroup ? L = T.overridePopoutGroup : (L = this.createGroup({ id: U }), E && this._onDidAddGroup.fire(L)) : L = O, E === null) return console.error("dockview: failed to create popout. perhaps you need to allow pop-ups for this website"), G.dispose(), this._onDidOpenPopoutWindowFail.fire(), this.movingLock(() => moveGroupWithoutDestroying({
				from: L,
				to: O
			})), O.api.isVisible || O.api.setVisible(!0), !1;
			let z = document.createElement("div");
			z.className = "dv-overlay-render-container";
			let B = new OverlayRenderContainer(z, this);
			L.model.renderContainer = B, L.layout(W.window.innerWidth, W.window.innerHeight);
			let V;
			if (!(T != null && T.overridePopoutGroup) && I) if (C instanceof DockviewPanel) this.movingLock(() => {
				let T = O.model.removePanel(C);
				L.model.openPanel(T);
			});
			else switch (this.movingLock(() => moveGroupWithoutDestroying({
				from: O,
				to: L
			})), F) {
				case "grid":
					O.api.setVisible(!1);
					break;
				case "floating":
				case "popout":
					V = (D = this._floatingGroups.find((T) => T.group.api.id === C.api.id)) == null ? void 0 : D.overlay.toJSON(), this.removeGroup(O);
					break;
			}
			E.classList.add("dv-dockview"), E.style.overflow = "hidden", E.appendChild(z), E.appendChild(L.element);
			let K = document.createElement("div"), J = new DropTargetAnchorContainer(K, { disabled: this.rootDropTargetContainer.disabled });
			E.appendChild(K), L.model.dropTargetContainer = J, L.model.location = {
				type: "popout",
				getWindow: () => W.window,
				popoutUrl: T == null ? void 0 : T.popoutUrl
			}, I && C.api.location.type === "grid" && C.api.setVisible(!1), this.doSetGroupAndPanelActive(L), G.addDisposables(L.api.onDidActiveChange((C) => {
				var T;
				C.isActive && ((T = W.window) == null || T.focus());
			}), L.api.onWillFocus(() => {
				var C;
				(C = W.window) == null || C.focus();
			}));
			let Y, X = I && O && this.getPanel(O.id), Z = {
				window: W,
				popoutGroup: L,
				referenceGroup: X ? O.id : void 0,
				disposable: { dispose: () => (G.dispose(), Y) }
			}, Q = onDidWindowMoveEnd(W.window);
			return G.addDisposables(Q, onDidWindowResizeEnd(W.window, () => {
				this._onDidPopoutGroupSizeChange.fire({
					width: W.window.innerWidth,
					height: W.window.innerHeight,
					group: L
				});
			}), Q.event(() => {
				this._onDidPopoutGroupPositionChange.fire({
					screenX: W.window.screenX,
					screenY: W.window.screenX,
					group: L
				});
			}), addDisposableListener(W.window, "resize", () => {
				L.layout(W.window.innerWidth, W.window.innerHeight);
			}), B, Disposable.from(() => {
				if (!this.isDisposed) {
					if (I && this.getPanel(O.id)) this.movingLock(() => moveGroupWithoutDestroying({
						from: L,
						to: O
					})), O.api.isVisible || O.api.setVisible(!0), this.getPanel(L.id) && this.doRemoveGroup(L, { skipPopoutAssociated: !0 });
					else if (this.getPanel(L.id)) {
						if (L.model.renderContainer = this.overlayRenderContainer, L.model.dropTargetContainer = this.rootDropTargetContainer, Y = L, !this._popoutGroups.find((C) => C.popoutGroup === L)) return;
						V ? this.addFloatingGroup(L, {
							height: V.height,
							width: V.width,
							position: V
						}) : (this.doRemoveGroup(L, {
							skipDispose: !0,
							skipActive: !0,
							skipPopoutReturn: !0
						}), L.model.location = { type: "grid" }, this.movingLock(() => {
							this.doAddGroup(L, [0]);
						})), this.doSetGroupAndPanelActive(L);
					}
				}
			})), this._popoutGroups.push(Z), this.updateWatermark(), !0;
		}).catch((C) => (console.error("dockview: failed to create popout.", C), !1));
	}
	addFloatingGroup(C, T) {
		var E, D, O, F, I;
		let L;
		if (C instanceof DockviewPanel) L = this.createGroup(), this._onDidAddGroup.fire(L), this.movingLock(() => this.removePanel(C, {
			removeEmptyGroup: !0,
			skipDispose: !0,
			skipSetActiveGroup: !0
		})), this.movingLock(() => L.model.openPanel(C, { skipSetGroupActive: !0 }));
		else {
			L = C;
			let D = (E = this._popoutGroups.find((C) => C.popoutGroup === L)) == null ? void 0 : E.referenceGroup, O = D ? this.getPanel(D) : void 0;
			typeof (T == null ? void 0 : T.skipRemoveGroup) == "boolean" && T.skipRemoveGroup || (O ? (this.movingLock(() => moveGroupWithoutDestroying({
				from: C,
				to: O
			})), this.doRemoveGroup(C, {
				skipPopoutReturn: !0,
				skipPopoutAssociated: !0
			}), this.doRemoveGroup(O, { skipDispose: !0 }), L = O) : this.doRemoveGroup(C, {
				skipDispose: !0,
				skipPopoutReturn: !0,
				skipPopoutAssociated: !1
			}));
		}
		function z() {
			if (T != null && T.position) {
				let C = {};
				return "left" in T.position ? C.left = Math.max(T.position.left, 0) : "right" in T.position ? C.right = Math.max(T.position.right, 0) : C.left = DEFAULT_FLOATING_GROUP_POSITION.left, "top" in T.position ? C.top = Math.max(T.position.top, 0) : "bottom" in T.position ? C.bottom = Math.max(T.position.bottom, 0) : C.top = DEFAULT_FLOATING_GROUP_POSITION.top, typeof T.width == "number" ? C.width = Math.max(T.width, 0) : C.width = DEFAULT_FLOATING_GROUP_POSITION.width, typeof T.height == "number" ? C.height = Math.max(T.height, 0) : C.height = DEFAULT_FLOATING_GROUP_POSITION.height, C;
			}
			return {
				left: typeof (T == null ? void 0 : T.x) == "number" ? Math.max(T.x, 0) : DEFAULT_FLOATING_GROUP_POSITION.left,
				top: typeof (T == null ? void 0 : T.y) == "number" ? Math.max(T.y, 0) : DEFAULT_FLOATING_GROUP_POSITION.top,
				width: typeof (T == null ? void 0 : T.width) == "number" ? Math.max(T.width, 0) : DEFAULT_FLOATING_GROUP_POSITION.width,
				height: typeof (T == null ? void 0 : T.height) == "number" ? Math.max(T.height, 0) : DEFAULT_FLOATING_GROUP_POSITION.height
			};
		}
		let B = z(), V = new Overlay(Object.assign(Object.assign({
			container: this.gridview.element,
			content: L.element
		}, B), {
			minimumInViewportWidth: this.options.floatingGroupBounds === "boundedWithinViewport" ? void 0 : (O = (D = this.options.floatingGroupBounds) == null ? void 0 : D.minimumWidthWithinViewport) == null ? 100 : O,
			minimumInViewportHeight: this.options.floatingGroupBounds === "boundedWithinViewport" ? void 0 : (I = (F = this.options.floatingGroupBounds) == null ? void 0 : F.minimumHeightWithinViewport) == null ? 100 : I
		})), U = L.element.querySelector(".dv-void-container");
		if (!U) throw Error("failed to find drag handle");
		V.setupDrag(U, { inDragMode: typeof (T == null ? void 0 : T.inDragMode) == "boolean" ? T.inDragMode : !1 });
		let W = new DockviewFloatingGroupPanel(L, V), G = new CompositeDisposable(L.api.onDidActiveChange((C) => {
			C.isActive && V.bringToFront();
		}), watchElementResize(L.element, (C) => {
			let { width: T, height: E } = C.contentRect;
			L.layout(T, E);
		}));
		W.addDisposables(V.onDidChange(() => {
			L.layout(L.width, L.height);
		}), V.onDidChangeEnd(() => {
			this._bufferOnDidLayoutChange.fire();
		}), L.onDidChange((C) => {
			V.setBounds({
				height: C == null ? void 0 : C.height,
				width: C == null ? void 0 : C.width
			});
		}), { dispose: () => {
			G.dispose(), remove(this._floatingGroups, W), L.model.location = { type: "grid" }, this.updateWatermark();
		} }), this._floatingGroups.push(W), L.model.location = { type: "floating" }, T != null && T.skipActiveGroup || this.doSetGroupAndPanelActive(L), this.updateWatermark();
	}
	orthogonalize(C, T) {
		switch (this.gridview.normalize(), C) {
			case "top":
			case "bottom":
				this.gridview.orientation === Orientation.HORIZONTAL && this.gridview.insertOrthogonalSplitviewAtRoot();
				break;
			case "left":
			case "right":
				this.gridview.orientation === Orientation.VERTICAL && this.gridview.insertOrthogonalSplitviewAtRoot();
				break;
			default: break;
		}
		switch (C) {
			case "top":
			case "left":
			case "center": return this.createGroupAtLocation([0], void 0, T);
			case "bottom":
			case "right": return this.createGroupAtLocation([this.gridview.length], void 0, T);
			default: throw Error(`unsupported position ${C}`);
		}
	}
	updateOptions(C) {
		var T, E;
		if (super.updateOptions(C), "floatingGroupBounds" in C) for (let D of this._floatingGroups) {
			switch (C.floatingGroupBounds) {
				case "boundedWithinViewport":
					D.overlay.minimumInViewportHeight = void 0, D.overlay.minimumInViewportWidth = void 0;
					break;
				case void 0:
					D.overlay.minimumInViewportHeight = 100, D.overlay.minimumInViewportWidth = 100;
					break;
				default: D.overlay.minimumInViewportHeight = (T = C.floatingGroupBounds) == null ? void 0 : T.minimumHeightWithinViewport, D.overlay.minimumInViewportWidth = (E = C.floatingGroupBounds) == null ? void 0 : E.minimumWidthWithinViewport;
			}
			D.overlay.setBounds();
		}
		this.updateDropTargetModel(C);
		let D = this.options.disableDnd;
		this._options = Object.assign(Object.assign({}, this.options), C), D !== this.options.disableDnd && this.updateDragAndDropState(), "theme" in C && this.updateTheme(), this.layout(this.gridview.width, this.gridview.height, !0);
	}
	layout(C, T, E) {
		if (super.layout(C, T, E), this._floatingGroups) for (let C of this._floatingGroups) C.overlay.setBounds();
	}
	updateDragAndDropState() {
		for (let C of this.groups) C.model.updateDragAndDropState();
	}
	focus() {
		var C;
		(C = this.activeGroup) == null || C.focus();
	}
	getGroupPanel(C) {
		return this.panels.find((T) => T.id === C);
	}
	setActivePanel(C) {
		C.group.model.openPanel(C), this.doSetGroupAndPanelActive(C.group);
	}
	moveToNext(C = {}) {
		var T;
		if (!C.group) {
			if (!this.activeGroup) return;
			C.group = this.activeGroup;
		}
		if (C.includePanel && C.group && C.group.activePanel !== C.group.panels[C.group.panels.length - 1]) {
			C.group.model.moveToNext({ suppressRoll: !0 });
			return;
		}
		let E = getGridLocation(C.group.element), D = (T = this.gridview.next(E)) == null ? void 0 : T.view;
		this.doSetGroupAndPanelActive(D);
	}
	moveToPrevious(C = {}) {
		var T;
		if (!C.group) {
			if (!this.activeGroup) return;
			C.group = this.activeGroup;
		}
		if (C.includePanel && C.group && C.group.activePanel !== C.group.panels[0]) {
			C.group.model.moveToPrevious({ suppressRoll: !0 });
			return;
		}
		let E = getGridLocation(C.group.element), D = (T = this.gridview.previous(E)) == null ? void 0 : T.view;
		D && this.doSetGroupAndPanelActive(D);
	}
	toJSON() {
		var C;
		let T = this.gridview.serialize(), E = this.panels.reduce((C, T) => (C[T.id] = T.toJSON(), C), {}), D = this._floatingGroups.map((C) => ({
			data: C.group.toJSON(),
			position: C.overlay.toJSON()
		})), O = this._popoutGroups.map((C) => ({
			data: C.popoutGroup.toJSON(),
			gridReferenceGroup: C.referenceGroup,
			position: C.window.dimensions(),
			url: C.popoutGroup.api.location.type === "popout" ? C.popoutGroup.api.location.popoutUrl : void 0
		})), F = {
			grid: T,
			panels: E,
			activeGroup: (C = this.activeGroup) == null ? void 0 : C.id
		};
		return D.length > 0 && (F.floatingGroups = D), O.length > 0 && (F.popoutGroups = O), F;
	}
	fromJSON(C) {
		var T, E;
		if (this.clear(), typeof C != "object" || !C) throw Error("serialized layout must be a non-null object");
		let { grid: D, panels: O, activeGroup: F } = C;
		if (D.root.type !== "branch" || !Array.isArray(D.root.data)) throw Error("root must be of type branch");
		try {
			let I = this.width, L = this.height, z = (C) => {
				let { id: T, locked: E, hideHeader: D, views: F, activeView: I } = C;
				if (typeof T != "string") throw Error("group id must be of type string");
				let L = this.createGroup({
					id: T,
					locked: !!E,
					hideHeader: !!D
				});
				this._onDidAddGroup.fire(L);
				let z = [];
				for (let C of F) {
					let T = this._deserializer.fromJSON(O[C], L);
					z.push(T);
				}
				for (let C = 0; C < F.length; C++) {
					let T = z[C], E = typeof I == "string" && I === T.id;
					L.model.openPanel(T, {
						skipSetActive: !E,
						skipSetGroupActive: !0
					});
				}
				return !L.activePanel && L.panels.length > 0 && L.model.openPanel(L.panels[L.panels.length - 1], { skipSetGroupActive: !0 }), L;
			};
			this.gridview.deserialize(D, { fromJSON: (C) => z(C.data) }), this.layout(I, L, !0);
			let B = (T = C.floatingGroups) == null ? [] : T;
			for (let C of B) {
				let { data: T, position: E } = C, D = z(T);
				this.addFloatingGroup(D, {
					position: E,
					width: E.width,
					height: E.height,
					skipRemoveGroup: !0,
					inDragMode: !1
				});
			}
			let V = (E = C.popoutGroups) == null ? [] : E, U = [];
			V.forEach((C, T) => {
				let { data: E, position: D, gridReferenceGroup: O, url: F } = C, I = z(E), L = new Promise((C) => {
					setTimeout(() => {
						this.addPopoutGroup(I, {
							position: D == null ? void 0 : D,
							overridePopoutGroup: O ? I : void 0,
							referenceGroup: O ? this.getPanel(O) : void 0,
							popoutUrl: F
						}), C();
					}, T * 100);
				});
				U.push(L);
			}), this._popoutRestorationPromise = Promise.all(U).then(() => void 0);
			for (let C of this._floatingGroups) C.overlay.setBounds();
			if (typeof F == "string") {
				let C = this.getPanel(F);
				C && this.doSetGroupAndPanelActive(C);
			}
		} catch (C) {
			console.error("dockview: failed to deserialize layout. Reverting changes", C);
			for (let C of this.groups) for (let T of C.panels) this.removePanel(T, {
				removeEmptyGroup: !1,
				skipDispose: !1
			});
			for (let C of this.groups) C.dispose(), this._groups.delete(C.id), this._onDidRemoveGroup.fire(C);
			for (let C of [...this._floatingGroups]) C.dispose();
			throw this.clear(), C;
		}
		this.updateWatermark(), requestAnimationFrame(() => {
			this.overlayRenderContainer.updateAllPositions();
		}), this._onDidLayoutFromJSON.fire();
	}
	clear() {
		let C = Array.from(this._groups.values()).map((C) => C.value), T = !!this.activeGroup;
		for (let T of C) this.removeGroup(T, { skipActive: !0 });
		T && this.doSetGroupAndPanelActive(void 0), this.gridview.clear();
	}
	closeAllGroups() {
		for (let C of this._groups.entries()) {
			let [T, E] = C;
			E.value.model.closeAllPanels();
		}
	}
	addPanel(C) {
		var T, E;
		if (this.panels.find((T) => T.id === C.id)) throw Error(`panel with id ${C.id} already exists`);
		let D;
		if (C.position && C.floating) throw Error("you can only provide one of: position, floating as arguments to .addPanel(...)");
		let O = {
			width: C.initialWidth,
			height: C.initialHeight
		}, F;
		if (C.position) if (isPanelOptionsWithPanel(C.position)) {
			let T = typeof C.position.referencePanel == "string" ? this.getGroupPanel(C.position.referencePanel) : C.position.referencePanel;
			if (F = C.position.index, !T) throw Error(`referencePanel '${C.position.referencePanel}' does not exist`);
			D = this.findGroup(T);
		} else if (isPanelOptionsWithGroup(C.position)) {
			if (D = typeof C.position.referenceGroup == "string" ? (T = this._groups.get(C.position.referenceGroup)) == null ? void 0 : T.value : C.position.referenceGroup, F = C.position.index, !D) throw Error(`referenceGroup '${C.position.referenceGroup}' does not exist`);
		} else {
			let T = this.orthogonalize(directionToPosition(C.position.direction)), E = this.createPanel(C, T);
			return T.model.openPanel(E, {
				skipSetActive: C.inactive,
				skipSetGroupActive: C.inactive,
				index: F
			}), C.inactive || this.doSetGroupAndPanelActive(T), T.api.setSize({
				height: O == null ? void 0 : O.height,
				width: O == null ? void 0 : O.width
			}), E;
		}
		else D = this.activeGroup;
		let I;
		if (D) {
			let T = toTarget(((E = C.position) == null ? void 0 : E.direction) || "within");
			if (C.floating) {
				let T = this.createGroup();
				this._onDidAddGroup.fire(T);
				let E = typeof C.floating == "object" && C.floating !== null ? C.floating : {};
				this.addFloatingGroup(T, Object.assign(Object.assign({}, E), {
					inDragMode: !1,
					skipRemoveGroup: !0,
					skipActiveGroup: !0
				})), I = this.createPanel(C, T), T.model.openPanel(I, {
					skipSetActive: C.inactive,
					skipSetGroupActive: C.inactive,
					index: F
				});
			} else if (D.api.location.type === "floating" || T === "center") I = this.createPanel(C, D), D.model.openPanel(I, {
				skipSetActive: C.inactive,
				skipSetGroupActive: C.inactive,
				index: F
			}), D.api.setSize({
				width: O == null ? void 0 : O.width,
				height: O == null ? void 0 : O.height
			}), C.inactive || this.doSetGroupAndPanelActive(D);
			else {
				let E = getGridLocation(D.element), L = getRelativeLocation(this.gridview.orientation, E, T), z = this.createGroupAtLocation(L, this.orientationAtLocation(L) === Orientation.VERTICAL ? O == null ? void 0 : O.height : O == null ? void 0 : O.width);
				I = this.createPanel(C, z), z.model.openPanel(I, {
					skipSetActive: C.inactive,
					skipSetGroupActive: C.inactive,
					index: F
				}), C.inactive || this.doSetGroupAndPanelActive(z);
			}
		} else if (C.floating) {
			let T = this.createGroup();
			this._onDidAddGroup.fire(T);
			let E = typeof C.floating == "object" && C.floating !== null ? C.floating : {};
			this.addFloatingGroup(T, Object.assign(Object.assign({}, E), {
				inDragMode: !1,
				skipRemoveGroup: !0,
				skipActiveGroup: !0
			})), I = this.createPanel(C, T), T.model.openPanel(I, {
				skipSetActive: C.inactive,
				skipSetGroupActive: C.inactive,
				index: F
			});
		} else {
			let T = this.createGroupAtLocation([0], this.gridview.orientation === Orientation.VERTICAL ? O == null ? void 0 : O.height : O == null ? void 0 : O.width);
			I = this.createPanel(C, T), T.model.openPanel(I, {
				skipSetActive: C.inactive,
				skipSetGroupActive: C.inactive,
				index: F
			}), C.inactive || this.doSetGroupAndPanelActive(T);
		}
		return I;
	}
	removePanel(C, T = { removeEmptyGroup: !0 }) {
		let E = C.group;
		if (!E) throw Error(`cannot remove panel ${C.id}. it's missing a group.`);
		E.model.removePanel(C, { skipSetActiveGroup: T.skipSetActiveGroup }), T.skipDispose || (C.group.model.renderContainer.detatch(C), C.dispose()), E.size === 0 && T.removeEmptyGroup && this.removeGroup(E, { skipActive: T.skipSetActiveGroup });
	}
	createWatermarkComponent() {
		return this.options.createWatermarkComponent ? this.options.createWatermarkComponent() : new Watermark();
	}
	updateWatermark() {
		var C, T;
		if (this.groups.filter((C) => C.api.location.type === "grid" && C.api.isVisible).length === 0) {
			if (!this._watermark) {
				this._watermark = this.createWatermarkComponent(), this._watermark.init({ containerApi: new DockviewApi(this) });
				let C = document.createElement("div");
				C.className = "dv-watermark-container", addTestId(C, "watermark-component"), C.appendChild(this._watermark.element), this.gridview.element.appendChild(C);
			}
		} else this._watermark && (this._watermark.element.parentElement.remove(), (T = (C = this._watermark).dispose) == null || T.call(C), this._watermark = null);
	}
	addGroup(C) {
		var T;
		if (C) {
			let E;
			if (isGroupOptionsWithPanel(C)) {
				let T = typeof C.referencePanel == "string" ? this.panels.find((T) => T.id === C.referencePanel) : C.referencePanel;
				if (!T) throw Error(`reference panel ${C.referencePanel} does not exist`);
				if (E = this.findGroup(T), !E) throw Error(`reference group for reference panel ${C.referencePanel} does not exist`);
			} else if (isGroupOptionsWithGroup(C)) {
				if (E = typeof C.referenceGroup == "string" ? (T = this._groups.get(C.referenceGroup)) == null ? void 0 : T.value : C.referenceGroup, !E) throw Error(`reference group ${C.referenceGroup} does not exist`);
			} else {
				let T = this.orthogonalize(directionToPosition(C.direction), C);
				return C.skipSetActive || this.doSetGroupAndPanelActive(T), T;
			}
			let D = toTarget(C.direction || "within"), O = getGridLocation(E.element), F = getRelativeLocation(this.gridview.orientation, O, D), I = this.createGroup(C), L = this.getLocationOrientation(F) === Orientation.VERTICAL ? C.initialHeight : C.initialWidth;
			return this.doAddGroup(I, F, L), C.skipSetActive || this.doSetGroupAndPanelActive(I), I;
		} else {
			let T = this.createGroup(C);
			return this.doAddGroup(T), this.doSetGroupAndPanelActive(T), T;
		}
	}
	getLocationOrientation(C) {
		return C.length % 2 == 0 && this.gridview.orientation === Orientation.HORIZONTAL ? Orientation.HORIZONTAL : Orientation.VERTICAL;
	}
	removeGroup(C, T) {
		this.doRemoveGroup(C, T);
	}
	doRemoveGroup(C, T) {
		var E;
		let D = [...C.panels];
		if (!(T != null && T.skipDispose)) for (let C of D) this.removePanel(C, {
			removeEmptyGroup: !1,
			skipDispose: (E = T == null ? void 0 : T.skipDispose) == null ? !1 : E
		});
		let O = this.activePanel;
		if (C.api.location.type === "floating") {
			let E = this._floatingGroups.find((T) => T.group === C);
			if (E) {
				if (T != null && T.skipDispose || (E.group.dispose(), this._groups.delete(C.id), this._onDidRemoveGroup.fire(C)), remove(this._floatingGroups, E), E.dispose(), !(T != null && T.skipActive) && this._activeGroup === C) {
					let C = Array.from(this._groups.values());
					this.doSetGroupAndPanelActive(C.length > 0 ? C[0].value : void 0);
				}
				return E.group;
			}
			throw Error("failed to find floating group");
		}
		if (C.api.location.type === "popout") {
			let E = this._popoutGroups.find((T) => T.popoutGroup === C);
			if (E) {
				if (!(T != null && T.skipDispose)) {
					if (!(T != null && T.skipPopoutAssociated)) {
						let C = E.referenceGroup ? this.getPanel(E.referenceGroup) : void 0;
						C && C.panels.length === 0 && this.removeGroup(C);
					}
					E.popoutGroup.dispose(), this._groups.delete(C.id), this._onDidRemoveGroup.fire(C);
				}
				remove(this._popoutGroups, E);
				let D = E.disposable.dispose();
				if (!(T != null && T.skipPopoutReturn) && D && (this.doAddGroup(D, [0]), this.doSetGroupAndPanelActive(D)), !(T != null && T.skipActive) && this._activeGroup === C) {
					let C = Array.from(this._groups.values());
					this.doSetGroupAndPanelActive(C.length > 0 ? C[0].value : void 0);
				}
				return this.updateWatermark(), E.popoutGroup;
			}
			throw Error("failed to find popout group");
		}
		let F = super.doRemoveGroup(C, T);
		return T != null && T.skipActive || this.activePanel !== O && this._onDidActivePanelChange.fire(this.activePanel), F;
	}
	movingLock(C) {
		let T = this._moving;
		try {
			return this._moving = !0, C();
		} finally {
			this._moving = T;
		}
	}
	moveGroupOrPanel(C) {
		var T;
		let E = C.to.group, D = C.from.groupId, O = C.from.panelId, F = C.to.position, I = C.to.index, L = D ? (T = this._groups.get(D)) == null ? void 0 : T.value : void 0;
		if (!L) throw Error(`Failed to find group id ${D}`);
		if (O === void 0) {
			this.moveGroup({
				from: { group: L },
				to: {
					group: E,
					position: F
				},
				skipSetActive: C.skipSetActive
			});
			return;
		}
		if (!F || F === "center") {
			let T = this.movingLock(() => L.model.removePanel(O, {
				skipSetActive: !1,
				skipSetActiveGroup: !0
			}));
			if (!T) throw Error(`No panel with id ${O}`);
			L.model.size === 0 && this.doRemoveGroup(L, { skipActive: !0 });
			let D = E.model.size === 0;
			this.movingLock(() => {
				var O;
				return E.model.openPanel(T, {
					index: I,
					skipSetActive: ((O = C.skipSetActive) == null ? !1 : O) && !D,
					skipSetGroupActive: !0
				});
			}), C.skipSetActive || this.doSetGroupAndPanelActive(E), this._onDidMovePanel.fire({
				panel: T,
				from: L
			});
		} else {
			let C = getGridLocation(E.element), T = getRelativeLocation(this.gridview.orientation, C, F);
			if (L.size < 2) {
				let [C, D] = tail(T);
				if (L.api.location.type === "grid") {
					let [T, E] = tail(getGridLocation(L.element));
					if (sequenceEquals(T, C)) {
						this.gridview.moveView(T, E, D), this._onDidMovePanel.fire({
							panel: this.getGroupPanel(O),
							from: L
						});
						return;
					}
				}
				if (L.api.location.type === "popout") {
					let C = this._popoutGroups.find((C) => C.popoutGroup === L), E = this.movingLock(() => C.popoutGroup.model.removePanel(C.popoutGroup.panels[0], {
						skipSetActive: !0,
						skipSetActiveGroup: !0
					}));
					this.doRemoveGroup(L, { skipActive: !0 });
					let D = this.createGroupAtLocation(T);
					this.movingLock(() => D.model.openPanel(E)), this.doSetGroupAndPanelActive(D), this._onDidMovePanel.fire({
						panel: this.getGroupPanel(O),
						from: L
					});
					return;
				}
				let I = this.movingLock(() => this.doRemoveGroup(L, {
					skipActive: !0,
					skipDispose: !0
				})), z = getGridLocation(E.element), B = getRelativeLocation(this.gridview.orientation, z, F);
				this.movingLock(() => this.doAddGroup(I, B)), this.doSetGroupAndPanelActive(I), this._onDidMovePanel.fire({
					panel: this.getGroupPanel(O),
					from: L
				});
			} else {
				let T = this.movingLock(() => L.model.removePanel(O, {
					skipSetActive: !1,
					skipSetActiveGroup: !0
				}));
				if (!T) throw Error(`No panel with id ${O}`);
				let E = getRelativeLocation(this.gridview.orientation, C, F), D = this.createGroupAtLocation(E);
				this.movingLock(() => D.model.openPanel(T, { skipSetGroupActive: !0 })), this.doSetGroupAndPanelActive(D), this._onDidMovePanel.fire({
					panel: T,
					from: L
				});
			}
		}
	}
	moveGroup(C) {
		let T = C.from.group, E = C.to.group, D = C.to.position;
		if (D === "center") {
			let D = T.activePanel, O = this.movingLock(() => [...T.panels].map((C) => T.model.removePanel(C.id, { skipSetActive: !0 })));
			(T == null ? void 0 : T.model.size) === 0 && this.doRemoveGroup(T, { skipActive: !0 }), this.movingLock(() => {
				for (let C of O) E.model.openPanel(C, {
					skipSetActive: C !== D,
					skipSetGroupActive: !0
				});
			}), C.skipSetActive === !0 && this.activePanel || this.doSetGroupAndPanelActive(E);
		} else {
			switch (T.api.location.type) {
				case "grid":
					this.gridview.removeView(getGridLocation(T.element));
					break;
				case "floating": {
					let C = this._floatingGroups.find((C) => C.group === T);
					if (!C) throw Error("failed to find floating group");
					C.dispose();
					break;
				}
				case "popout": {
					let C = this._popoutGroups.find((C) => C.popoutGroup === T);
					if (!C) throw Error("failed to find popout group");
					let D = this._popoutGroups.indexOf(C);
					if (D >= 0 && this._popoutGroups.splice(D, 1), C.referenceGroup) {
						let T = this.getPanel(C.referenceGroup);
						T && !T.api.isVisible && this.doRemoveGroup(T, { skipActive: !0 });
					}
					C.window.dispose(), E.api.location.type === "grid" ? (T.model.renderContainer = this.overlayRenderContainer, T.model.dropTargetContainer = this.rootDropTargetContainer, T.model.location = { type: "grid" }) : E.api.location.type === "floating" && (T.model.renderContainer = this.overlayRenderContainer, T.model.dropTargetContainer = this.rootDropTargetContainer, T.model.location = { type: "floating" });
					break;
				}
			}
			if (E.api.location.type === "grid") {
				let C = getGridLocation(E.element), O = getRelativeLocation(this.gridview.orientation, C, D), F;
				switch (this.gridview.orientation) {
					case Orientation.VERTICAL:
						F = C.length % 2 == 0 ? T.api.width : T.api.height;
						break;
					case Orientation.HORIZONTAL:
						F = C.length % 2 == 0 ? T.api.height : T.api.width;
						break;
				}
				this.gridview.addView(T, F, O);
			} else if (E.api.location.type === "floating") {
				let C = this._floatingGroups.find((C) => C.group === E);
				if (C) {
					let E = C.overlay.toJSON(), D, O;
					D = "left" in E ? E.left + 50 : "right" in E ? Math.max(0, E.right - E.width - 50) : 50, O = "top" in E ? E.top + 50 : "bottom" in E ? Math.max(0, E.bottom - E.height - 50) : 50, this.addFloatingGroup(T, {
						height: E.height,
						width: E.width,
						position: {
							left: D,
							top: O
						}
					});
				}
			}
		}
		if (T.panels.forEach((C) => {
			this._onDidMovePanel.fire({
				panel: C,
				from: T
			});
		}), C.skipSetActive === !1) {
			let C = E == null ? T : E;
			this.doSetGroupAndPanelActive(C);
		}
	}
	doSetGroupActive(C) {
		super.doSetGroupActive(C);
		let T = this.activePanel;
		!this._moving && T !== this._onDidActivePanelChange.value && this._onDidActivePanelChange.fire(T);
	}
	doSetGroupAndPanelActive(C) {
		super.doSetGroupActive(C);
		let T = this.activePanel;
		C && this.hasMaximizedGroup() && !this.isMaximizedGroup(C) && this.exitMaximizedGroup(), !this._moving && T !== this._onDidActivePanelChange.value && this._onDidActivePanelChange.fire(T);
	}
	getNextGroupId() {
		let C = this.nextGroupId.next();
		for (; this._groups.has(C);) C = this.nextGroupId.next();
		return C;
	}
	createGroup(C) {
		C || (C = {});
		let T = C == null ? void 0 : C.id;
		if (T && this._groups.has(C.id) && (console.warn(`dockview: Duplicate group id ${C == null ? void 0 : C.id}. reassigning group id to avoid errors`), T = void 0), !T) for (T = this.nextGroupId.next(); this._groups.has(T);) T = this.nextGroupId.next();
		let E = new DockviewGroupPanel(this, T, C);
		if (E.init({
			params: {},
			accessor: this
		}), !this._groups.has(E.id)) {
			let C = new CompositeDisposable(E.model.onTabDragStart((C) => {
				this._onWillDragPanel.fire(C);
			}), E.model.onGroupDragStart((C) => {
				this._onWillDragGroup.fire(C);
			}), E.model.onMove((C) => {
				let { groupId: T, itemId: D, target: O, index: F } = C;
				this.moveGroupOrPanel({
					from: {
						groupId: T,
						panelId: D
					},
					to: {
						group: E,
						position: O,
						index: F
					}
				});
			}), E.model.onDidDrop((C) => {
				this._onDidDrop.fire(C);
			}), E.model.onWillDrop((C) => {
				this._onWillDrop.fire(C);
			}), E.model.onWillShowOverlay((C) => {
				if (this.options.disableDnd) {
					C.preventDefault();
					return;
				}
				this._onWillShowOverlay.fire(C);
			}), E.model.onUnhandledDragOverEvent((C) => {
				this._onUnhandledDragOverEvent.fire(C);
			}), E.model.onDidAddPanel((C) => {
				this._moving || this._onDidAddPanel.fire(C.panel);
			}), E.model.onDidRemovePanel((C) => {
				this._moving || this._onDidRemovePanel.fire(C.panel);
			}), E.model.onDidActivePanelChange((C) => {
				this._moving || C.panel === this.activePanel && this._onDidActivePanelChange.value !== C.panel && this._onDidActivePanelChange.fire(C.panel);
			}), Event$2.any(E.model.onDidPanelTitleChange, E.model.onDidPanelParametersChange)(() => {
				this._bufferOnDidLayoutChange.fire();
			}));
			this._groups.set(E.id, {
				value: E,
				disposable: C
			});
		}
		return E.initialize(), E;
	}
	createPanel(C, T) {
		var E, D, O;
		let F = C.component, I = (E = C.tabComponent) == null ? this.options.defaultTabComponent : E, L = new DockviewPanelModel(this, C.id, F, I), z = new DockviewPanel(C.id, F, I, this, this._api, T, L, {
			renderer: C.renderer,
			minimumWidth: C.minimumWidth,
			minimumHeight: C.minimumHeight,
			maximumWidth: C.maximumWidth,
			maximumHeight: C.maximumHeight
		});
		return z.init({
			title: (D = C.title) == null ? C.id : D,
			params: (O = C == null ? void 0 : C.params) == null ? {} : O
		}), z;
	}
	createGroupAtLocation(C, T, E) {
		let D = this.createGroup(E);
		return this.doAddGroup(D, C, T), D;
	}
	findGroup(C) {
		var T;
		return (T = Array.from(this._groups.values()).find((T) => T.value.model.containsPanel(C))) == null ? void 0 : T.value;
	}
	orientationAtLocation(C) {
		let T = this.gridview.orientation;
		return C.length % 2 == 1 ? T : orthogonal(T);
	}
	updateDropTargetModel(C) {
		"dndEdges" in C && (this._rootDropTarget.disabled = typeof C.dndEdges == "boolean" && C.dndEdges === !1, typeof C.dndEdges == "object" && C.dndEdges !== null ? this._rootDropTarget.setOverlayModel(C.dndEdges) : this._rootDropTarget.setOverlayModel(DEFAULT_ROOT_OVERLAY_MODEL)), "rootOverlayModel" in C && this.updateDropTargetModel({ dndEdges: C.dndEdges });
	}
	updateTheme() {
		var C, T;
		let E = (C = this._options.theme) == null ? themeAbyss : C;
		switch (this._themeClassnames.setClassNames(E.className), this.gridview.margin = (T = E.gap) == null ? 0 : T, E.dndOverlayMounting) {
			case "absolute":
				this.rootDropTargetContainer.disabled = !1;
				break;
			case "relative":
			default:
				this.rootDropTargetContainer.disabled = !0;
				break;
		}
	}
}, GridviewComponent = class extends BaseGrid {
	get orientation() {
		return this.gridview.orientation;
	}
	set orientation(C) {
		this.gridview.orientation = C;
	}
	get options() {
		return this._options;
	}
	get deserializer() {
		return this._deserializer;
	}
	set deserializer(C) {
		this._deserializer = C;
	}
	constructor(C, T) {
		var E;
		super(C, {
			proportionalLayout: (E = T.proportionalLayout) == null ? !0 : E,
			orientation: T.orientation,
			styles: T.hideBorders ? { separatorBorder: "transparent" } : void 0,
			disableAutoResizing: T.disableAutoResizing,
			className: T.className
		}), this._onDidLayoutfromJSON = new Emitter(), this.onDidLayoutFromJSON = this._onDidLayoutfromJSON.event, this._onDidRemoveGroup = new Emitter(), this.onDidRemoveGroup = this._onDidRemoveGroup.event, this._onDidAddGroup = new Emitter(), this.onDidAddGroup = this._onDidAddGroup.event, this._onDidActiveGroupChange = new Emitter(), this.onDidActiveGroupChange = this._onDidActiveGroupChange.event, this._options = T, this.addDisposables(this._onDidAddGroup, this._onDidRemoveGroup, this._onDidActiveGroupChange, this.onDidAdd((C) => {
			this._onDidAddGroup.fire(C);
		}), this.onDidRemove((C) => {
			this._onDidRemoveGroup.fire(C);
		}), this.onDidActiveChange((C) => {
			this._onDidActiveGroupChange.fire(C);
		}));
	}
	updateOptions(C) {
		super.updateOptions(C);
		let T = typeof C.orientation == "string" && this.gridview.orientation !== C.orientation;
		this._options = Object.assign(Object.assign({}, this.options), C), T && (this.gridview.orientation = C.orientation), this.layout(this.gridview.width, this.gridview.height, !0);
	}
	removePanel(C) {
		this.removeGroup(C);
	}
	toJSON() {
		var C;
		return {
			grid: this.gridview.serialize(),
			activePanel: (C = this.activeGroup) == null ? void 0 : C.id
		};
	}
	setVisible(C, T) {
		this.gridview.setViewVisible(getGridLocation(C.element), T);
	}
	setActive(C) {
		this._groups.forEach((T, E) => {
			T.value.setActive(C === T.value);
		});
	}
	focus() {
		var C;
		(C = this.activeGroup) == null || C.focus();
	}
	fromJSON(C) {
		this.clear();
		let { grid: T, activePanel: E } = C;
		try {
			let C = [], D = this.width, O = this.height;
			if (this.gridview.deserialize(T, { fromJSON: (T) => {
				let { data: E } = T, D = this.options.createComponent({
					id: E.id,
					name: E.component
				});
				return C.push(() => D.init({
					params: E.params,
					minimumWidth: E.minimumWidth,
					maximumWidth: E.maximumWidth,
					minimumHeight: E.minimumHeight,
					maximumHeight: E.maximumHeight,
					priority: E.priority,
					snap: !!E.snap,
					accessor: this,
					isVisible: T.visible
				})), this._onDidAddGroup.fire(D), this.registerPanel(D), D;
			} }), this.layout(D, O, !0), C.forEach((C) => C()), typeof E == "string") {
				let C = this.getPanel(E);
				C && this.doSetGroupActive(C);
			}
		} catch (C) {
			for (let C of this.groups) C.dispose(), this._groups.delete(C.id), this._onDidRemoveGroup.fire(C);
			throw this.clear(), C;
		}
		this._onDidLayoutfromJSON.fire();
	}
	clear() {
		let C = this.activeGroup, T = Array.from(this._groups.values());
		for (let C of T) C.disposable.dispose(), this.doRemoveGroup(C.value, { skipActive: !0 });
		C && this.doSetGroupActive(void 0), this.gridview.clear();
	}
	movePanel(C, T) {
		var E;
		let D, O = this.gridview.remove(C), F = (E = this._groups.get(T.reference)) == null ? void 0 : E.value;
		if (!F) throw Error(`reference group ${T.reference} does not exist`);
		let I = toTarget(T.direction);
		if (I === "center") throw Error(`${I} not supported as an option`);
		{
			let C = getGridLocation(F.element);
			D = getRelativeLocation(this.gridview.orientation, C, I);
		}
		this.doAddGroup(O, D, T.size);
	}
	addPanel(C) {
		var T, E, D, O;
		let F = (T = C.location) == null ? [0] : T;
		if ((E = C.position) != null && E.referencePanel) {
			let T = (D = this._groups.get(C.position.referencePanel)) == null ? void 0 : D.value;
			if (!T) throw Error(`reference group ${C.position.referencePanel} does not exist`);
			let E = toTarget(C.position.direction);
			if (E === "center") throw Error(`${E} not supported as an option`);
			{
				let C = getGridLocation(T.element);
				F = getRelativeLocation(this.gridview.orientation, C, E);
			}
		}
		let I = this.options.createComponent({
			id: C.id,
			name: C.component
		});
		return I.init({
			params: (O = C.params) == null ? {} : O,
			minimumWidth: C.minimumWidth,
			maximumWidth: C.maximumWidth,
			minimumHeight: C.minimumHeight,
			maximumHeight: C.maximumHeight,
			priority: C.priority,
			snap: !!C.snap,
			accessor: this,
			isVisible: !0
		}), this.doAddGroup(I, F, C.size), this.registerPanel(I), this.doSetGroupActive(I), I;
	}
	registerPanel(C) {
		let T = new CompositeDisposable(C.api.onDidFocusChange((T) => {
			T.isFocused && this._groups.forEach((T) => {
				let E = T.value;
				E === C ? E.setActive(!0) : E.setActive(!1);
			});
		}));
		this._groups.set(C.id, {
			value: C,
			disposable: T
		});
	}
	moveGroup(C, T, E) {
		let D = this.getPanel(T);
		if (!D) throw Error("invalid operation");
		let O = getGridLocation(C.element), [F, I] = tail(getRelativeLocation(this.gridview.orientation, O, E)), [L, z] = tail(getGridLocation(D.element));
		if (sequenceEquals(L, F)) {
			this.gridview.moveView(L, z, I);
			return;
		}
		let B = this.doRemoveGroup(D, {
			skipActive: !0,
			skipDispose: !0
		}), V = getGridLocation(C.element), U = getRelativeLocation(this.gridview.orientation, V, E);
		this.doAddGroup(B, U);
	}
	removeGroup(C) {
		super.removeGroup(C);
	}
	dispose() {
		super.dispose(), this._onDidLayoutfromJSON.dispose();
	}
}, SplitviewComponent = class extends Resizable {
	get panels() {
		return this.splitview.getViews();
	}
	get options() {
		return this._options;
	}
	get length() {
		return this._panels.size;
	}
	get orientation() {
		return this.splitview.orientation;
	}
	get splitview() {
		return this._splitview;
	}
	set splitview(C) {
		this._splitview && this._splitview.dispose(), this._splitview = C, this._splitviewChangeDisposable.value = new CompositeDisposable(this._splitview.onDidSashEnd(() => {
			this._onDidLayoutChange.fire(void 0);
		}), this._splitview.onDidAddView((C) => this._onDidAddView.fire(C)), this._splitview.onDidRemoveView((C) => this._onDidRemoveView.fire(C)));
	}
	get minimumSize() {
		return this.splitview.minimumSize;
	}
	get maximumSize() {
		return this.splitview.maximumSize;
	}
	get height() {
		return this.splitview.orientation === Orientation.HORIZONTAL ? this.splitview.orthogonalSize : this.splitview.size;
	}
	get width() {
		return this.splitview.orientation === Orientation.HORIZONTAL ? this.splitview.size : this.splitview.orthogonalSize;
	}
	constructor(C, T) {
		var E;
		super(document.createElement("div"), T.disableAutoResizing), this._splitviewChangeDisposable = new MutableDisposable(), this._panels = /* @__PURE__ */ new Map(), this._onDidLayoutfromJSON = new Emitter(), this.onDidLayoutFromJSON = this._onDidLayoutfromJSON.event, this._onDidAddView = new Emitter(), this.onDidAddView = this._onDidAddView.event, this._onDidRemoveView = new Emitter(), this.onDidRemoveView = this._onDidRemoveView.event, this._onDidLayoutChange = new Emitter(), this.onDidLayoutChange = this._onDidLayoutChange.event, this.element.style.height = "100%", this.element.style.width = "100%", this._classNames = new Classnames(this.element), this._classNames.setClassNames((E = T.className) == null ? "" : E), C.appendChild(this.element), this._options = T, this.splitview = new Splitview(this.element, T), this.addDisposables(this._onDidAddView, this._onDidLayoutfromJSON, this._onDidRemoveView, this._onDidLayoutChange);
	}
	updateOptions(C) {
		var T, E;
		"className" in C && this._classNames.setClassNames((T = C.className) == null ? "" : T), "disableResizing" in C && (this.disableResizing = (E = C.disableAutoResizing) == null ? !1 : E), typeof C.orientation == "string" && (this.splitview.orientation = C.orientation), this._options = Object.assign(Object.assign({}, this.options), C), this.splitview.layout(this.splitview.size, this.splitview.orthogonalSize);
	}
	focus() {
		var C;
		(C = this._activePanel) == null || C.focus();
	}
	movePanel(C, T) {
		this.splitview.moveView(C, T);
	}
	setVisible(C, T) {
		let E = this.panels.indexOf(C);
		this.splitview.setViewVisible(E, T);
	}
	setActive(C, T) {
		this._activePanel = C, this.panels.filter((T) => T !== C).forEach((C) => {
			C.api._onDidActiveChange.fire({ isActive: !1 }), T || C.focus();
		}), C.api._onDidActiveChange.fire({ isActive: !0 }), T || C.focus();
	}
	removePanel(C, T) {
		let E = this._panels.get(C.id);
		if (!E) throw Error(`unknown splitview panel ${C.id}`);
		E.dispose(), this._panels.delete(C.id);
		let D = this.panels.findIndex((T) => T === C);
		this.splitview.removeView(D, T).dispose();
		let O = this.panels;
		O.length > 0 && this.setActive(O[O.length - 1]);
	}
	getPanel(C) {
		return this.panels.find((T) => T.id === C);
	}
	addPanel(C) {
		var T;
		if (this._panels.has(C.id)) throw Error(`panel ${C.id} already exists`);
		let E = this.options.createComponent({
			id: C.id,
			name: C.component
		});
		E.orientation = this.splitview.orientation, E.init({
			params: (T = C.params) == null ? {} : T,
			minimumSize: C.minimumSize,
			maximumSize: C.maximumSize,
			snap: C.snap,
			priority: C.priority,
			accessor: this
		});
		let D = typeof C.size == "number" ? C.size : Sizing.Distribute, O = typeof C.index == "number" ? C.index : void 0;
		return this.splitview.addView(E, D, O), this.doAddView(E), this.setActive(E), E;
	}
	layout(C, T) {
		let [E, D] = this.splitview.orientation === Orientation.HORIZONTAL ? [C, T] : [T, C];
		this.splitview.layout(E, D);
	}
	doAddView(C) {
		let T = C.api.onDidFocusChange((T) => {
			T.isFocused && this.setActive(C, !0);
		});
		this._panels.set(C.id, T);
	}
	toJSON() {
		var C;
		return {
			views: this.splitview.getViews().map((C, T) => ({
				size: this.splitview.getViewSize(T),
				data: C.toJSON(),
				snap: !!C.snap,
				priority: C.priority
			})),
			activeView: (C = this._activePanel) == null ? void 0 : C.id,
			size: this.splitview.size,
			orientation: this.splitview.orientation
		};
	}
	fromJSON(C) {
		this.clear();
		let { views: T, orientation: E, size: D, activeView: O } = C, F = [], I = this.width, L = this.height;
		if (this.splitview = new Splitview(this.element, {
			orientation: E,
			proportionalLayout: this.options.proportionalLayout,
			descriptor: {
				size: D,
				views: T.map((C) => {
					let T = C.data;
					if (this._panels.has(T.id)) throw Error(`panel ${T.id} already exists`);
					let D = this.options.createComponent({
						id: T.id,
						name: T.component
					});
					return F.push(() => {
						var E;
						D.init({
							params: (E = T.params) == null ? {} : E,
							minimumSize: T.minimumSize,
							maximumSize: T.maximumSize,
							snap: C.snap,
							priority: C.priority,
							accessor: this
						});
					}), D.orientation = E, this.doAddView(D), setTimeout(() => {
						this._onDidAddView.fire(D);
					}, 0), {
						size: C.size,
						view: D
					};
				})
			}
		}), this.layout(I, L), F.forEach((C) => C()), typeof O == "string") {
			let C = this.getPanel(O);
			C && this.setActive(C);
		}
		this._onDidLayoutfromJSON.fire();
	}
	clear() {
		for (let C of this._panels.values()) C.dispose();
		for (this._panels.clear(); this.splitview.length > 0;) this.splitview.removeView(0, Sizing.Distribute, !0).dispose();
	}
	dispose() {
		for (let C of this._panels.values()) C.dispose();
		this._panels.clear();
		let C = this.splitview.getViews();
		this._splitviewChangeDisposable.dispose(), this.splitview.dispose();
		for (let T of C) T.dispose();
		this.element.remove(), super.dispose();
	}
}, DefaultHeader = class extends CompositeDisposable {
	get element() {
		return this._element;
	}
	constructor() {
		super(), this._expandedIcon = createExpandMoreButton(), this._collapsedIcon = createChevronRightButton(), this.disposable = new MutableDisposable(), this.apiRef = { api: null }, this._element = document.createElement("div"), this.element.className = "dv-default-header", this._content = document.createElement("span"), this._expander = document.createElement("div"), this._expander.className = "dv-pane-header-icon", this.element.appendChild(this._expander), this.element.appendChild(this._content), this.addDisposables(addDisposableListener(this._element, "click", () => {
			var C;
			(C = this.apiRef.api) == null || C.setExpanded(!this.apiRef.api.isExpanded);
		}));
	}
	init(C) {
		this.apiRef.api = C.api, this._content.textContent = C.title, this.updateIcon(), this.disposable.value = C.api.onDidExpansionChange(() => {
			this.updateIcon();
		});
	}
	updateIcon() {
		var C;
		let T = !!((C = this.apiRef.api) != null && C.isExpanded);
		toggleClass(this._expander, "collapsed", !T), T ? (this._expander.contains(this._collapsedIcon) && this._collapsedIcon.remove(), this._expander.contains(this._expandedIcon) || this._expander.appendChild(this._expandedIcon)) : (this._expander.contains(this._expandedIcon) && this._expandedIcon.remove(), this._expander.contains(this._collapsedIcon) || this._expander.appendChild(this._collapsedIcon));
	}
	update(C) {}
	dispose() {
		this.disposable.dispose(), super.dispose();
	}
}, nextLayoutId = sequentialNumberGenerator(), HEADER_SIZE = 22, MINIMUM_BODY_SIZE = 0, MAXIMUM_BODY_SIZE = 9007199254740991, PaneFramework = class extends DraggablePaneviewPanel {
	constructor(C) {
		super({
			accessor: C.accessor,
			id: C.id,
			component: C.component,
			headerComponent: C.headerComponent,
			orientation: C.orientation,
			isExpanded: C.isExpanded,
			disableDnd: C.disableDnd,
			headerSize: C.headerSize,
			minimumBodySize: C.minimumBodySize,
			maximumBodySize: C.maximumBodySize
		}), this.options = C;
	}
	getBodyComponent() {
		return this.options.body;
	}
	getHeaderComponent() {
		return this.options.header;
	}
}, PaneviewComponent = class extends Resizable {
	get id() {
		return this._id;
	}
	get panels() {
		return this.paneview.getPanes();
	}
	set paneview(C) {
		this._paneview = C, this._disposable.value = new CompositeDisposable(this._paneview.onDidChange(() => {
			this._onDidLayoutChange.fire(void 0);
		}), this._paneview.onDidAddView((C) => this._onDidAddView.fire(C)), this._paneview.onDidRemoveView((C) => this._onDidRemoveView.fire(C)));
	}
	get paneview() {
		return this._paneview;
	}
	get minimumSize() {
		return this.paneview.minimumSize;
	}
	get maximumSize() {
		return this.paneview.maximumSize;
	}
	get height() {
		return this.paneview.orientation === Orientation.HORIZONTAL ? this.paneview.orthogonalSize : this.paneview.size;
	}
	get width() {
		return this.paneview.orientation === Orientation.HORIZONTAL ? this.paneview.size : this.paneview.orthogonalSize;
	}
	get options() {
		return this._options;
	}
	constructor(C, T) {
		var E;
		super(document.createElement("div"), T.disableAutoResizing), this._id = nextLayoutId.next(), this._disposable = new MutableDisposable(), this._viewDisposables = /* @__PURE__ */ new Map(), this._onDidLayoutfromJSON = new Emitter(), this.onDidLayoutFromJSON = this._onDidLayoutfromJSON.event, this._onDidLayoutChange = new Emitter(), this.onDidLayoutChange = this._onDidLayoutChange.event, this._onDidDrop = new Emitter(), this.onDidDrop = this._onDidDrop.event, this._onDidAddView = new Emitter(), this.onDidAddView = this._onDidAddView.event, this._onDidRemoveView = new Emitter(), this.onDidRemoveView = this._onDidRemoveView.event, this._onUnhandledDragOverEvent = new Emitter(), this.onUnhandledDragOverEvent = this._onUnhandledDragOverEvent.event, this.element.style.height = "100%", this.element.style.width = "100%", this.addDisposables(this._onDidLayoutChange, this._onDidLayoutfromJSON, this._onDidDrop, this._onDidAddView, this._onDidRemoveView, this._onUnhandledDragOverEvent), this._classNames = new Classnames(this.element), this._classNames.setClassNames((E = T.className) == null ? "" : E), C.appendChild(this.element), this._options = T, this.paneview = new Paneview(this.element, { orientation: Orientation.VERTICAL }), this.addDisposables(this._disposable);
	}
	setVisible(C, T) {
		let E = this.panels.indexOf(C);
		this.paneview.setViewVisible(E, T);
	}
	focus() {}
	updateOptions(C) {
		var T, E;
		"className" in C && this._classNames.setClassNames((T = C.className) == null ? "" : T), "disableResizing" in C && (this.disableResizing = (E = C.disableAutoResizing) == null ? !1 : E), this._options = Object.assign(Object.assign({}, this.options), C);
	}
	addPanel(C) {
		var T, E;
		let D = this.options.createComponent({
			id: C.id,
			name: C.component
		}), O;
		C.headerComponent && this.options.createHeaderComponent && (O = this.options.createHeaderComponent({
			id: C.id,
			name: C.headerComponent
		})), O || (O = new DefaultHeader());
		let F = new PaneFramework({
			id: C.id,
			component: C.component,
			headerComponent: C.headerComponent,
			header: O,
			body: D,
			orientation: Orientation.VERTICAL,
			isExpanded: !!C.isExpanded,
			disableDnd: !!this.options.disableDnd,
			accessor: this,
			headerSize: (T = C.headerSize) == null ? HEADER_SIZE : T,
			minimumBodySize: MINIMUM_BODY_SIZE,
			maximumBodySize: MAXIMUM_BODY_SIZE
		});
		this.doAddPanel(F);
		let I = typeof C.size == "number" ? C.size : Sizing.Distribute, L = typeof C.index == "number" ? C.index : void 0;
		return F.init({
			params: (E = C.params) == null ? {} : E,
			minimumBodySize: C.minimumBodySize,
			maximumBodySize: C.maximumBodySize,
			isExpanded: C.isExpanded,
			title: C.title,
			containerApi: new PaneviewApi(this),
			accessor: this
		}), this.paneview.addPane(F, I, L), F.orientation = this.paneview.orientation, F;
	}
	removePanel(C) {
		let T = this.panels.findIndex((T) => T === C);
		this.paneview.removePane(T), this.doRemovePanel(C);
	}
	movePanel(C, T) {
		this.paneview.moveView(C, T);
	}
	getPanel(C) {
		return this.panels.find((T) => T.id === C);
	}
	layout(C, T) {
		let [E, D] = this.paneview.orientation === Orientation.HORIZONTAL ? [C, T] : [T, C];
		this.paneview.layout(E, D);
	}
	toJSON() {
		let C = (C) => C === 9007199254740991 || C === Infinity ? void 0 : C, T = (C) => C <= 0 ? void 0 : C;
		return {
			views: this.paneview.getPanes().map((E, D) => ({
				size: this.paneview.getViewSize(D),
				data: E.toJSON(),
				minimumSize: T(E.minimumBodySize),
				maximumSize: C(E.maximumBodySize),
				headerSize: E.headerSize,
				expanded: E.isExpanded()
			})),
			size: this.paneview.size
		};
	}
	fromJSON(C) {
		this.clear();
		let { views: T, size: E } = C, D = [], O = this.width, F = this.height;
		this.paneview = new Paneview(this.element, {
			orientation: Orientation.VERTICAL,
			descriptor: {
				size: E,
				views: T.map((C) => {
					var T, E, O;
					let F = C.data, I = this.options.createComponent({
						id: F.id,
						name: F.component
					}), L;
					F.headerComponent && this.options.createHeaderComponent && (L = this.options.createHeaderComponent({
						id: F.id,
						name: F.headerComponent
					})), L || (L = new DefaultHeader());
					let z = new PaneFramework({
						id: F.id,
						component: F.component,
						headerComponent: F.headerComponent,
						header: L,
						body: I,
						orientation: Orientation.VERTICAL,
						isExpanded: !!C.expanded,
						disableDnd: !!this.options.disableDnd,
						accessor: this,
						headerSize: (T = C.headerSize) == null ? HEADER_SIZE : T,
						minimumBodySize: (E = C.minimumSize) == null ? MINIMUM_BODY_SIZE : E,
						maximumBodySize: (O = C.maximumSize) == null ? MAXIMUM_BODY_SIZE : O
					});
					return this.doAddPanel(z), D.push(() => {
						var T;
						z.init({
							params: (T = F.params) == null ? {} : T,
							minimumBodySize: C.minimumSize,
							maximumBodySize: C.maximumSize,
							title: F.title,
							isExpanded: !!C.expanded,
							containerApi: new PaneviewApi(this),
							accessor: this
						}), z.orientation = this.paneview.orientation;
					}), setTimeout(() => {
						this._onDidAddView.fire(z);
					}, 0), {
						size: C.size,
						view: z
					};
				})
			}
		}), this.layout(O, F), D.forEach((C) => C()), this._onDidLayoutfromJSON.fire();
	}
	clear() {
		for (let [C, T] of this._viewDisposables.entries()) T.dispose();
		this._viewDisposables.clear(), this.paneview.dispose();
	}
	doAddPanel(C) {
		let T = new CompositeDisposable(C.onDidDrop((C) => {
			this._onDidDrop.fire(C);
		}), C.onUnhandledDragOverEvent((C) => {
			this._onUnhandledDragOverEvent.fire(C);
		}));
		this._viewDisposables.set(C.id, T);
	}
	doRemovePanel(C) {
		let T = this._viewDisposables.get(C.id);
		T && (T.dispose(), this._viewDisposables.delete(C.id));
	}
	dispose() {
		super.dispose();
		for (let [C, T] of this._viewDisposables.entries()) T.dispose();
		this._viewDisposables.clear(), this.element.remove(), this.paneview.dispose();
	}
}, SplitviewPanel = class extends BasePanelView {
	get priority() {
		return this._priority;
	}
	set orientation(C) {
		this._orientation = C;
	}
	get orientation() {
		return this._orientation;
	}
	get minimumSize() {
		let C = typeof this._minimumSize == "function" ? this._minimumSize() : this._minimumSize;
		return C !== this._evaluatedMinimumSize && (this._evaluatedMinimumSize = C, this.updateConstraints()), C;
	}
	get maximumSize() {
		let C = typeof this._maximumSize == "function" ? this._maximumSize() : this._maximumSize;
		return C !== this._evaluatedMaximumSize && (this._evaluatedMaximumSize = C, this.updateConstraints()), C;
	}
	get snap() {
		return this._snap;
	}
	constructor(C, T) {
		super(C, T, new SplitviewPanelApiImpl(C, T)), this._evaluatedMinimumSize = 0, this._evaluatedMaximumSize = Infinity, this._minimumSize = 0, this._maximumSize = Infinity, this._snap = !1, this._onDidChange = new Emitter(), this.onDidChange = this._onDidChange.event, this.api.initialize(this), this.addDisposables(this._onDidChange, this.api.onWillVisibilityChange((C) => {
			let { isVisible: T } = C, { accessor: E } = this._params;
			E.setVisible(this, T);
		}), this.api.onActiveChange(() => {
			let { accessor: C } = this._params;
			C.setActive(this);
		}), this.api.onDidConstraintsChangeInternal((C) => {
			(typeof C.minimumSize == "number" || typeof C.minimumSize == "function") && (this._minimumSize = C.minimumSize), (typeof C.maximumSize == "number" || typeof C.maximumSize == "function") && (this._maximumSize = C.maximumSize), this.updateConstraints();
		}), this.api.onDidSizeChange((C) => {
			this._onDidChange.fire({ size: C.size });
		}));
	}
	setVisible(C) {
		this.api._onDidVisibilityChange.fire({ isVisible: C });
	}
	setActive(C) {
		this.api._onDidActiveChange.fire({ isActive: C });
	}
	layout(C, T) {
		let [E, D] = this.orientation === Orientation.HORIZONTAL ? [C, T] : [T, C];
		super.layout(E, D);
	}
	init(C) {
		super.init(C), this._priority = C.priority, C.minimumSize && (this._minimumSize = C.minimumSize), C.maximumSize && (this._maximumSize = C.maximumSize), C.snap && (this._snap = C.snap);
	}
	toJSON() {
		return Object.assign(Object.assign({}, super.toJSON()), {
			minimumSize: ((C) => C <= 0 ? void 0 : C)(this.minimumSize),
			maximumSize: ((C) => C === 9007199254740991 || C === Infinity ? void 0 : C)(this.maximumSize)
		});
	}
	updateConstraints() {
		this.api._onDidConstraintsChange.fire({
			maximumSize: this._evaluatedMaximumSize,
			minimumSize: this._evaluatedMinimumSize
		});
	}
};
function createDockview(C, T) {
	return new DockviewComponent(C, T).api;
}
function createSplitview(C, T) {
	return new SplitviewApi(new SplitviewComponent(C, T));
}
function createGridview(C, T) {
	return new GridviewApi(new GridviewComponent(C, T));
}
function createPaneview(C, T) {
	return new PaneviewApi(new PaneviewComponent(C, T));
}
var SvelteDockComponentRenderer = class extends PanelRendererBase {
	constructor(C) {
		super(_objectSpread2(_objectSpread2({}, C), {}, {
			panelTarget: "dock",
			initOptionsToProps: ({ params: C, api: T, containerApi: E }) => ({
				params: C,
				api: T,
				containerApi: E
			})
		})), this._onDidFocus = new Emitter(), this.onDidFocus = this._onDidFocus.event, this._onDidBlur = new Emitter(), this.onDidBlur = this._onDidBlur.event;
	}
	dispose() {
		super.dispose(), this._onDidFocus.dispose(), this._onDidBlur.dispose();
	}
}, SvelteDockHeaderRenderer = class extends PanelRendererBase {
	constructor(C) {
		super(_objectSpread2(_objectSpread2({}, C), {}, {
			panelTarget: "dockheader",
			initOptionsToProps: ({ params: C, api: T, containerApi: E }) => ({
				params: C,
				api: T,
				containerApi: E
			})
		}));
	}
}, SvelteWatermarkRenderer = class extends PanelRendererBase {
	constructor(C) {
		super(_objectSpread2(_objectSpread2({}, C), {}, {
			propsHasParams: !1,
			panelTarget: "dockwatermark",
			initOptionsToProps: ({ group: C, containerApi: T }) => ({
				group: C,
				containerApi: T
			})
		}));
	}
}, SvelteDockActionsHeaderRenderer = class extends PanelRendererBase {
	constructor(C, E) {
		super(_objectSpread2(_objectSpread2({}, E), {}, {
			propsHasParams: !1,
			panelTarget: "dockactions",
			initOptionsToProps: ({ api: T, containerApi: E }) => ({
				api: T,
				containerApi: E,
				group: C,
				panels: C.model.panels,
				activePanel: C.model.activePanel,
				isGroupActive: C.api.isActive
			})
		})), this.mutableDisposable = new MutableDisposable(), this.group = C;
	}
	init(C) {
		this.mutableDisposable.value = new CompositeDisposable(this.group.model.onDidAddPanel(() => this.updatePanels()), this.group.model.onDidRemovePanel(() => this.updatePanels()), this.group.model.onDidActivePanelChange(() => this.updateActivePanel()), C.api.onDidActiveChange(() => this.updateGroupActive())), super.init(C);
	}
	dispose() {
		super.dispose(), this.mutableDisposable.dispose();
	}
	updatePanels() {
		var C;
		(C = this.propsUpdater) == null || C.updateSingle("panels", this.group.model.panels);
	}
	updateActivePanel() {
		var C;
		(C = this.propsUpdater) == null || C.updateSingle("activePanel", this.group.model.activePanel);
	}
	updateGroupActive() {
		var C;
		(C = this.propsUpdater) == null || C.updateSingle("isGroupActive", this.group.api.isActive);
	}
}, root$34 = /* @__PURE__ */ from_html("<span class=\"svelte-1wa7fd6\"><div></div></span>"), $$css$26 = {
	hash: "svelte-1wa7fd6",
	code: "\r\n  /** Copied from 'dockview/dist/styles/dockview.css' with extra `div` scoping */span.svelte-1wa7fd6 .dv-svg {display:inline-block;fill:currentcolor;line-height:1;stroke:currentcolor;stroke-width:0;}span.svelte-1wa7fd6 .dockview-theme-dark {--dv-paneview-active-outline-color: dodgerblue;--dv-tabs-and-actions-container-font-size: 13px;--dv-tabs-and-actions-container-height: 35px;--dv-drag-over-background-color: rgba(83, 89, 93, 0.5);--dv-drag-over-border-color: white;--dv-tabs-container-scrollbar-color: #888;--dv-icon-hover-background-color: rgba(90, 93, 94, 0.31);--dv-floating-box-shadow: 8px 8px 8px 0px rgba(83, 89, 93, 0.5);--dv-overlay-z-index: 999;--dv-active-sash-transition-duration: 0.1s;--dv-active-sash-transition-delay: 0.5s;--dv-group-view-background-color: #1e1e1e;--dv-tabs-and-actions-container-background-color: #252526;--dv-activegroup-visiblepanel-tab-background-color: #1e1e1e;--dv-activegroup-hiddenpanel-tab-background-color: #2d2d2d;--dv-inactivegroup-visiblepanel-tab-background-color: #1e1e1e;--dv-inactivegroup-hiddenpanel-tab-background-color: #2d2d2d;--dv-tab-divider-color: #1e1e1e;--dv-activegroup-visiblepanel-tab-color: white;--dv-activegroup-hiddenpanel-tab-color: #969696;--dv-inactivegroup-visiblepanel-tab-color: #8f8f8f;--dv-inactivegroup-hiddenpanel-tab-color: #626262;--dv-separator-border: rgb(68, 68, 68);--dv-paneview-header-border-color: rgba(204, 204, 204, 0.2);}span.svelte-1wa7fd6 .dockview-theme-light {--dv-paneview-active-outline-color: dodgerblue;--dv-tabs-and-actions-container-font-size: 13px;--dv-tabs-and-actions-container-height: 35px;--dv-drag-over-background-color: rgba(83, 89, 93, 0.5);--dv-drag-over-border-color: white;--dv-tabs-container-scrollbar-color: #888;--dv-icon-hover-background-color: rgba(90, 93, 94, 0.31);--dv-floating-box-shadow: 8px 8px 8px 0px rgba(83, 89, 93, 0.5);--dv-overlay-z-index: 999;--dv-active-sash-transition-duration: 0.1s;--dv-active-sash-transition-delay: 0.5s;--dv-group-view-background-color: white;--dv-tabs-and-actions-container-background-color: #b11616;--dv-activegroup-visiblepanel-tab-background-color: white;--dv-activegroup-hiddenpanel-tab-background-color: #ececec;--dv-inactivegroup-visiblepanel-tab-background-color: white;--dv-inactivegroup-hiddenpanel-tab-background-color: #ececec;--dv-tab-divider-color: white;--dv-activegroup-visiblepanel-tab-color: rgb(51, 51, 51);--dv-activegroup-hiddenpanel-tab-color: rgba(51, 51, 51, 0.7);--dv-inactivegroup-visiblepanel-tab-color: rgba(51, 51, 51, 0.7);--dv-inactivegroup-hiddenpanel-tab-color: rgba(51, 51, 51, 0.35);--dv-separator-border: rgba(128, 128, 128, 0.35);--dv-paneview-header-border-color: rgb(51, 51, 51);}span.svelte-1wa7fd6 .dockview-theme-vs {--dv-paneview-active-outline-color: dodgerblue;--dv-drag-over-background-color: rgba(83, 89, 93, 0.5);--dv-drag-over-border-color: white;--dv-tabs-container-scrollbar-color: #888;--dv-icon-hover-background-color: rgba(90, 93, 94, 0.31);--dv-floating-box-shadow: 8px 8px 8px 0px rgba(83, 89, 93, 0.5);--dv-overlay-z-index: 999;--dv-active-sash-transition-duration: 0.1s;--dv-active-sash-transition-delay: 0.5s;--dv-group-view-background-color: #1e1e1e;--dv-tabs-and-actions-container-background-color: #252526;--dv-activegroup-visiblepanel-tab-background-color: #1e1e1e;--dv-activegroup-hiddenpanel-tab-background-color: #2d2d2d;--dv-inactivegroup-visiblepanel-tab-background-color: #1e1e1e;--dv-inactivegroup-hiddenpanel-tab-background-color: #2d2d2d;--dv-tab-divider-color: #1e1e1e;--dv-activegroup-hiddenpanel-tab-color: #969696;--dv-inactivegroup-visiblepanel-tab-color: #8f8f8f;--dv-inactivegroup-hiddenpanel-tab-color: #626262;--dv-separator-border: rgb(68, 68, 68);--dv-paneview-header-border-color: rgba(204, 204, 204, 0.2);--dv-tabs-and-actions-container-background-color: #2d2d30;--dv-tabs-and-actions-container-height: 20px;--dv-tabs-and-actions-container-font-size: 11px;--dv-activegroup-visiblepanel-tab-background-color: #007acc;--dv-inactivegroup-visiblepanel-tab-background-color: #3f3f46;--dv-activegroup-visiblepanel-tab-color: white;--dv-activegroup-hiddenpanel-tab-color: white;--dv-inactivegroup-visiblepanel-tab-color: white;--dv-inactivegroup-hiddenpanel-tab-color: white;}span.svelte-1wa7fd6\r\n    \r\n      .dockview-theme-vs\r\n        .dv-groupview.dv-active-group\r\n        > .dv-tabs-and-actions-container\r\n     {box-sizing:content-box;border-bottom:2px solid\r\n      var(--dv-activegroup-visiblepanel-tab-background-color);}span.svelte-1wa7fd6\r\n    \r\n      .dockview-theme-vs\r\n        .dv-groupview.dv-active-group\r\n        > .dv-tabs-and-actions-container\r\n        .dv-tab.dv-active-tab\r\n     {border-top:2px solid\r\n      var(--dv-activegroup-visiblepanel-tab-background-color);}span.svelte-1wa7fd6\r\n    \r\n      .dockview-theme-vs\r\n        .dv-groupview.dv-active-group\r\n        > .dv-tabs-and-actions-container\r\n        .dv-tab.dv-inactive-tab\r\n     {border-top:2px solid var(--dv-activegroup-hiddenpanel-tab-background-color);}span.svelte-1wa7fd6\r\n    \r\n      .dockview-theme-vs\r\n        .dv-groupview.dv-inactive-group\r\n        > .dv-tabs-and-actions-container\r\n     {box-sizing:content-box;border-bottom:2px solid\r\n      var(--dv-inactivegroup-visiblepanel-tab-background-color);}span.svelte-1wa7fd6\r\n    \r\n      .dockview-theme-vs\r\n        .dv-groupview.dv-inactive-group\r\n        > .dv-tabs-and-actions-container\r\n        .dv-tab.dv-active-tab\r\n     {border-top:2px solid\r\n      var(--dv-inactivegroup-visiblepanel-tab-background-color);}span.svelte-1wa7fd6\r\n    \r\n      .dockview-theme-vs\r\n        .dv-groupview.dv-inactive-group\r\n        > .dv-tabs-and-actions-container\r\n        .dv-tab.dv-inactive-tab\r\n     {border-top:2px solid\r\n      var(--dv-inactivegroup-hiddenpanel-tab-background-color);}span.svelte-1wa7fd6 .dockview-theme-abyss {--dv-paneview-active-outline-color: dodgerblue;--dv-tabs-and-actions-container-font-size: 13px;--dv-tabs-and-actions-container-height: 35px;--dv-drag-over-background-color: rgba(83, 89, 93, 0.5);--dv-drag-over-border-color: white;--dv-tabs-container-scrollbar-color: #888;--dv-icon-hover-background-color: rgba(90, 93, 94, 0.31);--dv-floating-box-shadow: 8px 8px 8px 0px rgba(83, 89, 93, 0.5);--dv-overlay-z-index: 999;--dv-active-sash-transition-duration: 0.1s;--dv-active-sash-transition-delay: 0.5s;--dv-group-view-background-color: #000c18;--dv-tabs-and-actions-container-background-color: #1c1c2a;--dv-activegroup-visiblepanel-tab-background-color: #000c18;--dv-activegroup-hiddenpanel-tab-background-color: #10192c;--dv-inactivegroup-visiblepanel-tab-background-color: #000c18;--dv-inactivegroup-hiddenpanel-tab-background-color: #10192c;--dv-tab-divider-color: #2b2b4a;--dv-activegroup-visiblepanel-tab-color: white;--dv-activegroup-hiddenpanel-tab-color: rgba(255, 255, 255, 0.5);--dv-inactivegroup-visiblepanel-tab-color: rgba(255, 255, 255, 0.5);--dv-inactivegroup-hiddenpanel-tab-color: rgba(255, 255, 255, 0.25);--dv-separator-border: #2b2b4a;--dv-paneview-header-border-color: #2b2b4a;--dv-paneview-active-outline-color: #596f99;}span.svelte-1wa7fd6 .dockview-theme-dracula {--dv-paneview-active-outline-color: dodgerblue;--dv-tabs-and-actions-container-font-size: 13px;--dv-tabs-and-actions-container-height: 35px;--dv-drag-over-background-color: rgba(83, 89, 93, 0.5);--dv-drag-over-border-color: white;--dv-tabs-container-scrollbar-color: #888;--dv-icon-hover-background-color: rgba(90, 93, 94, 0.31);--dv-floating-box-shadow: 8px 8px 8px 0px rgba(83, 89, 93, 0.5);--dv-overlay-z-index: 999;--dv-active-sash-transition-duration: 0.1s;--dv-active-sash-transition-delay: 0.5s;--dv-group-view-background-color: #282a36;--dv-tabs-and-actions-container-background-color: #191a21;--dv-activegroup-visiblepanel-tab-background-color: #282a36;--dv-activegroup-hiddenpanel-tab-background-color: #21222c;--dv-inactivegroup-visiblepanel-tab-background-color: #282a36;--dv-inactivegroup-hiddenpanel-tab-background-color: #21222c;--dv-tab-divider-color: #191a21;--dv-activegroup-visiblepanel-tab-color: rgb(248, 248, 242);--dv-activegroup-hiddenpanel-tab-color: rgb(98, 114, 164);--dv-inactivegroup-visiblepanel-tab-color: rgba(248, 248, 242, 0.5);--dv-inactivegroup-hiddenpanel-tab-color: rgba(98, 114, 164, 0.5);--dv-separator-border: #bd93f9;--dv-paneview-header-border-color: #bd93f9;--dv-paneview-active-outline-color: #6272a4;}span.svelte-1wa7fd6\r\n    \r\n      .dockview-theme-dracula\r\n        .dv-groupview.dv-active-group\r\n        > .dv-tabs-and-actions-container\r\n        > .dv-tabs-container\r\n        > .dv-tab.dv-active-tab\r\n     {position:relative;}span.svelte-1wa7fd6\r\n    \r\n      .dockview-theme-dracula\r\n        .dv-groupview.dv-active-group\r\n        > .dv-tabs-and-actions-container\r\n        > .dv-tabs-container\r\n        > .dv-tab.dv-active-tab::after\r\n     {position:absolute;left:0px;top:0px;content:\"\";width:100%;height:1px;background-color:#94527e;z-index:999;}span.svelte-1wa7fd6\r\n    \r\n      .dockview-theme-dracula\r\n        .dv-groupview.dv-inactive-group\r\n        > .dv-tabs-and-actions-container\r\n        > .dv-tabs-container\r\n        > .dv-tab.dv-active-tab\r\n     {position:relative;}span.svelte-1wa7fd6\r\n    \r\n      .dockview-theme-dracula\r\n        .dv-groupview.dv-inactive-group\r\n        > .dv-tabs-and-actions-container\r\n        > .dv-tabs-container\r\n        > .dv-tab.dv-active-tab::after\r\n     {position:absolute;left:0px;bottom:0px;content:\"\";width:100%;height:1px;background-color:#5e3d5a;z-index:999;}span.svelte-1wa7fd6 .dockview-theme-replit {--dv-paneview-active-outline-color: dodgerblue;--dv-tabs-and-actions-container-font-size: 13px;--dv-tabs-and-actions-container-height: 35px;--dv-drag-over-background-color: rgba(83, 89, 93, 0.5);--dv-drag-over-border-color: white;--dv-tabs-container-scrollbar-color: #888;--dv-icon-hover-background-color: rgba(90, 93, 94, 0.31);--dv-floating-box-shadow: 8px 8px 8px 0px rgba(83, 89, 93, 0.5);--dv-overlay-z-index: 999;--dv-active-sash-transition-duration: 0.1s;--dv-active-sash-transition-delay: 0.5s;--dv-group-view-background-color: #ebeced;--dv-tabs-and-actions-container-background-color: #fcfcfc;--dv-activegroup-visiblepanel-tab-background-color: #f0f1f2;--dv-activegroup-hiddenpanel-tab-background-color: #fcfcfc;--dv-inactivegroup-visiblepanel-tab-background-color: #f0f1f2;--dv-inactivegroup-hiddenpanel-tab-background-color: #fcfcfc;--dv-tab-divider-color: transparent;--dv-activegroup-visiblepanel-tab-color: rgb(51, 51, 51);--dv-activegroup-hiddenpanel-tab-color: rgb(51, 51, 51);--dv-inactivegroup-visiblepanel-tab-color: rgb(51, 51, 51);--dv-inactivegroup-hiddenpanel-tab-color: rgb(51, 51, 51);--dv-separator-border: transparent;--dv-paneview-header-border-color: rgb(51, 51, 51);--dv-separator-handle-background-color: #cfd1d3;--dv-separator-handle-hover-background-color: #babbbb;}span.svelte-1wa7fd6\r\n    .dockview-theme-replit .dv-resize-container:has(> .dv-groupview) {border-radius:8px;}span.svelte-1wa7fd6 .dockview-theme-replit .dv-groupview {overflow:hidden;border-radius:10px;}span.svelte-1wa7fd6\r\n    \r\n      .dockview-theme-replit .dv-groupview .dv-tabs-and-actions-container\r\n     {border-bottom:1px solid rgba(128, 128, 128, 0.35);}span.svelte-1wa7fd6\r\n    \r\n      .dockview-theme-replit\r\n        .dv-groupview\r\n        .dv-tabs-and-actions-container\r\n        .dv-tab\r\n     {margin:4px;border-radius:8px;}span.svelte-1wa7fd6\r\n    \r\n      .dockview-theme-replit\r\n        .dv-groupview\r\n        .dv-tabs-and-actions-container\r\n        .dv-tab\r\n        .dv-svg\r\n     {height:8px;width:8px;}span.svelte-1wa7fd6\r\n    \r\n      .dockview-theme-replit\r\n        .dv-groupview\r\n        .dv-tabs-and-actions-container\r\n        .dv-tab:hover\r\n     {background-color:#e4e5e6 !important;}span.svelte-1wa7fd6 .dockview-theme-replit .dv-groupview .dv-content-container {background-color:#fcfcfc;}span.svelte-1wa7fd6 .dockview-theme-replit .dv-groupview.dv-active-group {border:1px solid rgba(128, 128, 128, 0.35);flex:1;}span.svelte-1wa7fd6 .dockview-theme-replit .dv-groupview.dv-inactive-group {border:1px solid transparent;}span.svelte-1wa7fd6\r\n    \r\n      .dockview-theme-replit\r\n        .dv-vertical\r\n        > .dv-sash-container\r\n        > .dv-sash:not(.disabled)::after\r\n     {content:\"\";height:4px;width:40px;border-radius:2px;top:50%;left:50%;transform:translate(-50%, -50%);background-color:var(--dv-separator-handle-background-color);position:absolute;}span.svelte-1wa7fd6\r\n    \r\n      .dockview-theme-replit\r\n        .dv-vertical\r\n        > .dv-sash-container\r\n        > .dv-sash:not(.disabled):hover::after\r\n     {background-color:var(--dv-separator-handle-hover-background-color);}span.svelte-1wa7fd6\r\n    \r\n      .dockview-theme-replit\r\n        .dv-horizontal\r\n        > .dv-sash-container\r\n        > .dv-sash:not(.disabled)::after\r\n     {content:\"\";height:40px;width:4px;border-radius:2px;top:50%;left:50%;transform:translate(-50%, -50%);background-color:var(--dv-separator-handle-background-color);position:absolute;}span.svelte-1wa7fd6\r\n    \r\n      .dockview-theme-replit\r\n        .dv-horizontal\r\n        > .dv-sash-container\r\n        > .dv-sash:not(.disabled):hover::after\r\n     {background-color:var(--dv-separator-handle-hover-background-color);}span.svelte-1wa7fd6 .dv-drop-target {position:relative;}span.svelte-1wa7fd6 .dv-drop-target > .dv-drop-target-dropzone {position:absolute;left:0px;top:0px;height:100%;width:100%;z-index:1000;pointer-events:none;}span.svelte-1wa7fd6\r\n    \r\n      .dv-drop-target > .dv-drop-target-dropzone > .dv-drop-target-selection\r\n     {position:relative;box-sizing:border-box;height:100%;width:100%;background-color:var(--dv-drag-over-background-color);transition:top 70ms ease-out,\r\n      left 70ms ease-out,\r\n      width 70ms ease-out,\r\n      height 70ms ease-out,\r\n      opacity 0.15s ease-out;will-change:transform;pointer-events:none;}span.svelte-1wa7fd6\r\n    \r\n      .dv-drop-target\r\n        > .dv-drop-target-dropzone\r\n        > .dv-drop-target-selection.dv-drop-target-top.dv-drop-target-small-vertical\r\n     {border-top:1px solid var(--dv-drag-over-border-color);}span.svelte-1wa7fd6\r\n    \r\n      .dv-drop-target\r\n        > .dv-drop-target-dropzone\r\n        > .dv-drop-target-selection.dv-drop-target-bottom.dv-drop-target-small-vertical\r\n     {border-bottom:1px solid var(--dv-drag-over-border-color);}span.svelte-1wa7fd6\r\n    \r\n      .dv-drop-target\r\n        > .dv-drop-target-dropzone\r\n        > .dv-drop-target-selection.dv-drop-target-left.dv-drop-target-small-horizontal\r\n     {border-left:1px solid var(--dv-drag-over-border-color);}span.svelte-1wa7fd6\r\n    \r\n      .dv-drop-target\r\n        > .dv-drop-target-dropzone\r\n        > .dv-drop-target-selection.dv-drop-target-right.dv-drop-target-small-horizontal\r\n     {border-right:1px solid var(--dv-drag-over-border-color);}span.svelte-1wa7fd6 .dv-dockview {position:relative;background-color:var(--dv-group-view-background-color);}span.svelte-1wa7fd6 .dv-dockview .dv-watermark-container {position:absolute;top:0px;left:0px;height:100%;width:100%;z-index:1;}span.svelte-1wa7fd6 .dv-dockview .dv-overlay-render-container {position:relative;}span.svelte-1wa7fd6\r\n    \r\n      .dv-groupview.dv-active-group\r\n        > .dv-tabs-and-actions-container\r\n        > .dv-tabs-container\r\n        > .dv-tab.dv-active-tab\r\n     {\r\n    /* background-color: var(--dv-activegroup-visiblepanel-tab-background-color); */color:var(--dv-activegroup-visiblepanel-tab-color);}span.svelte-1wa7fd6\r\n    \r\n      .dv-groupview.dv-active-group\r\n        > .dv-tabs-and-actions-container\r\n        > .dv-tabs-container\r\n        > .dv-tab.dv-inactive-tab\r\n     {\r\n    /* background-color: var(--dv-activegroup-hiddenpanel-tab-background-color); */color:var(--dv-activegroup-hiddenpanel-tab-color);}span.svelte-1wa7fd6\r\n    \r\n      .dv-groupview.dv-inactive-group\r\n        > .dv-tabs-and-actions-container\r\n        > .dv-tabs-container\r\n        > .dv-tab.dv-active-tab\r\n     {background-color:var(--dv-inactivegroup-visiblepanel-tab-background-color);color:var(--dv-inactivegroup-visiblepanel-tab-color);}span.svelte-1wa7fd6\r\n    \r\n      .dv-groupview.dv-inactive-group\r\n        > .dv-tabs-and-actions-container\r\n        > .dv-tabs-container\r\n        > .dv-tab.dv-inactive-tab\r\n     {background-color:var(--dv-inactivegroup-hiddenpanel-tab-background-color);color:var(--dv-inactivegroup-hiddenpanel-tab-color);}\r\n\r\n  /**\r\n * when a tab is dragged we lose the above stylings because they are conditional on parent elements\r\n * therefore we also set some stylings for the dragging event\r\n **/span.svelte-1wa7fd6 .dv-tab.dv-tab-dragging {background-color:var(--dv-activegroup-visiblepanel-tab-background-color);color:var(--dv-activegroup-visiblepanel-tab-color);}span.svelte-1wa7fd6 .dv-groupview {display:flex;flex-direction:column;height:100%;background-color:var(--dv-group-view-background-color);overflow:hidden;}span.svelte-1wa7fd6 .dv-groupview:focus {outline:none;}span.svelte-1wa7fd6 .dv-groupview > .dv-content-container {flex:1;width:100%;}span.svelte-1wa7fd6 .dv-root-wrapper {height:100%;width:100%;}span.svelte-1wa7fd6 .dv-grid-view,\r\n  span.svelte-1wa7fd6 .dv-branch-node {height:100%;width:100%;}span.svelte-1wa7fd6 .dv-debug .dv-resize-container .dv-resize-handle-top {background-color:red;}span.svelte-1wa7fd6 .dv-debug .dv-resize-container .dv-resize-handle-bottom {background-color:green;}span.svelte-1wa7fd6 .dv-debug .dv-resize-container .dv-resize-handle-left {background-color:yellow;}span.svelte-1wa7fd6 .dv-debug .dv-resize-container .dv-resize-handle-right {background-color:blue;}span.svelte-1wa7fd6 .dv-debug .dv-resize-container .dv-resize-handle-topleft,\r\n  span.svelte-1wa7fd6 .dv-debug .dv-resize-container .dv-resize-handle-topright,\r\n  span.svelte-1wa7fd6 .dv-debug .dv-resize-container .dv-resize-handle-bottomleft,\r\n  span.svelte-1wa7fd6 .dv-debug .dv-resize-container .dv-resize-handle-bottomright {background-color:cyan;}span.svelte-1wa7fd6 .dv-resize-container {--dv-overlay-z-index: var(--dv-overlay-z-index, 999);position:absolute;z-index:calc(var(--dv-overlay-z-index) - 2);border:1px solid var(--dv-tab-divider-color);box-shadow:var(--dv-floating-box-shadow);}span.svelte-1wa7fd6 .dv-resize-container.dv-hidden {display:none;}span.svelte-1wa7fd6 .dv-resize-container.dv-resize-container-dragging {opacity:0.5;}span.svelte-1wa7fd6 .dv-resize-container .dv-resize-handle-top {height:4px;width:calc(100% - 8px);left:4px;top:-2px;z-index:var(--dv-overlay-z-index);position:absolute;cursor:ns-resize;}span.svelte-1wa7fd6 .dv-resize-container .dv-resize-handle-bottom {height:4px;width:calc(100% - 8px);left:4px;bottom:-2px;z-index:var(--dv-overlay-z-index);position:absolute;cursor:ns-resize;}span.svelte-1wa7fd6 .dv-resize-container .dv-resize-handle-left {height:calc(100% - 8px);width:4px;left:-2px;top:4px;z-index:var(--dv-overlay-z-index);position:absolute;cursor:ew-resize;}span.svelte-1wa7fd6 .dv-resize-container .dv-resize-handle-right {height:calc(100% - 8px);width:4px;right:-2px;top:4px;z-index:var(--dv-overlay-z-index);position:absolute;cursor:ew-resize;}span.svelte-1wa7fd6 .dv-resize-container .dv-resize-handle-topleft {height:4px;width:4px;top:-2px;left:-2px;z-index:var(--dv-overlay-z-index);position:absolute;cursor:nw-resize;}span.svelte-1wa7fd6 .dv-resize-container .dv-resize-handle-topright {height:4px;width:4px;right:-2px;top:-2px;z-index:var(--dv-overlay-z-index);position:absolute;cursor:ne-resize;}span.svelte-1wa7fd6 .dv-resize-container .dv-resize-handle-bottomleft {height:4px;width:4px;left:-2px;bottom:-2px;z-index:var(--dv-overlay-z-index);position:absolute;cursor:sw-resize;}span.svelte-1wa7fd6 .dv-resize-container .dv-resize-handle-bottomright {height:4px;width:4px;right:-2px;bottom:-2px;z-index:var(--dv-overlay-z-index);position:absolute;cursor:se-resize;}span.svelte-1wa7fd6 .dv-render-overlay {--dv-overlay-z-index: var(--dv-overlay-z-index, 999);position:absolute;z-index:1;height:100%;}span.svelte-1wa7fd6 .dv-render-overlay.dv-render-overlay-float {z-index:calc(var(--dv-overlay-z-index) - 1);}span.svelte-1wa7fd6 .dv-debug .dv-render-overlay {outline:1px solid red;outline-offset:-1;}span.svelte-1wa7fd6 .dv-pane-container {height:100%;width:100%;}span.svelte-1wa7fd6 .dv-pane-container.dv-animated .dv-view {transition-duration:0.15s;transition-timing-function:ease-out;}span.svelte-1wa7fd6 .dv-pane-container .dv-view {overflow:hidden;display:flex;flex-direction:column;padding:0px !important;}span.svelte-1wa7fd6 .dv-pane-container .dv-view:not(:first-child)::before {background-color:transparent !important;}span.svelte-1wa7fd6\r\n    \r\n      .dv-pane-container .dv-view:not(:first-child) .dv-pane > .dv-pane-header\r\n     {border-top:1px solid var(--dv-paneview-header-border-color);}span.svelte-1wa7fd6 .dv-pane-container .dv-view .dv-default-header {background-color:var(--dv-group-view-background-color);color:var(--dv-activegroup-visiblepanel-tab-color);display:flex;padding:0px 8px;cursor:pointer;}span.svelte-1wa7fd6\r\n    \r\n      .dv-pane-container .dv-view .dv-default-header .dv-pane-header-icon\r\n     {display:flex;justify-content:center;align-items:center;}span.svelte-1wa7fd6 .dv-pane-container .dv-view .dv-default-header > span {padding-left:8px;flex-grow:1;}span.svelte-1wa7fd6 .dv-pane-container:first-of-type > .dv-pane > .dv-pane-header {border-top:none !important;}span.svelte-1wa7fd6 .dv-pane-container .dv-pane {display:flex;flex-direction:column;overflow:hidden;height:100%;}span.svelte-1wa7fd6 .dv-pane-container .dv-pane .dv-pane-header {box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;user-select:none;position:relative;outline:none;}span.svelte-1wa7fd6 .dv-pane-container .dv-pane .dv-pane-header.dv-pane-draggable {cursor:pointer;}span.svelte-1wa7fd6 .dv-pane-container .dv-pane .dv-pane-header:focus:before,\r\n  span.svelte-1wa7fd6\r\n    .dv-pane-container .dv-pane .dv-pane-header:focus-within:before {position:absolute;top:0;left:0;width:100%;height:100%;z-index:5;content:\"\";pointer-events:none;outline:1px solid;outline-width:-1px;outline-style:solid;outline-offset:-1px;outline-color:var(--dv-paneview-active-outline-color);}span.svelte-1wa7fd6 .dv-pane-container .dv-pane .dv-pane-body {overflow-y:auto;overflow-x:hidden;flex-grow:1;position:relative;outline:none;}span.svelte-1wa7fd6 .dv-pane-container .dv-pane .dv-pane-body:focus:before,\r\n  span.svelte-1wa7fd6 .dv-pane-container .dv-pane .dv-pane-body:focus-within:before {position:absolute;top:0;left:0;width:100%;height:100%;z-index:5;content:\"\";pointer-events:none;outline:1px solid;outline-width:-1px;outline-style:solid;outline-offset:-1px;outline-color:var(--dv-paneview-active-outline-color);}span.svelte-1wa7fd6\r\n    \r\n      .dv-debug .dv-split-view-container .dv-sash-container .dv-sash.dv-enabled\r\n     {background-color:var(--background, #000000);}span.svelte-1wa7fd6\r\n    \r\n      .dv-debug .dv-split-view-container .dv-sash-container .dv-sash.dv-disabled\r\n     {background-color:orange;}span.svelte-1wa7fd6\r\n    \r\n      .dv-debug .dv-split-view-container .dv-sash-container .dv-sash.dv-maximum\r\n     {background-color:green;}span.svelte-1wa7fd6\r\n    \r\n      .dv-debug .dv-split-view-container .dv-sash-container .dv-sash.dv-minimum\r\n     {background-color:red;}span.svelte-1wa7fd6 .dv-split-view-container {position:relative;overflow:hidden;height:100%;width:100%;}span.svelte-1wa7fd6\r\n    \r\n      .dv-split-view-container.dv-splitview-disabled\r\n        > .dv-sash-container\r\n        > .dv-sash\r\n     {background-color:var(--dock-view-border, #2b2b2b);pointer-events:none;}span.svelte-1wa7fd6 .dv-split-view-container.dv-animation .dv-view,\r\n  span.svelte-1wa7fd6 .dv-split-view-container.dv-animation .dv-sash {transition-duration:0.15s;transition-timing-function:ease-out;}span.svelte-1wa7fd6 .dv-split-view-container.dv-horizontal {height:100%;}span.svelte-1wa7fd6\r\n    \r\n      .dv-split-view-container.dv-horizontal > .dv-sash-container > .dv-sash\r\n     {height:100%;width:4px;background-color:var(--dock-view-border, #2b2b2b);}span.svelte-1wa7fd6\r\n    \r\n      .dv-split-view-container.dv-horizontal\r\n        > .dv-sash-container\r\n        > .dv-sash.dv-enabled\r\n     {cursor:ew-resize;background-color:var(--background, #000000);}span.svelte-1wa7fd6\r\n    \r\n      .dv-split-view-container.dv-horizontal\r\n        > .dv-sash-container\r\n        > .dv-sash.dv-disabled\r\n     {cursor:default;}span.svelte-1wa7fd6\r\n    \r\n      .dv-split-view-container.dv-horizontal\r\n        > .dv-sash-container\r\n        > .dv-sash.dv-maximum\r\n     {cursor:w-resize;}span.svelte-1wa7fd6\r\n    \r\n      .dv-split-view-container.dv-horizontal\r\n        > .dv-sash-container\r\n        > .dv-sash.dv-minimum\r\n     {cursor:e-resize;}span.svelte-1wa7fd6\r\n    \r\n      .dv-split-view-container.dv-horizontal\r\n        > .dv-view-container\r\n        > .dv-view:not(:first-child)::before\r\n     {height:100%;width:1px;}span.svelte-1wa7fd6 .dv-split-view-container.dv-vertical {width:100%;}span.svelte-1wa7fd6\r\n    \r\n      .dv-split-view-container.dv-vertical > .dv-sash-container > .dv-sash\r\n     {width:100%;height:4px;}span.svelte-1wa7fd6\r\n    \r\n      .dv-split-view-container.dv-vertical\r\n        > .dv-sash-container\r\n        > .dv-sash.dv-enabled\r\n     {cursor:ns-resize;background-color:var(--background, #000000);}span.svelte-1wa7fd6\r\n    \r\n      .dv-split-view-container.dv-vertical\r\n        > .dv-sash-container\r\n        > .dv-sash.dv-disabled\r\n     {cursor:default;}span.svelte-1wa7fd6\r\n    \r\n      .dv-split-view-container.dv-vertical\r\n        > .dv-sash-container\r\n        > .dv-sash.dv-maximum\r\n     {cursor:n-resize;}span.svelte-1wa7fd6\r\n    \r\n      .dv-split-view-container.dv-vertical\r\n        > .dv-sash-container\r\n        > .dv-sash.dv-minimum\r\n     {cursor:s-resize;}span.svelte-1wa7fd6\r\n    \r\n      .dv-split-view-container.dv-vertical > .dv-view-container > .dv-view\r\n     {width:100%;}span.svelte-1wa7fd6\r\n    \r\n      .dv-split-view-container.dv-vertical\r\n        > .dv-view-container\r\n        > .dv-view:not(:first-child)::before\r\n     {height:1px;width:100%;}span.svelte-1wa7fd6 .dv-split-view-container .dv-sash-container {height:100%;width:100%;position:absolute;}span.svelte-1wa7fd6 .dv-split-view-container .dv-sash-container .dv-sash {position:absolute;z-index:2;outline:none;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;touch-action:none;}span.svelte-1wa7fd6\r\n    \r\n      .dv-split-view-container .dv-sash-container .dv-sash:not(.disabled):active\r\n    ,\r\n  span.svelte-1wa7fd6\r\n    \r\n      .dv-split-view-container .dv-sash-container .dv-sash:not(.disabled):hover\r\n     {background-color:var(--dv-active-sash-color, transparent);transition-property:background-color;transition-timing-function:ease-in-out;transition-duration:var(--dv-active-sash-transition-duration, 0.1s);transition-delay:var(--dv-active-sash-transition-delay, 0.5s);}span.svelte-1wa7fd6 .dv-split-view-container .dv-view-container {position:relative;height:100%;width:100%;}span.svelte-1wa7fd6 .dv-split-view-container .dv-view-container .dv-view {height:100%;box-sizing:border-box;overflow:auto;position:absolute;}span.svelte-1wa7fd6\r\n    \r\n      .dv-split-view-container.dv-separator-border\r\n        .dv-view:not(:first-child)::before\r\n     {content:\" \";position:absolute;top:0;left:0;z-index:5;pointer-events:none;background-color:var(--dv-separator-border);}span.svelte-1wa7fd6 .dv-dragged {transform:translate3d(\r\n      0px,\r\n      0px,\r\n      0px\r\n    ); /* forces tab to be drawn on a separate layer (see https://github.com/microsoft/vscode/issues/18733) */}span.svelte-1wa7fd6 .dv-tab {flex-shrink:0;}span.svelte-1wa7fd6 .dv-tab:focus-within,\r\n  span.svelte-1wa7fd6 .dv-tab:focus {position:relative;}span.svelte-1wa7fd6 .dv-tab:focus-within::after,\r\n  span.svelte-1wa7fd6 .dv-tab:focus::after {position:absolute;content:\"\";height:100%;width:100%;top:0px;left:0px;pointer-events:none;outline:1px solid var(--dv-tab-divider-color) !important;outline-offset:-1px;z-index:5;}span.svelte-1wa7fd6 .dv-tab.dv-tab-dragging .dv-default-tab-action {background-color:var(--dv-activegroup-visiblepanel-tab-color);}span.svelte-1wa7fd6 .dv-tab.dv-active-tab .dv-default-tab .dv-default-tab-action {visibility:visible;}span.svelte-1wa7fd6 .dv-tab.dv-inactive-tab .dv-default-tab .dv-default-tab-action {visibility:hidden;}span.svelte-1wa7fd6\r\n    \r\n      .dv-tab.dv-inactive-tab .dv-default-tab:hover .dv-default-tab-action\r\n     {visibility:visible;}span.svelte-1wa7fd6 .dv-tab .dv-default-tab {position:relative;height:100%;display:flex;min-width:80px;align-items:center;padding:0px 8px;white-space:nowrap;text-overflow:ellipsis;}span.svelte-1wa7fd6 .dv-tab .dv-default-tab .dv-default-tab-content {padding:0px 8px;flex-grow:1;}span.svelte-1wa7fd6 .dv-tab .dv-default-tab .dv-default-tab-action {padding:4px;display:flex;align-items:center;justify-content:center;box-sizing:border-box;}span.svelte-1wa7fd6 .dv-tab .dv-default-tab .dv-default-tab-action:hover {border-radius:2px;background-color:var(--dv-icon-hover-background-color);}span.svelte-1wa7fd6 .dv-tabs-and-actions-container {display:flex;background-color:var(--background-dark);flex-shrink:0;box-sizing:border-box;height:var(--dv-tabs-and-actions-container-height);font-size:var(--dv-tabs-and-actions-container-font-size);}span.svelte-1wa7fd6\r\n    \r\n      .dv-tabs-and-actions-container.dv-single-tab.dv-full-width-single-tab\r\n        .dv-tabs-container\r\n     {flex-grow:1;}span.svelte-1wa7fd6\r\n    \r\n      .dv-tabs-and-actions-container.dv-single-tab.dv-full-width-single-tab\r\n        .dv-tabs-container\r\n        .dv-tab\r\n     {flex-grow:1;}span.svelte-1wa7fd6\r\n    \r\n      .dv-tabs-and-actions-container.dv-single-tab.dv-full-width-single-tab\r\n        .dv-void-container\r\n     {flex-grow:0;}span.svelte-1wa7fd6 .dv-tabs-and-actions-container .dv-void-container {display:flex;flex-grow:1;cursor:grab;background-color:var(--background-dark);border-bottom:2px solid var(--button-border);}span.svelte-1wa7fd6 .dv-tabs-and-actions-container .dv-tabs-container {display:flex;overflow-x:overlay;overflow-y:hidden;scrollbar-width:thin;\r\n    /* Track */\r\n    /* Handle */}span.svelte-1wa7fd6\r\n    \r\n      .dv-tabs-and-actions-container .dv-tabs-container::-webkit-scrollbar\r\n     {height:3px;}span.svelte-1wa7fd6\r\n    \r\n      .dv-tabs-and-actions-container .dv-tabs-container::-webkit-scrollbar-track\r\n     {background:transparent;}span.svelte-1wa7fd6\r\n    \r\n      .dv-tabs-and-actions-container .dv-tabs-container::-webkit-scrollbar-thumb\r\n     {background:var(--dv-tabs-container-scrollbar-color);}span.svelte-1wa7fd6 .dv-tabs-and-actions-container .dv-tabs-container .dv-tab {-webkit-user-drag:element;outline:none;min-width:75px;cursor:pointer;position:relative;box-sizing:border-box;}span.svelte-1wa7fd6\r\n    \r\n      .dv-tabs-and-actions-container\r\n        .dv-tabs-container\r\n        .dv-tab:not(:first-child)::before\r\n     {content:\" \";position:absolute;top:0;left:0;z-index:5;pointer-events:none;background-color:var(--dv-tab-divider-color);width:1px;height:100%;}span.svelte-1wa7fd6 .dv-watermark {display:flex;height:100%;background-color:var(--background, #000000);}"
};
function ViewContainer(C, T) {
	push(T, !0), append_styles(C, $$css$26);
	let E = prop(T, "element", 15), D = prop(T, "id", 7), O = prop(T, "theme", 7);
	var F = {
		get element() {
			return E();
		},
		set element(C) {
			E(C), flushSync();
		},
		get id() {
			return D();
		},
		set id(C) {
			D(C), flushSync();
		},
		get theme() {
			return O();
		},
		set theme(C) {
			O(C), flushSync();
		}
	}, I = root$34(), L = child(I);
	return set_style(L, "", {}, {
		height: "100%",
		width: "100%"
	}), bind_this(L, (C) => E(C), () => E()), reset(I), template_effect(() => {
		var C, T;
		set_attribute(I, "id", `${(C = D()) == null ? "" : C}-wrapper`), set_attribute(L, "id", D()), set_class(L, 1, `dockview-theme-${(T = O()) == null ? "dark" : T}`);
	}), append(C, I), pop(F);
}
create_custom_element(ViewContainer, {
	element: {},
	id: {},
	theme: {}
}, [], [], !0);
var dockCount = 0, createGroupControlElement = (C) => C ? (T) => {
	if ("component" in C) return new SvelteDockActionsHeaderRenderer(T, {
		viewIndex: dockCount,
		id: T.id,
		name: C.component.name,
		svelteComponent: C.component
	});
	if ("snippet" in C) return new SvelteDockActionsHeaderRenderer(T, {
		viewIndex: dockCount,
		id: T.id,
		name: C.snippet.name,
		svelteComponent: SnippetRender,
		propsPostProcessor: (T) => T.snippet = C.snippet
	});
	throw Error("Invalid component and/or snippet");
} : void 0;
function DockView(C, E) {
	push(E, !0);
	let D = dockCount++, O = prop(E, "components", 7), F = prop(E, "snippets", 7), I = prop(E, "tabs", 7), L = prop(E, "theme", 7), z = prop(E, "watermark", 7), B = prop(E, "defaultTab", 7), V = prop(E, "rightHeaderActions", 7), U = prop(E, "leftHeaderActions", 7), W = prop(E, "prefixHeaderActions", 7), G = prop(E, "onReady", 7), K = prop(E, "onDidDrop", 7), J = prop(E, "onWillDrop", 7), Y = prop(E, "orientation", 7), X = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"components",
		"snippets",
		"tabs",
		"theme",
		"watermark",
		"defaultTab",
		"rightHeaderActions",
		"leftHeaderActions",
		"prefixHeaderActions",
		"onReady",
		"onDidDrop",
		"onWillDrop",
		"orientation"
	]), Z;
	for (let C of PROPERTY_KEYS_DOCKVIEW) user_effect(() => Z == null ? void 0 : Z.updateOptions({ [C]: X[C] }));
	let Q = {
		createLeftHeaderActionComponent: createGroupControlElement(U()),
		createRightHeaderActionComponent: createGroupControlElement(V()),
		createPrefixHeaderActionComponent: createGroupControlElement(W()),
		createComponent: (C) => {
			let { component: T, propsPostProcessor: E, name: I } = getComponentToMount("dock", O(), F(), C);
			return new SvelteDockComponentRenderer({
				name: I,
				id: C.id,
				viewIndex: D,
				svelteComponent: T,
				propsPostProcessor: E
			});
		},
		createTabComponent: I() ? (C) => {
			let { component: T, propsPostProcessor: E, name: O } = getComponentToMount("dock", I().components, I().snippets, C);
			return new SvelteDockHeaderRenderer({
				name: O,
				id: C.id,
				viewIndex: D,
				svelteComponent: T,
				propsPostProcessor: E
			});
		} : void 0,
		createWatermarkComponent: z() ? () => {
			if ("component" in z()) return new SvelteWatermarkRenderer({
				name: z().component.name,
				id: "watermark",
				viewIndex: D,
				svelteComponent: z().component
			});
			if ("snippet" in z()) return new SvelteWatermarkRenderer({
				name: "watermark",
				id: "watermark",
				viewIndex: D,
				svelteComponent: SnippetRender,
				propsPostProcessor: (C) => C.snippet = z().snippet
			});
			throw Error("Invalid watermark component and/or snippet");
		} : void 0
	}, NL = /* @__PURE__ */ state(void 0);
	onMount(() => {
		var C;
		let E = createDockview(get(NL), _objectSpread2(_objectSpread2({}, extractCoreOptions(X, PROPERTY_KEYS_DOCKVIEW)), Q));
		Z = Object.assign(E, createExtendedAPI("dock", E, D));
		let { clientWidth: O, clientHeight: F } = get(NL);
		Z.layout(O, F), (C = G()) == null || C({ api: Z });
	}), user_effect(() => {
		K() && (Z == null || Z.onDidDrop(K()));
	}), user_effect(() => {
		J() && (Z == null || Z.onWillDrop(J()));
	}), onDestroy(() => {
		Z == null || Z.dispose();
	});
	var PL = {
		get components() {
			return O();
		},
		set components(C) {
			O(C), flushSync();
		},
		get snippets() {
			return F();
		},
		set snippets(C) {
			F(C), flushSync();
		},
		get tabs() {
			return I();
		},
		set tabs(C) {
			I(C), flushSync();
		},
		get theme() {
			return L();
		},
		set theme(C) {
			L(C), flushSync();
		},
		get watermark() {
			return z();
		},
		set watermark(C) {
			z(C), flushSync();
		},
		get defaultTab() {
			return B();
		},
		set defaultTab(C) {
			B(C), flushSync();
		},
		get rightHeaderActions() {
			return V();
		},
		set rightHeaderActions(C) {
			V(C), flushSync();
		},
		get leftHeaderActions() {
			return U();
		},
		set leftHeaderActions(C) {
			U(C), flushSync();
		},
		get prefixHeaderActions() {
			return W();
		},
		set prefixHeaderActions(C) {
			W(C), flushSync();
		},
		get onReady() {
			return G();
		},
		set onReady(C) {
			G(C), flushSync();
		},
		get onDidDrop() {
			return K();
		},
		set onDidDrop(C) {
			K(C), flushSync();
		},
		get onWillDrop() {
			return J();
		},
		set onWillDrop(C) {
			J(C), flushSync();
		},
		get orientation() {
			return Y();
		},
		set orientation(C) {
			Y(C), flushSync();
		}
	};
	{
		let T = /* @__PURE__ */ user_derived(() => `dock${D}`);
		ViewContainer(C, {
			get id() {
				return get(T);
			},
			get theme() {
				return L();
			},
			get element() {
				return get(NL);
			},
			set element(C) {
				set(NL, C, !0);
			}
		});
	}
	return pop(PL);
}
create_custom_element(DockView, {
	components: {},
	snippets: {},
	tabs: {},
	theme: {},
	watermark: {},
	defaultTab: {},
	rightHeaderActions: {},
	leftHeaderActions: {},
	prefixHeaderActions: {},
	onReady: {},
	onDidDrop: {},
	onWillDrop: {},
	orientation: {}
}, [], [], !0);
var paneCount = 0, SveltePanePanelRenderer = class extends PanelRendererBase {
	constructor(E) {
		super(_objectSpread2(_objectSpread2({}, E), {}, { initOptionsToProps: ({ params: C, api: T, title: E, containerApi: D }) => ({
			params: C,
			api: T,
			title: E,
			containerApi: D
		}) })), _defineProperty(this, "id", void 0), this.id = E.id;
	}
	toJSON() {
		return { id: this.id };
	}
};
function PaneView(C, E) {
	push(E, !0);
	let D = prop(E, "components", 7), O = prop(E, "snippets", 7), F = prop(E, "headers", 7), I = prop(E, "onReady", 7), L = prop(E, "onDidDrop", 7), z = prop(E, "theme", 7), B = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"components",
		"snippets",
		"headers",
		"onReady",
		"onDidDrop",
		"theme"
	]), V = paneCount++, U;
	for (let C of PROPERTY_KEYS_PANEVIEW) user_effect(() => U == null ? void 0 : U.updateOptions({ [C]: B[C] }));
	let W = {
		createComponent: (C) => {
			let { component: T, propsPostProcessor: E, name: F } = getComponentToMount("pane", D(), O(), C);
			return new SveltePanePanelRenderer({
				id: C.id,
				name: F,
				svelteComponent: T,
				viewIndex: V,
				propsPostProcessor: E,
				panelTarget: "pane"
			});
		},
		createHeaderComponent: (C) => {
			var T, E;
			let { component: D, propsPostProcessor: O, name: I } = getComponentToMount("pane", (T = F()) == null ? void 0 : T.components, (E = F()) == null ? void 0 : E.snippets, C);
			return new SveltePanePanelRenderer({
				id: C.id,
				name: I,
				svelteComponent: D,
				viewIndex: V,
				propsPostProcessor: O,
				panelTarget: "paneheader"
			});
		}
	}, G = /* @__PURE__ */ state(void 0);
	onMount(() => {
		var C;
		let E = createPaneview(get(G), _objectSpread2(_objectSpread2({}, extractCoreOptions(B, PROPERTY_KEYS_PANEVIEW)), W));
		U = Object.assign(E, createExtendedAPI("pane", E, V));
		let { clientWidth: D, clientHeight: O } = get(G);
		U.layout(D, O), (C = I()) == null || C({ api: U });
	}), user_effect(() => {
		L() && (U == null || U.onDidDrop(L()));
	}), onDestroy(() => {
		U == null || U.dispose();
	});
	var K = {
		get components() {
			return D();
		},
		set components(C) {
			D(C), flushSync();
		},
		get snippets() {
			return O();
		},
		set snippets(C) {
			O(C), flushSync();
		},
		get headers() {
			return F();
		},
		set headers(C) {
			F(C), flushSync();
		},
		get onReady() {
			return I();
		},
		set onReady(C) {
			I(C), flushSync();
		},
		get onDidDrop() {
			return L();
		},
		set onDidDrop(C) {
			L(C), flushSync();
		},
		get theme() {
			return z();
		},
		set theme(C) {
			z(C), flushSync();
		}
	};
	{
		let T = /* @__PURE__ */ user_derived(() => `pane${V}`);
		ViewContainer(C, {
			get id() {
				return get(T);
			},
			get theme() {
				return z();
			},
			get element() {
				return get(G);
			},
			set element(C) {
				set(G, C, !0);
			}
		});
	}
	return pop(K);
}
create_custom_element(PaneView, {
	components: {},
	snippets: {},
	headers: {},
	onReady: {},
	onDidDrop: {},
	theme: {}
}, [], [], !0);
var splitCount = 0, SvelteGridviewPanel$1 = class extends SplitviewPanel {
	constructor(E) {
		super(E.id, E.name), _defineProperty(this, "renderer", void 0);
		let D = this;
		this.renderer = new PanelRendererBase(_objectSpread2(_objectSpread2({}, E), {}, {
			element: this.element,
			panelTarget: "split",
			initOptionsToProps: (C) => {
				var T;
				return {
					params: (T = C == null ? void 0 : C.params) == null ? {} : T,
					api: D.api,
					containerApi: new SplitviewApi(C.accessor)
				};
			}
		}));
	}
	getComponent() {
		return this.renderer.init(this._params), this.renderer;
	}
};
function SplitView(C, E) {
	push(E, !0);
	let D = prop(E, "components", 7), O = prop(E, "snippets", 7), F = prop(E, "onReady", 7), I = prop(E, "theme", 7), L = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"components",
		"snippets",
		"onReady",
		"theme"
	]), z = splitCount++, B;
	for (let C of PROPERTY_KEYS_SPLITVIEW) user_effect(() => B == null ? void 0 : B.updateOptions({ [C]: L[C] }));
	let V = { createComponent: (C) => {
		let { component: T, propsPostProcessor: E, name: F } = getComponentToMount("split", D(), O(), C);
		return new SvelteGridviewPanel$1({
			id: C.id,
			name: F,
			svelteComponent: T,
			viewIndex: z,
			propsPostProcessor: E
		});
	} }, U = /* @__PURE__ */ state(void 0);
	onMount(() => {
		var C;
		let E = createSplitview(get(U), _objectSpread2(_objectSpread2({}, extractCoreOptions(L, PROPERTY_KEYS_SPLITVIEW)), V));
		B = Object.assign(E, createExtendedAPI("split", E, z));
		let { clientWidth: D, clientHeight: O } = get(U);
		B.layout(D, O), (C = F()) == null || C({ api: B });
	}), onDestroy(() => {
		B == null || B.dispose();
	});
	var W = {
		get components() {
			return D();
		},
		set components(C) {
			D(C), flushSync();
		},
		get snippets() {
			return O();
		},
		set snippets(C) {
			O(C), flushSync();
		},
		get onReady() {
			return F();
		},
		set onReady(C) {
			F(C), flushSync();
		},
		get theme() {
			return I();
		},
		set theme(C) {
			I(C), flushSync();
		}
	};
	{
		let T = /* @__PURE__ */ user_derived(() => `split${z}`);
		ViewContainer(C, {
			get id() {
				return get(T);
			},
			get theme() {
				return I();
			},
			get element() {
				return get(U);
			},
			set element(C) {
				set(U, C, !0);
			}
		});
	}
	return pop(W);
}
create_custom_element(SplitView, {
	components: {},
	snippets: {},
	onReady: {},
	theme: {}
}, [], [], !0);
var gridCount = 0, SvelteGridviewPanel = class extends GridviewPanel {
	constructor(E) {
		super(E.id, E.name), _defineProperty(this, "render", void 0);
		let D = this;
		this.render = new PanelRendererBase(_objectSpread2(_objectSpread2({}, E), {}, {
			element: this.element,
			panelTarget: "grid",
			initOptionsToProps: (C) => {
				var T;
				return {
					params: (T = C == null ? void 0 : C.params) == null ? {} : T,
					api: D.api,
					containerApi: new GridviewApi(C.accessor)
				};
			}
		}));
	}
	getComponent() {
		return this.render.init(this._params), this.render;
	}
};
function GridView(C, E) {
	push(E, !0);
	let D = prop(E, "components", 7), O = prop(E, "snippets", 7), F = prop(E, "theme", 7), I = prop(E, "onReady", 7), L = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"components",
		"snippets",
		"theme",
		"onReady"
	]), z = gridCount++, B;
	for (let C of PROPERTY_KEYS_GRIDVIEW) user_effect(() => B == null ? void 0 : B.updateOptions({ [C]: L[C] }));
	let V = { createComponent: (C) => {
		let { component: T, propsPostProcessor: E, name: F } = getComponentToMount("grid", D(), O(), C);
		return new SvelteGridviewPanel({
			id: C.id,
			name: F,
			svelteComponent: T,
			viewIndex: z,
			propsPostProcessor: E
		});
	} }, U = /* @__PURE__ */ state(void 0);
	user_effect(() => {
		var C;
		let E = createGridview(get(U), _objectSpread2(_objectSpread2({}, extractCoreOptions(L, PROPERTY_KEYS_GRIDVIEW)), V));
		B = Object.assign(E, createExtendedAPI("grid", E, z));
		let { clientWidth: D, clientHeight: O } = get(U);
		B.layout(D, O), (C = I()) == null || C({ api: B });
	}), onDestroy(() => {
		B == null || B.dispose();
	});
	var W = {
		get components() {
			return D();
		},
		set components(C) {
			D(C), flushSync();
		},
		get snippets() {
			return O();
		},
		set snippets(C) {
			O(C), flushSync();
		},
		get theme() {
			return F();
		},
		set theme(C) {
			F(C), flushSync();
		},
		get onReady() {
			return I();
		},
		set onReady(C) {
			I(C), flushSync();
		}
	};
	{
		let T = /* @__PURE__ */ user_derived(() => `grid${z}`);
		ViewContainer(C, {
			get id() {
				return get(T);
			},
			get theme() {
				return F();
			},
			get element() {
				return get(U);
			},
			set element(C) {
				set(U, C, !0);
			}
		});
	}
	return pop(W);
}
create_custom_element(GridView, {
	components: {},
	snippets: {},
	theme: {},
	onReady: {}
}, [], [], !0), proxy({
	curScreen: null,
	curGraph: null,
	screens: {},
	graphs: {}
});
const api = proxy({});
let widgetStores = proxy({
	widgets: [],
	isSelectedChange: !1
}), widgetProps = proxy({
	props: [],
	selectedCellsIds: "ss",
	selectedCellsLen: 0,
	curlvglShape: null,
	update: 0
}), Asserts = proxy({
	data: [],
	fonts: {}
});
const lvglBinFont = proxy({}), LvglBaseNameSet = proxy(/* @__PURE__ */ new Set());
function WgtAccordionItem(C, T) {
	push(T, !0);
	let E = prop(T, "label", 7, ""), D = prop(T, "children", 7);
	return AccordionItem(C, {
		activeClass: "bg-gray-800 text-white",
		inactiveClass: "bg-gray-800 text-white",
		class: "bg-gray-800",
		header: (C) => {
			next();
			var T = text();
			template_effect(() => set_text(T, E())), append(C, T);
		},
		children: (C, T) => {
			var E = comment();
			key(first_child(E), () => widgetProps.update, (C) => {
				var T = comment();
				snippet(first_child(T), D), append(C, T);
			}), append(C, E);
		},
		$$slots: {
			header: !0,
			default: !0
		}
	}), pop({
		get label() {
			return E();
		},
		set label(C = "") {
			E(C), flushSync();
		},
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		}
	});
}
create_custom_element(WgtAccordionItem, {
	label: {},
	children: {}
}, [], [], !0);
let lv_align_t$1 = /* @__PURE__ */ function(C) {
	return C[C.LV_ALIGN_DEFAULT = 0] = "LV_ALIGN_DEFAULT", C[C.LV_ALIGN_TOP_LEFT = 1] = "LV_ALIGN_TOP_LEFT", C[C.LV_ALIGN_TOP_MID = 2] = "LV_ALIGN_TOP_MID", C[C.LV_ALIGN_TOP_RIGHT = 3] = "LV_ALIGN_TOP_RIGHT", C[C.LV_ALIGN_BOTTOM_LEFT = 4] = "LV_ALIGN_BOTTOM_LEFT", C[C.LV_ALIGN_BOTTOM_MID = 5] = "LV_ALIGN_BOTTOM_MID", C[C.LV_ALIGN_BOTTOM_RIGHT = 6] = "LV_ALIGN_BOTTOM_RIGHT", C[C.LV_ALIGN_LEFT_MID = 7] = "LV_ALIGN_LEFT_MID", C[C.LV_ALIGN_RIGHT_MID = 8] = "LV_ALIGN_RIGHT_MID", C[C.LV_ALIGN_CENTER = 9] = "LV_ALIGN_CENTER", C[C.LV_ALIGN_OUT_TOP_LEFT = 10] = "LV_ALIGN_OUT_TOP_LEFT", C[C.LV_ALIGN_OUT_TOP_MID = 11] = "LV_ALIGN_OUT_TOP_MID", C[C.LV_ALIGN_OUT_TOP_RIGHT = 12] = "LV_ALIGN_OUT_TOP_RIGHT", C[C.LV_ALIGN_OUT_BOTTOM_LEFT = 13] = "LV_ALIGN_OUT_BOTTOM_LEFT", C[C.LV_ALIGN_OUT_BOTTOM_MID = 14] = "LV_ALIGN_OUT_BOTTOM_MID", C[C.LV_ALIGN_OUT_BOTTOM_RIGHT = 15] = "LV_ALIGN_OUT_BOTTOM_RIGHT", C[C.LV_ALIGN_OUT_LEFT_TOP = 16] = "LV_ALIGN_OUT_LEFT_TOP", C[C.LV_ALIGN_OUT_LEFT_MID = 17] = "LV_ALIGN_OUT_LEFT_MID", C[C.LV_ALIGN_OUT_LEFT_BOTTOM = 18] = "LV_ALIGN_OUT_LEFT_BOTTOM", C[C.LV_ALIGN_OUT_RIGHT_TOP = 19] = "LV_ALIGN_OUT_RIGHT_TOP", C[C.LV_ALIGN_OUT_RIGHT_MID = 20] = "LV_ALIGN_OUT_RIGHT_MID", C[C.LV_ALIGN_OUT_RIGHT_BOTTOM = 21] = "LV_ALIGN_OUT_RIGHT_BOTTOM", C;
}({}), lv_obj_flag_t$1 = /* @__PURE__ */ function(C) {
	return C[C.LV_OBJ_FLAG_HIDDEN = 1] = "LV_OBJ_FLAG_HIDDEN", C[C.LV_OBJ_FLAG_CLICKABLE = 2] = "LV_OBJ_FLAG_CLICKABLE", C[C.LV_OBJ_FLAG_CLICK_FOCUSABLE = 4] = "LV_OBJ_FLAG_CLICK_FOCUSABLE", C[C.LV_OBJ_FLAG_CHECKABLE = 8] = "LV_OBJ_FLAG_CHECKABLE", C[C.LV_OBJ_FLAG_SCROLLABLE = 16] = "LV_OBJ_FLAG_SCROLLABLE", C[C.LV_OBJ_FLAG_SCROLL_ELASTIC = 32] = "LV_OBJ_FLAG_SCROLL_ELASTIC", C[C.LV_OBJ_FLAG_SCROLL_MOMENTUM = 64] = "LV_OBJ_FLAG_SCROLL_MOMENTUM", C[C.LV_OBJ_FLAG_SCROLL_ONE = 128] = "LV_OBJ_FLAG_SCROLL_ONE", C[C.LV_OBJ_FLAG_SCROLL_CHAIN_HOR = 256] = "LV_OBJ_FLAG_SCROLL_CHAIN_HOR", C[C.LV_OBJ_FLAG_SCROLL_CHAIN_VER = 512] = "LV_OBJ_FLAG_SCROLL_CHAIN_VER", C[C.LV_OBJ_FLAG_SCROLL_CHAIN = 768] = "LV_OBJ_FLAG_SCROLL_CHAIN", C[C.LV_OBJ_FLAG_SCROLL_ON_FOCUS = 1024] = "LV_OBJ_FLAG_SCROLL_ON_FOCUS", C[C.LV_OBJ_FLAG_SCROLL_WITH_ARROW = 2048] = "LV_OBJ_FLAG_SCROLL_WITH_ARROW", C[C.LV_OBJ_FLAG_SNAPPABLE = 4096] = "LV_OBJ_FLAG_SNAPPABLE", C[C.LV_OBJ_FLAG_PRESS_LOCK = 8192] = "LV_OBJ_FLAG_PRESS_LOCK", C[C.LV_OBJ_FLAG_EVENT_BUBBLE = 16384] = "LV_OBJ_FLAG_EVENT_BUBBLE", C[C.LV_OBJ_FLAG_GESTURE_BUBBLE = 32768] = "LV_OBJ_FLAG_GESTURE_BUBBLE", C[C.LV_OBJ_FLAG_ADV_HITTEST = 65536] = "LV_OBJ_FLAG_ADV_HITTEST", C[C.LV_OBJ_FLAG_IGNORE_LAYOUT = 131072] = "LV_OBJ_FLAG_IGNORE_LAYOUT", C[C.LV_OBJ_FLAG_FLOATING = 262144] = "LV_OBJ_FLAG_FLOATING", C[C.LV_OBJ_FLAG_SEND_DRAW_TASK_EVENTS = 524288] = "LV_OBJ_FLAG_SEND_DRAW_TASK_EVENTS", C[C.LV_OBJ_FLAG_OVERFLOW_VISIBLE = 1048576] = "LV_OBJ_FLAG_OVERFLOW_VISIBLE", C[C.LV_OBJ_FLAG_LAYOUT_1 = 8388608] = "LV_OBJ_FLAG_LAYOUT_1", C[C.LV_OBJ_FLAG_LAYOUT_2 = 16777216] = "LV_OBJ_FLAG_LAYOUT_2", C[C.LV_OBJ_FLAG_WIDGET_1 = 33554432] = "LV_OBJ_FLAG_WIDGET_1", C[C.LV_OBJ_FLAG_WIDGET_2 = 67108864] = "LV_OBJ_FLAG_WIDGET_2", C[C.LV_OBJ_FLAG_USER_1 = 134217728] = "LV_OBJ_FLAG_USER_1", C[C.LV_OBJ_FLAG_USER_2 = 268435456] = "LV_OBJ_FLAG_USER_2", C[C.LV_OBJ_FLAG_USER_3 = 536870912] = "LV_OBJ_FLAG_USER_3", C[C.LV_OBJ_FLAG_USER_4 = 1073741824] = "LV_OBJ_FLAG_USER_4", C;
}({}), lv_scrollbar_mode_t$1 = /* @__PURE__ */ function(C) {
	return C[C.LV_SCROLLBAR_MODE_OFF = 0] = "LV_SCROLLBAR_MODE_OFF", C[C.LV_SCROLLBAR_MODE_ON = 1] = "LV_SCROLLBAR_MODE_ON", C[C.LV_SCROLLBAR_MODE_ACTIVE = 2] = "LV_SCROLLBAR_MODE_ACTIVE", C[C.LV_SCROLLBAR_MODE_AUTO = 3] = "LV_SCROLLBAR_MODE_AUTO", C;
}({}), lv_scroll_snap_t$1 = /* @__PURE__ */ function(C) {
	return C[C.LV_SCROLL_SNAP_NONE = 0] = "LV_SCROLL_SNAP_NONE", C[C.LV_SCROLL_SNAP_START = 1] = "LV_SCROLL_SNAP_START", C[C.LV_SCROLL_SNAP_END = 2] = "LV_SCROLL_SNAP_END", C[C.LV_SCROLL_SNAP_CENTER = 3] = "LV_SCROLL_SNAP_CENTER", C;
}({}), lv_border_side_t$1 = /* @__PURE__ */ function(C) {
	return C[C.LV_BORDER_SIDE_NONE = 0] = "LV_BORDER_SIDE_NONE", C[C.LV_BORDER_SIDE_BOTTOM = 1] = "LV_BORDER_SIDE_BOTTOM", C[C.LV_BORDER_SIDE_TOP = 2] = "LV_BORDER_SIDE_TOP", C[C.LV_BORDER_SIDE_LEFT = 4] = "LV_BORDER_SIDE_LEFT", C[C.LV_BORDER_SIDE_RIGHT = 8] = "LV_BORDER_SIDE_RIGHT", C[C.LV_BORDER_SIDE_FULL = 15] = "LV_BORDER_SIDE_FULL", C[C.LV_BORDER_SIDE_INTERNAL = 16] = "LV_BORDER_SIDE_INTERNAL", C;
}({}), lv_text_align_t$1 = /* @__PURE__ */ function(C) {
	return C[C.LV_TEXT_ALIGN_AUTO = 0] = "LV_TEXT_ALIGN_AUTO", C[C.LV_TEXT_ALIGN_LEFT = 1] = "LV_TEXT_ALIGN_LEFT", C[C.LV_TEXT_ALIGN_CENTER = 2] = "LV_TEXT_ALIGN_CENTER", C[C.LV_TEXT_ALIGN_RIGHT = 3] = "LV_TEXT_ALIGN_RIGHT", C;
}({}), lv_state_t$1 = /* @__PURE__ */ function(C) {
	return C[C.LV_STATE_CHECKED = 1] = "LV_STATE_CHECKED", C[C.LV_STATE_FOCUSED = 2] = "LV_STATE_FOCUSED", C[C.LV_STATE_FOCUS_KEY = 4] = "LV_STATE_FOCUS_KEY", C[C.LV_STATE_EDITED = 8] = "LV_STATE_EDITED", C[C.LV_STATE_HOVERED = 16] = "LV_STATE_HOVERED", C[C.LV_STATE_PRESSED = 32] = "LV_STATE_PRESSED", C[C.LV_STATE_SCROLLED = 64] = "LV_STATE_SCROLLED", C[C.LV_STATE_DISABLED = 128] = "LV_STATE_DISABLED", C[C.LV_STATE_USER_1 = 4096] = "LV_STATE_USER_1", C[C.LV_STATE_USER_2 = 8192] = "LV_STATE_USER_2", C[C.LV_STATE_USER_3 = 16384] = "LV_STATE_USER_3", C[C.LV_STATE_USER_4 = 32768] = "LV_STATE_USER_4", C[C.LV_STATE_ANY = 65535] = "LV_STATE_ANY", C;
}({}), lv_grad_dir_t$1 = /* @__PURE__ */ function(C) {
	return C[C.LV_GRAD_DIR_NONE = 0] = "LV_GRAD_DIR_NONE", C[C.LV_GRAD_DIR_VER = 1] = "LV_GRAD_DIR_VER", C[C.LV_GRAD_DIR_HOR = 2] = "LV_GRAD_DIR_HOR", C;
}({}), lv_chart_type_t$1 = /* @__PURE__ */ function(C) {
	return C[C.LV_CHART_TYPE_NONE = 0] = "LV_CHART_TYPE_NONE", C[C.LV_CHART_TYPE_LINE = 1] = "LV_CHART_TYPE_LINE", C[C.LV_CHART_TYPE_BAR = 2] = "LV_CHART_TYPE_BAR", C[C.LV_CHART_TYPE_SCATTER = 3] = "LV_CHART_TYPE_SCATTER", C;
}({}), lv_chart_update_mode_t = /* @__PURE__ */ function(C) {
	return C[C.LV_CHART_UPDATE_MODE_SHIFT = 0] = "LV_CHART_UPDATE_MODE_SHIFT", C[C.LV_CHART_UPDATE_MODE_CIRCULAR = 1] = "LV_CHART_UPDATE_MODE_CIRCULAR", C;
}({}), lv_chart_axis_t = /* @__PURE__ */ function(C) {
	return C[C.LV_CHART_AXIS_PRIMARY_Y = 0] = "LV_CHART_AXIS_PRIMARY_Y", C[C.LV_CHART_AXIS_SECONDARY_Y = 1] = "LV_CHART_AXIS_SECONDARY_Y", C[C.LV_CHART_AXIS_PRIMARY_X = 2] = "LV_CHART_AXIS_PRIMARY_X", C[C.LV_CHART_AXIS_SECONDARY_X = 4] = "LV_CHART_AXIS_SECONDARY_X", C[C._LV_CHART_AXIS_LAST = 5] = "_LV_CHART_AXIS_LAST", C;
}({}), lv_bar_mode_t$1 = /* @__PURE__ */ function(C) {
	return C[C.LV_BAR_MODE_NORMAL = 0] = "LV_BAR_MODE_NORMAL", C[C.LV_BAR_MODE_SYMMETRICAL = 1] = "LV_BAR_MODE_SYMMETRICAL", C[C.LV_BAR_MODE_RANGE = 2] = "LV_BAR_MODE_RANGE", C;
}({}), lv_slider_mode_t$1 = /* @__PURE__ */ function(C) {
	return C[C.LV_SLIDER_MODE_NORMAL = 0] = "LV_SLIDER_MODE_NORMAL", C[C.LV_SLIDER_MODE_SYMMETRICAL = 1] = "LV_SLIDER_MODE_SYMMETRICAL", C[C.LV_SLIDER_MODE_RANGE = 2] = "LV_SLIDER_MODE_RANGE", C;
}({}), lv_arc_mode_t$1 = /* @__PURE__ */ function(C) {
	return C[C.LV_ARC_MODE_NORMAL = 0] = "LV_ARC_MODE_NORMAL", C[C.LV_ARC_MODE_SYMMETRICAL = 1] = "LV_ARC_MODE_SYMMETRICAL", C[C.LV_ARC_MODE_REVERSE = 2] = "LV_ARC_MODE_REVERSE", C;
}({}), lv_label_long_mode_t$1 = /* @__PURE__ */ function(C) {
	return C[C.LV_LABEL_LONG_WRAP = 0] = "LV_LABEL_LONG_WRAP", C[C.LV_LABEL_LONG_SCROLL = 1] = "LV_LABEL_LONG_SCROLL", C[C.LV_LABEL_LONG_SCROLL_CIRCULAR = 2] = "LV_LABEL_LONG_SCROLL_CIRCULAR", C[C.LV_LABEL_LONG_CLIP = 3] = "LV_LABEL_LONG_CLIP", C;
}({}), lv_dir_t$1 = /* @__PURE__ */ function(C) {
	return C[C.LV_DIR_NONE = 0] = "LV_DIR_NONE", C[C.LV_DIR_LEFT = 1] = "LV_DIR_LEFT", C[C.LV_DIR_RIGHT = 2] = "LV_DIR_RIGHT", C[C.LV_DIR_TOP = 4] = "LV_DIR_TOP", C[C.LV_DIR_BOTTOM = 8] = "LV_DIR_BOTTOM", C[C.LV_DIR_HOR = 3] = "LV_DIR_HOR", C[C.LV_DIR_VER = 12] = "LV_DIR_VER", C[C.LV_DIR_ALL = 15] = "LV_DIR_ALL", C;
}({}), lv_text_decor_t$1 = /* @__PURE__ */ function(C) {
	return C[C.LV_TEXT_DECOR_NONE = 0] = "LV_TEXT_DECOR_NONE", C[C.LV_TEXT_DECOR_UNDERLINE = 1] = "LV_TEXT_DECOR_UNDERLINE", C[C.LV_TEXT_DECOR_STRIKETHROUGH = 2] = "LV_TEXT_DECOR_STRIKETHROUGH", C;
}({}), lv_event_code_t$1 = /* @__PURE__ */ function(C) {
	return C[C.LV_EVENT_ALL = 0] = "LV_EVENT_ALL", C[C.LV_EVENT_PRESSED = 1] = "LV_EVENT_PRESSED", C[C.LV_EVENT_PRESSING = 2] = "LV_EVENT_PRESSING", C[C.LV_EVENT_PRESS_LOST = 3] = "LV_EVENT_PRESS_LOST", C[C.LV_EVENT_SHORT_CLICKED = 4] = "LV_EVENT_SHORT_CLICKED", C[C.LV_EVENT_LONG_PRESSED = 5] = "LV_EVENT_LONG_PRESSED", C[C.LV_EVENT_LONG_PRESSED_REPEAT = 6] = "LV_EVENT_LONG_PRESSED_REPEAT", C[C.LV_EVENT_CLICKED = 7] = "LV_EVENT_CLICKED", C[C.LV_EVENT_RELEASED = 8] = "LV_EVENT_RELEASED", C[C.LV_EVENT_SCROLL_BEGIN = 9] = "LV_EVENT_SCROLL_BEGIN", C[C.LV_EVENT_SCROLL_THROW_BEGIN = 10] = "LV_EVENT_SCROLL_THROW_BEGIN", C[C.LV_EVENT_SCROLL_END = 11] = "LV_EVENT_SCROLL_END", C[C.LV_EVENT_SCROLL = 12] = "LV_EVENT_SCROLL", C[C.LV_EVENT_GESTURE = 13] = "LV_EVENT_GESTURE", C[C.LV_EVENT_KEY = 14] = "LV_EVENT_KEY", C[C.LV_EVENT_FOCUSED = 15] = "LV_EVENT_FOCUSED", C[C.LV_EVENT_DEFOCUSED = 16] = "LV_EVENT_DEFOCUSED", C[C.LV_EVENT_LEAVE = 17] = "LV_EVENT_LEAVE", C[C.LV_EVENT_HIT_TEST = 18] = "LV_EVENT_HIT_TEST", C[C.LV_EVENT_INDEV_RESET = 19] = "LV_EVENT_INDEV_RESET", C[C.LV_EVENT_COVER_CHECK = 20] = "LV_EVENT_COVER_CHECK", C[C.LV_EVENT_REFR_EXT_DRAW_SIZE = 21] = "LV_EVENT_REFR_EXT_DRAW_SIZE", C[C.LV_EVENT_DRAW_MAIN_BEGIN = 22] = "LV_EVENT_DRAW_MAIN_BEGIN", C[C.LV_EVENT_DRAW_MAIN = 23] = "LV_EVENT_DRAW_MAIN", C[C.LV_EVENT_DRAW_MAIN_END = 24] = "LV_EVENT_DRAW_MAIN_END", C[C.LV_EVENT_DRAW_POST_BEGIN = 25] = "LV_EVENT_DRAW_POST_BEGIN", C[C.LV_EVENT_DRAW_POST = 26] = "LV_EVENT_DRAW_POST", C[C.LV_EVENT_DRAW_POST_END = 27] = "LV_EVENT_DRAW_POST_END", C[C.LV_EVENT_DRAW_TASK_ADDED = 28] = "LV_EVENT_DRAW_TASK_ADDED", C[C.LV_EVENT_VALUE_CHANGED = 29] = "LV_EVENT_VALUE_CHANGED", C[C.LV_EVENT_INSERT = 30] = "LV_EVENT_INSERT", C[C.LV_EVENT_REFRESH = 31] = "LV_EVENT_REFRESH", C[C.LV_EVENT_READY = 32] = "LV_EVENT_READY", C[C.LV_EVENT_CANCEL = 33] = "LV_EVENT_CANCEL", C[C.LV_EVENT_CREATE = 34] = "LV_EVENT_CREATE", C[C.LV_EVENT_DELETE = 35] = "LV_EVENT_DELETE", C[C.LV_EVENT_CHILD_CHANGED = 36] = "LV_EVENT_CHILD_CHANGED", C[C.LV_EVENT_CHILD_CREATED = 37] = "LV_EVENT_CHILD_CREATED", C[C.LV_EVENT_CHILD_DELETED = 38] = "LV_EVENT_CHILD_DELETED", C[C.LV_EVENT_SCREEN_UNLOAD_START = 39] = "LV_EVENT_SCREEN_UNLOAD_START", C[C.LV_EVENT_SCREEN_LOAD_START = 40] = "LV_EVENT_SCREEN_LOAD_START", C[C.LV_EVENT_SCREEN_LOADED = 41] = "LV_EVENT_SCREEN_LOADED", C[C.LV_EVENT_SCREEN_UNLOADED = 42] = "LV_EVENT_SCREEN_UNLOADED", C[C.LV_EVENT_SIZE_CHANGED = 43] = "LV_EVENT_SIZE_CHANGED", C[C.LV_EVENT_STYLE_CHANGED = 44] = "LV_EVENT_STYLE_CHANGED", C[C.LV_EVENT_LAYOUT_CHANGED = 45] = "LV_EVENT_LAYOUT_CHANGED", C[C.LV_EVENT_GET_SELF_SIZE = 46] = "LV_EVENT_GET_SELF_SIZE", C[C.LV_EVENT_INVALIDATE_AREA = 47] = "LV_EVENT_INVALIDATE_AREA", C[C.LV_EVENT_RESOLUTION_CHANGED = 48] = "LV_EVENT_RESOLUTION_CHANGED", C[C.LV_EVENT_COLOR_FORMAT_CHANGED = 49] = "LV_EVENT_COLOR_FORMAT_CHANGED", C[C.LV_EVENT_REFR_REQUEST = 50] = "LV_EVENT_REFR_REQUEST", C[C.LV_EVENT_REFR_START = 51] = "LV_EVENT_REFR_START", C[C.LV_EVENT_REFR_READY = 52] = "LV_EVENT_REFR_READY", C[C.LV_EVENT_RENDER_START = 53] = "LV_EVENT_RENDER_START", C[C.LV_EVENT_RENDER_READY = 54] = "LV_EVENT_RENDER_READY", C[C.LV_EVENT_FLUSH_START = 55] = "LV_EVENT_FLUSH_START", C[C.LV_EVENT_FLUSH_FINISH = 56] = "LV_EVENT_FLUSH_FINISH", C[C.LV_EVENT_VSYNC = 57] = "LV_EVENT_VSYNC", C[C._LV_EVENT_LAST = 58] = "_LV_EVENT_LAST", C[C.LV_EVENT_PREPROCESS = 32768] = "LV_EVENT_PREPROCESS", C;
}({}), lv_menu_mode_header_t = /* @__PURE__ */ function(C) {
	return C[C.LV_MENU_HEADER_TOP_FIXED = 0] = "LV_MENU_HEADER_TOP_FIXED", C[C.LV_MENU_HEADER_TOP_UNFIXED = 1] = "LV_MENU_HEADER_TOP_UNFIXED", C[C.LV_MENU_HEADER_BOTTOM_FIXED = 2] = "LV_MENU_HEADER_BOTTOM_FIXED", C;
}({}), lv_menu_mode_root_back_button_t = /* @__PURE__ */ function(C) {
	return C[C.LV_MENU_ROOT_BACK_BUTTON_DISABLED = 0] = "LV_MENU_ROOT_BACK_BUTTON_DISABLED", C[C.LV_MENU_ROOT_BACK_BUTTON_ENABLED = 1] = "LV_MENU_ROOT_BACK_BUTTON_ENABLED", C;
}({}), lv_scale_mode_t = /* @__PURE__ */ function(C) {
	return C[C.LV_SCALE_MODE_HORIZONTAL_TOP = 0] = "LV_SCALE_MODE_HORIZONTAL_TOP", C[C.LV_SCALE_MODE_HORIZONTAL_BOTTOM = 1] = "LV_SCALE_MODE_HORIZONTAL_BOTTOM", C[C.LV_SCALE_MODE_VERTICAL_LEFT = 2] = "LV_SCALE_MODE_VERTICAL_LEFT", C[C.LV_SCALE_MODE_VERTICAL_RIGHT = 4] = "LV_SCALE_MODE_VERTICAL_RIGHT", C[C.LV_SCALE_MODE_ROUND_INNER = 8] = "LV_SCALE_MODE_ROUND_INNER", C[C.LV_SCALE_MODE_ROUND_OUTER = 16] = "LV_SCALE_MODE_ROUND_OUTER", C[C._LV_SCALE_MODE_LAST = 17] = "_LV_SCALE_MODE_LAST", C;
}({}), lv_blend_mode_t = /* @__PURE__ */ function(C) {
	return C[C.LV_BLEND_MODE_NORMAL = 0] = "LV_BLEND_MODE_NORMAL", C[C.LV_BLEND_MODE_ADDITIVE = 1] = "LV_BLEND_MODE_ADDITIVE", C[C.LV_BLEND_MODE_SUBTRACTIVE = 2] = "LV_BLEND_MODE_SUBTRACTIVE", C[C.LV_BLEND_MODE_MULTIPLY = 3] = "LV_BLEND_MODE_MULTIPLY", C;
}({}), lv_image_align_t = /* @__PURE__ */ function(C) {
	return C[C.LV_IMAGE_ALIGN_DEFAULT = 0] = "LV_IMAGE_ALIGN_DEFAULT", C[C.LV_IMAGE_ALIGN_TOP_LEFT = 1] = "LV_IMAGE_ALIGN_TOP_LEFT", C[C.LV_IMAGE_ALIGN_TOP_MID = 2] = "LV_IMAGE_ALIGN_TOP_MID", C[C.LV_IMAGE_ALIGN_TOP_RIGHT = 3] = "LV_IMAGE_ALIGN_TOP_RIGHT", C[C.LV_IMAGE_ALIGN_BOTTOM_LEFT = 4] = "LV_IMAGE_ALIGN_BOTTOM_LEFT", C[C.LV_IMAGE_ALIGN_BOTTOM_MID = 5] = "LV_IMAGE_ALIGN_BOTTOM_MID", C[C.LV_IMAGE_ALIGN_BOTTOM_RIGHT = 6] = "LV_IMAGE_ALIGN_BOTTOM_RIGHT", C[C.LV_IMAGE_ALIGN_LEFT_MID = 7] = "LV_IMAGE_ALIGN_LEFT_MID", C[C.LV_IMAGE_ALIGN_RIGHT_MID = 8] = "LV_IMAGE_ALIGN_RIGHT_MID", C[C.LV_IMAGE_ALIGN_CENTER = 9] = "LV_IMAGE_ALIGN_CENTER", C[C._LV_IMAGE_ALIGN_AUTO_TRANSFORM = 10] = "_LV_IMAGE_ALIGN_AUTO_TRANSFORM", C[C.LV_IMAGE_ALIGN_STRETCH = 11] = "LV_IMAGE_ALIGN_STRETCH", C[C.LV_IMAGE_ALIGN_TILE = 12] = "LV_IMAGE_ALIGN_TILE", C;
}({}), lv_pipe_shape_t = /* @__PURE__ */ function(C) {
	return C[C.LV_PIPE_SHAPE_LINE = 0] = "LV_PIPE_SHAPE_LINE", C[C.LV_PIPE_SHAPE_ROUND = 1] = "LV_PIPE_SHAPE_ROUND", C[C.LV_PIPE_SHAPE_T_SHAPE = 2] = "LV_PIPE_SHAPE_T_SHAPE", C[C.LV_PIPE_SHAPE_CROSS = 3] = "LV_PIPE_SHAPE_CROSS", C;
}({});
function format$1(C, T = 2, E = !1) {
	let D = C.split("_").slice(T);
	if (D) {
		let C = "";
		return D.forEach((T) => {
			C += T + " ";
		}), C = C.trimEnd(), E && (C = C.toLowerCase().replace("flag ", "")), C;
	}
	return " ";
}
function enumToOpts$1(C, T = 2, E = !1) {
	let D = [];
	for (let O in C) if (Object.prototype.hasOwnProperty.call(C, O)) {
		if (isNaN(Number(C[O]))) continue;
		let F = format$1(O, T, E), I = C[O];
		D.push({
			label: F,
			value: I
		});
	}
	return D;
}
enumToOpts$1(lv_align_t$1), enumToOpts$1(lv_dir_t$1);
const LvFlags = enumToOpts$1(lv_obj_flag_t$1, 3, !0);
enumToOpts$1(lv_scrollbar_mode_t$1, 3), enumToOpts$1(lv_scroll_snap_t$1), enumToOpts$1(lv_border_side_t$1), enumToOpts$1(lv_text_align_t$1, 3);
const LvStateOpts = enumToOpts$1(lv_state_t$1, 2, !0);
enumToOpts$1(lv_grad_dir_t$1, 3, !0);
const StateOpts = [
	{
		label: "DEFAULT",
		value: 0
	},
	{
		label: "CHECKED",
		value: lv_state_t$1.LV_STATE_CHECKED
	},
	{
		label: "FOCUSED",
		value: lv_state_t$1.LV_STATE_FOCUSED
	},
	{
		label: "FOCUS_KEY",
		value: lv_state_t$1.LV_STATE_FOCUS_KEY
	},
	{
		label: "PRESSED",
		value: lv_state_t$1.LV_STATE_PRESSED
	},
	{
		label: "DISABLE",
		value: lv_state_t$1.LV_STATE_DISABLED
	},
	{
		label: "SCROLLED",
		value: lv_state_t$1.LV_STATE_SCROLLED
	},
	{
		label: "CHECKED | FOCUSED",
		value: lv_state_t$1.LV_STATE_CHECKED | lv_state_t$1.LV_STATE_FOCUSED
	},
	{
		label: "CHECKED | PRESSED",
		value: lv_state_t$1.LV_STATE_CHECKED | lv_state_t$1.LV_STATE_PRESSED
	},
	{
		label: "CHECKED | FOCUS_KEY",
		value: lv_state_t$1.LV_STATE_CHECKED | lv_state_t$1.LV_STATE_FOCUS_KEY
	},
	{
		label: "USER_1",
		value: lv_state_t$1.LV_STATE_USER_1
	},
	{
		label: "USER_2",
		value: lv_state_t$1.LV_STATE_USER_2
	},
	{
		label: "USER_3",
		value: lv_state_t$1.LV_STATE_USER_3
	},
	{
		label: "USER_4",
		value: lv_state_t$1.LV_STATE_USER_4
	}
];
StateOpts.map((C) => ({
	label: C.label,
	value: C.label
})), new Map(StateOpts.map((C) => [C.label, C.value])), enumToOpts$1(lv_slider_mode_t$1, 3, !0), enumToOpts$1(lv_arc_mode_t$1, 3, !0);
var lv_common_flags$1 = /* @__PURE__ */ function(C) {
	return C[C.LV_OBJ_FLAG_HIDDEN = 1] = "LV_OBJ_FLAG_HIDDEN", C[C.LV_OBJ_FLAG_CLICKABLE = 2] = "LV_OBJ_FLAG_CLICKABLE", C[C.LV_OBJ_FLAG_CLICK_FOCUSABLE = 4] = "LV_OBJ_FLAG_CLICK_FOCUSABLE", C[C.LV_OBJ_FLAG_CHECKABLE = 8] = "LV_OBJ_FLAG_CHECKABLE", C[C.LV_OBJ_FLAG_PRESS_LOCK = 2048] = "LV_OBJ_FLAG_PRESS_LOCK", C[C.LV_OBJ_FLAG_EVENT_BUBBLE = 4096] = "LV_OBJ_FLAG_EVENT_BUBBLE", C[C.LV_OBJ_FLAG_GESTURE_BUBBLE = 8192] = "LV_OBJ_FLAG_GESTURE_BUBBLE", C[C.LV_OBJ_FLAG_ADV_HITTEST = 16384] = "LV_OBJ_FLAG_ADV_HITTEST", C[C.LV_OBJ_FLAG_IGNORE_LAYOUT = 32768] = "LV_OBJ_FLAG_IGNORE_LAYOUT", C[C.LV_OBJ_FLAG_FLOATING = 65536] = "LV_OBJ_FLAG_FLOATING", C[C.LV_OBJ_FLAG_SNAPABLE = 1024] = "LV_OBJ_FLAG_SNAPABLE", C[C.LV_OBJ_FLAG_SCROLLABLE = 16] = "LV_OBJ_FLAG_SCROLLABLE", C[C.LV_OBJ_FLAG_SCROLL_ELASTIC = 32] = "LV_OBJ_FLAG_SCROLL_ELASTIC", C[C.LV_OBJ_FLAG_SCROLL_MOMENTUM = 64] = "LV_OBJ_FLAG_SCROLL_MOMENTUM", C[C.LV_OBJ_FLAG_SCROLL_ONE = 128] = "LV_OBJ_FLAG_SCROLL_ONE", C[C.LV_OBJ_FLAG_SCROLL_CHAIN = 256] = "LV_OBJ_FLAG_SCROLL_CHAIN", C[C.LV_OBJ_FLAG_SCROLL_ON_FOCUS = 512] = "LV_OBJ_FLAG_SCROLL_ON_FOCUS", C;
}(lv_common_flags$1 || {});
enumToOpts$1(lv_common_flags$1, 3, !0), enumToOpts$1(lv_label_long_mode_t$1), enumToOpts$1(lv_bar_mode_t$1, 3, !0);
const LvChartTypeOpts = enumToOpts$1(lv_chart_type_t$1, 3, !0);
enumToOpts$1(lv_text_decor_t$1, 3, !0), enumToOpts$1(lv_event_code_t$1, 2, !0);
const LvInputEventCodeOpts = enumToOpts$1(lv_event_code_t$1, 0, !0);
var root_6$6 = /* @__PURE__ */ from_html("<hr class=\"ml-10 my-4\"/>"), root_3$19 = /* @__PURE__ */ from_html("<!> <!>", 1);
function Flags(C, T) {
	push(T, !0);
	let E = LvFlags.filter((C) => C.value <= 1 << 20), D = LvFlags.filter((C) => C.value > 1 << 20);
	function O(C, T) {
		var E;
		(E = T.target) != null && E.checked ? F().value |= C : F().value &= ~C;
	}
	let F = prop(T, "props", 7);
	return WgtAccordionItem(C, {
		label: "Flags",
		children: (C, T) => {
			var I = comment(), L = first_child(I), z = (C) => {
				var T = comment();
				each(first_child(T), 17, () => [E, D], index, (C, T, E) => {
					var D = root_3$19(), I = first_child(D);
					each(I, 17, () => get(T), index, (C, T) => {
						{
							let E = /* @__PURE__ */ user_derived(() => (F().value & get(T).value) !== 0);
							Checkbox(C, {
								class: "flex-none mx-1",
								get checked() {
									return get(E);
								},
								onchange: (C) => O(get(T).value, C),
								children: (C, E) => {
									next();
									var D = text();
									template_effect(() => set_text(D, get(T).label)), append(C, D);
								},
								$$slots: { default: !0 }
							});
						}
					});
					var L = sibling(I, 2), z = (C) => {
						append(C, root_6$6());
					};
					if_block(L, (C) => {
						E < 1 && C(z);
					}), append(C, D);
				}), append(C, T);
			};
			if_block(L, (C) => {
				F().type.toLowerCase() != "screen" && C(z);
			}), append(C, I);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return F();
		},
		set props(C) {
			F(C), flushSync();
		}
	});
}
create_custom_element(Flags, { props: {} }, [], [], !0), enable_legacy_mode_flag();
function States(C, T) {
	push(T, !1);
	let E = LvStateOpts.map((C) => ({
		value: C.value,
		label: C.label
	}));
	function D(C, T) {
		var E;
		(E = T.target) != null && E.checked ? O(O().value |= C, !0) : O(O().value &= ~C, !0);
	}
	let O = prop(T, "props", 12);
	return init(), WgtAccordionItem(C, {
		label: "States",
		children: (C, T) => {
			var F = comment();
			each(first_child(F), 1, () => E, index, (C, T) => {
				{
					let E = /* @__PURE__ */ derived_safe_equal(() => (deep_read_state(O()), get(T), untrack(() => (O().value & get(T).value) !== 0)));
					Checkbox(C, {
						class: "flex-none mx-1",
						get checked() {
							return get(E);
						},
						onchange: (C) => D(get(T).value, C),
						children: (C, E) => {
							next();
							var D = text();
							template_effect(() => set_text(D, (get(T), untrack(() => get(T).label)))), append(C, D);
						},
						$$slots: { default: !0 }
					});
				}
			}), append(C, F);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return O();
		},
		set props(C) {
			O(C), flushSync();
		}
	});
}
create_custom_element(States, { props: {} }, [], [], !0);
const dirPositionList = [
	{
		value: lv_dir_t$1.LV_DIR_TOP,
		name: "Top"
	},
	{
		value: lv_dir_t$1.LV_DIR_BOTTOM,
		name: "Bottom"
	},
	{
		value: lv_dir_t$1.LV_DIR_LEFT,
		name: "Left"
	},
	{
		value: lv_dir_t$1.LV_DIR_RIGHT,
		name: "Right"
	},
	{
		value: lv_dir_t$1.LV_DIR_NONE,
		name: "None"
	},
	{
		value: lv_dir_t$1.LV_DIR_ALL,
		name: "All"
	}
], textModeList = [
	{
		value: lv_label_long_mode_t$1.LV_LABEL_LONG_WRAP,
		name: "wrap"
	},
	{
		value: lv_label_long_mode_t$1.LV_LABEL_LONG_SCROLL,
		name: "scroll"
	},
	{
		value: lv_label_long_mode_t$1.LV_LABEL_LONG_SCROLL_CIRCULAR,
		name: "scroll circular"
	},
	{
		value: lv_label_long_mode_t$1.LV_LABEL_LONG_CLIP,
		name: "clip"
	}
], lvDefaultFontList = [
	{
		name: "lv_font_montserrat_8",
		value: "8"
	},
	{
		name: "lv_font_montserrat_10",
		value: "10"
	},
	{
		name: "lv_font_montserrat_12",
		value: "12"
	},
	{
		name: "lv_font_montserrat_14",
		value: "14"
	},
	{
		name: "lv_font_montserrat_16",
		value: "16"
	},
	{
		name: "lv_font_montserrat_18",
		value: "18"
	},
	{
		name: "lv_font_montserrat_20",
		value: "20"
	},
	{
		name: "lv_font_montserrat_22",
		value: "22"
	},
	{
		name: "lv_font_montserrat_24",
		value: "24"
	},
	{
		name: "lv_font_montserrat_26",
		value: "26"
	},
	{
		name: "lv_font_montserrat_28",
		value: "28"
	},
	{
		name: "lv_font_montserrat_30",
		value: "30"
	},
	{
		name: "lv_font_montserrat_32",
		value: "32"
	},
	{
		name: "lv_font_montserrat_34",
		value: "34"
	},
	{
		name: "lv_font_montserrat_36",
		value: "36"
	},
	{
		name: "lv_font_montserrat_38",
		value: "38"
	},
	{
		name: "lv_font_montserrat_40",
		value: "40"
	},
	{
		name: "lv_font_montserrat_42",
		value: "42"
	},
	{
		name: "lv_font_montserrat_44",
		value: "44"
	},
	{
		name: "lv_font_montserrat_46",
		value: "46"
	},
	{
		name: "lv_font_montserrat_48",
		value: "48"
	},
	{
		name: "lv_font_montserrat_28_compressed",
		value: "28c"
	},
	{
		name: "lv_font_dejavu_16_persian_hebrew",
		value: "dejavu16"
	},
	{
		name: "lv_font_simsun_16_cjk",
		value: "simsun16"
	},
	{
		name: "lv_font_unscii_8",
		value: "unscii8"
	},
	{
		name: "lv_font_unscii_16",
		value: "unscii16"
	}
], lvSymbolList = [
	{
		name: "LV_SYMBOL_AUDIO",
		value: "LV_SYMBOL_AUDIO"
	},
	{
		name: "LV_SYMBOL_VIDEO",
		value: "LV_SYMBOL_VIDEO"
	},
	{
		name: "LV_SYMBOL_LIST",
		value: "LV_SYMBOL_LIST"
	},
	{
		name: "LV_SYMBOL_OK",
		value: "LV_SYMBOL_OK"
	},
	{
		name: "LV_SYMBOL_CLOSE",
		value: "LV_SYMBOL_CLOSE"
	},
	{
		name: "LV_SYMBOL_POWER",
		value: "LV_SYMBOL_POWER"
	},
	{
		name: "LV_SYMBOL_SETTINGS",
		value: "LV_SYMBOL_SETTINGS"
	},
	{
		name: "LV_SYMBOL_HOME",
		value: "LV_SYMBOL_HOME"
	},
	{
		name: "LV_SYMBOL_DOWNLOAD",
		value: "LV_SYMBOL_DOWNLOAD"
	},
	{
		name: "LV_SYMBOL_DRIVE",
		value: "LV_SYMBOL_DRIVE"
	},
	{
		name: "LV_SYMBOL_REFRESH",
		value: "LV_SYMBOL_REFRESH"
	},
	{
		name: "LV_SYMBOL_MUTE",
		value: "LV_SYMBOL_MUTE"
	},
	{
		name: "LV_SYMBOL_VOLUME_MID",
		value: "LV_SYMBOL_VOLUME_MID"
	},
	{
		name: "LV_SYMBOL_VOLUME_MAX",
		value: "LV_SYMBOL_VOLUME_MAX"
	},
	{
		name: "LV_SYMBOL_IMAGE",
		value: "LV_SYMBOL_IMAGE"
	},
	{
		name: "LV_SYMBOL_TINT",
		value: "LV_SYMBOL_TINT"
	},
	{
		name: "LV_SYMBOL_PREV",
		value: "LV_SYMBOL_PREV"
	},
	{
		name: "LV_SYMBOL_PLAY",
		value: "LV_SYMBOL_PLAY"
	},
	{
		name: "LV_SYMBOL_PAUSE",
		value: "LV_SYMBOL_PAUSE"
	},
	{
		name: "LV_SYMBOL_STOP",
		value: "LV_SYMBOL_STOP"
	},
	{
		name: "LV_SYMBOL_NEXT",
		value: "LV_SYMBOL_NEXT"
	},
	{
		name: "LV_SYMBOL_EJECT",
		value: "LV_SYMBOL_EJECT"
	},
	{
		name: "LV_SYMBOL_LEFT",
		value: "LV_SYMBOL_LEFT"
	},
	{
		name: "LV_SYMBOL_RIGHT",
		value: "LV_SYMBOL_RIGHT"
	},
	{
		name: "LV_SYMBOL_PLUS",
		value: "LV_SYMBOL_PLUS"
	},
	{
		name: "LV_SYMBOL_MINUS",
		value: "LV_SYMBOL_MINUS"
	},
	{
		name: "LV_SYMBOL_EYE_OPEN",
		value: "LV_SYMBOL_EYE_OPEN"
	},
	{
		name: "LV_SYMBOL_EYE_CLOSE",
		value: "LV_SYMBOL_EYE_CLOSE"
	},
	{
		name: "LV_SYMBOL_WARNING",
		value: "LV_SYMBOL_WARNING"
	},
	{
		name: "LV_SYMBOL_SHUFFLE",
		value: "LV_SYMBOL_SHUFFLE"
	},
	{
		name: "LV_SYMBOL_UP",
		value: "LV_SYMBOL_UP"
	},
	{
		name: "LV_SYMBOL_DOWN",
		value: "LV_SYMBOL_DOWN"
	},
	{
		name: "LV_SYMBOL_LOOP",
		value: "LV_SYMBOL_LOOP"
	},
	{
		name: "LV_SYMBOL_DIRECTORY",
		value: "LV_SYMBOL_DIRECTORY"
	},
	{
		name: "LV_SYMBOL_UPLOAD",
		value: "LV_SYMBOL_UPLOAD"
	},
	{
		name: "LV_SYMBOL_CALL",
		value: "LV_SYMBOL_CALL"
	},
	{
		name: "LV_SYMBOL_CUT",
		value: "LV_SYMBOL_CUT"
	},
	{
		name: "LV_SYMBOL_COPY",
		value: "LV_SYMBOL_COPY"
	},
	{
		name: "LV_SYMBOL_SAVE",
		value: "LV_SYMBOL_SAVE"
	},
	{
		name: "LV_SYMBOL_BARS",
		value: "LV_SYMBOL_BARS"
	},
	{
		name: "LV_SYMBOL_ENVELOPE",
		value: "LV_SYMBOL_ENVELOPE"
	},
	{
		name: "LV_SYMBOL_CHARGE",
		value: "LV_SYMBOL_CHARGE"
	},
	{
		name: "LV_SYMBOL_PASTE",
		value: "LV_SYMBOL_PASTE"
	},
	{
		name: "LV_SYMBOL_BELL",
		value: "LV_SYMBOL_BELL"
	},
	{
		name: "LV_SYMBOL_KEYBOARD",
		value: "LV_SYMBOL_KEYBOARD"
	},
	{
		name: "LV_SYMBOL_GPS",
		value: "LV_SYMBOL_GPS"
	},
	{
		name: "LV_SYMBOL_FILE",
		value: "LV_SYMBOL_FILE"
	},
	{
		name: "LV_SYMBOL_WIFI",
		value: "LV_SYMBOL_WIFI"
	},
	{
		name: "LV_SYMBOL_BATTERY_FULL",
		value: "LV_SYMBOL_BATTERY_FULL"
	},
	{
		name: "LV_SYMBOL_BATTERY_3",
		value: "LV_SYMBOL_BATTERY_3"
	},
	{
		name: "LV_SYMBOL_BATTERY_2",
		value: "LV_SYMBOL_BATTERY_2"
	},
	{
		name: "LV_SYMBOL_BATTERY_1",
		value: "LV_SYMBOL_BATTERY_1"
	},
	{
		name: "LV_SYMBOL_BATTERY_EMPTY",
		value: "LV_SYMBOL_BATTERY_EMPTY"
	},
	{
		name: "LV_SYMBOL_USB",
		value: "LV_SYMBOL_USB"
	},
	{
		name: "LV_SYMBOL_BLUETOOTH",
		value: "LV_SYMBOL_BLUETOOTH"
	},
	{
		name: "LV_SYMBOL_TRASH",
		value: "LV_SYMBOL_TRASH"
	},
	{
		name: "LV_SYMBOL_EDIT",
		value: "LV_SYMBOL_EDIT"
	},
	{
		name: "LV_SYMBOL_BACKSPACE",
		value: "LV_SYMBOL_BACKSPACE"
	},
	{
		name: "LV_SYMBOL_SD_CARD",
		value: "LV_SYMBOL_SD_CARD"
	},
	{
		name: "LV_SYMBOL_NEW_LINE",
		value: "LV_SYMBOL_NEW_LINE"
	},
	{
		name: "LV_SYMBOL_DUMMY",
		value: "LV_SYMBOL_DUMMY"
	}
], lvGradDirList = [
	{
		name: "LV_GRAD_DIR_NONE",
		value: lv_grad_dir_t$1.LV_GRAD_DIR_NONE
	},
	{
		name: "LV_GRAD_DIR_VER",
		value: lv_grad_dir_t$1.LV_GRAD_DIR_VER
	},
	{
		name: "LV_GRAD_DIR_HOR",
		value: lv_grad_dir_t$1.LV_GRAD_DIR_HOR
	}
], lvBlendModeList = [
	{
		name: "LV_BLEND_MODE_NORMAL",
		value: lv_blend_mode_t.LV_BLEND_MODE_NORMAL
	},
	{
		name: "LV_BLEND_MODE_ADDITIVE",
		value: lv_blend_mode_t.LV_BLEND_MODE_ADDITIVE
	},
	{
		name: "LV_BLEND_MODE_SUBTRACTIVE",
		value: lv_blend_mode_t.LV_BLEND_MODE_SUBTRACTIVE
	},
	{
		name: "LV_BLEND_MODE_MULTIPLY",
		value: lv_blend_mode_t.LV_BLEND_MODE_MULTIPLY
	}
], lvImageAlignList = [
	{
		name: "LV_IMAGE_ALIGN_DEFAULT",
		value: lv_image_align_t.LV_IMAGE_ALIGN_DEFAULT
	},
	{
		name: "LV_IMAGE_ALIGN_TOP_LEFT",
		value: lv_image_align_t.LV_IMAGE_ALIGN_TOP_LEFT
	},
	{
		name: "LV_IMAGE_ALIGN_TOP_MID",
		value: lv_image_align_t.LV_IMAGE_ALIGN_TOP_MID
	},
	{
		name: "LV_IMAGE_ALIGN_TOP_RIGHT",
		value: lv_image_align_t.LV_IMAGE_ALIGN_TOP_RIGHT
	},
	{
		name: "LV_IMAGE_ALIGN_BOTTOM_LEFT",
		value: lv_image_align_t.LV_IMAGE_ALIGN_BOTTOM_LEFT
	},
	{
		name: "LV_IMAGE_ALIGN_BOTTOM_MID",
		value: lv_image_align_t.LV_IMAGE_ALIGN_BOTTOM_MID
	},
	{
		name: "LV_IMAGE_ALIGN_BOTTOM_RIGHT",
		value: lv_image_align_t.LV_IMAGE_ALIGN_BOTTOM_RIGHT
	},
	{
		name: "LV_IMAGE_ALIGN_LEFT_MID",
		value: lv_image_align_t.LV_IMAGE_ALIGN_LEFT_MID
	},
	{
		name: "LV_IMAGE_ALIGN_RIGHT_MID",
		value: lv_image_align_t.LV_IMAGE_ALIGN_RIGHT_MID
	},
	{
		name: "LV_IMAGE_ALIGN_CENTER",
		value: lv_image_align_t.LV_IMAGE_ALIGN_CENTER
	},
	{
		name: "LV_IMAGE_ALIGN_TILE",
		value: lv_image_align_t.LV_IMAGE_ALIGN_TILE
	},
	{
		name: "LV_IMAGE_ALIGN_STRETCH",
		value: lv_image_align_t.LV_IMAGE_ALIGN_STRETCH
	}
], lvAlignList = [
	{
		name: "LV_ALIGN_DEFAULT",
		value: lv_align_t$1.LV_ALIGN_DEFAULT
	},
	{
		name: "LV_ALIGN_TOP_LEFT",
		value: lv_align_t$1.LV_ALIGN_TOP_LEFT
	},
	{
		name: "LV_ALIGN_TOP_MID",
		value: lv_align_t$1.LV_ALIGN_TOP_MID
	},
	{
		name: "LV_ALIGN_TOP_RIGHT",
		value: lv_align_t$1.LV_ALIGN_TOP_RIGHT
	},
	{
		name: "LV_ALIGN_BOTTOM_LEFT",
		value: lv_align_t$1.LV_ALIGN_BOTTOM_LEFT
	},
	{
		name: "LV_ALIGN_BOTTOM_MID",
		value: lv_align_t$1.LV_ALIGN_BOTTOM_MID
	},
	{
		name: "LV_ALIGN_BOTTOM_RIGHT",
		value: lv_align_t$1.LV_ALIGN_BOTTOM_RIGHT
	},
	{
		name: "LV_ALIGN_LEFT_MID",
		value: lv_align_t$1.LV_ALIGN_LEFT_MID
	},
	{
		name: "LV_ALIGN_RIGHT_MID",
		value: lv_align_t$1.LV_ALIGN_RIGHT_MID
	},
	{
		name: "LV_ALIGN_CENTER",
		value: lv_align_t$1.LV_ALIGN_CENTER
	},
	{
		name: "LV_ALIGN_OUT_TOP_LEFT",
		value: lv_align_t$1.LV_ALIGN_OUT_TOP_LEFT
	},
	{
		name: "LV_ALIGN_OUT_TOP_MID",
		value: lv_align_t$1.LV_ALIGN_OUT_TOP_MID
	},
	{
		name: "LV_ALIGN_OUT_TOP_RIGHT",
		value: lv_align_t$1.LV_ALIGN_OUT_TOP_RIGHT
	},
	{
		name: "LV_ALIGN_OUT_BOTTOM_LEFT",
		value: lv_align_t$1.LV_ALIGN_OUT_BOTTOM_LEFT
	},
	{
		name: "LV_ALIGN_OUT_BOTTOM_MID",
		value: lv_align_t$1.LV_ALIGN_OUT_BOTTOM_MID
	},
	{
		name: "LV_ALIGN_OUT_BOTTOM_RIGHT",
		value: lv_align_t$1.LV_ALIGN_OUT_BOTTOM_RIGHT
	},
	{
		name: "LV_ALIGN_OUT_LEFT_TOP",
		value: lv_align_t$1.LV_ALIGN_OUT_LEFT_TOP
	},
	{
		name: "LV_ALIGN_OUT_LEFT_MID",
		value: lv_align_t$1.LV_ALIGN_OUT_LEFT_MID
	},
	{
		name: "LV_ALIGN_OUT_LEFT_BOTTOM",
		value: lv_align_t$1.LV_ALIGN_OUT_LEFT_BOTTOM
	},
	{
		name: "LV_ALIGN_OUT_RIGHT_TOP",
		value: lv_align_t$1.LV_ALIGN_OUT_RIGHT_TOP
	},
	{
		name: "LV_ALIGN_OUT_RIGHT_MID",
		value: lv_align_t$1.LV_ALIGN_OUT_RIGHT_MID
	},
	{
		name: "LV_ALIGN_OUT_RIGHT_BOTTOM",
		value: lv_align_t$1.LV_ALIGN_OUT_RIGHT_BOTTOM
	}
], lvChartTypeList = LvChartTypeOpts.map((C) => ({
	name: C.label,
	value: C.value
})), lvChartUpdateModeList = [{
	name: "LV_CHART_UPDATE_MODE_SHIFT",
	value: lv_chart_update_mode_t.LV_CHART_UPDATE_MODE_SHIFT
}, {
	name: "LV_CHART_UPDATE_MODE_CIRCULAR",
	value: lv_chart_update_mode_t.LV_CHART_UPDATE_MODE_CIRCULAR
}], lvChartSeriesTypeList = [
	{
		name: "LV_CHART_AXIS_PRIMARY_Y",
		value: lv_chart_axis_t.LV_CHART_AXIS_PRIMARY_Y
	},
	{
		name: "LV_CHART_AXIS_SECONDARY_Y",
		value: lv_chart_axis_t.LV_CHART_AXIS_SECONDARY_Y
	},
	{
		name: "LV_CHART_AXIS_PRIMARY_X",
		value: lv_chart_axis_t.LV_CHART_AXIS_PRIMARY_X
	},
	{
		name: "LV_CHART_AXIS_SECONDARY_X",
		value: lv_chart_axis_t.LV_CHART_AXIS_SECONDARY_X
	}
];
lv_menu_mode_header_t.LV_MENU_HEADER_TOP_FIXED, lv_menu_mode_header_t.LV_MENU_HEADER_BOTTOM_FIXED, lv_menu_mode_header_t.LV_MENU_HEADER_BOTTOM_FIXED, lv_menu_mode_root_back_button_t.LV_MENU_ROOT_BACK_BUTTON_DISABLED, lv_menu_mode_root_back_button_t.LV_MENU_ROOT_BACK_BUTTON_ENABLED;
var root_2$23 = /* @__PURE__ */ from_html("<div class=\"overlay-gray-curtain svelte-vokmfx\"></div>"), root_3$18 = /* @__PURE__ */ from_html("<div class=\"resize resize-top svelte-vokmfx\"></div> <div class=\"resize resize-bottom svelte-vokmfx\"></div> <div class=\"resize resize-left svelte-vokmfx\"></div> <div class=\"resize resize-right svelte-vokmfx\"></div>", 1), root_1$54 = /* @__PURE__ */ from_html("<!> <div class=\"wrapper svelte-vokmfx\"><!> <div class=\"head svelte-vokmfx\"><p> </p> <button></button></div> <div class=\"content svelte-vokmfx\"><div class=\"content-content svelte-vokmfx\"><!></div></div></div>", 1), $$css$25 = {
	hash: "svelte-vokmfx",
	code: ".overlay-gray-curtain.svelte-vokmfx {position:fixed;top:0;left:0;width:100vw;height:100vh;background:var(--gray-curtain, rgba(0, 0, 0, 0.5));z-index:1000;}.wrapper.svelte-vokmfx {display:flex;justify-content:center;flex-direction:column;position:fixed;left:50vw;top:50vh;width:800px;height:800px;background-color:var(--background, #000000);z-index:1001;box-shadow:0 0 5px var(--box-shadow, #ccc);border-radius:8px;overflow:hidden;}.wrapper.svelte-vokmfx .resize-top:where(.svelte-vokmfx) {position:absolute;top:0;left:50%;transform:translate(-50%);height:10px;width:95%;cursor:ns-resize;border-radius:8px;background-color:transparent;z-index:1004;}.wrapper.svelte-vokmfx .resize-bottom:where(.svelte-vokmfx) {position:absolute;top:100%;left:50%;transform:translate(-50%, -100%);height:10px;width:95%;cursor:ns-resize;border-radius:8px;background-color:transparent;z-index:1004;}.wrapper.svelte-vokmfx .resize-left:where(.svelte-vokmfx) {position:absolute;top:50%;left:0;transform:translate(0, -50%);height:95%;width:10px;cursor:ew-resize;border-radius:8px;background-color:transparent;z-index:1004;}.wrapper.svelte-vokmfx .resize-right:where(.svelte-vokmfx) {position:absolute;top:50%;left:100%;transform:translate(-100%, -50%);height:95%;width:10px;cursor:ew-resize;border-radius:8px;background-color:transparent;z-index:1004;}.wrapper.svelte-vokmfx .head:where(.svelte-vokmfx) {width:100%;height:30px;box-sizing:border-box;cursor:move;border-bottom:2px solid var(--dock-view-border, #2b2b2b);display:flex;align-items:center;flex-direction:row;justify-content:space-between;padding:0 15px;}.wrapper.svelte-vokmfx .head:where(.svelte-vokmfx) .button-close:where(.svelte-vokmfx) {float:right;color:var(--button-font, #ccc);font-size:18px;}.wrapper.svelte-vokmfx .content:where(.svelte-vokmfx) {\n  /* width: 100%; */height:80%;flex:1;display:flex;align-items:center;justify-content:center;padding:0 10px;}.wrapper.svelte-vokmfx .content:where(.svelte-vokmfx) .content-content:where(.svelte-vokmfx) {width:100%;flex:1;height:100%;box-sizing:border-box;}.wrapper.svelte-vokmfx .footer:where(.svelte-vokmfx) {width:100%;height:60px;display:flex;justify-content:right;flex-direction:row;box-sizing:border-box;border-top:2px solid var(--border, #ccc);align-items:center;padding:0 26px;}"
};
function CommonModalLogic(C, E) {
	push(E, !0), append_styles(C, $$css$25);
	let D = prop(E, "onClose", 7, () => {}), O = prop(E, "isOpenState", 15, !1), F = prop(E, "isPublicState", 7, !1), I = prop(E, "haveCurtain", 7, !1), L = prop(E, "headTitle", 7, ""), z = prop(E, "isDraggable", 7, !0), B = prop(E, "isStretchable", 7, !0), V = prop(E, "styled", 7, void 0), U = /* @__PURE__ */ state(void 0), W = /* @__PURE__ */ state(void 0), G = /* @__PURE__ */ state(proxy(O())), K = /* @__PURE__ */ state(proxy(F()));
	user_effect(() => {
		O(), requestAnimationFrame(() => {
			set(G, O(), !0);
		});
	});
	let J = /* @__PURE__ */ state(!1), Y = .8, X = /* @__PURE__ */ state(proxy({
		width: 800,
		height: 800
	})), Z = /* @__PURE__ */ state(proxy({
		x: 0,
		y: 0
	}));
	function Q(C, T, E) {
		return Math.min(Math.max(T, C), E);
	}
	let NL = () => {
		set(G, !1), O(!1), set(K, !1), D()();
	}, PL = (C, E) => {
		C.preventDefault();
		let D = {
			startX: C.clientX,
			startY: C.clientY,
			startWidth: get(X).width,
			startHeight: get(X).height,
			startOffsetX: get(Z).x,
			startOffsetY: get(Z).y
		};
		document.body.style.userSelect = "none";
		let O = document.body.getBoundingClientRect(), F = get(W).getBoundingClientRect(), I = O.width, L = O.height, z = (C) => {
			let O = Q(C.clientX, 0, I) - D.startX, z = Q(C.clientY, 0, L) - D.startY;
			switch (E) {
				case "head":
					set(Z, {
						x: D.startOffsetX + O,
						y: D.startOffsetY + z
					}, !0);
					break;
				case "top":
					set(Z, _objectSpread2(_objectSpread2({}, get(Z)), {}, { y: Q(D.startOffsetY + z, 0, F.bottom - 300) }), !0), set(X, _objectSpread2(_objectSpread2({}, get(X)), {}, { height: Q(D.startHeight - z, 300, I) }), !0);
					break;
				case "bottom":
					set(X, _objectSpread2(_objectSpread2({}, get(X)), {}, { height: Q(D.startHeight + z, 300, I) }), !0);
					break;
				case "left":
					set(Z, _objectSpread2(_objectSpread2({}, get(Z)), {}, { x: Q(D.startOffsetX + O, 0, F.right - 300) }), !0), set(X, _objectSpread2(_objectSpread2({}, get(X)), {}, { width: Q(D.startWidth - O, 300, L) }), !0);
					break;
				case "right":
					set(X, _objectSpread2(_objectSpread2({}, get(X)), {}, { width: Q(D.startWidth + O, 300, I) }), !0);
					break;
			}
		}, B = () => {
			window.removeEventListener("mousemove", z), window.removeEventListener("mouseup", B), document.body.style.userSelect = "";
		};
		window.addEventListener("mousemove", z), window.addEventListener("mouseup", B);
	}, FL = /* @__PURE__ */ state(proxy({}));
	onMount(() => {
		window.addEventListener("resize", IL);
	}), onDestroy(() => {
		window.removeEventListener("resize", IL);
	}), user_effect(() => {
		V() && requestAnimationFrame(() => {
			var C, E;
			set(X, _objectSpread2(_objectSpread2({}, get(X)), {}, {
				width: (C = V().width) == null ? get(X).width : C,
				height: (E = V().height) == null ? get(X).height : E
			}), !0);
		});
	});
	let IL = () => {
		if (get(W)) {
			var C;
			let T = document.body.getBoundingClientRect(), E = (C = get(W)) == null ? void 0 : C.getBoundingClientRect();
			B() && set(X, {
				width: T.width * Y > 800 ? 800 : T.width * Y,
				height: T.height * Y > 600 ? 600 : T.height * Y
			}, !0), set(Z, {
				x: (T.width - E.width) / 2,
				y: (T.height - E.height) / 2
			}, !0);
		}
	};
	user_effect(() => {
		get(G) && get(W) && IL();
	});
	let LL = (C) => {
		var T;
		(T = get(W)) != null && T.contains(C.target) ? set(J, !0) : set(J, !1);
	};
	onMount(() => {
		IL(), window.addEventListener("click", LL), window.addEventListener("mousedown", LL);
	}), onDestroy(() => {
		window.removeEventListener("click", LL), window.removeEventListener("mousedown", LL);
	});
	var RL = {
		get onClose() {
			return D();
		},
		set onClose(C = () => {}) {
			D(C), flushSync();
		},
		get isOpenState() {
			return O();
		},
		set isOpenState(C = !1) {
			O(C), flushSync();
		},
		get isPublicState() {
			return F();
		},
		set isPublicState(C = !1) {
			F(C), flushSync();
		},
		get haveCurtain() {
			return I();
		},
		set haveCurtain(C = !1) {
			I(C), flushSync();
		},
		get headTitle() {
			return L();
		},
		set headTitle(C = "") {
			L(C), flushSync();
		},
		get isDraggable() {
			return z();
		},
		set isDraggable(C = !0) {
			z(C), flushSync();
		},
		get isStretchable() {
			return B();
		},
		set isStretchable(C = !0) {
			B(C), flushSync();
		},
		get styled() {
			return V();
		},
		set styled(C = void 0) {
			V(C), flushSync();
		}
	}, zL = comment(), BL = first_child(zL), VL = (C) => {
		var T = root_1$54(), D = first_child(T), O = (C) => {
			var T = root_2$23();
			template_effect(() => set_style(T, get(K) ? "z-index: 1005;" : `${get(J) ? "z-index:1003;" : ""}`)), append(C, T);
		};
		if_block(D, (C) => {
			(I() || get(K)) && C(O);
		});
		var F = sibling(D, 2);
		F.__click = () => {
			set(J, !0);
		};
		var V = child(F), G = (C) => {
			var T = root_3$18(), E = first_child(T);
			E.__mousedown = (C) => {
				PL(C, "top");
			};
			var D = sibling(E, 2);
			D.__mousedown = (C) => {
				PL(C, "bottom");
			};
			var O = sibling(D, 2);
			O.__mousedown = (C) => {
				PL(C, "left");
			};
			var F = sibling(O, 2);
			F.__mousedown = (C) => {
				PL(C, "right");
			}, append(C, T);
		};
		if_block(V, (C) => {
			B() && C(G);
		});
		var Y = sibling(V, 2);
		Y.__mousedown = (C) => {
			z() && PL(C, "head");
		};
		var Q = child(Y), IL = child(Q, !0);
		reset(Q);
		var LL = sibling(Q, 2);
		set_class(LL, 1, "button-close iconItem iconfont icon-close", "svelte-vokmfx"), LL.__click = NL, reset(Y);
		var RL = sibling(Y, 2), zL = child(RL), BL = child(zL), VL = (C) => {
			var T = comment(), E = first_child(T), D = (C) => {
				var T = comment();
				component(first_child(T), () => get(U), (C, T) => {
					T(C, spread_props(() => get(FL)));
				}), append(C, T);
			};
			if_block(E, (C) => {
				get(U) && C(D);
			}), append(C, T);
		}, HL = (C) => {
			var T = comment();
			slot(first_child(T), E, "default", {}, null), append(C, T);
		};
		if_block(BL, (C) => {
			get(K) ? C(VL) : C(HL, !1);
		}), reset(zL), reset(RL), reset(F), bind_this(F, (C) => set(W, C), () => get(W)), template_effect(() => {
			var C, T, E, D;
			set_style(F, `width:${(C = get(X).width) == null ? "" : C}px;height:${(T = get(X).height) == null ? "" : T}px;left:${(E = get(Z).x) == null ? "" : E}px;top:${(D = get(Z).y) == null ? "" : D}px;${get(K) ? "z-index: 1006" : `${get(J) ? "z-index:1004;" : ""}`}`), set_text(IL, L()), set_style(RL, B() ? "" : "padding:0;");
		}), append(C, T);
	};
	return if_block(BL, (C) => {
		get(G) && C(VL);
	}), append(C, zL), pop(RL);
}
delegate(["click", "mousedown"]), customElements.define("common-modal-logic", create_custom_element(CommonModalLogic, {
	onClose: {},
	isOpenState: {},
	isPublicState: {},
	haveCurtain: {},
	headTitle: {},
	isDraggable: {},
	isStretchable: {},
	styled: {}
}, ["default"], [], !0));
var root_1$53 = /* @__PURE__ */ from_html("<div class=\"drag-op svelte-ewp74w\"><span class=\"svelte-ewp74w\"></span></div>"), root$33 = /* @__PURE__ */ from_html("<div class=\"wrapper common-drag-wrapper svelte-ewp74w\"><div class=\"wrapper-content common-drag-content svelte-ewp74w\" role=\"button\" tabindex=\"0\" aria-label=\"Drag Element\"><div><!> <!></div></div></div>"), $$css$24 = {
	hash: "svelte-ewp74w",
	code: ".wrapper.svelte-ewp74w {width:100%;height:-moz-fit-content;height:fit-content;margin:0;}.wrapper.svelte-ewp74w .wrapper-content:where(.svelte-ewp74w) {width:100%;height:-moz-fit-content;height:fit-content;display:flex;margin:0;}.wrapper.svelte-ewp74w .wrapper-content:where(.svelte-ewp74w) .common-drag-content-content:where(.svelte-ewp74w) {width:100%;height:-moz-fit-content;height:fit-content;position:relative;display:flex;box-sizing:border-box;flex-direction:row;justify-content:left;align-items:center;margin:0;}.wrapper.svelte-ewp74w .wrapper-content:where(.svelte-ewp74w) .common-drag-content-content:where(.svelte-ewp74w) .drag-op:where(.svelte-ewp74w) {display:flex;width:15px;height:12px;max-width:15px;max-height:12px;min-width:15px;min-height:12px;display:block;z-index:inherit;cursor:move;margin:0 10px;}.wrapper.svelte-ewp74w .wrapper-content:where(.svelte-ewp74w) .common-drag-content-content:where(.svelte-ewp74w) .drag-op:where(.svelte-ewp74w) span:where(.svelte-ewp74w) {display:block;height:2px;width:100%;background-color:var(--drag-op, #686868);position:relative;}.wrapper.svelte-ewp74w .wrapper-content:where(.svelte-ewp74w) .common-drag-content-content:where(.svelte-ewp74w) .drag-op:where(.svelte-ewp74w) span:where(.svelte-ewp74w):before {content:\"\";display:block;height:2px;width:100%;background-color:var(--drag-op, #686868);position:absolute;top:5px;}.wrapper.svelte-ewp74w .wrapper-content:where(.svelte-ewp74w) .common-drag-content-content:where(.svelte-ewp74w) .drag-op:where(.svelte-ewp74w) span:where(.svelte-ewp74w):after {content:\"\";display:block;height:2px;width:100%;background-color:var(--drag-op, #686868);position:absolute;top:10px;}"
};
function CommonDragItem(C, T) {
	push(T, !0), append_styles(C, $$css$24);
	let E = prop(T, "children", 7), D = prop(T, "hasHandle", 7, !0), O, F = /* @__PURE__ */ state(0), I = getContext("handleCommonDagItem"), L = getContext("changeChildItem"), z = (C) => {
		I(C);
	};
	onMount(_asyncToGenerator(function* () {
		yield tick();
		let C = O == null ? void 0 : O.querySelector(".content-content");
		C && set(F, C.getBoundingClientRect().height, !0), L(!0);
	}));
	var B = {
		get children() {
			return E();
		},
		set children(C) {
			E(C), flushSync();
		},
		get hasHandle() {
			return D();
		},
		set hasHandle(C = !0) {
			D(C), flushSync();
		}
	}, V = root$33(), U = child(V);
	U.__mousedown = z;
	var W = child(U), G = child(W), K = (C) => {
		append(C, root_1$53());
	};
	return if_block(G, (C) => {
		D() && C(K);
	}), snippet(sibling(G, 2), E), reset(W), reset(U), reset(V), bind_this(V, (C) => O = C, () => O), template_effect(() => set_class(W, 1, `content-content common-drag-content-content ${D() ? "" : "drag-op"}`, "svelte-ewp74w")), append(C, V), pop(B);
}
delegate(["mousedown"]), create_custom_element(CommonDragItem, {
	children: {},
	hasHandle: {}
}, [], [], !0);
var root$32 = /* @__PURE__ */ from_html("<div class=\"wrapper this-class-for-child svelte-jg1z3\"><div class=\"wrapper-overflow svelte-jg1z3\"><!></div></div>"), $$css$23 = {
	hash: "svelte-jg1z3",
	code: ".wrapper.svelte-jg1z3 {position:relative;height:100%;overflow-y:hidden;display:flex;flex-direction:column;}.wrapper.svelte-jg1z3 .wrapper-overflow:where(.svelte-jg1z3) {position:relative;height:100%;overflow-y:auto;display:flex;flex-direction:column;gap:0;}"
};
function CommonDrag(C, T) {
	push(T, !0), append_styles(C, $$css$23);
	let E = prop(T, "children", 7), D = prop(T, "commonDragNewOrd", 7, () => {}), O = /* @__PURE__ */ state(null), F = /* @__PURE__ */ state(null), I = /* @__PURE__ */ state(null), L = /* @__PURE__ */ state(null), z = /* @__PURE__ */ state(null), B = /* @__PURE__ */ state(0), V = /* @__PURE__ */ state(proxy([])), U = /* @__PURE__ */ state(-1), W = /* @__PURE__ */ state(proxy([])), G = /* @__PURE__ */ state(0), K = /* @__PURE__ */ state(null), J = (C) => {
		try {
			var T;
			document.body.style.userSelect = "none";
			let E = C.target;
			if ((T = E.closest(".drag-op")) != null && T.classList.contains("drag-op")) {
				if (C.button !== 0) return;
				if (set(z, E.closest(".common-drag-content-content"), !0), set(I, E.closest(".common-drag-content"), !0), set(L, E.closest(".common-drag-wrapper"), !0), get(z) && get(I) && get(O)) {
					let T = get(z).getBoundingClientRect(), E = get(O).getBoundingClientRect();
					get(I).style.border = "1px dashed black", get(I).style.height = `${T.height}px`, set(B, C.clientY, !0), get(z).style.position = "fixed", get(z).style.opacity = "1", get(z).style.boxShadow = "0 0 5px black", get(z).style.zIndex = "1002", get(z).style.width = `${E.width}px`, get(z).style.top = `${get(B) - T.height / 2}px`, get(z).style.left = `${E.x}px`;
				}
				document.addEventListener("mousemove", X), document.addEventListener("mouseup", Y);
			}
		} catch (C) {
			console.error(C), console.warn("The drag handle is not selected");
		}
	}, Y = () => {
		NL(), document.body.style.userSelect = "auto", document.removeEventListener("mousemove", X), document.removeEventListener("mouseup", Y);
	}, X = (C) => {
		requestAnimationFrame(() => {
			if (get(z) && get(F)) {
				let T = C.clientY - get(z).getBoundingClientRect().height / 2;
				get(z).style.top = `${T}px`;
				let E = get(F).getBoundingClientRect(), D = get(z).getBoundingClientRect(), O = E.height, I = O * .2, L = get(F).scrollTop, B = get(F).scrollHeight, V = L > 0, U = L < B - O;
				D.top < E.top + I && V ? set(G, -Math.min(10, (E.top + I - D.top) / 5)) : D.bottom > E.bottom - I && U ? set(G, Math.min(10, (D.bottom - (E.bottom - I)) / 5), !0) : set(G, 0), get(G) === 0 ? get(K) && (clearInterval(get(K)), set(K, null)) : get(K) || set(K, window.setInterval(() => {
					let C = get(F).scrollTop + get(G);
					get(G) < 0 && C >= 0 || get(G) > 0 && C <= B - O ? get(F).scrollTop = C : (clearInterval(get(K)), set(K, null), set(G, 0));
				}, 16), !0);
			}
			Z(C);
		});
	}, Z = (C) => {
		if (get(F) && get(L) && get(z)) {
			let E = Array.from(get(F).children), O = get(U) > 0 ? get(U) : E.indexOf(get(L)), I = Math.round((get(z).getBoundingClientRect().top - get(L).getBoundingClientRect().top) / get(L).getBoundingClientRect().height);
			if (I && O + I >= 0 && O + I < E.length) {
				var T;
				set(U, O + I), D()(Q(get(W), O, I));
				let E = (T = get(F)) == null ? void 0 : T.children.length;
				set(W, Array.from({ length: E }, (C, T) => T), !0), set(B, C.clientY, !0);
			}
		}
	};
	function Q(C, T, E) {
		let D = [...C];
		if (D.length === 0) throw Error("");
		if (T < 0 || T >= D.length) throw Error("");
		let O = (T + E) % D.length;
		O < 0 && (O += D.length);
		let [F] = D.splice(T, 1);
		return D.splice(O, 0, F), D;
	}
	let NL = () => {
		get(O) && (set(V, Array.from(get(F).children).map((C) => Math.round((C.getBoundingClientRect().y - get(O).getBoundingClientRect().y) / C.getBoundingClientRect().height)), !0), get(z) && get(I) && (get(z).style.opacity = "", get(z).style.position = "", get(z).style.width = "", get(z).style.left = "", get(z).style.top = "", get(z).style.zIndex = "", get(z).style.boxShadow = "", get(I).style.border = "none", get(I).style.height = "fit-content", set(z, null), set(U, -1)));
	};
	setContext("changeChildItem", (C) => {
		var T;
		let E = (T = get(F)) == null ? void 0 : T.children.length;
		set(W, Array.from({ length: E }, (C, T) => T), !0);
	}), setContext("handleCommonDagItem", J), onMount(_asyncToGenerator(function* () {
		var C;
		yield tick();
		let T = (C = get(F)) == null ? void 0 : C.children.length;
		set(W, Array.from({ length: T }, (C, T) => T), !0);
	}));
	var PL = {
		get children() {
			return E();
		},
		set children(C) {
			E(C), flushSync();
		},
		get commonDragNewOrd() {
			return D();
		},
		set commonDragNewOrd(C = () => {}) {
			D(C), flushSync();
		}
	}, FL = root$32(), IL = child(FL);
	return snippet(child(IL), E), reset(IL), bind_this(IL, (C) => set(F, C), () => get(F)), reset(FL), bind_this(FL, (C) => set(O, C), () => get(O)), append(C, FL), pop(PL);
}
create_custom_element(CommonDrag, {
	children: {},
	commonDragNewOrd: {}
}, [], [], !0);
var editableTypeOption = [
	{
		label: "==",
		value: "eq"
	},
	{
		label: "!=",
		value: "neq"
	},
	{
		label: "<",
		value: "lt"
	},
	{
		label: "<=",
		value: "lte"
	},
	{
		label: ">",
		value: "gt"
	},
	{
		label: ">=",
		value: "gte"
	},
	{
		label: "Between",
		value: "btwn"
	},
	{
		label: "Is True",
		value: "true"
	},
	{
		label: "Is False",
		value: "false"
	},
	{
		label: "Is Empty",
		value: "empty"
	},
	{
		label: "Is Not Empty",
		value: "nempty"
	}
], root_2$22 = /* @__PURE__ */ from_html("to <property-input></property-input>", 3), root_1$52 = /* @__PURE__ */ from_html("<property-input></property-input> <!>", 3), root$31 = /* @__PURE__ */ from_html("<div class=\"wrapper svelte-1rwe1a2\"><div class=\"module-line svelte-1rwe1a2\"><property-input></property-input> <!> <span class=\"min-w-[40px] text-center mx-1\">assign</span> <div class=\"min-w-[80px]\"><property-input></property-input></div> <button></button></div></div>", 2), $$css$22 = {
	hash: "svelte-1rwe1a2",
	code: "@charset \"UTF-8\";.wrapper.svelte-1rwe1a2 {width:calc(100% - 10px);height:50px;box-sizing:border-box;margin:0 5px;-webkit-user-select:none;-moz-user-select:none;user-select:none;border-bottom:1px solid var(--border, #ccc);background-color:var(--background, #000000);color:var(--font, #ffffff);}.wrapper.svelte-1rwe1a2 .module-line:where(.svelte-1rwe1a2) {width:100%;height:50px;background-color:transparent;display:flex;flex-direction:row;justify-content:left;align-items:center;gap:8px;}.wrapper.svelte-1rwe1a2 .module-line:where(.svelte-1rwe1a2) .button-item:where(.svelte-1rwe1a2) {min-width:60px;width:-moz-fit-content;width:fit-content;height:34px;box-sizing:border-box;padding:6px;border-radius:4px;line-height:22px;color:var(--button-font, #ffffff);border:1px solid var(--button-border, #ccc);}.wrapper.svelte-1rwe1a2 .module-line:where(.svelte-1rwe1a2) .input-item:where(.svelte-1rwe1a2) {flex:1;width:100%;height:34px;display:flex;justify-content:left;align-items:center;color:var(--input-color, #ffffff);}.wrapper.svelte-1rwe1a2 .module-line:where(.svelte-1rwe1a2) .button-close:where(.svelte-1rwe1a2) {width:22px;height:22px;box-sizing:border-box;text-align:center;color:var(--icon, #ffffff);font-size:12px;padding:3px;display:flex;justify-content:center;align-items:center;cursor:pointer;background-color:var(--background, #ccc);border-radius:4px;box-shadow:0 0 5px inset var(--box-shadow);}.clear-input.svelte-1rwe1a2 {\n  /*  */border:none;outline:none;\n  /*  */background:none;padding:0;\n  /*  */font-family:inherit;font-size:inherit;font-weight:inherit;color:inherit;\n  /*  */box-sizing:border-box; /*  */margin:0;\n  /*  */-webkit-appearance:none; /*  WebKit  */-moz-appearance:none; /*  Firefox  */appearance:none;\n  /*  */cursor:text;}.clear-input.svelte-1rwe1a2:focus {outline:none;border-color:#3b82f6;box-shadow:0 0 0 2px rgba(59, 130, 246, 0.2);}.clear-input.svelte-1rwe1a2:disabled {background-color:#f3f4f6;border-color:#e5e7eb;color:#9ca3af;cursor:not-allowed;}"
};
function EditableListItem(C, T) {
	push(T, !0), append_styles(C, $$css$22);
	let E = prop(T, "deleteItem", 7), D = prop(T, "key", 7), O = prop(T, "type", 15), F = prop(T, "value", 15), I = prop(T, "valueType", 7), L = prop(T, "resultValue", 15), z = prop(T, "resultType", 7), B = /* @__PURE__ */ user_derived(() => I() === "string" ? [
		{
			name: "==",
			value: "eq"
		},
		{
			name: "!=",
			value: "neq"
		},
		{
			name: "Is Empty",
			value: "empty"
		},
		{
			name: "Is Not Empty",
			value: "nempty"
		}
	] : I() === "boolean" ? [{
		name: "Is True",
		value: "true"
	}, {
		name: "Is False",
		value: "false"
	}] : editableTypeOption.map((C) => ({
		value: C.value,
		name: C.label
	})).filter((C) => ![
		"true",
		"false",
		"empty",
		"nempty"
	].includes(C.value))), V = /* @__PURE__ */ user_derived(() => U(O())), U = (C) => [
		"eq",
		"neq",
		"lt",
		"lte",
		"gt",
		"gte"
	].includes(C) ? "compare" : C === "btwn" ? "range" : [
		"true",
		"false",
		"empty",
		"nempty"
	].includes(C) ? "state" : "compare";
	function W(C) {
		return C === "boolean" ? "checkbox" : C === "string" ? "string" : "number";
	}
	var G = {
		get deleteItem() {
			return E();
		},
		set deleteItem(C) {
			E(C), flushSync();
		},
		get key() {
			return D();
		},
		set key(C) {
			D(C), flushSync();
		},
		get type() {
			return O();
		},
		set type(C) {
			O(C), flushSync();
		},
		get value() {
			return F();
		},
		set value(C) {
			F(C), flushSync();
		},
		get valueType() {
			return I();
		},
		set valueType(C) {
			I(C), flushSync();
		},
		get resultValue() {
			return L();
		},
		set resultValue(C) {
			L(C), flushSync();
		},
		get resultType() {
			return z();
		},
		set resultType(C) {
			z(C), flushSync();
		}
	}, K = root$31(), J = child(K), Y = child(J);
	set_custom_element_data(Y, "label", ""), set_custom_element_data(Y, "type", "option"), template_effect(() => set_custom_element_data(Y, "options", get(B))), template_effect(() => set_custom_element_data(Y, "value", O())), set_class(Y, 1, "min-w-[90px]");
	var X = sibling(Y, 2), Z = (C) => {
		var T = root_1$52(), E = first_child(T);
		set_custom_element_data(E, "label", ""), template_effect(() => set_custom_element_data(E, "type", I())), template_effect(() => set_custom_element_data(E, "value", F()[0]));
		var D = sibling(E, 2), O = (C) => {
			var T = root_2$22(), E = sibling(first_child(T));
			set_custom_element_data(E, "label", ""), template_effect(() => set_custom_element_data(E, "type", I())), template_effect(() => set_custom_element_data(E, "value", F()[1])), event("Change", E, (C) => {
				F(F()[1] = C, !0);
			}), append(C, T);
		};
		if_block(D, (C) => {
			get(V) === "range" && C(O);
		}), event("Change", E, (C) => {
			F(F()[0] = C, !0);
		}), append(C, T);
	};
	if_block(X, (C) => {
		get(V) !== "state" && C(Z);
	});
	var Q = sibling(X, 4), NL = child(Q);
	template_effect(() => set_custom_element_data(NL, "label", W(z()) === "checkbox" ? "True" : "")), template_effect(() => set_custom_element_data(NL, "value", L())), template_effect(() => set_custom_element_data(NL, "type", W(z()))), reset(Q);
	var PL = sibling(Q, 2);
	return set_class(PL, 1, "button-close iconItem iconfont icon-close", "svelte-1rwe1a2"), PL.__click = () => {
		var C;
		(C = E()) == null || C(D());
	}, reset(J), reset(K), event("Change", Y, (C) => {
		O(C);
	}), event("Change", NL, (C) => {
		L(C);
	}), append(C, K), pop(G);
}
delegate(["click"]), create_custom_element(EditableListItem, {
	deleteItem: {},
	key: {},
	type: {},
	value: {},
	valueType: {},
	resultValue: {},
	resultType: {}
}, [], [], !0);
function deepClone(C, T = /* @__PURE__ */ new WeakMap()) {
	if (typeof C != "object" || !C) return C;
	if (T.has(C)) return T.get(C);
	if (C instanceof Date) return new Date(C.getTime());
	if (C instanceof RegExp) return new RegExp(C.source, C.flags);
	if (C instanceof Map) {
		let E = /* @__PURE__ */ new Map();
		return T.set(C, E), C.forEach((C, D) => {
			E.set(deepClone(D, T), deepClone(C, T));
		}), E;
	}
	if (C instanceof Set) {
		let E = /* @__PURE__ */ new Set();
		return T.set(C, E), C.forEach((C) => E.add(deepClone(C, T))), E;
	}
	if (Array.isArray(C)) {
		let E = [];
		T.set(C, E);
		for (let D of C) E.push(deepClone(D, T));
		return E;
	}
	let E = Object.create(Object.getPrototypeOf(C));
	T.set(C, E);
	let D = [...Object.getOwnPropertyNames(C), ...Object.getOwnPropertySymbols(C)];
	for (let O of D) E[O] = deepClone(C[O], T);
	return E;
}
function deepWatch(C, T, E, D = [], O = /* @__PURE__ */ new WeakMap()) {
	if (typeof C != "object" || !C) return C;
	if (O.has(C)) return O.get(C);
	let F = new Proxy(C, {
		get(C, F, I) {
			let L = Reflect.get(C, F, I);
			return Array.isArray(C) && typeof L == "function" && [
				"push",
				"pop",
				"shift",
				"unshift",
				"splice",
				"sort",
				"reverse"
			].includes(F) ? L.bind(C) : typeof L == "object" && L ? deepWatch(L, T, E, D.concat(String(F)), O) : L;
		},
		set(C, O, F, I) {
			let L = C[O], z = [...D, String(O)].join("."), B = Reflect.set(C, O, F, I);
			return !E.includes(O) && L !== F && T({
				path: z,
				type: "set",
				oldValue: L,
				newValue: F
			}), B;
		},
		deleteProperty(C, E) {
			if (E in C) {
				let O = C[E], F = [...D, String(E)].join("."), I = Reflect.deleteProperty(C, E);
				return T({
					path: F,
					type: "delete",
					oldValue: O,
					newValue: void 0
				}), I;
			}
			return !1;
		}
	});
	return O.set(C, F), F;
}
function hexWithAlpha(C, T) {
	if (!C) return "#000000ff";
	T = Math.max(0, Math.min(255, T));
	let E = C.replace(/^#/, "");
	if (E.length === 3 && (E = E.split("").map((C) => C + C).join("")), E.length !== 6) throw Error("Invalid hex color format");
	let D = T.toString(16).padStart(2, "0");
	return `#${E}${D}`;
}
function isClickInside(C, T) {
	if (!C) return !1;
	let E = C.getBoundingClientRect();
	return T.clientX >= E.left && T.clientX <= E.right && T.clientY >= E.top && T.clientY <= E.bottom;
}
function getValueType(C, T) {
	let E = C.split(".").pop(), D = T.structAndVarRelationIntegrate.getTreeFlattener();
	if (E) {
		var O;
		let C = (O = D.getNodeBySourceId(E)) == null ? void 0 : O.source;
		if (C) {
			let T = C.dataType;
			if ([
				"char",
				"string",
				"unsigned char"
			].includes(T)) return "string";
			if (T === "bool") return "boolean";
			if ([
				"float",
				"double",
				"long double"
			].includes(T)) return "float";
			if (["unsigned short", "unsigned long long"].includes(T)) return "unsigned";
		}
	}
	return "number";
}
function widgetTreeToArray(C) {
	let T = [];
	for (let E of C) T.push(E), E.children.length > 0 && T.push(...widgetTreeToArray(E.children));
	return T;
}
var cached = /* @__PURE__ */ new Set(), charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
function genRandomStr(C) {
	let T = [];
	for (let E = 0; E < C; E++) T.push(charset[Math.floor(Math.random() * 62)]);
	let E = T.join("");
	return cached.has(E) ? genRandomStr(C) : (cached.add(E), E);
}
function toCamelCase(C) {
	return C.replace(/\s+([a-zA-Z])/g, (C, T) => T.toUpperCase()).replace(/^\w/, (C) => C.toLowerCase());
}
function findWidget(C, T, E) {
	for (let D = 0; D < C.length; D++) {
		let O = C[D];
		if (E && E(O) || !E && O.id === T) return O;
		if (O.children.length > 0) {
			let C = findWidget(O.children, T);
			if (C) return C;
		}
	}
	return null;
}
const cKeywords = new Set(/* @__PURE__ */ "auto.break.case.char.const.continue.default.do.double.else.enum.extern.float.for.goto.if.inline.int.long.register.restrict.return.short.signed.sizeof.static.struct.switch.typedef.union.unsigned.void.volatile.while._Alignas._Alignof._Atomic._Bool._Complex._Generic._Imaginary._Noreturn._Static_assert._Thread_local".split("."));
function isValidCVariableName(C) {
	return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(C) && !cKeywords.has(C);
}
var root_4$12 = /* @__PURE__ */ from_html("<span class=\"iconfont icon-arrow-right\"></span>"), root_3$17 = /* @__PURE__ */ from_html("<button> <!></button>"), root_2$21 = /* @__PURE__ */ from_html("<div class=\"wrapper-item svelte-rsgoib\"></div>"), root_1$51 = /* @__PURE__ */ from_html("<div class=\"wrapper-option svelte-rsgoib\"></div>"), root$30 = /* @__PURE__ */ from_html("<div class=\"wrapper svelte-rsgoib\"><div class=\"wrapper-input svelte-rsgoib\"><div class=\"wrapper-scroller svelte-rsgoib\"><input readonly=\"\" class=\"clear-input svelte-rsgoib\" placeholder=\"Please select...\"/> <span class=\"iconClose iconfont icon-close svelte-rsgoib\"></span> <span class=\"iconArrowDown iconfont icon-arrow-down svelte-rsgoib\"></span></div></div> <!></div>"), $$css$21 = {
	hash: "svelte-rsgoib",
	code: "@charset \"UTF-8\";.wrapper.svelte-rsgoib {display:inline;width:-moz-max-content;width:max-content;height:-moz-max-content;height:max-content;left:10px;top:10px;}.wrapper-input.svelte-rsgoib {width:100%;display:flex;justify-content:left;align-items:center;flex-direction:row;min-height:20px;height:100%;max-height:32px;box-sizing:border-box;box-shadow:0 0 1px white inset;padding:0 8px;overflow:hidden;}.wrapper-input.svelte-rsgoib .wrapper-scroller:where(.svelte-rsgoib) {overflow:auto;width:100%;height:100%;display:flex;justify-content:flex-start;flex-direction:row;cursor:pointer;}.wrapper-input.svelte-rsgoib .wrapper-scroller:where(.svelte-rsgoib) .iconClose:where(.svelte-rsgoib) {\n  /* display: none;\n  border-radius: 50%;\n  box-sizing: border-box;\n  font-size: 8px;\n  background-color: #cbcbcb;\n  color: black;\n  padding: 4px; */\n  /* display: none; */opacity:0;width:-moz-fit-content;width:fit-content;font-size:8px;white-space:nowrap; /*   */}.wrapper-input.svelte-rsgoib .wrapper-scroller:where(.svelte-rsgoib):hover .iconClose:where(.svelte-rsgoib) {\n  /* display: block; */opacity:1;}.wrapper-input.svelte-rsgoib .wrapper-scroller:where(.svelte-rsgoib):hover .iconArrowDown:where(.svelte-rsgoib) {display:none;}.wrapper-input.svelte-rsgoib .wrapper-scroller:where(.svelte-rsgoib) input:where(.svelte-rsgoib) {color:white;width:100%;height:100%;font-size:14px;cursor:pointer;}.wrapper-input.svelte-rsgoib .wrapper-scroller:where(.svelte-rsgoib)::-webkit-scrollbar {display:none;}.wrapper-input.svelte-rsgoib .wrapper-scroller:where(.svelte-rsgoib) span:where(.svelte-rsgoib) {margin:auto;line-height:100%;position:relative;right:0px;color:white;}.wrapper-option.svelte-rsgoib {position:fixed;top:1000vh;width:-moz-max-content;width:max-content;height:200px;box-sizing:border-box;box-shadow:0 0 1px white inset;display:flex;justify-content:flex-start;flex-direction:row;border-radius:8px;box-shadow:0 0 5px rgba(0, 0, 0, 0.397);border-radius:0.5rem;z-index:100000;background-color:white;}.wrapper-option.svelte-rsgoib .wrapper-item:where(.svelte-rsgoib) {min-width:120px;height:200px;box-sizing:border-box;border-right:1px solid rgba(5, 5, 5, 0.06);padding:4px;display:flex;justify-content:flex-start;flex-direction:column;overflow:auto;}.wrapper-option.svelte-rsgoib .wrapper-item:where(.svelte-rsgoib) .item:where(.svelte-rsgoib) {height:30px;min-height:30px;max-height:30px;width:100%;border-radius:0.5rem;text-align:left;padding:0 8px;cursor:pointer;color:rgba(0, 0, 0, 0.6274509804);display:flex;justify-content:space-between;align-items:center;}.wrapper-option.svelte-rsgoib .wrapper-item:where(.svelte-rsgoib) .item:where(.svelte-rsgoib):hover {background-color:rgba(0, 0, 0, 0.0588235294);}.wrapper-option.svelte-rsgoib .wrapper-item:where(.svelte-rsgoib) .item-disabled:where(.svelte-rsgoib) {height:30px;min-height:30px;max-height:30px;width:100%;border-radius:0.5rem;text-align:left;padding:0 8px;cursor:pointer;display:flex;justify-content:space-between;align-items:center;background-color:#f5f5f5;color:#434343;cursor:not-allowed;}.wrapper-option.svelte-rsgoib .wrapper-item:where(.svelte-rsgoib) .item-select:where(.svelte-rsgoib) {height:30px;min-height:30px;max-height:30px;width:100%;border-radius:0.5rem;text-align:left;padding:0 8px;cursor:pointer;color:rgba(0, 0, 0, 0.6274509804);background-color:#e6f4ff;display:flex;align-items:center;justify-content:space-between;font-weight:bold;}.wrapper-option.svelte-rsgoib .wrapper-item:where(.svelte-rsgoib):last-child {border-right:none;}.clear-input.svelte-rsgoib {border:none;outline:none;background:none;padding:0;font-family:inherit;font-size:inherit;font-weight:inherit;color:inherit;box-sizing:border-box;margin:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:text;}.clear-input.svelte-rsgoib:focus {outline:none;box-shadow:none;border:none;}.clear-input.svelte-rsgoib:disabled {opacity:1;cursor:not-allowed;background:none;}"
};
function MCXACascader(C, T) {
	push(T, !0), append_styles(C, $$css$21);
	let E = prop(T, "option", 7), D = prop(T, "onChange", 7), O = prop(T, "defaultValue", 15, ""), F = prop(T, "checkToClosePopup", 7, !0), I = prop(T, "isLocal", 7, !1), L = prop(T, "api", 7), z = /* @__PURE__ */ state(proxy(deepClone(E()))), B = /* @__PURE__ */ state(void 0), V = /* @__PURE__ */ state(void 0), U = /* @__PURE__ */ state(proxy([])), W = /* @__PURE__ */ state(proxy(/* @__PURE__ */ new Map())), G = /* @__PURE__ */ state(0), K = /* @__PURE__ */ state(0), J = /* @__PURE__ */ state(!1), Y = /* @__PURE__ */ state(""), X = /* @__PURE__ */ state(""), Z = /* @__PURE__ */ state(void 0);
	user_effect(() => {
		set(z, deepClone(E()), !0), requestAnimationFrame(() => {
			Q();
		});
	}), user_effect(() => {
		O(), O() !== get(X) && requestAnimationFrame(() => {
			Q();
		});
	});
	let Q = () => {
		if (!O()) return;
		set(X, O(), !0);
		let C = O().split(".");
		if (get(z).length !== 0 && C.length !== 0) {
			let T = [], E = [get(z)[0]], D = get(z)[0].find((T) => T.value === C[0]);
			if (D) {
				T.push(D);
				for (let O = 1; O < C.length; O++) D !== void 0 && D.children && D.children.length && (E.push(D.children), D = D.children.find((T) => T.value === C[O]), D && T.push(D));
				let F = /* @__PURE__ */ new Map();
				for (let C = 0; C < T.length; C++) {
					let E = T[C];
					E && F.set(C, E);
				}
				set(W, F, !0), set(z, E, !0);
				let I = PL(T);
				set(Y, I.labelStr, !0), set(X, I.valueStr, !0), O(I.valueStr);
			}
		}
	}, NL = (C, T) => {
		get(W).set(C, T), T.children && T.children.length > 0 ? get(z).length > C + 1 ? get(z)[C + 1] = T.children : get(z).push(T.children) : get(z).splice(C + 1), get(z).splice(C + 2);
		let E = get(W).size;
		for (let T = C + 1; T < E; T++) get(W).delete(T);
		let D = [];
		for (let C = 0; C < get(W).size; C++) D.push(get(W).get(C));
		set(U, D, !0);
		let L = PL(D);
		return set(Y, L.labelStr, !0), set(X, L.valueStr, !0), O(L.valueStr), set(W, new Map(get(W)), !0), F() && (get(U)[get(U).length - 1].children || set(J, !1)), !I() && get(Z) && get(Z).changeSelect(get(W)), {};
	}, PL = (C) => ({
		valueStr: C.map((C) => {
			if (C) return C.value;
		}).join("."),
		labelStr: C.map((C) => {
			if (C) return C.label;
		}).join(".")
	}), FL = (C = void 0) => {
		if (get(B)) {
			let T = get(B).getBoundingClientRect();
			set(G, T.left, !0), C ? set(K, C, !0) : set(K, T.top + T.height), I() || (set(Z, L().popUp.getPopUp("mcxa-cascader-option-id-3d7c2e4a-6c52-48ce-9c41-b3ab0e4adbcf"), !0), get(Z).changeOptions(get(z)), get(Z).changeShow({
				show: get(J),
				top: get(K),
				left: get(G),
				select: get(W)
			}), get(Z).getSelectData(NL));
		}
	}, IL = (C) => {
		var T, E;
		let D = {
			clientX: C.clientX,
			clientY: C.clientY
		};
		get(Z) && (T = get(Z)) != null && T.getDOMRef() && isClickInside((E = get(Z)) == null ? void 0 : E.getDOMRef(), D) ? set(J, !0) : isClickInside(get(V), D) ? isClickInside(get(B), D) ? set(J, !get(J)) : set(J, !0) : set(J, !1), !I() && get(Z) && get(Z).changeShow({ show: get(J) });
	};
	onMount(() => {
		FL(), set(z, deepClone(E()), !0), document.addEventListener("mousedown", (C) => {
			IL(C);
		});
	}), onDestroy(() => {
		document.removeEventListener("mousedown", IL);
	});
	let LL = () => {
		set(W, /* @__PURE__ */ new Map(), !0), set(U, [], !0), set(Y, ""), set(X, ""), set(z, deepClone(E()), !0), set(J, !1), D() && D()({
			obj: {},
			str: ""
		}), get(Z) && get(Z).changeShow({
			show: get(J),
			top: get(K),
			left: get(G),
			select: get(W)
		});
	};
	user_effect(() => {
		get(J) || requestAnimationFrame(() => {
			I() && FL(99999999), get(Y).split(".").length === 2 && D() && D()({
				obj: get(U),
				str: get(X)
			});
		});
	});
	var RL = {
		get option() {
			return E();
		},
		set option(C) {
			E(C), flushSync();
		},
		get onChange() {
			return D();
		},
		set onChange(C) {
			D(C), flushSync();
		},
		get defaultValue() {
			return O();
		},
		set defaultValue(C = "") {
			O(C), flushSync();
		},
		get checkToClosePopup() {
			return F();
		},
		set checkToClosePopup(C = !0) {
			F(C), flushSync();
		},
		get isLocal() {
			return I();
		},
		set isLocal(C = !1) {
			I(C), flushSync();
		},
		get api() {
			return L();
		},
		set api(C) {
			L(C), flushSync();
		}
	}, zL = root$30(), BL = child(zL), VL = child(BL);
	VL.__click = () => {
		FL();
	};
	var HL = child(VL);
	remove_input_defaults(HL);
	var UL = sibling(HL, 2);
	UL.__click = (C) => {
		C.preventDefault(), C.stopPropagation(), LL();
	}, next(2), reset(VL), reset(BL), bind_this(BL, (C) => set(B, C), () => get(B));
	var WL = sibling(BL, 2), GL = (C) => {
		var T = root_1$51();
		each(T, 21, () => get(z), index, (C, T, E) => {
			var D = root_2$21();
			each(D, 21, () => get(T), index, (C, T) => {
				var D = root_3$17();
				D.__click = () => NL(E, get(T));
				var O = child(D), F = sibling(O), I = (C) => {
					append(C, root_4$12());
				};
				if_block(F, (C) => {
					get(T).children && get(T).children.length && C(I);
				}), reset(D), template_effect((C) => {
					var E;
					D.disabled = get(T).disabled, set_class(D, 1, C, "svelte-rsgoib"), set_text(O, `${(E = get(T).label) == null ? "" : E} `);
				}, [() => {
					var C;
					return clsx$1(((C = get(W).get(E)) == null ? void 0 : C.value) === get(T).value ? "item-select" : `${get(T).disabled ? "item-disabled" : "item"}`);
				}]), append(C, D);
			}), reset(D), append(C, D);
		}), reset(T), template_effect(() => set_style(T, `top:${get(K)}px;left:${get(G)}px;`)), append(C, T);
	};
	return if_block(WL, (C) => {
		get(J) && I() && C(GL);
	}), reset(zL), bind_this(zL, (C) => set(V, C), () => get(V)), bind_value(HL, () => get(Y), (C) => set(Y, C)), append(C, zL), pop(RL);
}
delegate(["click"]), create_custom_element(MCXACascader, {
	option: {},
	onChange: {},
	defaultValue: {},
	checkToClosePopup: {},
	isLocal: {},
	api: {}
}, [], [], !0);
var root$29 = /* @__PURE__ */ from_html("<div class=\"wrapper svelte-k07szt\"><!></div>"), $$css$20 = {
	hash: "svelte-k07szt",
	code: ".wrapper.svelte-k07szt {height:30px;box-sizing:border-box;border:1px solid #cbcbcb;}"
};
function Cascader(C, T) {
	push(T, !0), append_styles(C, $$css$20);
	function E(C, T) {
		let D = [];
		for (let O = 0; O < C.length; O++) {
			let F = !1, I = C[O];
			T === "string" ? F = I.dataType !== "string" : I.dataType === "string" && (F = !0), T === void 0 && (F = !1), I.type === "folder" && (F = !1);
			let L = {
				label: I.name,
				value: I.id,
				children: void 0,
				disabled: F
			};
			I.children && I.children.length && (L.children = E(I.children, T)), D.push(L);
		}
		return D;
	}
	let D = prop(T, "type", 7, void 0), O = prop(T, "onChange", 7, (C) => {}), F = prop(T, "value", 15, ""), I = prop(T, "checkToClosePopup", 7, !1), L = prop(T, "disabled", 7, !1), z = prop(T, "api", 7), B = /* @__PURE__ */ state(proxy([])), V = () => {
		let C = E(z().structAndVarRelationIntegrate.getTreeFlattener().buildSourceTree(), D())[1];
		C != null && C.children ? set(B, [[...C.children.filter((C) => C.children)]], !0) : set(B, [[]], !0);
	};
	onMount(() => {
		V(), z().eventBus.on(`tree:flattener:rename:${z().structAndVarRelationIntegrate.getTreeFlattener().getId()}`, () => {
			V();
		}), z().eventBus.on(z().constant.structAndVarRelationConstants.VARIABLE_EXCEL_OPEN, (C) => {
			V();
		}), z().eventBus.on(z().constant.structAndVarRelationConstants.UPDATE_TREENODE_STRUCT_AND_VARRELATION_INTEGRATE, () => {
			O()({
				obj: {},
				str: F()
			}), V();
		});
	});
	var U = {
		get type() {
			return D();
		},
		set type(C = void 0) {
			D(C), flushSync();
		},
		get onChange() {
			return O();
		},
		set onChange(C = (C) => {}) {
			O(C), flushSync();
		},
		get value() {
			return F();
		},
		set value(C = "") {
			F(C), flushSync();
		},
		get checkToClosePopup() {
			return I();
		},
		set checkToClosePopup(C = !1) {
			I(C), flushSync();
		},
		get disabled() {
			return L();
		},
		set disabled(C = !1) {
			L(C), flushSync();
		},
		get api() {
			return z();
		},
		set api(C) {
			z(C), flushSync();
		}
	}, W = root$29();
	return MCXACascader(child(W), {
		get option() {
			return get(B);
		},
		get onChange() {
			return O();
		},
		get checkToClosePopup() {
			return I();
		},
		get api() {
			return z();
		},
		get defaultValue() {
			return F();
		},
		set defaultValue(C) {
			F(C);
		}
	}), reset(W), append(C, W), pop(U);
}
create_custom_element(Cascader, {
	type: {},
	onChange: {},
	value: {},
	checkToClosePopup: {},
	disabled: {},
	api: {}
}, [], [], !0);
var root$28 = /* @__PURE__ */ from_html("<div class=\"wrapper svelte-rtd0j9\"><div class=\"head svelte-rtd0j9\"><!></div> <div class=\"content svelte-rtd0j9\"><!></div> <div class=\"operate svelte-rtd0j9\"><button class=\"operate-add svelte-rtd0j9\"></button></div></div>"), $$css$19 = {
	hash: "svelte-rtd0j9",
	code: ".wrapper.svelte-rtd0j9 {flex:1;width:100%;height:100%;display:flex;justify-content:space-between;flex-direction:column;}.wrapper.svelte-rtd0j9 .content:where(.svelte-rtd0j9) {height:calc(100% - 50px);overflow-y:hidden;}.wrapper.svelte-rtd0j9 .operate:where(.svelte-rtd0j9) {width:100%;height:60px;box-sizing:border-box;padding:10px;display:flex;justify-content:right;flex-direction:row;align-items:center;}.wrapper.svelte-rtd0j9 .operate:where(.svelte-rtd0j9) .operate-add:where(.svelte-rtd0j9) {color:var(--button-font, #ffffff);height:34px;line-height:34px;background-color:black;width:120px;text-align:center;border-radius:4px;border:1px solid var(--border, #ccc);}.wrapper.svelte-rtd0j9 .head:where(.svelte-rtd0j9) {width:100%;margin:10px 0px;}"
};
function EditableList(C, T) {
	push(T, !0), append_styles(C, $$css$19);
	let E = prop(T, "list", 15), D = prop(T, "bindVar", 15), O = prop(T, "valueType", 7), F = prop(T, "resultType", 7), I = prop(T, "onBindVarChange", 7), L = prop(T, "api", 7), z = () => "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, function(C) {
		let T = Math.random() * 16 | 0;
		return (C === "x" ? T : T & 3 | 8).toString(16);
	}), B = /* @__PURE__ */ user_derived(() => !D().includes(".")), V = (C) => {
		E(C.map((C, T) => E()[C]));
	}, U = () => {
		let C = "eq";
		O() === "boolean" && (C = "true");
		function T(C) {
			return C === "string" ? [""] : C === "number" || C === "unsigned" || C === "float" ? [0, 100] : [];
		}
		let D = {
			key: z(),
			condition: C,
			value: T(O()),
			valueType: O(),
			result: F() === "string" ? "" : 0
		};
		E().push(D);
	}, W = (C) => {
		let T = E().findIndex((T) => T.key === C);
		T !== -1 && E().splice(T, 1);
	};
	var G = {
		get list() {
			return E();
		},
		set list(C) {
			E(C), flushSync();
		},
		get bindVar() {
			return D();
		},
		set bindVar(C) {
			D(C), flushSync();
		},
		get valueType() {
			return O();
		},
		set valueType(C) {
			O(C), flushSync();
		},
		get resultType() {
			return F();
		},
		set resultType(C) {
			F(C), flushSync();
		},
		get onBindVarChange() {
			return I();
		},
		set onBindVarChange(C) {
			I(C), flushSync();
		},
		get api() {
			return L();
		},
		set api(C) {
			L(C), flushSync();
		}
	}, K = root$28(), J = child(K);
	Cascader(child(J), {
		checkToClosePopup: !0,
		get onChange() {
			return I();
		},
		get api() {
			return L();
		},
		get value() {
			return D();
		},
		set value(C) {
			D(C);
		}
	}), reset(J);
	var Y = sibling(J, 2);
	CommonDrag(child(Y), {
		commonDragNewOrd: (C) => {
			V(C);
		},
		children: (C, T) => {
			var D = comment();
			each(first_child(D), 17, E, (C) => C.key, (C, T, E) => {
				var D = comment(), I = first_child(D), L = (C) => {
					CommonDragItem(C, {
						children: (C, E) => {
							EditableListItem(C, {
								deleteItem: W,
								get key() {
									return get(T).key;
								},
								get valueType() {
									return O();
								},
								get resultType() {
									return F();
								},
								get value() {
									return get(T).value;
								},
								set value(C) {
									get(T).value = C;
								},
								get resultValue() {
									return get(T).result;
								},
								set resultValue(C) {
									get(T).result = C;
								},
								get type() {
									return get(T).condition;
								},
								set type(C) {
									get(T).condition = C;
								}
							});
						},
						$$slots: { default: !0 }
					});
				};
				if_block(I, (C) => {
					get(T) && C(L);
				}), append(C, D);
			}), append(C, D);
		},
		$$slots: { default: !0 }
	}), reset(Y);
	var X = sibling(Y, 2), Z = child(X);
	return Z.__click = U, reset(X), reset(K), template_effect(() => Z.disabled = get(B)), append(C, K), pop(G);
}
delegate(["click"]), create_custom_element(EditableList, {
	list: {},
	bindVar: {},
	valueType: {},
	resultType: {},
	onBindVarChange: {},
	api: {}
}, [], [], !0);
var root_1$50 = /* @__PURE__ */ from_html("<div class=\"wrapper svelte-baiffd\"><!></div>"), root$27 = /* @__PURE__ */ from_html("<button class=\"advanced-operations svelte-baiffd\"></button> <!>", 1), $$css$18 = {
	hash: "svelte-baiffd",
	code: ".wrapper.svelte-baiffd {display:flex;flex-direction:column;justify-content:start;height:100%;}.advanced-operations.svelte-baiffd {white-space:nowrap;height:30px;border-top-right-radius:8px;border-bottom-right-radius:8px;background-color:#cbcbcb;padding:0 8px 0 8px;color:var(--font-deep, #333333);}"
};
function Advanced(C, T) {
	push(T, !0), append_styles(C, $$css$18);
	let E = prop(T, "bindVar", 15), D = prop(T, "valueType", 7), O = prop(T, "data", 7), F = prop(T, "onChange", 7), I = prop(T, "resultType", 7), L = prop(T, "onBindVarChange", 7), z = prop(T, "api", 7), B = /* @__PURE__ */ state(!1), V = /* @__PURE__ */ state(proxy(O())), U = D();
	user_effect(() => {
		D(), U !== D() && (set(V, [], !0), U = D());
	});
	let W = () => {
		set(B, !get(B));
	};
	var G = {
		get bindVar() {
			return E();
		},
		set bindVar(C) {
			E(C), flushSync();
		},
		get valueType() {
			return D();
		},
		set valueType(C) {
			D(C), flushSync();
		},
		get data() {
			return O();
		},
		set data(C) {
			O(C), flushSync();
		},
		get onChange() {
			return F();
		},
		set onChange(C) {
			F(C), flushSync();
		},
		get resultType() {
			return I();
		},
		set resultType(C) {
			I(C), flushSync();
		},
		get onBindVarChange() {
			return L();
		},
		set onBindVarChange(C) {
			L(C), flushSync();
		},
		get api() {
			return z();
		},
		set api(C) {
			z(C), flushSync();
		}
	}, K = root$27(), J = first_child(K);
	return J.__click = () => {
		W();
	}, CommonModalLogic(sibling(J, 2), {
		haveCurtain: !0,
		onClose: () => {
			F()(get(V));
		},
		get isOpenState() {
			return get(B);
		},
		set isOpenState(C) {
			set(B, C, !0);
		},
		children: (C, T) => {
			var O = root_1$50();
			EditableList(child(O), {
				get valueType() {
					return D();
				},
				get resultType() {
					return I();
				},
				get onBindVarChange() {
					return L();
				},
				get api() {
					return z();
				},
				get bindVar() {
					return E();
				},
				set bindVar(C) {
					E(C);
				},
				get list() {
					return get(V);
				},
				set list(C) {
					set(V, C, !0);
				}
			}), reset(O), append(C, O);
		},
		$$slots: { default: !0 }
	}), append(C, K), pop(G);
}
delegate(["click"]), create_custom_element(Advanced, {
	bindVar: {},
	valueType: {},
	data: {},
	onChange: {},
	resultType: {},
	onBindVarChange: {},
	api: {}
}, [], [], !0);
var root$26 = /* @__PURE__ */ from_html("<div class=\"wrapper svelte-142kenf\"><button aria-label=\"select value\" class=\"wrapper-value svelte-142kenf\"><p class=\"svelte-142kenf\"> </p></button></div>"), $$css$17 = {
	hash: "svelte-142kenf",
	code: ".wrapper.svelte-142kenf {width:100%;height:100%;display:flex;justify-content:left;align-items:center;color:var(--font, #ffffff);background-color:transparent;flex-direction:column;}.wrapper.svelte-142kenf .wrapper-value:where(.svelte-142kenf) {width:100%;height:100%;box-sizing:border-box;padding:0px;border:none;padding-right:0;cursor:pointer;display:flex;align-items:center;justify-content:left;flex-direction:row;background-color:transparent;color:white;}.wrapper.svelte-142kenf .wrapper-value:where(.svelte-142kenf) p:where(.svelte-142kenf) {text-align:left;width:100%;height:-moz-fit-content;height:fit-content;flex:1;overflow:hidden;margin:0;background-color:transparent;}"
};
function MCXASelect(C, T) {
	push(T, !0), append_styles(C, $$css$17);
	let E = prop(T, "value", 15), D = prop(T, "options", 7), O = prop(T, "api", 7), F = prop(T, "onChange", 7), I = /* @__PURE__ */ state(void 0), L = /* @__PURE__ */ user_derived(() => D().find((C) => C.value === E())), z = (C) => {
		E(C), F()(E());
	}, B = () => {
		let C = get(I).getBoundingClientRect();
		D().length && O().eventBus.emit("mcxa-select-option-id-3d7c2e4a-6c52-48ce-9c41-b3ab0e4adbcf", {
			value: E(),
			options: D(),
			showSelectState: !0,
			onSelect: z,
			rect: C
		});
	};
	var V = {
		get value() {
			return E();
		},
		set value(C) {
			E(C), flushSync();
		},
		get options() {
			return D();
		},
		set options(C) {
			D(C), flushSync();
		},
		get api() {
			return O();
		},
		set api(C) {
			O(C), flushSync();
		},
		get onChange() {
			return F();
		},
		set onChange(C) {
			F(C), flushSync();
		}
	}, U = root$26(), W = child(U);
	W.__click = B;
	var G = child(W), K = child(G, !0);
	return reset(G), reset(W), reset(U), bind_this(U, (C) => set(I, C), () => get(I)), template_effect(() => set_text(K, get(L) ? get(L).label : E())), append(C, U), pop(V);
}
delegate(["click"]), create_custom_element(MCXASelect, {
	value: {},
	options: {},
	api: {},
	onChange: {}
}, [], [], !0);
var root_1$49 = /* @__PURE__ */ from_html("<!> <!>", 1), root_3$16 = /* @__PURE__ */ from_html("<property-input></property-input>", 2), root$25 = /* @__PURE__ */ from_html("<div class=\"wrapper svelte-1r35q2h\"><span> </span> <div class=\"wrapper-op flex justify-between items-center gap-1 svelte-1r35q2h\"><div class=\"mcxa-select svelte-1r35q2h\"><!></div> <!></div></div>"), $$css$16 = {
	hash: "svelte-1r35q2h",
	code: ".wrapper.svelte-1r35q2h {margin:5px 5px;position:relative;width:100%;height:-moz-fit-content;height:fit-content;display:flex;justify-content:left;flex-direction:column;align-items:start;border-radius:8px;gap:8px;\n  /* border: 1px solid black; */}.wrapper.svelte-1r35q2h .wrapper-op:where(.svelte-1r35q2h) {display:flex;justify-content:space-between;align-items:center;gap:1px;}.wrapper.svelte-1r35q2h .wrapper-op:where(.svelte-1r35q2h) .mcxa-select:where(.svelte-1r35q2h) {min-width:60px;}"
};
function ControlVariables(C, T) {
	push(T, !0), append_styles(C, $$css$16);
	let E = [
		{
			label: "static",
			value: "static"
		},
		{
			label: "dynamic",
			value: "dynamic"
		},
		{
			label: "function",
			value: "function"
		}
	], D = prop(T, "variable", 7), O = prop(T, "onChange", 7), F = prop(T, "label", 7), I = prop(T, "value", 7), L = prop(T, "type", 7), z = prop(T, "options", 7), B = prop(T, "api", 7), V = /* @__PURE__ */ state(proxy(D())), U = /* @__PURE__ */ state(proxy(get(V).isDynamic ? "dynamic" : "static"));
	user_effect(() => {
		get(V).isDynamic, get(V).type, get(V).bindVar, get(V).expression, requestAnimationFrame(() => {
			O()(get(V));
		});
	});
	function W(C, T = /* @__PURE__ */ new WeakMap()) {
		if (typeof C != "object" || !C) return C;
		if (T.has(C)) return T.get(C);
		if (C instanceof Date) return new Date(C.getTime());
		if (C instanceof RegExp) return new RegExp(C.source, C.flags);
		if (C instanceof Map) {
			let E = /* @__PURE__ */ new Map();
			return T.set(C, E), C.forEach((C, D) => {
				E.set(W(D, T), W(C, T));
			}), E;
		}
		if (C instanceof Set) {
			let E = /* @__PURE__ */ new Set();
			return T.set(C, E), C.forEach((C) => E.add(W(C, T))), E;
		}
		if (Array.isArray(C)) {
			let E = [];
			T.set(C, E);
			for (let D of C) E.push(W(D, T));
			return E;
		}
		let E = Object.create(Object.getPrototypeOf(C));
		T.set(C, E);
		let D = [...Object.getOwnPropertyNames(C), ...Object.getOwnPropertySymbols(C)];
		for (let O of D) E[O] = W(C[O], T);
		return E;
	}
	function G(C) {
		let T = C.split(".").pop(), E = B().structAndVarRelationIntegrate.getTreeFlattener();
		if (T) {
			var D;
			let C = (D = E.getNodeBySourceId(T)) == null ? void 0 : D.source;
			if (C) {
				let T = C.dataType;
				if ([
					"char",
					"string",
					"unsigned char"
				].includes(T)) return "string";
				if (T === "bool") return "boolean";
				if ([
					"float",
					"double",
					"long double"
				].includes(T)) return "float";
				if (["unsigned short", "unsigned long long"].includes(T)) return "unsigned";
			}
		}
		return "number";
	}
	let K = /* @__PURE__ */ state("number"), J = /* @__PURE__ */ user_derived(() => {
		var C;
		let T = (C = get(V).bindVar) == null ? void 0 : C.split(".").pop();
		if (!T) return !0;
		let E = B().structAndVarRelationIntegrate.getTreeFlattener();
		if (T) {
			var D;
			let C = (D = E.getNodeBySourceId(T)) == null ? void 0 : D.source;
			if (C) {
				let T = C.dataType;
				if (["char", "string"].includes(T)) return get(V).type !== "string";
			}
		}
		return !1;
	}), Y = get(V).type;
	function X(C) {
		return C.length ? C.map((C) => ({
			key: C.key,
			condition: C.condition,
			value: [...C.value],
			valueType: C.valueType,
			result: C.result
		})) : [];
	}
	function Z(C) {
		let T = X(C);
		get(V).expression = T;
	}
	function Q(C) {
		set(K, G(C.str), !0), get(V).bindVar = C.str;
	}
	user_effect(() => {
		get(U), get(V).isDynamic = get(U) === "dynamic";
	});
	var NL = {
		get variable() {
			return D();
		},
		set variable(C) {
			D(C), flushSync();
		},
		get onChange() {
			return O();
		},
		set onChange(C) {
			O(C), flushSync();
		},
		get label() {
			return F();
		},
		set label(C) {
			F(C), flushSync();
		},
		get value() {
			return I();
		},
		set value(C) {
			I(C), flushSync();
		},
		get type() {
			return L();
		},
		set type(C) {
			L(C), flushSync();
		},
		get options() {
			return z();
		},
		set options(C) {
			z(C), flushSync();
		},
		get api() {
			return B();
		},
		set api(C) {
			B(C), flushSync();
		}
	}, PL = root$25(), FL = child(PL), IL = child(FL, !0);
	reset(FL);
	var LL = sibling(FL, 2), RL = child(LL);
	MCXASelect(child(RL), {
		get api() {
			return B();
		},
		get options() {
			return E;
		},
		onChange: (C) => {
			console.log(C);
		},
		get value() {
			return get(U);
		},
		set value(C) {
			set(U, C, !0);
		}
	}), reset(RL);
	var zL = sibling(RL, 2), BL = (C) => {
		var T = root_1$49(), E = first_child(T);
		Cascader(E, {
			get disabled() {
				return get(J);
			},
			onChange: Q,
			get type() {
				return get(V).type;
			},
			checkToClosePopup: !0,
			get api() {
				return B();
			},
			get value() {
				return get(V).bindVar;
			},
			set value(C) {
				get(V).bindVar = C;
			}
		});
		var D = sibling(E, 2);
		{
			let C = /* @__PURE__ */ user_derived(() => {
				var C;
				return (C = get(V).bindVar) == null ? "" : C;
			}), T = /* @__PURE__ */ user_derived(() => {
				var C;
				return W((C = get(V).expression) == null ? [] : C);
			});
			Advanced(D, {
				get valueType() {
					return get(K);
				},
				get bindVar() {
					return get(C);
				},
				get data() {
					return get(T);
				},
				onChange: Z,
				onBindVarChange: Q,
				get resultType() {
					return Y;
				},
				get api() {
					return B();
				}
			});
		}
		append(C, T);
	}, VL = (C) => {
		var T = comment(), E = first_child(T), D = (C) => {
			var T = root_3$16();
			template_effect(() => set_custom_element_data(T, "label", F())), template_effect(() => set_custom_element_data(T, "value", I())), template_effect(() => set_custom_element_data(T, "type", L())), template_effect(() => set_custom_element_data(T, "options", z())), event("Change", T, function(...C) {
				var T;
				(T = O()) == null || T.apply(this, C);
			}), append(C, T);
		};
		if_block(E, (C) => {
			get(U) === "static" && C(D);
		}, !0), append(C, T);
	};
	return if_block(zL, (C) => {
		get(U) === "dynamic" ? C(BL) : C(VL, !1);
	}), reset(LL), reset(PL), template_effect(() => set_text(IL, F())), append(C, PL), pop(NL);
}
customElements.define("control-variables", create_custom_element(ControlVariables, {
	variable: {},
	onChange: {},
	label: {},
	value: {},
	type: {},
	options: {},
	api: {}
}, [], [], !0));
var root_1$48 = /* @__PURE__ */ from_html("<div class=\"tooltip-content svelte-10y7o9n\"> </div>"), root$24 = /* @__PURE__ */ from_html("<div class=\"tooltip svelte-10y7o9n\"><!> <!></div>"), $$css$15 = {
	hash: "svelte-10y7o9n",
	code: "@charset \"UTF-8\";.tooltip.svelte-10y7o9n {position:relative;height:-moz-max-content;height:max-content;width:-moz-max-content;width:max-content;}.tooltip.svelte-10y7o9n .tooltip-content:where(.svelte-10y7o9n) {z-index:9999;display:block; /*  block isActive  */position:fixed;padding:4px 10px;border-radius:8px;background-color:rgba(0, 0, 0, 0.85);color:white;box-sizing:border-box;border:1px solid #ccc;font-size:14px;pointer-events:none; /*  */}"
};
function Tooltip(C, T) {
	push(T, !0), append_styles(C, $$css$15);
	let E = prop(T, "children", 7), D = prop(T, "title", 7), O = prop(T, "height", 7, void 0), F = /* @__PURE__ */ state(null), I = /* @__PURE__ */ state(!1);
	var L = {
		get children() {
			return E();
		},
		set children(C) {
			E(C), flushSync();
		},
		get title() {
			return D();
		},
		set title(C) {
			D(C), flushSync();
		},
		get height() {
			return O();
		},
		set height(C = void 0) {
			O(C), flushSync();
		}
	}, z = root$24(), B = child(z);
	snippet(B, E);
	var V = sibling(B, 2), U = (C) => {
		var T = root_1$48(), E = child(T, !0);
		reset(T), template_effect((C) => {
			set_style(T, C), set_text(E, D());
		}, [() => `top: ${get(F).getBoundingClientRect().bottom}px;
                     left: ${get(F).getBoundingClientRect().left}px`]), append(C, T);
	};
	return if_block(V, (C) => {
		get(F) && get(I) && C(U);
	}), reset(z), bind_this(z, (C) => set(F, C), () => get(F)), template_effect(() => set_style(z, O() ? `height:${O()}` : "")), event("mouseenter", z, () => set(I, !0)), event("mouseleave", z, () => set(I, !1)), append(C, z), pop(L);
}
create_custom_element(Tooltip, {
	children: {},
	title: {},
	height: {}
}, [], [], !0);
var r = {
	grad: .9,
	turn: 360,
	rad: 360 / (2 * Math.PI)
}, t$1 = function(C) {
	return typeof C == "string" ? C.length > 0 : typeof C == "number";
}, n = function(C, T, E) {
	return T === void 0 && (T = 0), E === void 0 && (E = Math.pow(10, T)), Math.round(E * C) / E + 0;
}, e = function(C, T, E) {
	return T === void 0 && (T = 0), E === void 0 && (E = 1), C > E ? E : C > T ? C : T;
}, u = function(C) {
	return (C = isFinite(C) ? C % 360 : 0) > 0 ? C : C + 360;
}, a = function(C) {
	return {
		r: e(C.r, 0, 255),
		g: e(C.g, 0, 255),
		b: e(C.b, 0, 255),
		a: e(C.a)
	};
}, o$1 = function(C) {
	return {
		r: n(C.r),
		g: n(C.g),
		b: n(C.b),
		a: n(C.a, 3)
	};
}, i = /^#([0-9a-f]{3,8})$/i, s = function(C) {
	var T = C.toString(16);
	return T.length < 2 ? "0" + T : T;
}, h = function(C) {
	var T = C.r, E = C.g, D = C.b, O = C.a, F = Math.max(T, E, D), I = F - Math.min(T, E, D), L = I ? F === T ? (E - D) / I : F === E ? 2 + (D - T) / I : 4 + (T - E) / I : 0;
	return {
		h: 60 * (L < 0 ? L + 6 : L),
		s: F ? I / F * 100 : 0,
		v: F / 255 * 100,
		a: O
	};
}, b = function(C) {
	var T = C.h, E = C.s, D = C.v, O = C.a;
	T = T / 360 * 6, E /= 100, D /= 100;
	var F = Math.floor(T), I = D * (1 - E), L = D * (1 - (T - F) * E), z = D * (1 - (1 - T + F) * E), B = F % 6;
	return {
		r: 255 * [
			D,
			L,
			I,
			I,
			z,
			D
		][B],
		g: 255 * [
			z,
			D,
			D,
			L,
			I,
			I
		][B],
		b: 255 * [
			I,
			I,
			z,
			D,
			D,
			L
		][B],
		a: O
	};
}, g = function(C) {
	return {
		h: u(C.h),
		s: e(C.s, 0, 100),
		l: e(C.l, 0, 100),
		a: e(C.a)
	};
}, d = function(C) {
	return {
		h: n(C.h),
		s: n(C.s),
		l: n(C.l),
		a: n(C.a, 3)
	};
}, f = function(C) {
	return b((E = (T = C).s, {
		h: T.h,
		s: (E *= ((D = T.l) < 50 ? D : 100 - D) / 100) > 0 ? 2 * E / (D + E) * 100 : 0,
		v: D + E,
		a: T.a
	}));
	var T, E, D;
}, c = function(C) {
	return {
		h: (T = h(C)).h,
		s: (O = (200 - (E = T.s)) * (D = T.v) / 100) > 0 && O < 200 ? E * D / 100 / (O <= 100 ? O : 200 - O) * 100 : 0,
		l: O / 2,
		a: T.a
	};
	var T, E, D, O;
}, l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, y = {
	string: [
		[function(C) {
			var T = i.exec(C);
			return T ? (C = T[1]).length <= 4 ? {
				r: parseInt(C[0] + C[0], 16),
				g: parseInt(C[1] + C[1], 16),
				b: parseInt(C[2] + C[2], 16),
				a: C.length === 4 ? n(parseInt(C[3] + C[3], 16) / 255, 2) : 1
			} : C.length === 6 || C.length === 8 ? {
				r: parseInt(C.substr(0, 2), 16),
				g: parseInt(C.substr(2, 2), 16),
				b: parseInt(C.substr(4, 2), 16),
				a: C.length === 8 ? n(parseInt(C.substr(6, 2), 16) / 255, 2) : 1
			} : null : null;
		}, "hex"],
		[function(C) {
			var T = v.exec(C) || m.exec(C);
			return T ? T[2] !== T[4] || T[4] !== T[6] ? null : a({
				r: Number(T[1]) / (T[2] ? 100 / 255 : 1),
				g: Number(T[3]) / (T[4] ? 100 / 255 : 1),
				b: Number(T[5]) / (T[6] ? 100 / 255 : 1),
				a: T[7] === void 0 ? 1 : Number(T[7]) / (T[8] ? 100 : 1)
			}) : null;
		}, "rgb"],
		[function(C) {
			var T = l.exec(C) || p.exec(C);
			if (!T) return null;
			var E, D;
			return f(g({
				h: (E = T[1], D = T[2], D === void 0 && (D = "deg"), Number(E) * (r[D] || 1)),
				s: Number(T[3]),
				l: Number(T[4]),
				a: T[5] === void 0 ? 1 : Number(T[5]) / (T[6] ? 100 : 1)
			}));
		}, "hsl"]
	],
	object: [
		[function(C) {
			var T = C.r, E = C.g, D = C.b, O = C.a, F = O === void 0 ? 1 : O;
			return t$1(T) && t$1(E) && t$1(D) ? a({
				r: Number(T),
				g: Number(E),
				b: Number(D),
				a: Number(F)
			}) : null;
		}, "rgb"],
		[function(C) {
			var T = C.h, E = C.s, D = C.l, O = C.a, F = O === void 0 ? 1 : O;
			return !t$1(T) || !t$1(E) || !t$1(D) ? null : f(g({
				h: Number(T),
				s: Number(E),
				l: Number(D),
				a: Number(F)
			}));
		}, "hsl"],
		[function(C) {
			var T = C.h, E = C.s, D = C.v, O = C.a, F = O === void 0 ? 1 : O;
			return !t$1(T) || !t$1(E) || !t$1(D) ? null : b(function(C) {
				return {
					h: u(C.h),
					s: e(C.s, 0, 100),
					v: e(C.v, 0, 100),
					a: e(C.a)
				};
			}({
				h: Number(T),
				s: Number(E),
				v: Number(D),
				a: Number(F)
			}));
		}, "hsv"]
	]
}, N = function(C, T) {
	for (var E = 0; E < T.length; E++) {
		var D = T[E][0](C);
		if (D) return [D, T[E][1]];
	}
	return [null, void 0];
}, x = function(C) {
	return typeof C == "string" ? N(C.trim(), y.string) : typeof C == "object" && C ? N(C, y.object) : [null, void 0];
}, M = function(C, T) {
	var E = c(C);
	return {
		h: E.h,
		s: e(E.s + 100 * T, 0, 100),
		l: E.l,
		a: E.a
	};
}, H = function(C) {
	return (299 * C.r + 587 * C.g + 114 * C.b) / 1e3 / 255;
}, $ = function(C, T) {
	var E = c(C);
	return {
		h: E.h,
		s: E.s,
		l: e(E.l + 100 * T, 0, 100),
		a: E.a
	};
}, j = function() {
	function C(C) {
		this.parsed = x(C)[0], this.rgba = this.parsed || {
			r: 0,
			g: 0,
			b: 0,
			a: 1
		};
	}
	return C.prototype.isValid = function() {
		return this.parsed !== null;
	}, C.prototype.brightness = function() {
		return n(H(this.rgba), 2);
	}, C.prototype.isDark = function() {
		return H(this.rgba) < .5;
	}, C.prototype.isLight = function() {
		return H(this.rgba) >= .5;
	}, C.prototype.toHex = function() {
		return C = o$1(this.rgba), T = C.r, E = C.g, D = C.b, F = (O = C.a) < 1 ? s(n(255 * O)) : "", "#" + s(T) + s(E) + s(D) + F;
		var C, T, E, D, O, F;
	}, C.prototype.toRgb = function() {
		return o$1(this.rgba);
	}, C.prototype.toRgbString = function() {
		return C = o$1(this.rgba), T = C.r, E = C.g, D = C.b, (O = C.a) < 1 ? "rgba(" + T + ", " + E + ", " + D + ", " + O + ")" : "rgb(" + T + ", " + E + ", " + D + ")";
		var C, T, E, D, O;
	}, C.prototype.toHsl = function() {
		return d(c(this.rgba));
	}, C.prototype.toHslString = function() {
		return C = d(c(this.rgba)), T = C.h, E = C.s, D = C.l, (O = C.a) < 1 ? "hsla(" + T + ", " + E + "%, " + D + "%, " + O + ")" : "hsl(" + T + ", " + E + "%, " + D + "%)";
		var C, T, E, D, O;
	}, C.prototype.toHsv = function() {
		return C = h(this.rgba), {
			h: n(C.h),
			s: n(C.s),
			v: n(C.v),
			a: n(C.a, 3)
		};
		var C;
	}, C.prototype.invert = function() {
		return w({
			r: 255 - (C = this.rgba).r,
			g: 255 - C.g,
			b: 255 - C.b,
			a: C.a
		});
		var C;
	}, C.prototype.saturate = function(C) {
		return C === void 0 && (C = .1), w(M(this.rgba, C));
	}, C.prototype.desaturate = function(C) {
		return C === void 0 && (C = .1), w(M(this.rgba, -C));
	}, C.prototype.grayscale = function() {
		return w(M(this.rgba, -1));
	}, C.prototype.lighten = function(C) {
		return C === void 0 && (C = .1), w($(this.rgba, C));
	}, C.prototype.darken = function(C) {
		return C === void 0 && (C = .1), w($(this.rgba, -C));
	}, C.prototype.rotate = function(C) {
		return C === void 0 && (C = 15), this.hue(this.hue() + C);
	}, C.prototype.alpha = function(C) {
		return typeof C == "number" ? w({
			r: (T = this.rgba).r,
			g: T.g,
			b: T.b,
			a: C
		}) : n(this.rgba.a, 3);
		var T;
	}, C.prototype.hue = function(C) {
		var T = c(this.rgba);
		return typeof C == "number" ? w({
			h: C,
			s: T.s,
			l: T.l,
			a: T.a
		}) : n(T.h);
	}, C.prototype.isEqual = function(C) {
		return this.toHex() === w(C).toHex();
	}, C;
}(), w = function(C) {
	return C instanceof j ? C : new j(C);
}, S = [], k = function(C) {
	C.forEach(function(C) {
		S.indexOf(C) < 0 && (C(j, y), S.push(C));
	});
}, root_1$47 = /* @__PURE__ */ from_html("<input type=\"hidden\"/>"), root$23 = /* @__PURE__ */ from_html("<div role=\"slider\" tabindex=\"0\"><div class=\"track svelte-1fbosnr\"></div> <div class=\"thumb svelte-1fbosnr\"></div></div> <!>", 1), $$css$14 = {
	hash: "svelte-1fbosnr",
	code: ".slider.svelte-1fbosnr {---track-width: var(--track-width, unset);---track-height: var(--track-height, 6px);---track-background: var(--track-background, #949494);---track-border: var(--track-border, none);---thumb-size: var(--thumb-size, 16px);---thumb-background: var(--thumb-background, #2d2d2d);---thumb-border: var(--thumb-border, none);---position: var(--position, 0px);---margin-inline-thumb-bigger: max(var(---thumb-size) - var(---track-height), 0px);---margin-inline-thumb-smaller: max(var(---track-height) - var(---thumb-size), 0px);position:relative;margin:auto;-moz-user-select:none;user-select:none;-webkit-user-select:none;background-color:transparent;cursor:pointer;}.slider.svelte-1fbosnr::before {background-color:transparent;}[aria-orientation='horizontal'].svelte-1fbosnr {width:var(---track-width);max-width:calc(100% - 2 * var(---margin-inline-thumb-bigger));height:calc(max(var(---track-height), var(---thumb-size)) + 4px);height:max(var(---track-height), var(---thumb-size));margin-inline:var(---margin-inline-thumb-bigger);margin-block:var(--margin-block, 8px);}[aria-orientation='vertical'].svelte-1fbosnr {width:max(var(---track-height), var(---thumb-size));height:var(---track-width);max-height:calc(100% - 2 * var(---margin-inline-thumb-bigger));margin-block:var(---margin-inline-thumb-bigger);margin-inline:var(--margin-block, 8px);}.track.svelte-1fbosnr {position:absolute;pointer-events:none;background:var(---track-background);border:var(---track-border);border-radius:calc(var(---track-height) / 2);box-sizing:border-box;}[aria-orientation='horizontal'].svelte-1fbosnr .track:where(.svelte-1fbosnr) {height:var(---track-height);top:50%;transform:translateY(-50%);left:0;right:0;}[aria-orientation='vertical'].svelte-1fbosnr .track:where(.svelte-1fbosnr) {width:var(---track-height);left:50%;transform:translateX(-50%);top:0;bottom:0;}.thumb.svelte-1fbosnr {pointer-events:none;position:absolute;height:var(---thumb-size);width:var(---thumb-size);border-radius:calc(var(---thumb-size) / 2);background:var(---thumb-background);border:var(---thumb-border);box-sizing:border-box;transform:translate(-50%, -50%);--margin-left: (2 * var(---track-height) - var(---thumb-size) - var(---margin-inline-thumb-smaller)) / 2;--left: calc(var(---position) * (100% - 2 * var(--margin-left)) + var(--margin-left));}[aria-orientation='horizontal'].svelte-1fbosnr:not(.reverse) .thumb:where(.svelte-1fbosnr) {top:50%;left:var(--left);}[aria-orientation='vertical'].svelte-1fbosnr:not(.reverse) .thumb:where(.svelte-1fbosnr) {left:50%;bottom:calc(var(--left) - var(---thumb-size));}[aria-orientation='horizontal'].reverse.svelte-1fbosnr .thumb:where(.svelte-1fbosnr) {top:50%;right:calc(var(--left) - var(---thumb-size));}[aria-orientation='vertical'].reverse.svelte-1fbosnr .thumb:where(.svelte-1fbosnr) {left:50%;top:calc(var(--left));}.slider.svelte-1fbosnr:focus-visible {outline:none;}.slider.svelte-1fbosnr:focus-visible .track:where(.svelte-1fbosnr) {outline:2px solid var(--focus-color, red);outline-offset:2px;}"
};
function Slider$1(C, T) {
	push(T, !0), append_styles(C, $$css$14);
	let E = prop(T, "min", 7, 0), D = prop(T, "max", 7, 100), O = prop(T, "step", 7, 1), F = prop(T, "value", 15, 50), I = prop(T, "ariaValueText", 7, (C) => C.toString()), L = prop(T, "name", 7), z = prop(T, "direction", 7, "horizontal"), B = prop(T, "reverse", 7, !1), V = prop(T, "keyboardOnly", 7, !1), U = prop(T, "slider", 7), W = prop(T, "ariaLabel", 7), G = prop(T, "ariaLabelledBy", 7), K = prop(T, "ariaControls", 7), J = prop(T, "isDragging", 7, !1), Y = prop(T, "onInput", 7), X = /* @__PURE__ */ user_derived(() => typeof E() == "string" ? parseFloat(E()) : E()), Z = /* @__PURE__ */ user_derived(() => typeof D() == "string" ? parseFloat(D()) : D()), Q = /* @__PURE__ */ user_derived(() => typeof O() == "string" ? parseFloat(O()) : O());
	function NL(C) {
		let T = 1 / get(Q), E = Math.round(C * T) / T;
		return Math.max(get(X), Math.min(get(Z), E));
	}
	function PL(C) {
		var T;
		let E = C.shiftKey ? get(Q) * 10 : get(Q);
		C.key === "ArrowUp" || C.key === "ArrowRight" ? (F(F() + E), C.preventDefault()) : C.key === "ArrowDown" || C.key === "ArrowLeft" ? (F(F() - E), C.preventDefault()) : C.key === "Home" ? (F(get(X)), C.preventDefault()) : C.key === "End" ? (F(get(Z)), C.preventDefault()) : C.key === "PageUp" ? (F(F() + get(Q) * 10), C.preventDefault()) : C.key === "PageDown" && (F(F() - get(Q) * 10), C.preventDefault()), F(NL(F())), (T = Y()) == null || T(F());
	}
	let FL = {
		horizontal: {
			clientSize: "clientWidth",
			offset: "left",
			client: "clientX"
		},
		vertical: {
			clientSize: "clientHeight",
			offset: "top",
			client: "clientY"
		}
	};
	function IL(C) {
		var T, E, D;
		let O = ((T = U()) == null ? void 0 : T[FL[z()].clientSize]) || 120, I = ((E = U()) == null ? void 0 : E.getBoundingClientRect()[FL[z()].offset]) || 0, L = C[FL[z()].client] - I;
		z() === "vertical" && (L = -1 * L + O), B() ? F(get(Z) - L / O * (get(Z) - get(X))) : F(L / O * (get(Z) - get(X)) + get(X)), F(NL(F())), (D = Y()) == null || D(F());
	}
	function LL(C) {
		IL(C), J(!0);
	}
	function RL(C) {
		J() && IL(C);
	}
	function zL() {
		J(!1);
	}
	function BL(C) {
		C.preventDefault(), IL({
			clientX: C.changedTouches[0].clientX,
			clientY: C.changedTouches[0].clientY
		});
	}
	let VL = /* @__PURE__ */ user_derived(() => ((F() - get(X)) / (get(Z) - get(X)) * 1).toFixed(4));
	var HL = {
		get min() {
			return E();
		},
		set min(C = 0) {
			E(C), flushSync();
		},
		get max() {
			return D();
		},
		set max(C = 100) {
			D(C), flushSync();
		},
		get step() {
			return O();
		},
		set step(C = 1) {
			O(C), flushSync();
		},
		get value() {
			return F();
		},
		set value(C = 50) {
			F(C), flushSync();
		},
		get ariaValueText() {
			return I();
		},
		set ariaValueText(C = (C) => C.toString()) {
			I(C), flushSync();
		},
		get name() {
			return L();
		},
		set name(C) {
			L(C), flushSync();
		},
		get direction() {
			return z();
		},
		set direction(C = "horizontal") {
			z(C), flushSync();
		},
		get reverse() {
			return B();
		},
		set reverse(C = !1) {
			B(C), flushSync();
		},
		get keyboardOnly() {
			return V();
		},
		set keyboardOnly(C = !1) {
			V(C), flushSync();
		},
		get slider() {
			return U();
		},
		set slider(C) {
			U(C), flushSync();
		},
		get ariaLabel() {
			return W();
		},
		set ariaLabel(C) {
			W(C), flushSync();
		},
		get ariaLabelledBy() {
			return G();
		},
		set ariaLabelledBy(C) {
			G(C), flushSync();
		},
		get ariaControls() {
			return K();
		},
		set ariaControls(C) {
			K(C), flushSync();
		},
		get isDragging() {
			return J();
		},
		set isDragging(C = !1) {
			J(C), flushSync();
		},
		get onInput() {
			return Y();
		},
		set onInput(C) {
			Y(C), flushSync();
		}
	}, UL = root$23();
	event("mousemove", $window, RL), event("mouseup", $window, zL);
	var WL = first_child(UL);
	let GL;
	WL.__keydown = PL, WL.__mousedown = function(...C) {
		var T;
		(T = V() ? void 0 : LL) == null || T.apply(this, C);
	}, WL.__touchstart = function(...C) {
		var T;
		(T = V() ? void 0 : BL) == null || T.apply(this, C);
	}, WL.__touchmove = function(...C) {
		var T;
		(T = V() ? void 0 : BL) == null || T.apply(this, C);
	}, WL.__touchend = function(...C) {
		var T;
		(T = V() ? void 0 : BL) == null || T.apply(this, C);
	};
	let KL;
	bind_this(WL, (C) => U(C), () => U());
	var qL = sibling(WL, 2), JL = (C) => {
		var T = root_1$47();
		remove_input_defaults(T), template_effect(() => {
			set_attribute(T, "name", L()), set_value(T, F());
		}), append(C, T);
	};
	return if_block(qL, (C) => {
		L() && C(JL);
	}), template_effect((C) => {
		GL = set_class(WL, 1, "slider svelte-1fbosnr", null, GL, { reverse: B() }), set_attribute(WL, "aria-orientation", z()), set_attribute(WL, "aria-valuemax", get(Z)), set_attribute(WL, "aria-valuemin", get(X)), set_attribute(WL, "aria-valuenow", F()), set_attribute(WL, "aria-valuetext", C), set_attribute(WL, "aria-label", W()), set_attribute(WL, "aria-labelledby", G()), set_attribute(WL, "aria-controls", K()), KL = set_style(WL, "", KL, { "--position": get(VL) });
	}, [() => I()(F())]), append(C, UL), pop(HL);
}
delegate([
	"keydown",
	"mousedown",
	"touchstart",
	"touchmove",
	"touchend"
]), create_custom_element(Slider$1, {
	min: {},
	max: {},
	step: {},
	value: {},
	ariaValueText: {},
	name: {},
	direction: {},
	reverse: {},
	keyboardOnly: {},
	slider: {},
	ariaLabel: {},
	ariaLabelledBy: {},
	ariaControls: {},
	isDragging: {},
	onInput: {}
}, [], [], !0);
var root$22 = /* @__PURE__ */ from_html("<div class=\"picker svelte-1uo4uxr\"><!> <div class=\"s svelte-1uo4uxr\"><!></div> <div class=\"v svelte-1uo4uxr\"><!></div></div>"), $$css$13 = {
	hash: "svelte-1uo4uxr",
	code: ".picker.svelte-1uo4uxr {position:relative;display:inline-block;width:var(--picker-width, 180px);height:var(--picker-height, 120px);background:linear-gradient(#ffffff00, #000000ff),\r\n			linear-gradient(0.25turn, #ffffffff, #00000000),\r\n			var(--picker-color-bg);border-radius:var(--picker-radius, 4px);outline:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;cursor:pointer;}.s.svelte-1uo4uxr,\r\n	.v.svelte-1uo4uxr {position:absolute;--track-background: none;--track-border: none;--thumb-background: none;--thumb-border: none;--thumb-size: 2px;--margin-block: 0;--track-height: var(--picker-indicator-size, 10px);-moz-user-select:none;user-select:none;-webkit-user-select:none;}.s.svelte-1uo4uxr {top:calc(\r\n			var(--pos-y) *\r\n				(\r\n					var(--picker-height, 180px) -\r\n						var(--picker-indicator-size, 10px) - 4px\r\n				) / 100 + 2px\r\n		);left:2px;--track-width: calc(var(--picker-width, 180px) - 4px);}.v.svelte-1uo4uxr {top:2px;left:calc(\r\n			var(--pos-x) *\r\n				(\r\n					var(--picker-width, 120px) -\r\n						var(--picker-indicator-size, 10px) - 4px\r\n				) / 100 + 2px\r\n		);--track-width: calc(var(--picker-height, 120px) - 4px);}"
};
function Picker(C, E) {
	push(E, !0), append_styles(C, $$css$13);
	let D = prop(E, "components", 7), O = prop(E, "h", 7), F = prop(E, "s", 15), I = prop(E, "v", 15), L = prop(E, "isDark", 7), z = prop(E, "texts", 7), B = prop(E, "onInput", 7), V = /* @__PURE__ */ state(void 0), U = !1, W = /* @__PURE__ */ state(proxy({
		x: 100,
		y: 0
	})), G = /* @__PURE__ */ user_derived(() => w({
		h: O(),
		s: 100,
		v: 100,
		a: 1
	}).toHex());
	function K(C, T, E) {
		return Math.min(Math.max(T, C), E);
	}
	function J(C) {
		if (!get(V)) return;
		let { width: T, left: E, height: D, top: O } = get(V).getBoundingClientRect(), L = {
			x: K(C.clientX - E, 0, T),
			y: K(C.clientY - O, 0, D)
		};
		F(K(L.x / T, 0, 1) * 100), I(K((D - L.y) / D, 0, 1) * 100), NL();
	}
	function Y(C) {
		C.preventDefault(), C.button === 0 && (U = !0, J(C));
	}
	function X() {
		U = !1;
	}
	function Z(C) {
		U && J(C);
	}
	function Q(C) {
		C.preventDefault(), J(C.changedTouches[0]);
	}
	user_effect(() => {
		typeof F() == "number" && typeof I() == "number" && get(V) && set(W, {
			x: F(),
			y: 100 - I()
		}, !0);
	});
	function NL(C = {}) {
		B()(_objectSpread2({
			s: F(),
			v: I()
		}, C));
	}
	var PL = {
		get components() {
			return D();
		},
		set components(C) {
			D(C), flushSync();
		},
		get h() {
			return O();
		},
		set h(C) {
			O(C), flushSync();
		},
		get s() {
			return F();
		},
		set s(C) {
			F(C), flushSync();
		},
		get v() {
			return I();
		},
		set v(C) {
			I(C), flushSync();
		},
		get isDark() {
			return L();
		},
		set isDark(C) {
			L(C), flushSync();
		},
		get texts() {
			return z();
		},
		set texts(C) {
			z(C), flushSync();
		},
		get onInput() {
			return B();
		},
		set onInput(C) {
			B(C), flushSync();
		}
	}, FL = root$22();
	event("mouseup", $window, X), event("mousemove", $window, Z), FL.__mousedown = Y, FL.__touchstart = Q, FL.__touchmove = Q, FL.__touchend = Q;
	let IL;
	var LL = child(FL);
	component(LL, () => D().pickerIndicator, (C, T) => {
		T(C, {
			get pos() {
				return get(W);
			},
			get isDark() {
				return L();
			}
		});
	});
	var RL = sibling(LL, 2);
	let zL;
	Slider$1(child(RL), {
		get value() {
			return F();
		},
		onInput: (C) => NL({ s: C }),
		keyboardOnly: !0,
		ariaValueText: (C) => `${C}%`,
		get ariaLabel() {
			return z().label.s;
		}
	}), reset(RL);
	var BL = sibling(RL, 2);
	let VL;
	return Slider$1(child(BL), {
		get value() {
			return I();
		},
		onInput: (C) => NL({ v: C }),
		keyboardOnly: !0,
		ariaValueText: (C) => `${C}%`,
		direction: "vertical",
		get ariaLabel() {
			return z().label.v;
		}
	}), reset(BL), reset(FL), bind_this(FL, (C) => set(V, C), () => get(V)), template_effect(() => {
		IL = set_style(FL, "", IL, { "--picker-color-bg": get(G) }), zL = set_style(RL, "", zL, { "--pos-y": get(W).y }), VL = set_style(BL, "", VL, { "--pos-x": get(W).x });
	}), append(C, FL), pop(PL);
}
delegate([
	"mousedown",
	"touchstart",
	"touchmove",
	"touchend"
]), create_custom_element(Picker, {
	components: {},
	h: {},
	s: {},
	v: {},
	isDark: {},
	texts: {},
	onInput: {}
}, [], [], !0);
var root$21 = /* @__PURE__ */ from_html("<div class=\"picker-indicator svelte-37gmp6\"></div>"), $$css$12 = {
	hash: "svelte-37gmp6",
	code: "div.svelte-37gmp6 {position:absolute;left:calc(var(--pos-x) * (var(--picker-width, 180px) - 2px) / 100 - var(--picker-indicator-size, 10px) / 2 + 1px);top:calc(var(--pos-y) * (var(--picker-height, 120px) - 2px) / 100 - var(--picker-indicator-size, 10px) / 2 + 1px);width:var(--picker-indicator-size, 10px);height:var(--picker-indicator-size, 10px);background-color:white;box-shadow:0 0 4px black;border-radius:50%;pointer-events:none;z-index:1;transition:box-shadow 0.2s;}"
};
function PickerIndicator(C, T) {
	push(T, !0), append_styles(C, $$css$12);
	let E = prop(T, "pos", 7);
	var D = {
		get pos() {
			return E();
		},
		set pos(C) {
			E(C), flushSync();
		}
	}, O = root$21();
	let F;
	return template_effect(() => F = set_style(O, "", F, {
		"--pos-x": E().x,
		"--pos-y": E().y
	})), append(C, O), pop(D);
}
create_custom_element(PickerIndicator, { pos: {} }, [], [], !0);
var root_1$46 = /* @__PURE__ */ from_html("<input class=\"svelte-1ort40\"/>"), root_3$15 = /* @__PURE__ */ from_html("<input type=\"number\" min=\"0\" max=\"255\" class=\"svelte-1ort40\"/> <input type=\"number\" min=\"0\" max=\"255\" class=\"svelte-1ort40\"/> <input type=\"number\" min=\"0\" max=\"255\" class=\"svelte-1ort40\"/>", 1), root_4$11 = /* @__PURE__ */ from_html("<input type=\"number\" min=\"0\" max=\"360\" class=\"svelte-1ort40\"/> <input type=\"number\" min=\"0\" max=\"100\" class=\"svelte-1ort40\"/> <input type=\"number\" min=\"0\" max=\"100\" class=\"svelte-1ort40\"/>", 1), root_5$9 = /* @__PURE__ */ from_html("<input type=\"number\" min=\"0\" max=\"1\" step=\"0.01\" class=\"svelte-1ort40\"/>"), root_6$5 = /* @__PURE__ */ from_html("<div class=\"wrapper-buttons svelte-1ort40\"><button type=\"button\" class=\"svelte-1ort40\"><span class=\"disappear svelte-1ort40\" aria-hidden=\"true\"> </span> <span class=\"appear svelte-1ort40\"> </span></button> <button class=\"button-icon svelte-1ort40\" aria-label=\"triggerColorPicker\"><span></span></button></div>"), root_7$3 = /* @__PURE__ */ from_html("<div class=\"button-like svelte-1ort40\"> </div>"), root$20 = /* @__PURE__ */ from_html("<div class=\"text-input svelte-1ort40\"><div class=\"input-container svelte-1ort40\"><!> <!></div> <!></div>"), $$css$11 = {
	hash: "svelte-1ort40",
	code: ".text-input.svelte-1ort40 {margin:var(--text-input-margin, 5px 0 0);}.input-container.svelte-1ort40 {display:flex;flex:1;gap:10px;}input.svelte-1ort40,\r\n  button.svelte-1ort40,\r\n  .button-like.svelte-1ort40 {flex:1;border:none;background-color:var(--cp-input-color, #eee);color:var(--cp-text-color, var(--cp-border-color));padding:0;border-radius:5px;height:30px;line-height:30px;text-align:center;}input.svelte-1ort40 {width:5px;font-family:inherit;}button.svelte-1ort40,\r\n  .button-like.svelte-1ort40 {position:relative;flex:1;margin:8px 0 0;height:30px;width:60%;transition:background-color 0.2s;cursor:pointer;font-family:inherit;}.button-like.svelte-1ort40 {cursor:default;}.appear.svelte-1ort40,\r\n  .disappear.svelte-1ort40 {position:absolute;left:50%;top:50%;transform:translate(-50%, -50%);width:100%;transition:all 0.5s;}button.svelte-1ort40:hover .disappear:where(.svelte-1ort40),\r\n  .appear.svelte-1ort40 {opacity:0;}.disappear.svelte-1ort40,\r\n  button.svelte-1ort40:hover .appear:where(.svelte-1ort40) {opacity:1;}button.svelte-1ort40:hover {background-color:var(--cp-button-hover-color, #ccc);}input.svelte-1ort40:focus,\r\n  button.svelte-1ort40:focus {outline:none;}input.svelte-1ort40:focus-visible,\r\n  button.svelte-1ort40:focus-visible {outline:2px solid var(--focus-color, red);outline-offset:2px;}.wrapper-buttons.svelte-1ort40 {display:flex;width:100%;margin-bottom:10px;align-items:center;gap:10px;}.button-icon.svelte-1ort40 {font-size:30px;width:30px;height:30px;margin-top:8px;text-align:center;line-height:30px;display:flex;flex:none;justify-content:center;align-items:center;background-color:var(--cp-input-color, #eee);color:var(--cp-text-color, var(--cp-border-color));}.button-icon.svelte-1ort40 span:where(.svelte-1ort40) {font-size:24px;}"
};
function TextInput(C, E) {
	push(E, !0), append_styles(C, $$css$11);
	let D = prop(E, "isAlpha", 7), O = prop(E, "rgb", 15), F = prop(E, "hsv", 15), I = prop(E, "hex", 15), L = prop(E, "textInputModes", 7), z = prop(E, "texts", 7), B = prop(E, "onInput", 7), V = /^#?([A-F0-9]{6}|[A-F0-9]{8})$/i, U = /* @__PURE__ */ state(proxy(L()[0] || "hex")), W = /* @__PURE__ */ user_derived(() => L()[(L().indexOf(get(U)) + 1) % L().length]), G = /* @__PURE__ */ user_derived(() => Math.round(F().h)), K = /* @__PURE__ */ user_derived(() => Math.round(F().s)), J = /* @__PURE__ */ user_derived(() => Math.round(F().v)), Y = /* @__PURE__ */ user_derived(() => F().a === void 0 ? 1 : Math.round(F().a * 100) / 100);
	function X(C) {
		let T = C.target;
		V.test(T.value) && (I(T.value), B()({ hex: I() }));
	}
	function Z(C) {
		return function(E) {
			let D = parseFloat(E.target.value);
			isNaN(D) && (D = 0), O(_objectSpread2(_objectSpread2({}, O()), {}, { [C]: D })), B()({ rgb: O() });
		};
	}
	function Q(C) {
		return function(E) {
			let D = parseFloat(E.target.value);
			isNaN(D) && (D = 0), F(_objectSpread2(_objectSpread2({}, F()), {}, { [C]: D })), B()({ hsv: F() });
		};
	}
	var NL = {
		get isAlpha() {
			return D();
		},
		set isAlpha(C) {
			D(C), flushSync();
		},
		get rgb() {
			return O();
		},
		set rgb(C) {
			O(C), flushSync();
		},
		get hsv() {
			return F();
		},
		set hsv(C) {
			F(C), flushSync();
		},
		get hex() {
			return I();
		},
		set hex(C) {
			I(C), flushSync();
		},
		get textInputModes() {
			return L();
		},
		set textInputModes(C) {
			L(C), flushSync();
		},
		get texts() {
			return z();
		},
		set texts(C) {
			z(C), flushSync();
		},
		get onInput() {
			return B();
		},
		set onInput(C) {
			B(C), flushSync();
		}
	}, PL = root$20(), FL = child(PL), IL = child(FL), LL = (C) => {
		var T = root_1$46();
		remove_input_defaults(T), T.__input = X, set_style(T, "", {}, { flex: 3 }), template_effect(() => {
			set_attribute(T, "aria-label", z().label.hex), set_value(T, I());
		}), append(C, T);
	}, RL = (C) => {
		var T = comment(), E = first_child(T), D = (C) => {
			var T = root_3$15(), E = first_child(T);
			remove_input_defaults(E);
			var D = /* @__PURE__ */ user_derived(() => Z("r"));
			E.__input = function(...C) {
				var T;
				(T = get(D)) == null || T.apply(this, C);
			};
			var F = sibling(E, 2);
			remove_input_defaults(F);
			var I = /* @__PURE__ */ user_derived(() => Z("g"));
			F.__input = function(...C) {
				var T;
				(T = get(I)) == null || T.apply(this, C);
			};
			var L = sibling(F, 2);
			remove_input_defaults(L);
			var B = /* @__PURE__ */ user_derived(() => Z("b"));
			L.__input = function(...C) {
				var T;
				(T = get(B)) == null || T.apply(this, C);
			}, template_effect(() => {
				set_attribute(E, "aria-label", z().label.r), set_value(E, O().r), set_attribute(F, "aria-label", z().label.g), set_value(F, O().g), set_attribute(L, "aria-label", z().label.b), set_value(L, O().b);
			}), append(C, T);
		}, F = (C) => {
			var T = root_4$11(), E = first_child(T);
			remove_input_defaults(E);
			var D = /* @__PURE__ */ user_derived(() => Q("h"));
			E.__input = function(...C) {
				var T;
				(T = get(D)) == null || T.apply(this, C);
			};
			var O = sibling(E, 2);
			remove_input_defaults(O);
			var F = /* @__PURE__ */ user_derived(() => Q("s"));
			O.__input = function(...C) {
				var T;
				(T = get(F)) == null || T.apply(this, C);
			};
			var I = sibling(O, 2);
			remove_input_defaults(I);
			var L = /* @__PURE__ */ user_derived(() => Q("v"));
			I.__input = function(...C) {
				var T;
				(T = get(L)) == null || T.apply(this, C);
			}, template_effect(() => {
				set_attribute(E, "aria-label", z().label.h), set_value(E, get(G)), set_attribute(O, "aria-label", z().label.s), set_value(O, get(K)), set_attribute(I, "aria-label", z().label.v), set_value(I, get(J));
			}), append(C, T);
		};
		if_block(E, (C) => {
			get(U) === "rgb" ? C(D) : C(F, !1);
		}, !0), append(C, T);
	};
	if_block(IL, (C) => {
		get(U) === "hex" ? C(LL) : C(RL, !1);
	});
	var zL = sibling(IL, 2), BL = (C) => {
		var T = root_5$9();
		remove_input_defaults(T);
		var E = /* @__PURE__ */ user_derived(() => get(U) === "hsv" ? Q("a") : Z("a"));
		T.__input = function(...C) {
			var T;
			(T = get(E)) == null || T.apply(this, C);
		}, template_effect(() => {
			set_attribute(T, "aria-label", z().label.a), set_value(T, get(Y));
		}), append(C, T);
	};
	if_block(zL, (C) => {
		D() && C(BL);
	}), reset(FL);
	var VL = sibling(FL, 2), HL = (C) => {
		var T = root_6$5(), E = child(T);
		E.__click = () => set(U, get(W), !0);
		var D = child(E), O = child(D, !0);
		reset(D);
		var F = sibling(D, 2), I = child(F);
		reset(F), reset(E);
		var L = sibling(E, 2), B = /* @__PURE__ */ user_derived(() => getContext("triggerColorPicker"));
		L.__click = function(...C) {
			var T;
			(T = get(B)) == null || T.apply(this, C);
		}, set_class(child(L), 1, "iconItem iconfont icon-sip-line", "svelte-1ort40"), reset(L), reset(T), template_effect(() => {
			var C, T;
			set_text(O, z().color[get(U)]), set_text(I, `${(C = z().changeTo) == null ? "" : C} ${(T = z().color[get(W)]) == null ? "" : T}`);
		}), append(C, T);
	}, UL = (C) => {
		var T = root_7$3(), E = child(T, !0);
		reset(T), template_effect(() => set_text(E, z().color[get(U)])), append(C, T);
	};
	return if_block(VL, (C) => {
		L().length > 1 ? C(HL) : C(UL, !1);
	}), reset(PL), append(C, PL), pop(NL);
}
delegate(["input", "click"]), create_custom_element(TextInput, {
	isAlpha: {},
	rgb: {},
	hsv: {},
	hex: {},
	textInputModes: {},
	texts: {},
	onInput: {}
}, [], [], !0);
var root$19 = /* @__PURE__ */ from_html("<label class=\"svelte-bfn45p\"><div class=\"container svelte-bfn45p\"><input type=\"color\" aria-haspopup=\"dialog\" class=\"svelte-bfn45p\"/> <div class=\"alpha svelte-bfn45p\"></div> <div class=\"color svelte-bfn45p\"></div></div> </label>"), $$css$10 = {
	hash: "svelte-bfn45p",
	code: "label.svelte-bfn45p {display:inline-flex;align-items:center;gap:8px;cursor:pointer;border-radius:3px;margin:4px;height:var(--input-size, 25px);-webkit-user-select:none;-moz-user-select:none;user-select:none;}.container.svelte-bfn45p {position:relative;display:block;display:flex;align-items:center;justify-content:center;width:var(--input-size, 25px);}input.svelte-bfn45p {margin:0;padding:0;border:none;width:1px;height:1px;flex-shrink:0;opacity:0;}.alpha.svelte-bfn45p {clip-path:circle(50%);background:var(--alpha-grid-bg);}.alpha.svelte-bfn45p,\r\n	.color.svelte-bfn45p {position:absolute;width:var(--input-size, 25px);height:var(--input-size, 25px);border-radius:50%;-webkit-user-select:none;-moz-user-select:none;user-select:none;}input.svelte-bfn45p:focus-visible ~ .color:where(.svelte-bfn45p) {outline:2px solid var(--focus-color, red);outline-offset:2px;}"
};
function Input$1(C, T) {
	push(T, !0), append_styles(C, $$css$10);
	let E = prop(T, "labelElement", 15), D = prop(T, "hex", 7), O = prop(T, "label", 7), F = prop(T, "name", 7, void 0), I = prop(T, "dir", 7);
	function L(C) {
		C.preventDefault();
	}
	var z = {
		get labelElement() {
			return E();
		},
		set labelElement(C) {
			E(C), flushSync();
		},
		get hex() {
			return D();
		},
		set hex(C) {
			D(C), flushSync();
		},
		get label() {
			return O();
		},
		set label(C) {
			O(C), flushSync();
		},
		get name() {
			return F();
		},
		set name(C = void 0) {
			F(C), flushSync();
		},
		get dir() {
			return I();
		},
		set dir(C) {
			I(C), flushSync();
		}
	}, B = root$19();
	B.__click = L, B.__mousedown = L;
	var V = child(B), U = child(V);
	remove_input_defaults(U), U.__click = L, U.__mousedown = L;
	var W = sibling(U, 4);
	let G;
	reset(V);
	var K = sibling(V);
	return reset(B), bind_this(B, (C) => E(C), () => E()), template_effect(() => {
		var C;
		set_attribute(B, "dir", I()), set_attribute(U, "name", F()), set_value(U, D()), G = set_style(W, "", G, { background: D() }), set_text(K, ` ${(C = O()) == null ? "" : C}`), B.dir = B.dir;
	}), append(C, B), pop(z);
}
delegate(["click", "mousedown"]), create_custom_element(Input$1, {
	labelElement: {},
	hex: {},
	label: {},
	name: {},
	dir: {}
}, [], [], !0);
var root$18 = /* @__PURE__ */ from_html("<div aria-label=\"color picker\"><!></div>"), $$css$9 = {
	hash: "svelte-1ceaxy2",
	code: "div.svelte-1ceaxy2 {width:-moz-max-content;width:max-content;}"
};
function Wrapper$1(C, T) {
	push(T, !0), append_styles(C, $$css$9);
	let E = prop(T, "wrapper", 15), D = prop(T, "isOpen", 7), O = prop(T, "isDialog", 7), F = prop(T, "children", 7);
	var I = {
		get wrapper() {
			return E();
		},
		set wrapper(C) {
			E(C), flushSync();
		},
		get isOpen() {
			return D();
		},
		set isOpen(C) {
			D(C), flushSync();
		},
		get isDialog() {
			return O();
		},
		set isDialog(C) {
			O(C), flushSync();
		},
		get children() {
			return F();
		},
		set children(C) {
			F(C), flushSync();
		}
	}, L = root$18();
	let z;
	return snippet(child(L), F), reset(L), bind_this(L, (C) => E(C), () => E()), template_effect(() => {
		z = set_class(L, 1, "wrapper svelte-1ceaxy2", null, z, { "is-open": D() }), set_attribute(L, "role", O() ? "dialog" : void 0);
	}), append(C, L), pop(I);
}
create_custom_element(Wrapper$1, {
	wrapper: {},
	isOpen: {},
	isDialog: {},
	children: {}
}, [], [], !0);
const defaultTexts = {
	label: {
		h: "hue channel",
		s: "saturation channel",
		v: "brightness channel",
		r: "red channel",
		g: "green channel",
		b: "blue channel",
		a: "alpha channel",
		hex: "hex color",
		withoutColor: "without color"
	},
	color: {
		rgb: "rgb",
		hsv: "hsv",
		hex: "hex"
	},
	changeTo: "change to "
}, defaultA11yTexts = {
	contrast: "contrast :",
	nbGradeSummary: (C) => C ? ` ${C} contrast grade${C && "s"} fail` : "Contrast grade information",
	guidelines: "Learn more at <a href=\"https://webaim.org/articles/contrast/\" target=\"_blank\">WebAIM contrast guide</a>"
};
var root$17 = /* @__PURE__ */ from_html("<label class=\"nullability-checkbox svelte-17ajml1\"><div class=\"svelte-17ajml1\"><input type=\"checkbox\" class=\"svelte-17ajml1\"/> <span class=\"svelte-17ajml1\"></span></div> </label>"), $$css$8 = {
	hash: "svelte-17ajml1",
	code: "label.svelte-17ajml1 {display:flex;justify-content:center;margin-bottom:4px;grid-area:nullable;-webkit-user-select:none;-moz-user-select:none;user-select:none;}input.svelte-17ajml1 {margin:0;}input.svelte-17ajml1:focus-visible {outline:none;}input.svelte-17ajml1:focus-visible + span:where(.svelte-17ajml1) {width:14px;height:14px;border-radius:2px;outline:2px solid var(--focus-color, red);outline-offset:2px;}div.svelte-17ajml1 {width:32px;aspect-ratio:2;position:relative;}div.svelte-17ajml1 :where(.svelte-17ajml1) {position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);}"
};
function NullabilityCheckbox(C, T) {
	push(T, !0), append_styles(C, $$css$8);
	let E = prop(T, "isUndefined", 15), D = prop(T, "texts", 7);
	var O = {
		get isUndefined() {
			return E();
		},
		set isUndefined(C) {
			E(C), flushSync();
		},
		get texts() {
			return D();
		},
		set texts(C) {
			D(C), flushSync();
		}
	}, F = root$17(), I = child(F), L = child(I);
	remove_input_defaults(L), next(2), reset(I);
	var z = sibling(I);
	return reset(F), template_effect(() => {
		var C;
		return set_text(z, ` ${(C = D().label.withoutColor) == null ? "" : C}`);
	}), bind_checked(L, E), append(C, F), pop(O);
}
create_custom_element(NullabilityCheckbox, {
	isUndefined: {},
	texts: {}
}, [], [], !0);
var root_2$20 = /* @__PURE__ */ from_html("<input type=\"hidden\"/>"), root_7$2 = /* @__PURE__ */ from_html("<div class=\"a svelte-7xbxbw\"><!></div>"), root_5$8 = /* @__PURE__ */ from_html("<!> <!> <div class=\"h svelte-7xbxbw\"><!></div> <!>", 1), root$16 = /* @__PURE__ */ from_html("<span><!> <!> <!> <!></span>"), $$css$7 = {
	hash: "svelte-7xbxbw",
	code: "span.svelte-7xbxbw {position:relative;color:var(--cp-text-color, var(--cp-border-color));--alpha-grid-bg: linear-gradient(\r\n					45deg,\r\n					#eee 25%,\r\n					#0000 25%,\r\n					#0000 75%,\r\n					#eee 75%\r\n				)\r\n				0 0 / 10px 10px,\r\n			linear-gradient(45deg, #eee 25%, #0000 25%, #0000 75%, #eee 75%) 5px\r\n				5px / 10px 10px;}.h.svelte-7xbxbw,\r\n	.a.svelte-7xbxbw {display:inline-flex;justify-content:center;--track-height: var(--slider-width, 10px);--track-width: var(--picker-height, 120px);--track-border: none;--thumb-size: calc(var(--slider-width, 10px) - 3px);--thumb-background: white;--thumb-border: 1px solid black;--margin-block: 0;--gradient-direction: 0.5turn;}.horizontal.svelte-7xbxbw .h:where(.svelte-7xbxbw),\r\n	.horizontal.svelte-7xbxbw .a:where(.svelte-7xbxbw) {--track-width: calc(var(--picker-width, 200px) - 12px);--gradient-direction: 0.25turn;margin:4px 6px;}.horizontal.svelte-7xbxbw .h:where(.svelte-7xbxbw) {margin-top:8px;}.vertical.svelte-7xbxbw .h:where(.svelte-7xbxbw),\r\n	.vertical.svelte-7xbxbw .a:where(.svelte-7xbxbw) {margin-left:3px;}.h.svelte-7xbxbw {grid-area:hue;--gradient-hue: #ff1500fb, #ffff00 17.2%, #ffff00 18.2%, #00ff00 33.3%,\r\n			#00ffff 49.5%, #00ffff 51.5%, #0000ff 67.7%, #ff00ff 83.3%, #ff0000;--track-background: linear-gradient(\r\n			var(--gradient-direction),\r\n			var(--gradient-hue)\r\n		);}.a.svelte-7xbxbw {grid-area:alpha;margin-top:2px;\r\n\r\n		/* redefine css variable as it may not be available in case of a portal */--alpha-grid-bg: linear-gradient(\r\n					45deg,\r\n					#eee 25%,\r\n					#0000 25%,\r\n					#0000 75%,\r\n					#eee 75%\r\n				)\r\n				0 0 / 10px 10px,\r\n			linear-gradient(45deg, #eee 25%, #0000 25%, #0000 75%, #eee 75%) 5px\r\n				5px / 10px 10px;--track-background: linear-gradient(\r\n				var(--gradient-direction),\r\n				rgba(0, 0, 0, 0),\r\n				var(--alphaless-color)\r\n			),\r\n			var(--alpha-grid-bg);}span.svelte-7xbxbw .sr-only {position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0;}"
};
function ColorPicker$2(C, E) {
	push(E, !0), append_styles(C, $$css$7);
	let D = prop(E, "components", 23, () => ({})), O = prop(E, "label", 7, "Choose a color"), F = prop(E, "name", 7, void 0), I = prop(E, "nullable", 7, !1), L = prop(E, "rgb", 31, () => proxy(I() ? null : {
		r: 255,
		g: 0,
		b: 0,
		a: 1
	})), z = prop(E, "hsv", 31, () => proxy(I() ? null : {
		h: 0,
		s: 100,
		v: 100,
		a: 1
	})), B = prop(E, "hex", 31, () => proxy(I() ? null : "#ff0000")), V = prop(E, "color", 15, null), U = prop(E, "isDark", 15, !1), W = prop(E, "isAlpha", 7, !0), G = prop(E, "isDialog", 7, !0), K = prop(E, "isOpen", 31, () => proxy(G())), J = prop(E, "position", 7, "responsive"), Y = prop(E, "dir", 7, "ltr"), X = prop(E, "isTextInput", 7, !0), Z = prop(E, "textInputModes", 23, () => [
		"hex",
		"rgb",
		"hsv"
	]), Q = prop(E, "sliderDirection", 7, "vertical"), NL = prop(E, "disableCloseClickOutside", 7, !1), PL = prop(E, "a11yColors", 23, () => [{ bgHex: "#ffffff" }]), FL = prop(E, "a11yLevel", 7, "AA"), IL = prop(E, "texts", 7, void 0), LL = prop(E, "a11yTexts", 7, void 0), RL = prop(E, "onInput", 7), zL = /* @__PURE__ */ state(proxy({
		r: 255,
		g: 0,
		b: 0,
		a: 1
	})), BL = /* @__PURE__ */ state(proxy({
		h: 0,
		s: 100,
		v: 100,
		a: 1
	})), VL = /* @__PURE__ */ state("#ff0000"), HL = /* @__PURE__ */ state(!1), UL = /* @__PURE__ */ state(proxy(get(HL))), WL = /* @__PURE__ */ state(void 0), GL = /* @__PURE__ */ state(void 0), KL = /* @__PURE__ */ state(void 0), qL = /* @__PURE__ */ state(1080), JL = /* @__PURE__ */ state(720), YL = {
		pickerIndicator: PickerIndicator,
		textInput: TextInput,
		input: Input$1,
		nullabilityCheckbox: NullabilityCheckbox,
		wrapper: Wrapper$1
	};
	function XL() {
		return _objectSpread2(_objectSpread2({}, YL), D());
	}
	function ZL() {
		var C, E, D, O;
		return {
			label: _objectSpread2(_objectSpread2({}, defaultTexts.label), (C = IL()) == null ? void 0 : C.label),
			color: _objectSpread2(_objectSpread2({}, defaultTexts.color), (E = IL()) == null ? void 0 : E.color),
			changeTo: (D = (O = IL()) == null ? void 0 : O.changeTo) == null ? defaultTexts.changeTo : D
		};
	}
	function QL({ key: C, target: T }) {}
	function $L() {
		return !(z() && L() && z().h === get(BL).h && z().s === get(BL).s && z().v === get(BL).v && z().a === get(BL).a && L().r === get(zL).r && L().g === get(zL).g && L().b === get(zL).b && L().a === get(zL).a && B() === get(VL));
	}
	function eR() {
		var C, E, D;
		if (get(HL) && !get(UL)) {
			var O;
			set(UL, !0), z(null), L(null), B(null), (O = RL()) == null || O({
				color: V(),
				hsv: z(),
				rgb: L(),
				hex: B()
			});
			return;
		} else if (get(UL) && !get(HL)) {
			var F;
			set(UL, !1), z(snapshot(get(BL))), L(snapshot(get(zL))), B(snapshot(get(VL))), (F = RL()) == null || F({
				color: V(),
				hsv: z(),
				rgb: L(),
				hex: B()
			});
			return;
		} else if (!z() && !L() && !B()) {
			var I;
			set(HL, set(UL, !0), !0), (I = RL()) == null || I({
				color: null,
				hsv: z(),
				rgb: L(),
				hex: B()
			});
			return;
		} else if (!$L()) return;
		set(HL, !1), z() && z().a === void 0 && z(_objectSpread2(_objectSpread2({}, z()), {}, { a: 1 })), get(BL).a === void 0 && set(BL, _objectSpread2(_objectSpread2({}, get(BL)), {}, { a: 1 }), !0), L() && L().a === void 0 && L(_objectSpread2(_objectSpread2({}, L()), {}, { a: 1 })), get(zL).a === void 0 && set(zL, _objectSpread2(_objectSpread2({}, get(zL)), {}, { a: 1 }), !0), ((C = B()) == null ? void 0 : C.substring(7)) === "ff" && B(B().substring(0, 7)), ((E = get(VL)) == null ? void 0 : E.substring(7)) === "ff" && set(VL, get(VL).substring(0, 7), !0), z() && (z().h !== get(BL).h || z().s !== get(BL).s || z().v !== get(BL).v || z().a !== get(BL).a || !L() && !B()) ? (V(w(z())), L(V().toRgb()), B(V().toHex())) : L() && (L().r !== get(zL).r || L().g !== get(zL).g || L().b !== get(zL).b || L().a !== get(zL).a || !z() && !B()) ? (V(w(L())), B(V().toHex()), z(V().toHsv())) : B() && (B() !== get(VL) || !z() && !L()) && (V(w(B())), L(V().toRgb()), z(V().toHsv())), V() && U(V().isDark()), !(!B() || !z() || !L()) && (set(BL, snapshot(z()), !0), set(zL, snapshot(L()), !0), set(VL, B(), !0), set(UL, get(HL), !0), (D = RL()) == null || D({
			color: V(),
			hsv: z(),
			rgb: L(),
			hex: B()
		}));
	}
	user_effect(() => {
		(z() || L() || B()) && eR();
	}), user_effect(() => {
		get(HL), eR();
	});
	function tR(C) {
		return (E) => {
			z() || (set(HL, !1), set(UL, !1), z(snapshot(get(BL)))), z(_objectSpread2(_objectSpread2({}, z()), {}, { [C]: E }));
		};
	}
	function nR(C) {
		return (E) => {
			z() || (set(HL, !1), set(UL, !1), z(snapshot(get(BL)))), z(_objectSpread2(_objectSpread2({}, z()), Object.fromEntries(C.map((C) => [C, E[C]]))));
		};
	}
	function rR() {
		return iR.apply(this, arguments);
	}
	function iR() {
		return iR = _asyncToGenerator(function* () {
			if (yield tick(), J() === "fixed" || !K() || !G() || !get(GL) || !get(KL)) return;
			let C = get(KL).getBoundingClientRect(), T = get(GL).getBoundingClientRect();
			if ((J() === "responsive" || J() === "responsive-y") && (T.top + C.height + 12 > get(JL) ? get(KL).style.top = `-${C.height + 12}px` : get(KL).style.top = `${T.height + 12}px`), J() === "responsive" || J() === "responsive-x") if (Y() === "rtl") {
				let E = T.left + T.width - C.width < 0;
				console.log(E, T.left - C.width, T.left, C.width), E ? get(KL).style.left = "0px" : get(KL).style.left = `${T.width - C.width}px`;
			} else T.left + C.width > get(qL) ? get(KL).style.left = `${T.width - C.width}px` : get(KL).style.left = "0px";
		}), iR.apply(this, arguments);
	}
	user_effect(() => {
		get(qL) && get(JL) && K() && rR();
	});
	let aR = /* @__PURE__ */ user_derived(XL);
	var oR = {
		get components() {
			return D();
		},
		set components(C = {}) {
			D(C), flushSync();
		},
		get label() {
			return O();
		},
		set label(C = "Choose a color") {
			O(C), flushSync();
		},
		get name() {
			return F();
		},
		set name(C = void 0) {
			F(C), flushSync();
		},
		get nullable() {
			return I();
		},
		set nullable(C = !1) {
			I(C), flushSync();
		},
		get rgb() {
			return L();
		},
		set rgb(C = I ? null : {
			r: 255,
			g: 0,
			b: 0,
			a: 1
		}) {
			L(C), flushSync();
		},
		get hsv() {
			return z();
		},
		set hsv(C = I ? null : {
			h: 0,
			s: 100,
			v: 100,
			a: 1
		}) {
			z(C), flushSync();
		},
		get hex() {
			return B();
		},
		set hex(C = I ? null : "#ff0000") {
			B(C), flushSync();
		},
		get color() {
			return V();
		},
		set color(C = null) {
			V(C), flushSync();
		},
		get isDark() {
			return U();
		},
		set isDark(C = !1) {
			U(C), flushSync();
		},
		get isAlpha() {
			return W();
		},
		set isAlpha(C = !0) {
			W(C), flushSync();
		},
		get isDialog() {
			return G();
		},
		set isDialog(C = !0) {
			G(C), flushSync();
		},
		get isOpen() {
			return K();
		},
		set isOpen(C = G) {
			K(C), flushSync();
		},
		get position() {
			return J();
		},
		set position(C = "responsive") {
			J(C), flushSync();
		},
		get dir() {
			return Y();
		},
		set dir(C = "ltr") {
			Y(C), flushSync();
		},
		get isTextInput() {
			return X();
		},
		set isTextInput(C = !0) {
			X(C), flushSync();
		},
		get textInputModes() {
			return Z();
		},
		set textInputModes(C = [
			"hex",
			"rgb",
			"hsv"
		]) {
			Z(C), flushSync();
		},
		get sliderDirection() {
			return Q();
		},
		set sliderDirection(C = "vertical") {
			Q(C), flushSync();
		},
		get disableCloseClickOutside() {
			return NL();
		},
		set disableCloseClickOutside(C = !1) {
			NL(C), flushSync();
		},
		get a11yColors() {
			return PL();
		},
		set a11yColors(C = [{ bgHex: "#ffffff" }]) {
			PL(C), flushSync();
		},
		get a11yLevel() {
			return FL();
		},
		set a11yLevel(C = "AA") {
			FL(C), flushSync();
		},
		get texts() {
			return IL();
		},
		set texts(C = void 0) {
			IL(C), flushSync();
		},
		get a11yTexts() {
			return LL();
		},
		set a11yTexts(C = void 0) {
			LL(C), flushSync();
		},
		get onInput() {
			return RL();
		},
		set onInput(C) {
			RL(C), flushSync();
		}
	}, sR = root$16();
	event("keyup", $window, QL), event("scroll", $window, rR);
	var cR = child(sR), lR = (C) => {}, uR = (C) => {
		var T = comment(), E = first_child(T), D = (C) => {
			var T = root_2$20();
			remove_input_defaults(T), template_effect(() => {
				set_value(T, B()), set_attribute(T, "name", F());
			}), append(C, T);
		};
		if_block(E, (C) => {
			F() && C(D);
		}, !0), append(C, T);
	};
	if_block(cR, (C) => {
		G() ? C(lR) : C(uR, !1);
	});
	var dR = sibling(cR, 2), fR = (C) => {
		var T = comment(), E = first_child(T);
		{
			let C = /* @__PURE__ */ user_derived(() => {
				var C;
				return (C = B()) == null ? get(VL) : C;
			}), T = /* @__PURE__ */ user_derived(() => {
				var C;
				return (C = L()) == null ? get(zL) : C;
			}), D = /* @__PURE__ */ user_derived(() => {
				var C;
				return (C = z()) == null ? get(BL) : C;
			}), O = /* @__PURE__ */ user_derived(ZL);
			component(E, () => get(aR).textInput, (E, F) => {
				F(E, {
					get hex() {
						return get(C);
					},
					get rgb() {
						return get(T);
					},
					get hsv() {
						return get(D);
					},
					onInput: (C) => {
						C.hsv ? z(C.hsv) : C.rgb ? L(C.rgb) : C.hex && B(C.hex);
					},
					get isAlpha() {
						return W();
					},
					get textInputModes() {
						return Z();
					},
					get texts() {
						return get(O);
					}
				});
			});
		}
		append(C, T);
	};
	if_block(dR, (C) => {
		X() && C(fR);
	});
	var pR = sibling(dR, 2), mR = (C) => {
		var T = comment(), E = first_child(T);
		{
			let C = /* @__PURE__ */ user_derived(XL), T = /* @__PURE__ */ user_derived(() => B() || "#00000000");
			component(E, () => get(aR).a11yNotice, (E, D) => {
				D(E, {
					get components() {
						return get(C);
					},
					get a11yColors() {
						return PL();
					},
					get hex() {
						return get(T);
					},
					get a11yTexts() {
						return LL();
					},
					get a11yLevel() {
						return FL();
					}
				});
			});
		}
		append(C, T);
	};
	return if_block(pR, (C) => {
		XL().a11yNotice && C(mR);
	}), component(sibling(pR, 2), () => get(aR).wrapper, (C, T) => {
		T(C, {
			get isOpen() {
				return K();
			},
			get isDialog() {
				return G();
			},
			get wrapper() {
				return get(KL);
			},
			set wrapper(C) {
				set(KL, C, !0);
			},
			children: (C, T) => {
				var E = root_5$8(), D = first_child(E), O = (C) => {
					var T = comment(), E = first_child(T);
					{
						let C = /* @__PURE__ */ user_derived(ZL);
						component(E, () => get(aR).nullabilityCheckbox, (T, E) => {
							E(T, {
								get texts() {
									return get(C);
								},
								get isUndefined() {
									return get(HL);
								},
								set isUndefined(C) {
									set(HL, C, !0);
								}
							});
						});
					}
					append(C, T);
				};
				if_block(D, (C) => {
					I() && C(O);
				});
				var F = sibling(D, 2);
				{
					let C = /* @__PURE__ */ user_derived(XL), T = /* @__PURE__ */ user_derived(() => {
						var C, T;
						return (C = (T = z()) == null ? void 0 : T.h) == null ? get(BL).h : C;
					}), E = /* @__PURE__ */ user_derived(() => {
						var C, T;
						return (C = (T = z()) == null ? void 0 : T.s) == null ? get(BL).s : C;
					}), D = /* @__PURE__ */ user_derived(() => {
						var C, T;
						return (C = (T = z()) == null ? void 0 : T.v) == null ? get(BL).v : C;
					}), O = /* @__PURE__ */ user_derived(() => nR(["s", "v"])), I = /* @__PURE__ */ user_derived(ZL);
					Picker(F, {
						get components() {
							return get(C);
						},
						get h() {
							return get(T);
						},
						get s() {
							return get(E);
						},
						get v() {
							return get(D);
						},
						get onInput() {
							return get(O);
						},
						get isDark() {
							return U();
						},
						get texts() {
							return get(I);
						}
					});
				}
				var L = sibling(F, 2), V = child(L);
				{
					let C = /* @__PURE__ */ user_derived(() => {
						var C, T;
						return (C = (T = z()) == null ? void 0 : T.h) == null ? get(BL).h : C;
					}), T = /* @__PURE__ */ user_derived(() => tR("h")), E = /* @__PURE__ */ user_derived(() => Q() === "vertical"), D = /* @__PURE__ */ user_derived(() => ZL().label.h);
					Slider$1(V, {
						min: 0,
						max: 360,
						step: 1,
						get value() {
							return get(C);
						},
						get onInput() {
							return get(T);
						},
						get direction() {
							return Q();
						},
						get reverse() {
							return get(E);
						},
						get ariaLabel() {
							return get(D);
						}
					});
				}
				reset(L);
				var G = sibling(L, 2), K = (C) => {
					var T = root_7$2();
					let E;
					var D = child(T);
					{
						let C = /* @__PURE__ */ user_derived(() => {
							var C, T;
							return (C = (T = z()) == null ? void 0 : T.a) == null ? get(BL).a : C;
						}), T = /* @__PURE__ */ user_derived(() => tR("a")), E = /* @__PURE__ */ user_derived(() => Q() === "vertical"), O = /* @__PURE__ */ user_derived(() => ZL().label.a);
						Slider$1(D, {
							min: 0,
							max: 1,
							step: .01,
							get value() {
								return get(C);
							},
							get onInput() {
								return get(T);
							},
							get direction() {
								return Q();
							},
							get reverse() {
								return get(E);
							},
							get ariaLabel() {
								return get(O);
							}
						});
					}
					reset(T), template_effect((C) => E = set_style(T, "", E, C), [() => ({ "--alphaless-color": (B() ? B() : get(VL)).substring(0, 7) })]), append(C, T);
				};
				if_block(G, (C) => {
					W() && C(K);
				}), append(C, E);
			},
			$$slots: { default: !0 }
		});
	}), reset(sR), bind_this(sR, (C) => set(WL, C), () => get(WL)), template_effect(() => {
		var C;
		return set_class(sR, 1, `color-picker ${(C = Q()) == null ? "" : C}`, "svelte-7xbxbw");
	}), bind_window_size("innerWidth", (C) => set(qL, C, !0)), bind_window_size("innerHeight", (C) => set(JL, C, !0)), append(C, sR), pop(oR);
}
create_custom_element(ColorPicker$2, {
	components: {},
	label: {},
	name: {},
	nullable: {},
	rgb: {},
	hsv: {},
	hex: {},
	color: {},
	isDark: {},
	isAlpha: {},
	isDialog: {},
	isOpen: {},
	position: {},
	dir: {},
	isTextInput: {},
	textInputModes: {},
	sliderDirection: {},
	disableCloseClickOutside: {},
	a11yColors: {},
	a11yLevel: {},
	texts: {},
	a11yTexts: {},
	onInput: {}
}, [], [], !0);
var root$15 = /* @__PURE__ */ from_html("<div aria-label=\"color picker\"><!></div>"), $$css$6 = {
	hash: "svelte-j64634",
	code: "div.svelte-j64634 {background-color:var(--cp-bg-color, white);margin:0 10px 15px;border:1px solid var(--cp-border-color, black);border-radius:8px;display:none;--text-input-margin: 5px 5px 6px;--picker-radius: 8px 8px 0 0;--picker-width: 260px;}.is-open.svelte-j64634 {display:flex;flex-direction:column;}[role='dialog'].svelte-j64634 {position:absolute;top:calc(var(--input-size, 25px) + 12px);left:0;z-index:var(--picker-z-index, 2);}div.svelte-j64634:not([role='dialog']) {display:inline-flex;flex-direction:column;}"
};
function Wrapper(C, T) {
	push(T, !0), append_styles(C, $$css$6);
	let E = prop(T, "wrapper", 15), D = prop(T, "isOpen", 7), O = prop(T, "isDialog", 7), F = prop(T, "children", 7);
	var I = {
		get wrapper() {
			return E();
		},
		set wrapper(C) {
			E(C), flushSync();
		},
		get isOpen() {
			return D();
		},
		set isOpen(C) {
			D(C), flushSync();
		},
		get isDialog() {
			return O();
		},
		set isDialog(C) {
			O(C), flushSync();
		},
		get children() {
			return F();
		},
		set children(C) {
			F(C), flushSync();
		}
	}, L = root$15();
	let z;
	return snippet(child(L), F), reset(L), bind_this(L, (C) => E(C), () => E()), template_effect(() => {
		z = set_class(L, 1, "wrapper svelte-j64634", null, z, { "is-open": D() }), set_attribute(L, "role", O() ? "dialog" : void 0);
	}), append(C, L), pop(I);
}
create_custom_element(Wrapper, {
	wrapper: {},
	isOpen: {},
	isDialog: {},
	children: {}
}, [], [], !0);
var root$14 = /* @__PURE__ */ from_html("<div aria-label=\"color picker\"><!></div>"), $$css$5 = {
	hash: "svelte-12z4wwj",
	code: "div.svelte-12z4wwj {padding:6px;background-color:var(--cp-bg-color, white);margin:0 10px 10px;border:1px solid var(--cp-border-color, black);border-radius:12px;display:none;width:-moz-max-content;width:max-content;}.is-open.svelte-12z4wwj {display:block;}\r\n	@media (min-width: 768px) {.is-open.svelte-12z4wwj {display:grid;gap:5px;grid-template:'nullable . . .'\r\n				'picker hue alpha a11y'\r\n				'input input input a11y';grid-template-rows:auto var(--picker-height, 200px) auto;}\r\n	}div.svelte-12z4wwj .picker {grid-area:picker;}div.svelte-12z4wwj .text-input {grid-area:input;}div.svelte-12z4wwj .a11y-notice {grid-area:a11y;margin:0 4px 0 6px;}[role='dialog'].svelte-12z4wwj {position:absolute;top:calc(var(--input-size, 25px) + 12px);left:0;z-index:var(--picker-z-index, 2);}"
};
function A11yHorizontalWrapper(C, T) {
	push(T, !0), append_styles(C, $$css$5);
	let E = prop(T, "wrapper", 15), D = prop(T, "isOpen", 7), O = prop(T, "isDialog", 7), F = prop(T, "children", 7);
	var I = {
		get wrapper() {
			return E();
		},
		set wrapper(C) {
			E(C), flushSync();
		},
		get isOpen() {
			return D();
		},
		set isOpen(C) {
			D(C), flushSync();
		},
		get isDialog() {
			return O();
		},
		set isDialog(C) {
			O(C), flushSync();
		},
		get children() {
			return F();
		},
		set children(C) {
			F(C), flushSync();
		}
	}, L = root$14();
	let z;
	return snippet(child(L), F), reset(L), bind_this(L, (C) => E(C), () => E()), template_effect(() => {
		z = set_class(L, 1, "wrapper svelte-12z4wwj", null, z, { "is-open": D() }), set_attribute(L, "role", O() ? "dialog" : void 0);
	}), append(C, L), pop(I);
}
create_custom_element(A11yHorizontalWrapper, {
	wrapper: {},
	isOpen: {},
	isDialog: {},
	children: {}
}, [], [], !0);
var o = function(C) {
	var T = C / 255;
	return T < .04045 ? T / 12.92 : Math.pow((T + .055) / 1.055, 2.4);
}, t = function(C) {
	return .2126 * o(C.r) + .7152 * o(C.g) + .0722 * o(C.b);
};
function a11y_default(C) {
	C.prototype.luminance = function() {
		return C = t(this.rgba), (T = 2) === void 0 && (T = 0), E === void 0 && (E = Math.pow(10, T)), Math.round(E * C) / E + 0;
		var C, T, E;
	}, C.prototype.contrast = function(T) {
		T === void 0 && (T = "#FFF");
		var E, D, O, F, I, L, z, B = T instanceof C ? T : new C(T);
		return F = this.rgba, I = B.toRgb(), L = t(F), z = t(I), E = L > z ? (L + .05) / (z + .05) : (z + .05) / (L + .05), (D = 2) === void 0 && (D = 0), O === void 0 && (O = Math.pow(10, D)), Math.floor(O * E) / O + 0;
	}, C.prototype.isReadable = function(C, T) {
		return C === void 0 && (C = "#FFF"), T === void 0 && (T = {}), this.contrast(C) >= (I = (F = (E = T).size) === void 0 ? "normal" : F, (O = (D = E.level) === void 0 ? "AA" : D) === "AAA" && I === "normal" ? 7 : O === "AA" && I === "large" ? 3 : 4.5);
		var E, D, O, F, I;
	};
}
const grades = {
	normal: {
		AA: 4.5,
		AAA: 7
	},
	large: {
		AA: 3,
		AAA: 4.5
	}
};
function isGradeAchieved(C, T = "normal", E) {
	return C >= grades[T][E];
}
function getNumberOfGradeFailed({ contrast: C, size: T }, E) {
	if (!C) return 1;
	let D = isGradeAchieved(C, T, "AA");
	return E === "AA" ? D ? 0 : 1 : D ? isGradeAchieved(C, T, "AAA") ? 0 : 1 : 2;
}
function mix(C, T = "#FFFFFF") {
	let E = w(C).toRgb(), D = w(T).toRgb(), { r: O, g: F, b: I, a: L = 255 } = E, { r: z, g: B, b: V } = D, U = average(O, z, L), W = average(F, B, L), G = average(I, V, L);
	return "#" + U + W + G;
}
function average(C, T, E) {
	return Math.round(T + (C - T) * E).toString(16).padStart(2, "0");
}
function getContrast(C, E) {
	if (E) if (C.reverse) {
		var D;
		let O = mix(E, mix((D = C.bgHex) == null ? "#FFFFFF" : D)), F = mix(C.textHex, O);
		if (!F) return;
		let I = w(F);
		return _objectSpread2(_objectSpread2({}, C), {}, {
			trueColors: {
				textColor: C.textHex,
				bgColor: O
			},
			contrast: I.contrast(O)
		});
	} else {
		if (!C.bgHex) return;
		let D = mix(C.bgHex), O = mix(E, D);
		if (!O) return;
		let F = w(O);
		return _objectSpread2(_objectSpread2({}, C), {}, {
			trueColors: {
				textColor: E,
				bgColor: C.bgHex
			},
			contrast: F.contrast(D)
		});
	}
}
var root_2$19 = /* @__PURE__ */ from_html("<span class=\"guidelines svelte-1u3wffs\"><!></span>"), root$13 = /* @__PURE__ */ from_html("<div class=\"a11y-notice svelte-1u3wffs\"><span class=\"title svelte-1u3wffs\"> </span> <!> <!></div>"), $$css$4 = {
	hash: "svelte-1u3wffs",
	code: ".a11y-notice.svelte-1u3wffs {display:grid;grid-template-columns:auto 1fr;grid-template-rows:auto repeat(var(--item-count), 1fr) auto;justify-items:stretch;align-items:center;gap:0 12px;width:-moz-max-content;width:max-content;}.title.svelte-1u3wffs {margin:12px 0 0;grid-column:1 / 3;background:none;border:none;padding:0 8px;line-height:24px;}\r\n\r\n	@media (min-width: 768px) {.title.svelte-1u3wffs {margin:0;}\r\n	}.guidelines.svelte-1u3wffs {grid-column:1 / 3;margin-top:10px;font-size:12px;}.svelte-1u3wffs:focus-visible,\r\n	.guidelines.svelte-1u3wffs :focus-visible {border-radius:2px;outline:2px solid var(--focus-color, red);outline-offset:2px;}"
};
function A11yNotice(C, E) {
	push(E, !0), append_styles(C, $$css$4);
	let D = prop(E, "components", 7), O = prop(E, "hex", 7), F = prop(E, "a11yColors", 7), I = prop(E, "a11yLevel", 7), L = prop(E, "a11yTexts", 7, void 0);
	k([a11y_default]);
	function z() {
		return _objectSpread2(_objectSpread2({}, defaultA11yTexts), L());
	}
	let B = /* @__PURE__ */ user_derived(() => F().map((C) => getContrast(C, O())).filter(Boolean).map((C) => C)), V = /* @__PURE__ */ user_derived(() => get(B).map((C) => getNumberOfGradeFailed(C, I())).reduce((C, T) => C + T));
	var U = {
		get components() {
			return D();
		},
		set components(C) {
			D(C), flushSync();
		},
		get hex() {
			return O();
		},
		set hex(C) {
			O(C), flushSync();
		},
		get a11yColors() {
			return F();
		},
		set a11yColors(C) {
			F(C), flushSync();
		},
		get a11yLevel() {
			return I();
		},
		set a11yLevel(C) {
			I(C), flushSync();
		},
		get a11yTexts() {
			return L();
		},
		set a11yTexts(C = void 0) {
			L(C), flushSync();
		}
	}, W = root$13();
	let G;
	var K = child(W), J = child(K, !0);
	reset(K);
	var Y = sibling(K, 2);
	each(Y, 17, () => get(B), index, (C, T) => {
		let E = () => get(T).trueColors, O = () => get(T).contrast, F = () => get(T).placeholder, L = () => get(T).size;
		var B = comment(), V = first_child(B);
		{
			let C = /* @__PURE__ */ user_derived(() => z().contrast);
			component(V, () => D().a11ySingleNotice, (T, D) => {
				D(T, spread_props(E, {
					get contrast() {
						return O();
					},
					get placeholder() {
						return F();
					},
					get size() {
						return L();
					},
					get a11yLevel() {
						return I();
					},
					get contrastText() {
						return get(C);
					}
				}));
			});
		}
		append(C, B);
	});
	var X = sibling(Y, 2), Z = (C) => {
		var T = root_2$19();
		html(child(T), () => z().guidelines), reset(T), append(C, T);
	};
	return if_block(X, (C) => {
		z().guidelines && C(Z);
	}), reset(W), template_effect((C) => {
		G = set_style(W, "", G, { "--item-count": get(B).length }), set_text(J, C);
	}, [() => z().nbGradeSummary(get(V))]), append(C, W), pop(U);
}
create_custom_element(A11yNotice, {
	components: {},
	hex: {},
	a11yColors: {},
	a11yLevel: {},
	a11yTexts: {}
}, [], [], !0);
var root_1$45 = /* @__PURE__ */ from_html("<span>AAA</span>"), root$12 = /* @__PURE__ */ from_html("<p> </p> <div><p class=\"svelte-1me8zrc\"> </p> <span>AA</span> <!></div>", 1), $$css$3 = {
	hash: "svelte-1me8zrc",
	code: ".lorem.svelte-1me8zrc {flex:1;text-align:center;padding:4px 8px;margin-top:10px;border-radius:4px;border:1px solid black;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;}.large.svelte-1me8zrc {font-size:22px;padding:2px 8px;}.grade.svelte-1me8zrc {border-radius:50px;padding:0 8px 2px;background-color:#ff6100;font-weight:bold;}.grade-ok.svelte-1me8zrc {background-color:green;color:white;}p.svelte-1me8zrc {margin:0;}"
};
function A11ySingleNotice(C, T) {
	push(T, !0), append_styles(C, $$css$3);
	let E = prop(T, "placeholder", 7, void 0), D = prop(T, "size", 7, void 0), O = prop(T, "a11yLevel", 7), F = prop(T, "textColor", 7), I = prop(T, "bgColor", 7), L = prop(T, "contrast", 7, 1), z = prop(T, "contrastText", 7);
	var B = {
		get placeholder() {
			return E();
		},
		set placeholder(C = void 0) {
			E(C), flushSync();
		},
		get size() {
			return D();
		},
		set size(C = void 0) {
			D(C), flushSync();
		},
		get a11yLevel() {
			return O();
		},
		set a11yLevel(C) {
			O(C), flushSync();
		},
		get textColor() {
			return F();
		},
		set textColor(C) {
			F(C), flushSync();
		},
		get bgColor() {
			return I();
		},
		set bgColor(C) {
			I(C), flushSync();
		},
		get contrast() {
			return L();
		},
		set contrast(C = 1) {
			L(C), flushSync();
		},
		get contrastText() {
			return z();
		},
		set contrastText(C) {
			z(C), flushSync();
		}
	}, V = root$12(), U = first_child(V);
	let W, G;
	var K = child(U, !0);
	reset(U);
	var J = sibling(U, 2), Y = child(J), X = child(Y);
	reset(Y);
	var Z = sibling(Y, 2);
	let Q;
	var NL = sibling(Z, 2), PL = (C) => {
		var T = root_1$45();
		let E;
		template_effect((C) => E = set_class(T, 1, "grade svelte-1me8zrc", null, E, C), [() => ({ "grade-ok": isGradeAchieved(L(), D(), "AAA") })]), append(C, T);
	};
	return if_block(NL, (C) => {
		O() === "AAA" && C(PL);
	}), reset(J), template_effect((C, T) => {
		var O;
		W = set_class(U, 1, "lorem svelte-1me8zrc", null, W, { large: D() === "large" }), G = set_style(U, "", G, {
			color: F(),
			"background-color": I()
		}), set_text(K, E() || "Lorem Ipsum"), set_text(X, `${(O = z()) == null ? "" : O} ${C == null ? "" : C}`), Q = set_class(Z, 1, "grade svelte-1me8zrc", null, Q, T);
	}, [() => L() >= 10 ? L().toFixed(1) : L(), () => ({ "grade-ok": isGradeAchieved(L(), D(), "AA") })]), append(C, V), pop(B);
}
create_custom_element(A11ySingleNotice, {
	placeholder: {},
	size: {},
	a11yLevel: {},
	textColor: {},
	bgColor: {},
	contrast: {},
	contrastText: {}
}, [], [], !0);
var dist_default = ColorPicker$2, root_3$14 = /* @__PURE__ */ from_html("<button class=\"preset-colors-item svelte-1xz4g17\"></button>"), root_1$44 = /* @__PURE__ */ from_html("<div class=\"wrapper svelte-1xz4g17\"><button class=\"color-drag svelte-1xz4g17\" aria-label=\"drag\"></button> <div class=\"wrapper-color-picker svelte-1xz4g17\"><!></div> <div class=\"preset-colors svelte-1xz4g17\"></div></div>"), root$11 = /* @__PURE__ */ from_html("<span class=\"wrapper-show svelte-1xz4g17\"><button class=\"wrapper-title svelte-1xz4g17\" aria-label=\"color button\"></button> <!></span>"), $$css$2 = {
	hash: "svelte-1xz4g17",
	code: ".wrapper-show.svelte-1xz4g17 {overflow:hidden;width:100%;height:100%;display:flex;justify-content:center;flex-direction:row;align-items:center;}.wrapper-title.svelte-1xz4g17 {width:100%;height:100%;overflow:hidden;min-height:24px;}.wrapper.svelte-1xz4g17 {width:240px;min-width:240px;max-width:240px;height:-moz-fit-content;height:fit-content;background-color:white;border-radius:6px;display:flex;justify-content:center;flex-direction:column;position:fixed;z-index:1005;border:1px solid #ccc;box-shadow:0 0 5px #ccc;}.wrapper.svelte-1xz4g17 .color-drag:where(.svelte-1xz4g17) {position:absolute;top:0px;height:10px;width:100%;border-top-left-radius:6px;border-top-right-radius:6px;}.wrapper.svelte-1xz4g17 .color-drag:where(.svelte-1xz4g17):hover {background-color:#eeeeee;}.wrapper.svelte-1xz4g17 .wrapper-color-picker:where(.svelte-1xz4g17) {box-sizing:border-box;margin:auto;margin-top:10px;}.wrapper.svelte-1xz4g17 .preset-colors:where(.svelte-1xz4g17) {width:100%;height:-moz-fit-content;height:fit-content;display:flex;justify-content:left;gap:4px;flex-direction:row;box-sizing:border-box;flex-wrap:wrap;align-content:flex-start;padding-left:12px;padding-bottom:12px;}.wrapper.svelte-1xz4g17 .preset-colors:where(.svelte-1xz4g17) .preset-colors-item:where(.svelte-1xz4g17) {width:20px;height:20px;border:1px #ccc solid;border-radius:4px;}"
};
function MCXAColorPicker(C, T) {
	push(T, !0), append_styles(C, $$css$2);
	let E = prop(T, "color", 15, "#ffffff"), D = prop(T, "top", 7, 0), O = prop(T, "left", 7, 0), F = prop(T, "disabled", 7, !1), I = prop(T, "onChange", 7, () => {}), L = /* @__PURE__ */ state(proxy(D())), z = /* @__PURE__ */ state(proxy(O())), B = /* @__PURE__ */ state(void 0), V = /* @__PURE__ */ state(!1), U = /* @__PURE__ */ state(proxy({
		max: 0,
		min: 0
	})), W = /* @__PURE__ */ state(proxy({
		max: 0,
		min: 0
	})), G = /* @__PURE__ */ state(void 0), K = /* @__PURE__ */ state(!1);
	function J() {
		return Y.apply(this, arguments);
	}
	function Y() {
		return Y = _asyncToGenerator(function* () {
			if ("EyeDropper" in window) {
				let C = new EyeDropper();
				try {
					E((yield C.open()).sRGBHex);
				} catch (C) {
					console.error("", C);
				}
			} else console.log(" EyeDropper API");
		}), Y.apply(this, arguments);
	}
	let X = /* @__PURE__ */ state(proxy(/* @__PURE__ */ "#fff1f0.#ffccc7.#ffa39e.#ff7875.#ff4d4f.#f5222d.#cf1322.#a8071a.#820014.#fcffe6.#f4ffb8.#eaff8f.#d3f261.#bae637.#a0d911.#7cb305.#5b8c00.#3f6600.#e6fffb.#b5f5ec.#87e8de.#5cdbd3.#36cfc9.#13c2c2.#08979c.#006d75.#00474f".split("."))), Z = (C) => {
		var T, E;
		(T = get(B)) != null && T.contains(C.target) || (E = get(B)) != null && E.isSameNode(C.target) || set(V, !1);
	};
	function Q(C, T, E) {
		return Math.min(Math.max(T, C), E);
	}
	let NL = (C) => {
		set(K, !0), document.body.style.userSelect = "none", document.body.style.cursor = "pointer";
		let T = {
			x: C.clientX,
			y: C.clientY,
			top: get(L),
			left: get(z)
		}, E = (C) => {
			set(L, Q(C.clientY - T.y + T.top, get(W).min, get(W).max), !0), set(z, Q(C.clientX - T.x + T.left, get(U).min, get(U).max), !0);
		}, D = (C) => {
			window.removeEventListener("mousemove", E), window.removeEventListener("mouseup", D), document.body.style.userSelect = "", document.body.style.cursor = "", set(K, !1);
		};
		window.addEventListener("mousemove", E), window.addEventListener("mouseup", D);
	}, PL = () => {
		if (get(G)) {
			let C = document.body.getBoundingClientRect(), T = get(G).getBoundingClientRect();
			set(U, {
				min: 0,
				max: C.right - T.width
			}, !0), set(W, {
				min: 0,
				max: C.bottom - T.height
			}, !0), set(L, Q(get(L), get(W).min, get(W).max), !0), set(z, Q(get(z), get(U).min, get(U).max), !0);
		}
	};
	onMount(() => {
		if (setContext("triggerColorPicker", J), window.addEventListener("resize", PL), get(G)) {
			let C = document.body.getBoundingClientRect(), T = get(G).getBoundingClientRect();
			set(U, {
				min: 0,
				max: C.right - T.width
			}, !0), set(W, {
				min: 0,
				max: C.bottom - T.height
			}, !0), set(L, Q(D(), get(W).min, get(W).max), !0), set(z, Q(O(), get(U).min, get(U).max), !0);
		}
		window.addEventListener("click", Z);
	}), user_effect(() => {
		get(V) && requestAnimationFrame(() => {
			if (PL(), get(B)) {
				let C = get(B).getBoundingClientRect();
				set(z, C.left, !0), set(L, C.bottom, !0);
			}
		});
	}), onDestroy(() => {
		window.removeEventListener("click", Z);
	});
	var FL = {
		get color() {
			return E();
		},
		set color(C = "#ffffff") {
			E(C), flushSync();
		},
		get top() {
			return D();
		},
		set top(C = 0) {
			D(C), flushSync();
		},
		get left() {
			return O();
		},
		set left(C = 0) {
			O(C), flushSync();
		},
		get disabled() {
			return F();
		},
		set disabled(C = !1) {
			F(C), flushSync();
		},
		get onChange() {
			return I();
		},
		set onChange(C = () => {}) {
			I(C), flushSync();
		}
	}, IL = root$11(), LL = child(IL);
	LL.__click = (C) => {
		set(V, !get(V));
	};
	var RL = sibling(LL, 2), zL = (C) => {
		var T = root_1$44();
		T.__click = (C) => {
			C.preventDefault(), C.stopPropagation();
		};
		var D = child(T);
		D.__mousedown = NL;
		var O = sibling(D, 2);
		dist_default(child(O), {
			isDialog: !1,
			isDark: !1,
			onInput: (C) => {
				I()(C);
			},
			get hex() {
				return E();
			},
			set hex(C) {
				E(C);
			}
		}), reset(O);
		var F = sibling(O, 2);
		each(F, 21, () => get(X), index, (C, T) => {
			Tooltip(C, {
				get title() {
					return get(T);
				},
				height: "20px",
				children: (C, D) => {
					var O = root_3$14();
					O.__click = () => {
						E(get(T));
					}, template_effect(() => {
						var C;
						set_attribute(O, "aria-label", get(T)), set_style(O, `background-color: ${(C = get(T)) == null ? "" : C};`);
					}), append(C, O);
				},
				$$slots: { default: !0 }
			});
		}), reset(F), reset(T), bind_this(T, (C) => set(G, C), () => get(G)), template_effect(() => {
			var C, E;
			return set_style(T, `top:${(C = get(L)) == null ? "" : C}px;left:${(E = get(z)) == null ? "" : E}px`);
		}), append(C, T);
	};
	return if_block(RL, (C) => {
		get(V) && C(zL);
	}), reset(IL), bind_this(IL, (C) => set(B, C), () => get(B)), template_effect(() => {
		var C;
		LL.disabled = F(), set_style(LL, `background-color: ${(C = E()) == null ? "" : C};`);
	}), append(C, IL), pop(FL);
}
delegate(["click", "mousedown"]), create_custom_element(MCXAColorPicker, {
	color: {},
	top: {},
	left: {},
	disabled: {},
	onChange: {}
}, [], [], !0);
var root_10$2 = /* @__PURE__ */ from_html("<div class=\"flex items-center\"><input type=\"radio\" name=\"radio\" class=\"w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600\"/> <label class=\"ms-2 text-sm font-medium text-gray-900 dark:text-gray-300\"> </label></div>"), $$css$1 = {
	hash: "svelte-r95u3n",
	code: ""
};
function PropertyInput(C, T) {
	push(T, !0), append_styles(C, $$css$1);
	let E = prop(T, "label", 7), D = prop(T, "value", 15), O = prop(T, "type", 7, "string"), F = prop(T, "options", 23, () => []), I = prop(T, "onChange", 7), L = prop(T, "valid", 7), z = prop(T, "size", 7, "sm"), B = prop(T, "multiChild", 7), V = prop(T, "disabled", 7, !1), U = /* @__PURE__ */ rest_props(T, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"label",
		"value",
		"type",
		"options",
		"onChange",
		"valid",
		"size",
		"multiChild",
		"disabled"
	]), W = /* @__PURE__ */ state(proxy(D())), G = /* @__PURE__ */ state("default");
	function K(C, T) {
		var E;
		let F = !0;
		if (O() === "number" || O() == "float" || O() == "unsigned") {
			var z, B;
			C = O() === "number" || O() == "unsigned" ? parseInt(C) : parseFloat(C), isNaN(C) && (C = (O(), 0)), F = (z = (B = L()) == null ? void 0 : B(C)) == null ? !0 : z, O() === "unsigned" && C < 0 && (F = !1, C = Math.max(0, C), set(W, C, !0), D(C));
		}
		if (!F) {
			set(G, "red");
			return;
		}
		set(W, C, !0), D(C), set(G, "default"), (E = I()) == null || E(C, T);
	}
	function J(C, T) {
		C.key === "Enter" && (C.preventDefault(), K(get(W), T));
	}
	var Y = {
		get label() {
			return E();
		},
		set label(C) {
			E(C), flushSync();
		},
		get value() {
			return D();
		},
		set value(C) {
			D(C), flushSync();
		},
		get type() {
			return O();
		},
		set type(C = "string") {
			O(C), flushSync();
		},
		get options() {
			return F();
		},
		set options(C = []) {
			F(C), flushSync();
		},
		get onChange() {
			return I();
		},
		set onChange(C) {
			I(C), flushSync();
		},
		get valid() {
			return L();
		},
		set valid(C) {
			L(C), flushSync();
		},
		get size() {
			return z();
		},
		set size(C = "sm") {
			z(C), flushSync();
		},
		get multiChild() {
			return B();
		},
		set multiChild(C) {
			B(C), flushSync();
		},
		get disabled() {
			return V();
		},
		set disabled(C = !1) {
			V(C), flushSync();
		}
	}, X = comment(), Z = first_child(X), Q = (C) => {
		Select(C, spread_props({
			get items() {
				return F();
			},
			get disabled() {
				return V();
			},
			get size() {
				return z();
			}
		}, () => U, {
			onchange: (C) => {
				var T;
				let O = C.currentTarget.value;
				typeof D() == "number" && (O = parseInt(O)), (T = I()) == null || T(O, E());
			},
			get value() {
				return D();
			},
			set value(C) {
				D(C);
			}
		}));
	}, PL = (C) => {
		var T = comment(), L = first_child(T), Y = (C) => {
			MultiSelect(C, spread_props({
				get items() {
					return F();
				},
				get size() {
					return z();
				}
			}, () => U, {
				get value() {
					return D();
				},
				set value(C) {
					D(C);
				},
				children: (C, T) => {
					let E = () => T == null ? void 0 : T().item, D = () => T == null ? void 0 : T().clear;
					var O = comment();
					snippet(first_child(O), () => {
						var C;
						return (C = B()) == null ? noop : C;
					}, () => ({
						item: E(),
						clear: D()
					})), append(C, O);
				},
				$$slots: { default: !0 }
			}));
		}, X = (C) => {
			var T = comment(), L = first_child(T), B = (C) => {
				Checkbox(C, {
					get disabled() {
						return V();
					},
					onchange: (C) => {
						var T;
						(T = I()) == null || T(C.currentTarget.checked, E());
					},
					get checked() {
						return D();
					},
					set checked(C) {
						D(C);
					},
					children: (C, T) => {
						next();
						var D = text();
						template_effect(() => set_text(D, E())), append(C, D);
					},
					$$slots: { default: !0 }
				});
			}, Y = (C) => {
				var T = comment(), L = first_child(T), B = (C) => {
					var T = comment();
					each(first_child(T), 17, F, index, (C, T, E) => {
						var O = root_10$2(), F = child(O);
						remove_input_defaults(F), set_attribute(F, "id", `radio-${E}`), F.__change = (C) => {
							var E;
							D(C.currentTarget.value), (E = I()) == null || E(C.currentTarget.value, get(T).name);
						};
						var L = sibling(F, 2);
						set_attribute(L, "for", `radio-${E}`);
						var z = child(L, !0);
						reset(L), reset(O), template_effect(() => {
							set_value(F, get(T).value), set_text(z, get(T).name);
						}), append(C, O);
					}), append(C, T);
				}, Y = (C) => {
					var T = comment(), F = first_child(T), I = (C) => {
						Textarea(C, spread_props({ get disabled() {
							return V();
						} }, () => U, {
							class: "w-full",
							onblur: (C) => {
								let T = C.currentTarget.value;
								K(T, E());
							},
							get value() {
								return get(W);
							},
							set value(C) {
								set(W, C, !0);
							}
						}));
					}, L = (C) => {
						var T = comment(), F = first_child(T), I = (C) => {
							MCXAColorPicker(C, spread_props(() => U, {
								get color() {
									return D();
								},
								set color(C) {
									D(C);
								}
							}));
						}, L = (C) => {
							{
								let T = /* @__PURE__ */ user_derived(() => O() === "string" ? "text" : "number");
								Input(C, spread_props({
									class: "text-black",
									get type() {
										return get(T);
									},
									get disabled() {
										return V();
									},
									get color() {
										return get(G);
									}
								}, () => U, {
									onkeydown: (C) => J(C, E()),
									onblur: (C) => {
										let T = C.currentTarget.value;
										K(T, E());
									},
									get size() {
										return z();
									},
									get value() {
										return get(W);
									},
									set value(C) {
										set(W, C, !0);
									}
								}));
							}
						};
						if_block(F, (C) => {
							O() === "color" ? C(I) : C(L, !1);
						}, !0), append(C, T);
					};
					if_block(F, (C) => {
						O() === "textarea" ? C(I) : C(L, !1);
					}, !0), append(C, T);
				};
				if_block(L, (C) => {
					O() === "radio" ? C(B) : C(Y, !1);
				}, !0), append(C, T);
			};
			if_block(L, (C) => {
				O() === "checkbox" ? C(B) : C(Y, !1);
			}, !0), append(C, T);
		};
		if_block(L, (C) => {
			O() === "multi-option" ? C(Y) : C(X, !1);
		}, !0), append(C, T);
	};
	return if_block(Z, (C) => {
		O() === "option" ? C(Q) : C(PL, !1);
	}), append(C, X), pop(Y);
}
delegate(["change"]), create_custom_element(PropertyInput, {
	label: {},
	value: {},
	type: {},
	options: {},
	onChange: {},
	valid: {},
	size: {},
	multiChild: {},
	disabled: {}
}, [], [], !0);
var root_1$43 = /* @__PURE__ */ from_html("<span> </span> <div class=\"w-[60px] h-[25px] overflow-hidden border-[1px] border-solid border-gray-500\"><!></div>", 1);
function ColorPicker$1(C, T) {
	push(T, !0);
	let E = prop(T, "label", 7, "Color"), D = prop(T, "color", 15), O = prop(T, "opa", 15), F = prop(T, "onChange", 7), I = prop(T, "disabled", 7, !1);
	function L(C) {
		let T = C.hex;
		T && (T.length === 7 && (F() && F()(T, 255), D(T), O() !== void 0 && O(255)), T.length === 9 && (F() && F()(T.substring(0, 7), parseInt(T.substring(7, 9), 16)), D(T.substring(0, 7)), O() !== void 0 && O(parseInt(T.substring(7, 9), 16))));
	}
	return Label(C, {
		class: "flex-auto w-18 my-2 text-white",
		children: (C, T) => {
			var F = root_1$43(), z = first_child(F), B = child(z, !0);
			reset(z);
			var V = sibling(z, 2), U = child(V);
			{
				let C = /* @__PURE__ */ user_derived(() => hexWithAlpha(D(), O() ? O() : 255));
				MCXAColorPicker(U, {
					get color() {
						return get(C);
					},
					onChange: L,
					get disabled() {
						return I();
					}
				});
			}
			reset(V), template_effect(() => set_text(B, E())), append(C, F);
		},
		$$slots: { default: !0 }
	}), pop({
		get label() {
			return E();
		},
		set label(C = "Color") {
			E(C), flushSync();
		},
		get color() {
			return D();
		},
		set color(C) {
			D(C), flushSync();
		},
		get opa() {
			return O();
		},
		set opa(C) {
			O(C), flushSync();
		},
		get onChange() {
			return F();
		},
		set onChange(C) {
			F(C), flushSync();
		},
		get disabled() {
			return I();
		},
		set disabled(C = !1) {
			I(C), flushSync();
		}
	});
}
create_custom_element(ColorPicker$1, {
	label: {},
	color: {},
	opa: {},
	onChange: {},
	disabled: {}
}, [], [], !0);
var root_5$7 = /* @__PURE__ */ from_html("<span> </span>"), root_4$10 = /* @__PURE__ */ from_html("<!> <!>", 1), root_8$3 = /* @__PURE__ */ from_html("<span> </span>"), root_7$1 = /* @__PURE__ */ from_html("<!> <div class=\"h-full w-full flex items-center gap-2 flex-wrap\"><!></div>", 1);
function LabelInput(C, T) {
	push(T, !0);
	let E = prop(T, "label", 7), D = prop(T, "onChange", 7), O = prop(T, "value", 15), F = prop(T, "options", 7), I = prop(T, "type", 7), L = prop(T, "direction", 7, "vertical"), z = prop(T, "opa", 15), B = /* @__PURE__ */ rest_props(T, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"label",
		"onChange",
		"value",
		"options",
		"type",
		"direction",
		"opa"
	]);
	var V = {
		get label() {
			return E();
		},
		set label(C) {
			E(C), flushSync();
		},
		get onChange() {
			return D();
		},
		set onChange(C) {
			D(C), flushSync();
		},
		get value() {
			return O();
		},
		set value(C) {
			O(C), flushSync();
		},
		get options() {
			return F();
		},
		set options(C) {
			F(C), flushSync();
		},
		get type() {
			return I();
		},
		set type(C) {
			I(C), flushSync();
		},
		get direction() {
			return L();
		},
		set direction(C = "vertical") {
			L(C), flushSync();
		},
		get opa() {
			return z();
		},
		set opa(C) {
			z(C), flushSync();
		}
	}, U = comment(), W = first_child(U), G = (C) => {
		ColorPicker$1(C, {
			get label() {
				return E();
			},
			get color() {
				return O();
			},
			set color(C) {
				O(C);
			},
			get opa() {
				return z();
			},
			set opa(C) {
				z(C);
			}
		});
	}, K = (C) => {
		var T = comment(), z = first_child(T), V = (C) => {
			Label(C, {
				class: "flex-auto w-18 my-2 text-white",
				children: (C, T) => {
					var L = root_4$10(), z = first_child(L), V = (C) => {
						var T = root_5$7(), D = child(T, !0);
						reset(T), template_effect(() => set_text(D, E())), append(C, T);
					};
					if_block(z, (C) => {
						I() !== "checkbox" && E() && C(V);
					}), PropertyInput(sibling(z, 2), spread_props({
						get label() {
							return E();
						},
						get type() {
							return I();
						},
						get options() {
							return F();
						},
						get onChange() {
							return D();
						}
					}, () => B, {
						get value() {
							return O();
						},
						set value(C) {
							O(C);
						}
					})), append(C, L);
				},
				$$slots: { default: !0 }
			});
		}, U = (C) => {
			Label(C, {
				class: "flex-auto w-18 my-2 text-white flex items-center gap-2 whitespace-nowrap",
				children: (C, T) => {
					var L = root_7$1(), z = first_child(L), V = (C) => {
						var T = root_8$3(), D = child(T, !0);
						reset(T), template_effect(() => set_text(D, E())), append(C, T);
					};
					if_block(z, (C) => {
						I() !== "checkbox" && E() && C(V);
					});
					var U = sibling(z, 2);
					PropertyInput(child(U), spread_props({
						get label() {
							return E();
						},
						get type() {
							return I();
						},
						get options() {
							return F();
						},
						get onChange() {
							return D();
						}
					}, () => B, {
						get value() {
							return O();
						},
						set value(C) {
							O(C);
						}
					})), reset(U), append(C, L);
				},
				$$slots: { default: !0 }
			});
		};
		if_block(z, (C) => {
			L() === "vertical" ? C(V) : C(U, !1);
		}, !0), append(C, T);
	};
	return if_block(W, (C) => {
		I() === "color" ? C(G) : C(K, !1);
	}), append(C, U), pop(V);
}
create_custom_element(LabelInput, {
	label: {},
	onChange: {},
	value: {},
	options: {},
	type: {},
	direction: {},
	opa: {}
}, [], [], !0);
var root_3$13 = /* @__PURE__ */ from_html("<!> <!>", 1), root_8$2 = /* @__PURE__ */ from_html("<!> <!>", 1), root_2$18 = /* @__PURE__ */ from_html("<div class=\"flex gap-2 items-center\"><!></div> <div class=\"flex gap-2 items-center\"><!></div> <!>", 1);
function Layout(C, T) {
	push(T, !0);
	let E = getContext("mcxa_api"), D = prop(T, "props", 7), O = /* @__PURE__ */ state(0);
	function F(C, T) {
		console.log("onChange"), T && (T = toCamelCase(T), T === "align" ? (D().align = parseInt(C, 10), D().x = 0, D().y = 0, update(O)) : ("" + T, D()[T], D()[T] = C));
	}
	return onMount(() => {}), WgtAccordionItem(C, {
		label: "Layout",
		children: (C, T) => {
			var I = comment(), L = first_child(I), z = (C) => {
				var T = root_2$18(), I = first_child(T);
				key(child(I), () => get(O), (C) => {
					var T = root_3$13(), O = first_child(T), I = (C) => {
						ControlVariables(C, {
							label: "X",
							get variable() {
								return D().variables.x;
							},
							type: "number",
							get value() {
								return D().x;
							},
							onChange: F,
							get api() {
								return E;
							}
						});
					}, L = (C) => {
						LabelInput(C, {
							label: "X",
							type: "number",
							get value() {
								return D().x;
							},
							onChange: F
						});
					};
					if_block(O, (C) => {
						D().variables && D().variables.x ? C(I) : C(L, !1);
					});
					var z = sibling(O, 2), B = (C) => {
						ControlVariables(C, {
							label: "Y",
							get variable() {
								return D().variables.y;
							},
							type: "number",
							get value() {
								return D().y;
							},
							onChange: F,
							get api() {
								return E;
							}
						});
					}, V = (C) => {
						LabelInput(C, {
							label: "Y",
							type: "number",
							get value() {
								return D().y;
							},
							onChange: F
						});
					};
					if_block(z, (C) => {
						D().variables && D().variables.y ? C(B) : C(V, !1);
					}), append(C, T);
				}), reset(I);
				var L = sibling(I, 2);
				key(child(L), () => get(O), (C) => {
					var T = root_8$2(), O = first_child(T), I = (C) => {
						ControlVariables(C, {
							label: "Width",
							get variable() {
								return D().variables.width;
							},
							type: "number",
							get value() {
								return D().width;
							},
							onChange: F,
							get api() {
								return E;
							}
						});
					}, L = (C) => {
						LabelInput(C, {
							label: "Width",
							type: "number",
							get value() {
								return D().width;
							},
							onChange: F
						});
					};
					if_block(O, (C) => {
						D().variables && D().variables.width ? C(I) : C(L, !1);
					});
					var z = sibling(O, 2), B = (C) => {
						ControlVariables(C, {
							label: "Height",
							get variable() {
								return D().variables.height;
							},
							type: "number",
							get value() {
								return D().height;
							},
							onChange: F,
							get api() {
								return E;
							}
						});
					}, V = (C) => {
						LabelInput(C, {
							label: "Height",
							type: "number",
							get value() {
								return D().height;
							},
							onChange: F
						});
					};
					if_block(z, (C) => {
						D().variables && D().variables.height ? C(B) : C(V, !1);
					}), append(C, T);
				}), reset(L);
				var z = sibling(L, 2), B = (C) => {
					LabelInput(C, {
						label: "Align",
						type: "option",
						get options() {
							return lvAlignList;
						},
						get value() {
							return D().align;
						},
						onChange: F
					});
				};
				if_block(z, (C) => {
					D().align !== void 0 && C(B);
				}), append(C, T);
			};
			if_block(L, (C) => {
				D().isValid && C(z);
			}), append(C, I);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return D();
		},
		set props(C) {
			D(C), flushSync();
		}
	});
}
create_custom_element(Layout, { props: {} }, [], [], !0);
function cn(...C) {
	return twMerge(clsx(C));
}
var root_1$42 = /* @__PURE__ */ from_svg("<title> </title>"), root_2$17 = /* @__PURE__ */ from_svg("<desc> </desc>"), root$10 = /* @__PURE__ */ from_svg("<svg><!><!><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M6 18 17.94 6M18 18 6.06 6\"></path></svg>");
function CloseOutline(C, E) {
	var D, O, F, I, L;
	push(E, !0);
	let z = (D = getContext("iconCtx")) == null ? {} : D, B = {
		xs: "w-3 h-3",
		sm: "w-4 h-4",
		md: "w-5 h-5",
		lg: "w-6 h-6",
		xl: "w-8 h-8"
	}, V = prop(E, "size", 23, () => z.size || "md"), U = prop(E, "color", 23, () => z.color || "currentColor"), W = prop(E, "title", 7), G = prop(E, "strokeWidth", 23, () => z.strokeWidth || 2), K = prop(E, "desc", 7), J = prop(E, "class", 7), Y = prop(E, "ariaLabel", 7), X = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"size",
		"color",
		"title",
		"strokeWidth",
		"desc",
		"class",
		"ariaLabel"
	]), Z = `${((O = W()) == null ? void 0 : O.id) || ""} ${((F = K()) == null ? void 0 : F.id) || ""}`.trim(), Q = !!((I = W()) != null && I.id || (L = K()) != null && L.id), NL = !!Y() || Q;
	var PL = {
		get size() {
			return V();
		},
		set size(C = z.size || "md") {
			V(C), flushSync();
		},
		get color() {
			return U();
		},
		set color(C = z.color || "currentColor") {
			U(C), flushSync();
		},
		get title() {
			return W();
		},
		set title(C) {
			W(C), flushSync();
		},
		get strokeWidth() {
			return G();
		},
		set strokeWidth(C = z.strokeWidth || 2) {
			G(C), flushSync();
		},
		get desc() {
			return K();
		},
		set desc(C) {
			K(C), flushSync();
		},
		get class() {
			return J();
		},
		set class(C) {
			J(C), flushSync();
		},
		get ariaLabel() {
			return Y();
		},
		set ariaLabel(C) {
			Y(C), flushSync();
		}
	}, FL = root$10();
	attribute_effect(FL, (C) => _objectSpread2(_objectSpread2({
		xmlns: "http://www.w3.org/2000/svg",
		fill: "none",
		color: U()
	}, X), {}, {
		class: C,
		viewBox: "0 0 24 24",
		"aria-label": Y(),
		"aria-describedby": Q ? Z : void 0,
		"aria-hidden": !NL
	}), [() => cn("shrink-0", B[V()], J())]);
	var IL = child(FL), LL = (C) => {
		var T = root_1$42(), E = child(T, !0);
		reset(T), template_effect(() => {
			set_attribute(T, "id", W().id), set_text(E, W().title);
		}), append(C, T);
	};
	if_block(IL, (C) => {
		var T;
		(T = W()) != null && T.id && W().title && C(LL);
	});
	var RL = sibling(IL), zL = (C) => {
		var T = root_2$17(), E = child(T, !0);
		reset(T), template_effect(() => {
			set_attribute(T, "id", K().id), set_text(E, K().desc);
		}), append(C, T);
	};
	if_block(RL, (C) => {
		var T;
		(T = K()) != null && T.id && K().desc && C(zL);
	});
	var BL = sibling(RL);
	return reset(FL), template_effect(() => set_attribute(BL, "stroke-width", G())), append(C, FL), pop(PL);
}
create_custom_element(CloseOutline, {
	size: {},
	color: {},
	title: {},
	strokeWidth: {},
	desc: {},
	class: {},
	ariaLabel: {}
}, [], [], !0);
var root_1$41 = /* @__PURE__ */ from_svg("<title> </title>"), root_2$16 = /* @__PURE__ */ from_svg("<desc> </desc>"), root$9 = /* @__PURE__ */ from_svg("<svg><!><!><path fill-rule=\"evenodd\" d=\"M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm9.408-5.5a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2h-.01ZM10 10a1 1 0 1 0 0 2h1v3h-1a1 1 0 1 0 0 2h4a1 1 0 1 0 0-2h-1v-4a1 1 0 0 0-1-1h-2Z\" clip-rule=\"evenodd\"></path></svg>");
function InfoCircleSolid(C, E) {
	var D, O, F, I, L;
	push(E, !0);
	let z = (D = getContext("iconCtx")) == null ? {} : D, B = {
		xs: "w-3 h-3",
		sm: "w-4 h-4",
		md: "w-5 h-5",
		lg: "w-6 h-6",
		xl: "w-8 h-8"
	}, V = prop(E, "size", 23, () => z.size || "md"), U = prop(E, "color", 23, () => z.color || "currentColor"), W = prop(E, "title", 7), G = prop(E, "desc", 7), K = prop(E, "class", 7), J = prop(E, "ariaLabel", 7), Y = /* @__PURE__ */ rest_props(E, [
		"$$slots",
		"$$events",
		"$$legacy",
		"$$host",
		"size",
		"color",
		"title",
		"desc",
		"class",
		"ariaLabel"
	]), X = `${((O = W()) == null ? void 0 : O.id) || ""} ${((F = G()) == null ? void 0 : F.id) || ""}`.trim(), Z = !!((I = W()) != null && I.id || (L = G()) != null && L.id), Q = !!J() || Z;
	var NL = {
		get size() {
			return V();
		},
		set size(C = z.size || "md") {
			V(C), flushSync();
		},
		get color() {
			return U();
		},
		set color(C = z.color || "currentColor") {
			U(C), flushSync();
		},
		get title() {
			return W();
		},
		set title(C) {
			W(C), flushSync();
		},
		get desc() {
			return G();
		},
		set desc(C) {
			G(C), flushSync();
		},
		get class() {
			return K();
		},
		set class(C) {
			K(C), flushSync();
		},
		get ariaLabel() {
			return J();
		},
		set ariaLabel(C) {
			J(C), flushSync();
		}
	}, PL = root$9();
	attribute_effect(PL, (C) => _objectSpread2(_objectSpread2({
		xmlns: "http://www.w3.org/2000/svg",
		fill: U()
	}, Y), {}, {
		class: C,
		viewBox: "0 0 24 24",
		"aria-label": J(),
		"aria-describedby": Z ? X : void 0,
		"aria-hidden": !Q
	}), [() => cn("shrink-0", B[V()], K())]);
	var FL = child(PL), IL = (C) => {
		var T = root_1$41(), E = child(T, !0);
		reset(T), template_effect(() => {
			set_attribute(T, "id", W().id), set_text(E, W().title);
		}), append(C, T);
	};
	if_block(FL, (C) => {
		var T;
		(T = W()) != null && T.id && W().title && C(IL);
	});
	var LL = sibling(FL), RL = (C) => {
		var T = root_2$16(), E = child(T, !0);
		reset(T), template_effect(() => {
			set_attribute(T, "id", G().id), set_text(E, G().desc);
		}), append(C, T);
	};
	return if_block(LL, (C) => {
		var T;
		(T = G()) != null && T.id && G().desc && C(RL);
	}), next(), reset(PL), append(C, PL), pop(NL);
}
create_custom_element(InfoCircleSolid, {
	size: {},
	color: {},
	title: {},
	desc: {},
	class: {},
	ariaLabel: {}
}, [], [], !0);
var root_1$40 = /* @__PURE__ */ from_html("<div class=\"flex justify-start items-center gap-3 relative\"><div><!> <!></div> <!> <!></div>");
function Name(C, T) {
	push(T, !0);
	let E = prop(T, "props", 7), D = /* @__PURE__ */ state(proxy(E().name)), O = /* @__PURE__ */ state(!1), F = /* @__PURE__ */ state(""), I = /* @__PURE__ */ state(!0);
	function L() {
		set(O, !0), setTimeout(() => {
			set(O, !1);
		}, 2e3);
	}
	function z() {
		var C;
		let T = LvglBaseNameSet;
		if (T.has(get(D)) && get(D) !== E().name) {
			set(F, "name already exists"), L();
			return;
		}
		let O = (C = widgetProps.curlvglShape) == null ? void 0 : C.id;
		if (!O) {
			set(F, "no widget selected"), L();
			return;
		}
		let I = findWidget(widgetStores.widgets, O);
		I && (I.name = get(D), T.delete(E().name), E().name = get(D), T.add(get(D)));
	}
	var B = {
		get props() {
			return E();
		},
		set props(C) {
			E(C), flushSync();
		}
	}, V = comment();
	return key(first_child(V), () => widgetProps.update, (C) => {
		var T = root_1$40(), L = child(T), B = child(L);
		Input(B, {
			type: "text",
			required: !0,
			size: "sm",
			get value() {
				return E().name;
			},
			oninput: (C) => {
				set(D, C.target.value, !0), set(I, isValidCVariableName(get(D)), !0);
			}
		});
		var V = sibling(B, 2), U = (C) => {
			Helper(C, {
				class: "mt-2",
				color: "red",
				children: (C, T) => {
					next(), append(C, text("C"));
				},
				$$slots: { default: !0 }
			});
		};
		if_block(V, (C) => {
			get(I) || C(U);
		}), reset(L);
		var W = sibling(L, 2);
		{
			let C = /* @__PURE__ */ user_derived(() => !get(I));
			Button(W, {
				class: "bg-sky-500 text-white h-8",
				onclick: z,
				get disabled() {
					return get(C);
				},
				children: (C, T) => {
					next(), append(C, text("Rename"));
				},
				$$slots: { default: !0 }
			});
		}
		Alert(sibling(W, 2), {
			color: "red",
			class: "w-[50%] left-1/2 -translate-x-1/2 absolute",
			get alertStatus() {
				return get(O);
			},
			set alertStatus(C) {
				set(O, C, !0);
			},
			icon: (C) => {
				InfoCircleSolid(C, { class: "h-5 w-5" });
			},
			children: (C, T) => {
				next();
				var E = text();
				template_effect(() => set_text(E, get(F))), append(C, E);
			},
			$$slots: {
				icon: !0,
				default: !0
			}
		}), reset(T), append(C, T);
	}), append(C, V), pop(B);
}
create_custom_element(Name, { props: {} }, [], [], !0);
var root_1$39 = /* @__PURE__ */ from_html("<div class=\"flex\"><!> <!></div> <!> <div class=\"flex\"><!> <!></div> <!> <!>", 1);
function Arc$1(C, T) {
	push(T, !0);
	let E = getContext("mcxa_api"), D = [
		{
			value: 0,
			name: "NORMAL"
		},
		{
			value: 1,
			name: "REVERSE"
		},
		{
			value: 2,
			name: "SYMMETRICAL"
		}
	], O = prop(T, "props", 7);
	function F(C, T) {
		T && (T = toCamelCase(T), T === "value" && (C < O().minValue && (C = O().minValue), C > O().maxValue && (C = O().maxValue)), O()[T] = C);
	}
	function I(C) {
		let T = Number(C);
		return isNaN(T) ? !1 : T >= O().minValue && T <= O().maxValue;
	}
	return WgtAccordionItem(C, {
		label: "Arc",
		children: (C, T) => {
			var L = root_1$39(), z = first_child(L), B = child(z);
			ControlVariables(B, {
				label: "Min Value",
				get variable() {
					return O().variables.minValue;
				},
				type: "number",
				get value() {
					return O().minValue;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(B, 2), {
				label: "Max Value",
				get variable() {
					return O().variables.maxValue;
				},
				type: "number",
				get value() {
					return O().maxValue;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), reset(z);
			var V = sibling(z, 2);
			ControlVariables(V, {
				label: "Value",
				get variable() {
					return O().variables.value;
				},
				type: "number",
				get value() {
					return O().value;
				},
				valid: I,
				onChange: F,
				get api() {
					return E;
				}
			});
			var U = sibling(V, 2), W = child(U);
			ControlVariables(W, {
				label: "Bg Angle Start",
				get variable() {
					return O().variables.bgAngleStart;
				},
				type: "number",
				get value() {
					return O().bgAngleStart;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(W, 2), {
				get variable() {
					return O().variables.bgAngleEnd;
				},
				label: "Bg Angle End",
				type: "number",
				get value() {
					return O().bgAngleEnd;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), reset(U);
			var G = sibling(U, 2);
			LabelInput(G, {
				label: "Mode",
				type: "option",
				get options() {
					return D;
				},
				get value() {
					return O().mode;
				},
				onChange: F
			}), ControlVariables(sibling(G, 2), {
				get variable() {
					return O().variables.rotation;
				},
				label: "Rotation",
				type: "number",
				get value() {
					return O().rotation;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), append(C, L);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return O();
		},
		set props(C) {
			O(C), flushSync();
		}
	});
}
create_custom_element(Arc$1, { props: {} }, [], [], !0);
var root_3$12 = /* @__PURE__ */ from_html(" <br/> ", 1), root_1$38 = /* @__PURE__ */ from_html("<!> <!> <!> <!> <div class=\"flex items-center\"><!> <!></div> <div class=\"flex items-center\"><!> <!></div>", 1);
function Image$1(C, T) {
	push(T, !0);
	let E = getContext("mcxa_api"), D = [
		{
			name: "Hight adaptation",
			value: 2
		},
		{
			name: "Width adaptation",
			value: 1
		},
		{
			name: "All adaptation",
			value: 3
		},
		{
			name: "No adaptation",
			value: 4
		}
	], O = /* @__PURE__ */ state(""), F = /* @__PURE__ */ state(0), I = /* @__PURE__ */ state(0), L = prop(T, "props", 7), z = /* @__PURE__ */ user_derived(() => Asserts.data.filter((C) => C.type === "image").map((C) => ({
		name: C.name,
		value: C.name
	})));
	function B(C, T) {
		T && (T = toCamelCase(T), L()[T] = C);
	}
	return WgtAccordionItem(C, {
		label: "Image",
		children: (C, T) => {
			var V = root_1$38(), U = first_child(V);
			ControlVariables(U, {
				label: "Assert",
				get variable() {
					return L().variables.assert;
				},
				type: "option",
				get options() {
					return get(z);
				},
				get value() {
					return L().assert;
				},
				onChange: B,
				get api() {
					return E;
				}
			});
			var W = sibling(U, 2);
			LabelInput(W, {
				label: "Is Align",
				type: "checkbox",
				get value() {
					return L().isAlign;
				},
				onChange: B
			});
			var G = sibling(W, 2);
			Label(G, {
				class: "flex-auto mx-1 my-1",
				children: (C, T) => {
					var E = comment(), D = first_child(E), L = (C) => {
						var T, E, D = root_3$12(), L = first_child(D, !0);
						L.nodeValue = get(O);
						var z = sibling(L, 2);
						z.nodeValue = ` W: ${(T = get(F)) == null ? "" : T} H: ${(E = get(I)) == null ? "" : E}`, append(C, D);
					}, z = (C) => {
						append(C, text("Select an image"));
					};
					if_block(D, (C) => {
						get(O) == "" ? C(z, !1) : C(L);
					}), append(C, E);
				},
				$$slots: { default: !0 }
			});
			var K = sibling(G, 2);
			LabelInput(K, {
				label: "Flag",
				type: "option",
				get options() {
					return D;
				},
				get value() {
					return L().flag;
				},
				onChange: B
			});
			var J = sibling(K, 2), Y = child(J);
			ControlVariables(Y, {
				label: "Pivot X",
				get variable() {
					return L().variables.pivotX;
				},
				type: "number",
				get value() {
					return L().pivotX;
				},
				onChange: B,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(Y, 2), {
				label: "Pivot Y",
				get variable() {
					return L().variables.pivotY;
				},
				type: "number",
				get value() {
					return L().pivotY;
				},
				onChange: B,
				get api() {
					return E;
				}
			}), reset(J);
			var X = sibling(J, 2), Z = child(X);
			ControlVariables(Z, {
				label: "Rotation",
				get variable() {
					return L().variables.rotation;
				},
				type: "number",
				get value() {
					return L().rotation;
				},
				onChange: B,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(Z, 2), {
				label: "Scale",
				get variable() {
					return L().variables.scale;
				},
				type: "number",
				get value() {
					return L().scale;
				},
				onChange: B,
				get api() {
					return E;
				}
			}), reset(X), append(C, V);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return L();
		},
		set props(C) {
			L(C), flushSync();
		}
	});
}
create_custom_element(Image$1, { props: {} }, [], [], !0);
var root_1$37 = /* @__PURE__ */ from_html("<!> <!>", 1);
function Label$1(C, T) {
	push(T, !0);
	let E = getContext("mcxa_api"), D = prop(T, "props", 7);
	function O(C, T) {
		T && (T = toCamelCase(T), D()[T] = C);
	}
	return WgtAccordionItem(C, {
		label: "Label",
		children: (C, T) => {
			var F = root_1$37(), I = first_child(F);
			ControlVariables(I, {
				label: "Long Mode",
				get variable() {
					return D().variables.longMode;
				},
				type: "option",
				get options() {
					return textModeList;
				},
				get value() {
					return D().longMode;
				},
				onChange: O,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(I, 2), {
				label: "Text",
				get variable() {
					return D().variables.text;
				},
				type: "textarea",
				get value() {
					return D().text;
				},
				rows: 2,
				onChange: O,
				get api() {
					return E;
				}
			}), append(C, F);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return D();
		},
		set props(C) {
			D(C), flushSync();
		}
	});
}
create_custom_element(Label$1, { props: {} }, [], [], !0);
var root_5$6 = /* @__PURE__ */ from_html("<div class=\"flex py-1 items-center gap-4\"><!> <!> <button type=\"button\" class=\" justify-center top-0.5 right-4 bg-transparent text-white rounded\"><!></button></div>"), root_3$11 = /* @__PURE__ */ from_html("<div class=\"flex justify-between mr-4\"><p class=\"flex-1 text-center\">NAME</p></div> <!> <div class=\"text-center py-4 h-16\"><!></div>", 1), root_1$36 = /* @__PURE__ */ from_html("<div class=\"flex items-center gap-2\"><!> <!></div> <!> <!>", 1);
function TabView(C, T) {
	push(T, !0);
	let E = prop(T, "props", 7), D = /* @__PURE__ */ state(1), O = /* @__PURE__ */ state(proxy([]));
	function F() {
		let C = {
			id: genRandomStr(8),
			name: "Tab " + (E().tabCnt + 1)
		};
		get(O).push(C), E().addTab(C), E().curFocus = E().tabCnt - 1, update(D);
	}
	function I(C) {
		E().removeTab(C), update(D);
	}
	function L(C) {
		let T = E().tabs[C];
		E().renameTab(C, T.name), update(D);
	}
	return WgtAccordionItem(C, {
		label: "TabView",
		children: (C, T) => {
			var O = root_1$36(), z = first_child(O), B = child(z);
			LabelInput(B, {
				label: "Tab Position",
				get value() {
					return E().position;
				},
				type: "option",
				get options() {
					return dirPositionList;
				},
				onChange: (C) => {
					E().position = C;
				}
			}), LabelInput(sibling(B, 2), {
				label: "Tab Size",
				get value() {
					return E().tabsize;
				},
				type: "number",
				onChange: (C) => {
					E().tabsize = C;
				}
			}), reset(z);
			var V = sibling(z, 2);
			key(V, () => get(D), (C) => {
				{
					let T = /* @__PURE__ */ user_derived(() => E().tabs.length - 1);
					LabelInput(C, {
						label: "Current Tab",
						get value() {
							return E().activeTab;
						},
						type: "number",
						min: 0,
						get max() {
							return get(T);
						},
						onChange: (C) => {
							E().activeTab = C;
						}
					});
				}
			}), WgtAccordionItem(sibling(V, 2), {
				label: "TabView",
				children: (C, T) => {
					var O = root_3$11(), z = sibling(first_child(O), 2);
					key(z, () => get(D), (C) => {
						var T = comment();
						each(first_child(T), 19, () => E().tabs, (C) => C.id, (C, T, E) => {
							var D = root_5$6(), O = child(D);
							PropertyInput(O, {
								type: "string",
								label: "",
								get value() {
									return get(T).name;
								},
								onChange: (C) => {
									get(T).name = C;
								}
							});
							var F = sibling(O, 2);
							Button(F, {
								class: "p-1 rounded-full bg-sky-500/100  h-8 text-white hover:bg-sky-600 focus-within:outline-none",
								onclick: () => L(get(E)),
								children: (C, T) => {
									next(), append(C, text("Rename"));
								},
								$$slots: { default: !0 }
							});
							var z = sibling(F, 2);
							z.__click = () => I(get(E)), CloseOutline(child(z), { size: "md" }), reset(z), reset(D), append(C, D);
						}), append(C, T);
					});
					var B = sibling(z, 2);
					Button(child(B), {
						class: "rounded-full bg-sky-500/100 w-36 h-6 text-white hover:bg-sky-600 focus-within:outline-none",
						onclick: F,
						children: (C, T) => {
							next(), append(C, text("ADD TAB PAGE"));
						},
						$$slots: { default: !0 }
					}), reset(B), append(C, O);
				},
				$$slots: { default: !0 }
			}), append(C, O);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return E();
		},
		set props(C) {
			E(C), flushSync();
		}
	});
}
delegate(["click"]), create_custom_element(TabView, { props: {} }, [], [], !0);
var root_1$35 = /* @__PURE__ */ from_html("<!> <!> <div class=\"flex items-center\"><!> <!></div> <!> <!>", 1);
function TextArea(C, T) {
	push(T, !0);
	let E = getContext("mcxa_api"), D = prop(T, "props", 7);
	function O(C, T) {
		T && (T = toCamelCase(T), D()[T] = C);
	}
	return WgtAccordionItem(C, {
		label: "TextArea",
		children: (C, T) => {
			var F = root_1$35(), I = first_child(F);
			ControlVariables(I, {
				label: "Text",
				get variable() {
					return D().variables.text;
				},
				type: "string",
				get value() {
					return D().text;
				},
				onChange: O,
				get api() {
					return E;
				}
			});
			var L = sibling(I, 2);
			LabelInput(L, {
				label: "Placeholder",
				type: "string",
				get value() {
					return D().placeholder;
				},
				onChange: O
			});
			var z = sibling(L, 2), B = child(z);
			ControlVariables(B, {
				label: "Password Mode",
				get variable() {
					return D().variables.passwordMode;
				},
				type: "checkbox",
				get value() {
					return D().passwordMode;
				},
				onChange: O,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(B, 2), {
				label: "Oneline Mode",
				get variable() {
					return D().variables.onelineMode;
				},
				type: "checkbox",
				get value() {
					return D().onelineMode;
				},
				onChange: O,
				get api() {
					return E;
				}
			}), reset(z);
			var V = sibling(z, 2);
			ControlVariables(V, {
				label: "Accepted Characters",
				get variable() {
					return D().variables.acceptedCharacters;
				},
				type: "string",
				get value() {
					return D().acceptedCharacters;
				},
				onChange: O,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(V, 2), {
				label: "Max Length",
				get variable() {
					return D().variables.maxLength;
				},
				type: "number",
				get value() {
					return D().maxLength;
				},
				onChange: O,
				get api() {
					return E;
				}
			}), append(C, F);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return D();
		},
		set props(C) {
			D(C), flushSync();
		}
	});
}
create_custom_element(TextArea, { props: {} }, [], [], !0);
var root$8 = /* @__PURE__ */ from_html("<div class=\"flex items-center gap-1\"><!> <!> <!></div>");
function Calendar(C, T) {
	push(T, !0);
	let E = getContext("mcxa_api"), D = prop(T, "props", 7);
	function O(C, T) {
		T && (T = toCamelCase(T), D()[T] = C);
	}
	var F = {
		get props() {
			return D();
		},
		set props(C) {
			D(C), flushSync();
		}
	}, I = root$8(), L = child(I);
	ControlVariables(L, {
		label: "Today Day",
		get variable() {
			return D().variables.todayDay;
		},
		type: "number",
		get value() {
			return D().todayDay;
		},
		onChange: O,
		get api() {
			return E;
		}
	});
	var z = sibling(L, 2);
	return ControlVariables(z, {
		label: "Today Month",
		get variable() {
			return D().variables.todayMonth;
		},
		type: "number",
		get value() {
			return D().todayMonth;
		},
		onChange: O,
		get api() {
			return E;
		}
	}), ControlVariables(sibling(z, 2), {
		label: "Today Year",
		get variable() {
			return D().variables.todayYear;
		},
		type: "number",
		get value() {
			return D().todayYear;
		},
		onChange: O,
		get api() {
			return E;
		}
	}), reset(I), append(C, I), pop(F);
}
create_custom_element(Calendar, { props: {} }, [], [], !0);
function Checkbox$1(C, T) {
	push(T, !0);
	let E = getContext("mcxa_api"), D = prop(T, "props", 7);
	function O(C, T) {
		T && (T = toCamelCase(T), D()[T] = C);
	}
	return WgtAccordionItem(C, {
		label: "CheckBox",
		children: (C, T) => {
			ControlVariables(C, {
				label: "Title",
				get variable() {
					return D().variables.title;
				},
				type: "string",
				get value() {
					return D().title;
				},
				onChange: O,
				get api() {
					return E;
				}
			});
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return D();
		},
		set props(C) {
			D(C), flushSync();
		}
	});
}
create_custom_element(Checkbox$1, { props: {} }, [], [], !0);
var root_1$34 = /* @__PURE__ */ from_html("<!> <!> <!> <!>", 1);
function Dropdown(C, T) {
	push(T, !0);
	let E = getContext("mcxa_api"), D = [
		{
			name: "None",
			value: lv_dir_t$1.LV_DIR_NONE
		},
		{
			name: "Top",
			value: lv_dir_t$1.LV_DIR_TOP
		},
		{
			name: "Bottom",
			value: lv_dir_t$1.LV_DIR_BOTTOM
		},
		{
			name: "Left",
			value: lv_dir_t$1.LV_DIR_LEFT
		},
		{
			name: "Right",
			value: lv_dir_t$1.LV_DIR_RIGHT
		},
		{
			name: "Horizontal",
			value: lv_dir_t$1.LV_DIR_HOR
		},
		{
			name: "Vertical",
			value: lv_dir_t$1.LV_DIR_VER
		},
		{
			name: "All",
			value: lv_dir_t$1.LV_DIR_ALL
		}
	], O = prop(T, "props", 7);
	function F(C, T) {
		T && (T = toCamelCase(T), O()[T] = C);
	}
	return WgtAccordionItem(C, {
		label: "Dropdown",
		children: (C, T) => {
			var I = root_1$34(), L = first_child(I);
			ControlVariables(L, {
				label: "Options",
				get variable() {
					return O().variables.options;
				},
				type: "textarea",
				get value() {
					return O().options;
				},
				onChange: F,
				get api() {
					return E;
				}
			});
			var z = sibling(L, 2);
			LabelInput(z, {
				label: "Dir",
				get variable() {
					return O().variables.dir;
				},
				type: "option",
				get options() {
					return D;
				},
				get value() {
					return O().dir;
				},
				onChange: F
			});
			var B = sibling(z, 2);
			ControlVariables(B, {
				label: "Selected Highlight",
				get variable() {
					return O().variables.selectedHighlight;
				},
				type: "checkbox",
				get value() {
					return O().selectedHighlight;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(B, 2), {
				label: "Base Text",
				get variable() {
					return O().variables.baseText;
				},
				type: "string",
				get value() {
					return O().baseText;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), append(C, I);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return O();
		},
		set props(C) {
			O(C), flushSync();
		}
	});
}
create_custom_element(Dropdown, { props: {} }, [], [], !0);
var root_1$33 = /* @__PURE__ */ from_html("<div></div>");
function Imgbutton(C, T) {
	push(T, !0);
	let E = prop(T, "props", 7);
	return WgtAccordionItem(C, {
		label: "Imgbutton",
		children: (C, T) => {
			append(C, root_1$33());
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return E();
		},
		set props(C) {
			E(C), flushSync();
		}
	});
}
create_custom_element(Imgbutton, { props: {} }, [], [], !0);
var root_1$32 = /* @__PURE__ */ from_html("<div>Keyboard</div>");
function Keyboard(C, T) {
	push(T, !0);
	let E = prop(T, "props", 7);
	return WgtAccordionItem(C, {
		label: "Keyboard",
		children: (C, T) => {
			append(C, root_1$32());
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return E();
		},
		set props(C) {
			E(C), flushSync();
		}
	});
}
create_custom_element(Keyboard, { props: {} }, [], [], !0);
var root_1$31 = /* @__PURE__ */ from_html("<!> <!> <div class=\"flex items-center\"><!> <!></div>", 1);
function Roller(C, T) {
	push(T, !0);
	let E = getContext("mcxa_api"), D = [{
		value: 0,
		name: "NORMAL"
	}, {
		value: 1,
		name: "INFINITE"
	}], O = prop(T, "props", 7);
	proxy([]);
	function F(C, T) {
		T && (T = toCamelCase(T), O()[T] = C);
	}
	return WgtAccordionItem(C, {
		label: "Roller",
		children: (C, T) => {
			var I = root_1$31(), L = first_child(I);
			ControlVariables(L, {
				label: "Options",
				get variable() {
					return O().variables.options;
				},
				type: "textarea",
				get value() {
					return O().options;
				},
				onChange: F,
				get api() {
					return E;
				}
			});
			var z = sibling(L, 2);
			LabelInput(z, {
				label: "Mode",
				type: "option",
				get options() {
					return D;
				},
				get value() {
					return O().mode;
				},
				onChange: F
			});
			var B = sibling(z, 2), V = child(B);
			ControlVariables(V, {
				label: "Selected",
				get variable() {
					return O().variables.selected;
				},
				type: "number",
				get value() {
					return O().selected;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(V, 2), {
				label: "Visible Row Count",
				get variable() {
					return O().variables.visibleRowCount;
				},
				type: "number",
				get value() {
					return O().visibleRowCount;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), reset(B), append(C, I);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return O();
		},
		set props(C) {
			O(C), flushSync();
		}
	});
}
create_custom_element(Roller, { props: {} }, [], [], !0);
var root_1$30 = /* @__PURE__ */ from_html("<div class=\"flex items-center\"><!> <!></div> <!> <!> <!>", 1);
function Slider(C, T) {
	push(T, !0);
	let E = getContext("mcxa_api"), D = [
		{
			value: lv_slider_mode_t$1.LV_SLIDER_MODE_NORMAL,
			name: "NORMAL"
		},
		{
			value: lv_slider_mode_t$1.LV_SLIDER_MODE_RANGE,
			name: "RANGE"
		},
		{
			value: lv_slider_mode_t$1.LV_SLIDER_MODE_SYMMETRICAL,
			name: "SYMMETRICAL"
		}
	], O = prop(T, "props", 7);
	function F(C, T) {
		T && (T = toCamelCase(T), T === "value" && (C < O().min && (C = O().min), C > O().max && (C = O().max)), O()[T] = C);
	}
	return WgtAccordionItem(C, {
		label: "Slider",
		children: (C, T) => {
			var I = root_1$30(), L = first_child(I), z = child(L);
			ControlVariables(z, {
				label: "Min",
				get variable() {
					return O().variables.min;
				},
				type: "number",
				get value() {
					return O().min;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(z, 2), {
				label: "Max",
				get variable() {
					return O().variables.max;
				},
				type: "number",
				get value() {
					return O().max;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), reset(L);
			var B = sibling(L, 2);
			LabelInput(B, {
				label: "Mode",
				type: "option",
				get options() {
					return D;
				},
				get value() {
					return O().mode;
				},
				onChange: F
			});
			var V = sibling(B, 2);
			ControlVariables(V, {
				label: "Value",
				get variable() {
					return O().variables.value;
				},
				type: "number",
				get value() {
					return O().value;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(V, 2), {
				label: "Value Left",
				get variable() {
					return O().variables.valueLeft;
				},
				type: "number",
				get value() {
					return O().valueLeft;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), append(C, I);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return O();
		},
		set props(C) {
			O(C), flushSync();
		}
	});
}
create_custom_element(Slider, { props: {} }, [], [], !0);
var root_1$29 = /* @__PURE__ */ from_html("<div class=\"flex items-center\"><!> <!></div> <div class=\"flex items-center\"><!> <!></div> <div class=\"flex items-center\"><!> <!></div>", 1);
function Spinbox(C, T) {
	push(T, !0);
	let E = getContext("mcxa_api"), D = prop(T, "props", 7);
	function O(C, T) {
		T && (T = toCamelCase(T), D()[T] = C);
	}
	return WgtAccordionItem(C, {
		label: "Spinbox",
		children: (C, T) => {
			var F = root_1$29(), I = first_child(F), L = child(I);
			LabelInput(L, {
				label: "Digit Count",
				get variable() {
					return D().variables.digitCnt;
				},
				type: "number",
				get value() {
					return D().digitCnt;
				},
				onChange: (C) => D().digitCnt = C
			}), LabelInput(sibling(L, 2), {
				label: "Digit Position",
				get variable() {
					return D().variables.digitPosition;
				},
				type: "number",
				get value() {
					return D().digitPosition;
				},
				onChange: O
			}), reset(I);
			var z = sibling(I, 2), B = child(z);
			LabelInput(B, {
				label: "Min",
				get variable() {
					return D().variables.min;
				},
				type: "number",
				get value() {
					return D().min;
				},
				onChange: O
			}), LabelInput(sibling(B, 2), {
				label: "Max",
				get variable() {
					return D().variables.max;
				},
				type: "number",
				get value() {
					return D().max;
				},
				onChange: O
			}), reset(z);
			var V = sibling(z, 2), U = child(V);
			ControlVariables(U, {
				label: "Step",
				get variable() {
					return D().variables.step;
				},
				type: "number",
				get value() {
					return D().step;
				},
				onChange: O,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(U, 2), {
				label: "Value",
				get variable() {
					return D().variables.value;
				},
				type: "number",
				get value() {
					return D().value;
				},
				onChange: O,
				get api() {
					return E;
				}
			}), reset(V), append(C, F);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return D();
		},
		set props(C) {
			D(C), flushSync();
		}
	});
}
create_custom_element(Spinbox, { props: {} }, [], [], !0);
var root_1$28 = /* @__PURE__ */ from_html("<div class=\"flex items-center\"><!> <!></div> <!> <!> <!>", 1);
function Bar(C, T) {
	push(T, !0);
	let E = getContext("mcxa_api"), D = [
		{
			value: lv_bar_mode_t$1.LV_BAR_MODE_NORMAL,
			name: "NORMAL"
		},
		{
			value: lv_bar_mode_t$1.LV_BAR_MODE_SYMMETRICAL,
			name: "REVERSE"
		},
		{
			value: lv_bar_mode_t$1.LV_BAR_MODE_SYMMETRICAL,
			name: "SYMMETRICAL"
		}
	], O = prop(T, "props", 7);
	function F(C, T) {
		T && (T = toCamelCase(T), T === "value" && (C < O().min && (C = O().min), C > O().max && (C = O().max)), O()[T] = C);
	}
	return WgtAccordionItem(C, {
		label: "Bar",
		children: (C, T) => {
			var I = root_1$28(), L = first_child(I), z = child(L);
			ControlVariables(z, {
				label: "Min",
				get variable() {
					return O().variables.min;
				},
				type: "number",
				get value() {
					return O().min;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(z, 2), {
				label: "Max",
				get variable() {
					return O().variables.max;
				},
				type: "number",
				get value() {
					return O().max;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), reset(L);
			var B = sibling(L, 2);
			ControlVariables(B, {
				label: "Value",
				get variable() {
					return O().variables.value;
				},
				type: "number",
				get value() {
					return O().value;
				},
				onChange: F,
				get api() {
					return E;
				}
			});
			var V = sibling(B, 2);
			ControlVariables(V, {
				label: "Start Value",
				get variable() {
					return O().variables.startValue;
				},
				type: "number",
				get value() {
					return O().startValue;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), LabelInput(sibling(V, 2), {
				label: "Mode",
				get variable() {
					return O().variables.mode;
				},
				type: "option",
				get options() {
					return D;
				},
				get value() {
					return O().mode;
				},
				onChange: F
			}), append(C, I);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return O();
		},
		set props(C) {
			O(C), flushSync();
		}
	});
}
create_custom_element(Bar, { props: {} }, [], [], !0);
var root_3$10 = /* @__PURE__ */ from_html("<span>Color</span> <!>", 1), root_4$9 = /* @__PURE__ */ from_html("Axis <!>", 1), root_5$5 = /* @__PURE__ */ from_html("<span>Data</span> <!>", 1), root_2$15 = /* @__PURE__ */ from_html("<div class=\"flex\"><!> <!></div> <!>", 1);
function Data(C, T) {
	push(T, !1);
	let E = prop(T, "serieName", 12), D = [
		{
			value: 0,
			name: "NORMAL"
		},
		{
			value: 1,
			name: "REVERSE"
		},
		{
			value: 2,
			name: "SYMMETRICAL"
		}
	];
	return AccordionItem(C, {
		activeClass: "bg-gray-800 text-white",
		inactiveClass: "bg-gray-800 text-white",
		class: "bg-gray-800",
		header: (C) => {
			next();
			var T = text();
			template_effect(() => set_text(T, E())), append(C, T);
		},
		children: (C, T) => {
			var E = root_2$15(), O = first_child(E), F = child(O);
			Label(F, {
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_3$10();
					Input(sibling(first_child(E), 2), {
						type: "text",
						id: "first_name",
						placeholder: " ",
						required: !0,
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), Label(sibling(F, 2), {
				class: "flex-auto mx-1 my-1",
				children: (C, T) => {
					next();
					var E = root_4$9();
					Select(sibling(first_child(E)), {
						get items() {
							return D;
						},
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), reset(O), Label(sibling(O, 2), {
				for: "textarea-id",
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_5$5();
					Textarea(sibling(first_child(E), 2), {
						id: "textarea-id",
						placeholder: "Text",
						rows: 2,
						name: "message"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), append(C, E);
		},
		$$slots: {
			header: !0,
			default: !0
		}
	}), pop({
		get serieName() {
			return E();
		},
		set serieName(C) {
			E(C), flushSync();
		}
	});
}
create_custom_element(Data, { serieName: {} }, [], [], !0);
var root_3$9 = /* @__PURE__ */ from_html("<span>Major tick length</span> <!>", 1), root_4$8 = /* @__PURE__ */ from_html("<span>Major tick count</span> <!>", 1), root_5$4 = /* @__PURE__ */ from_html("<span>Minor tick length</span> <!>", 1), root_6$4 = /* @__PURE__ */ from_html("<span>Minor tick count</span> <!>", 1), root_8$1 = /* @__PURE__ */ from_html("<span>Zoom Y</span> <!>", 1), root_2$14 = /* @__PURE__ */ from_html("<div class=\"flex\"><!><!></div> <div class=\"flex\"><!><!></div> <!> <!>", 1), root_11$1 = /* @__PURE__ */ from_html("<span>Primary Y range min</span> <!>", 1), root_12 = /* @__PURE__ */ from_html("<span>Primary Y range max</span> <!>", 1), root_13$1 = /* @__PURE__ */ from_html("<span>Major tick length</span> <!>", 1), root_14 = /* @__PURE__ */ from_html("<span>Major tick count</span> <!>", 1), root_15 = /* @__PURE__ */ from_html("<span>Minor tick length</span> <!>", 1), root_16 = /* @__PURE__ */ from_html("<span>Minor tick count</span> <!>", 1), root_18 = /* @__PURE__ */ from_html("<span>Font size on Primary Y axis</span> <!>", 1), root_10$1 = /* @__PURE__ */ from_html("<div class=\"flex\"><!><!></div> <div class=\"flex\"><!><!></div> <div class=\"flex\"><!><!></div> <!> <!>", 1), root_21 = /* @__PURE__ */ from_html("<span>Secondary Y range min</span> <!>", 1), root_22 = /* @__PURE__ */ from_html("<span>Secondary Y range max</span> <!>", 1), root_23 = /* @__PURE__ */ from_html("<span>Major tick length</span> <!>", 1), root_24 = /* @__PURE__ */ from_html("<span>Major tick count</span> <!>", 1), root_25 = /* @__PURE__ */ from_html("<span>Minor tick length</span> <!>", 1), root_26 = /* @__PURE__ */ from_html("<span>Minor tick count</span> <!>", 1), root_28 = /* @__PURE__ */ from_html("<span>Font size on Secondary Y axis</span> <!>", 1), root_20 = /* @__PURE__ */ from_html("<div class=\"flex\"><!><!></div> <div class=\"flex\"><!><!></div> <div class=\"flex\"><!><!></div> <!> <!>", 1), root$7 = /* @__PURE__ */ from_html("<!> <!> <!>", 1);
function XYAxia(C) {
	let T = /* @__PURE__ */ mutable_source([
		!1,
		!1,
		!1
	]);
	var E = root$7(), D = first_child(E);
	AccordionItem(D, {
		activeClass: "bg-gray-800 text-white",
		inactiveClass: "bg-gray-800 text-white",
		class: "bg-gray-800",
		header: (C) => {
			next(), append(C, text("X Axis"));
		},
		children: (C, E) => {
			var D = root_2$14(), O = first_child(D), F = child(O);
			Label(F, {
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_3$9();
					Input(sibling(first_child(E), 2), {
						type: "text",
						id: "first_name",
						placeholder: " ",
						required: !0,
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), Label(sibling(F), {
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_4$8();
					Input(sibling(first_child(E), 2), {
						type: "text",
						id: "first_name",
						placeholder: " ",
						required: !0,
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), reset(O);
			var I = sibling(O, 2), L = child(I);
			Label(L, {
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_5$4();
					Input(sibling(first_child(E), 2), {
						type: "text",
						id: "first_name",
						placeholder: " ",
						required: !0,
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), Label(sibling(L), {
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_6$4();
					Input(sibling(first_child(E), 2), {
						type: "text",
						id: "first_name",
						placeholder: " ",
						required: !0,
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), reset(I);
			var z = sibling(I, 2);
			Checkbox(z, {
				class: "flex-none mx-1 ",
				get checked() {
					return get(T)[5];
				},
				set checked(C) {
					mutate(T, get(T)[5] = C);
				},
				children: (C, T) => {
					next(), append(C, text("Labels on X axis"));
				},
				$$slots: { default: !0 },
				$$legacy: !0
			}), Label(sibling(z, 2), {
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_8$1();
					Input(sibling(first_child(E), 2), {
						type: "text",
						id: "first_name",
						placeholder: " ",
						required: !0,
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), append(C, D);
		},
		$$slots: {
			header: !0,
			default: !0
		}
	});
	var O = sibling(D, 2);
	AccordionItem(O, {
		activeClass: "bg-gray-800 text-white",
		inactiveClass: "bg-gray-800 text-white",
		class: "bg-gray-800",
		header: (C) => {
			next(), append(C, text("Primary Y Axis"));
		},
		children: (C, E) => {
			var D = root_10$1(), O = first_child(D), F = child(O);
			Label(F, {
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_11$1();
					Input(sibling(first_child(E), 2), {
						type: "text",
						id: "first_name",
						placeholder: " ",
						required: !0,
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), Label(sibling(F), {
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_12();
					Input(sibling(first_child(E), 2), {
						type: "text",
						id: "first_name",
						placeholder: " ",
						required: !0,
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), reset(O);
			var I = sibling(O, 2), L = child(I);
			Label(L, {
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_13$1();
					Input(sibling(first_child(E), 2), {
						type: "text",
						id: "first_name",
						placeholder: " ",
						required: !0,
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), Label(sibling(L), {
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_14();
					Input(sibling(first_child(E), 2), {
						type: "text",
						id: "first_name",
						placeholder: " ",
						required: !0,
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), reset(I);
			var z = sibling(I, 2), B = child(z);
			Label(B, {
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_15();
					Input(sibling(first_child(E), 2), {
						type: "text",
						id: "first_name",
						placeholder: " ",
						required: !0,
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), Label(sibling(B), {
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_16();
					Input(sibling(first_child(E), 2), {
						type: "text",
						id: "first_name",
						placeholder: " ",
						required: !0,
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), reset(z);
			var V = sibling(z, 2);
			Checkbox(V, {
				class: "flex-none mx-1 ",
				get checked() {
					return get(T)[5];
				},
				set checked(C) {
					mutate(T, get(T)[5] = C);
				},
				children: (C, T) => {
					next(), append(C, text("Labels on Primary Y axis"));
				},
				$$slots: { default: !0 },
				$$legacy: !0
			}), Label(sibling(V, 2), {
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_18();
					Input(sibling(first_child(E), 2), {
						type: "text",
						id: "first_name",
						placeholder: " ",
						required: !0,
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), append(C, D);
		},
		$$slots: {
			header: !0,
			default: !0
		}
	}), AccordionItem(sibling(O, 2), {
		activeClass: "bg-gray-800 text-white",
		inactiveClass: "bg-gray-800 text-white",
		class: "bg-gray-800",
		header: (C) => {
			next(), append(C, text("Secondary Y Axis"));
		},
		children: (C, E) => {
			var D = root_20(), O = first_child(D), F = child(O);
			Label(F, {
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_21();
					Input(sibling(first_child(E), 2), {
						type: "text",
						id: "first_name",
						placeholder: " ",
						required: !0,
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), Label(sibling(F), {
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_22();
					Input(sibling(first_child(E), 2), {
						type: "text",
						id: "first_name",
						placeholder: " ",
						required: !0,
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), reset(O);
			var I = sibling(O, 2), L = child(I);
			Label(L, {
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_23();
					Input(sibling(first_child(E), 2), {
						type: "text",
						id: "first_name",
						placeholder: " ",
						required: !0,
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), Label(sibling(L), {
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_24();
					Input(sibling(first_child(E), 2), {
						type: "text",
						id: "first_name",
						placeholder: " ",
						required: !0,
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), reset(I);
			var z = sibling(I, 2), B = child(z);
			Label(B, {
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_25();
					Input(sibling(first_child(E), 2), {
						type: "text",
						id: "first_name",
						placeholder: " ",
						required: !0,
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), Label(sibling(B), {
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_26();
					Input(sibling(first_child(E), 2), {
						type: "text",
						id: "first_name",
						placeholder: " ",
						required: !0,
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), reset(z);
			var V = sibling(z, 2);
			Checkbox(V, {
				class: "flex-none mx-1 ",
				get checked() {
					return get(T)[5];
				},
				set checked(C) {
					mutate(T, get(T)[5] = C);
				},
				children: (C, T) => {
					next(), append(C, text("Labels on Secondary Y axis"));
				},
				$$slots: { default: !0 },
				$$legacy: !0
			}), Label(sibling(V, 2), {
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_28();
					Input(sibling(first_child(E), 2), {
						type: "text",
						id: "first_name",
						placeholder: " ",
						required: !0,
						size: "sm"
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), append(C, D);
		},
		$$slots: {
			header: !0,
			default: !0
		}
	}), append(C, E);
}
create_custom_element(XYAxia, {}, [], [], !0);
var root_5$3 = /* @__PURE__ */ from_html("<span class=\"text-white\">Color</span> <!>", 1), root_6$3 = /* @__PURE__ */ from_html("<span class=\"text-white\">Variable</span> <!>", 1), root_4$7 = /* @__PURE__ */ from_html("<div class=\"flex items-center gap-2\"><!> <!></div> <!> <!> <!> <!>", 1), root_1$27 = /* @__PURE__ */ from_html("<!> <!> <div class=\"flex items-center gap-2\"><!> <!></div> <!>", 1);
function Chart(C, T) {
	push(T, !0);
	let E = getContext("mcxa_api"), D = prop(T, "props", 7);
	function O(C, T) {
		T && (T = toCamelCase(T), D()[T] = C);
	}
	function F(C, T) {
		let E = T.hex;
		E && (D().serieses[C].color = E.substring(0, 7));
	}
	return WgtAccordionItem(C, {
		label: "Chart",
		children: (C, T) => {
			var I = root_1$27(), L = first_child(I);
			LabelInput(L, {
				label: "Type",
				get value() {
					return D().type;
				},
				type: "option",
				get options() {
					return lvChartTypeList;
				},
				onChange: O
			});
			var z = sibling(L, 2);
			LabelInput(z, {
				label: "Update Mode",
				get value() {
					return D().updateMode;
				},
				type: "option",
				get options() {
					return lvChartUpdateModeList;
				},
				onChange: O
			});
			var B = sibling(z, 2), V = child(B);
			LabelInput(V, {
				label: "Division Horizontal line count",
				get value() {
					return D().hdivLineCount;
				},
				type: "number",
				onChange: (C) => {
					D().hdivLineCount = C;
				}
			}), LabelInput(sibling(V, 2), {
				label: "Division Vertical line count",
				get value() {
					return D().vdivLineCount;
				},
				type: "number",
				onChange: (C) => {
					D().vdivLineCount = C;
				}
			}), reset(B), each(sibling(B, 2), 19, () => D().serieses, (C) => C.type, (C, T, I) => {
				AccordionItem(C, {
					activeClass: "bg-gray-800 text-white",
					inactiveClass: "bg-gray-800 text-white",
					class: "bg-gray-800",
					header: (C) => {
						next();
						var E = text();
						template_effect((C) => set_text(E, C), [() => {
							var C;
							return ((C = lvChartSeriesTypeList.find((C) => C.value === get(T).type)) == null ? void 0 : C.name) || "Unknown";
						}]), append(C, E);
					},
					children: (C, L) => {
						var z = root_4$7(), B = first_child(z), V = child(B);
						LabelInput(V, {
							label: "Min",
							get value() {
								return get(T).min;
							},
							type: "number",
							onChange: O
						}), LabelInput(sibling(V, 2), {
							label: "Max",
							get value() {
								return get(T).max;
							},
							type: "number",
							onChange: O
						}), reset(B);
						var U = sibling(B, 2);
						Label(U, {
							class: "flex-auto w-18 m-1",
							children: (C, E) => {
								var D = root_5$3(), O = sibling(first_child(D), 2);
								{
									let C = /* @__PURE__ */ user_derived(() => hexWithAlpha(get(T).color, 255));
									MCXAColorPicker(O, {
										get color() {
											return get(C);
										},
										onChange: (C) => F(get(I), C)
									});
								}
								append(C, D);
							},
							$$slots: { default: !0 }
						});
						var W = sibling(U, 2);
						Label(W, {
							class: "flex-auto w-18 m-1",
							children: (C, T) => {
								var D = root_6$3();
								Cascader(sibling(first_child(D), 2), { get api() {
									return E;
								} }), append(C, D);
							},
							$$slots: { default: !0 }
						});
						var G = sibling(W, 2);
						LabelInput(G, {
							label: "Hidden",
							type: "checkbox",
							get value() {
								return get(T).isHidden;
							},
							onChange: (C) => {
								get(T).isHidden = C;
							}
						}), Button(sibling(G, 2), {
							class: "m-2 bg-sky-500/100",
							onclick: () => D().apply(get(I)),
							children: (C, T) => {
								next(), append(C, text("Apply"));
							},
							$$slots: { default: !0 }
						}), append(C, z);
					},
					$$slots: {
						header: !0,
						default: !0
					}
				});
			}), append(C, I);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return D();
		},
		set props(C) {
			D(C), flushSync();
		}
	});
}
create_custom_element(Chart, { props: {} }, [], [], !0);
var root_2$13 = /* @__PURE__ */ from_html("<span>Color</span> <div class=\"w-[60px] h-[25px] overflow-hidden border-[1px] border-solid border-gray-500\"><!></div>", 1), root_1$26 = /* @__PURE__ */ from_html("<!> <div class=\"flex items-center\"><!> <!></div>", 1);
function Led(C, T) {
	push(T, !0);
	let E = getContext("mcxa_api"), D = prop(T, "props", 7);
	function O(C, T) {
		T && (T = toCamelCase(T), T === "onOff" && (T = "value"), D()[T] = C);
	}
	return WgtAccordionItem(C, {
		label: "Led",
		children: (C, T) => {
			var F = root_1$26(), I = first_child(F);
			Label(I, {
				for: "color-input",
				class: "flex-auto w-18 m-1 mt-2",
				children: (C, T) => {
					var E = root_2$13(), O = sibling(first_child(E), 2);
					MCXAColorPicker(child(O), {
						get color() {
							return D().color;
						},
						onChange: (C) => {
							let T = C.hex;
							D().color = T.slice(0, 7);
						}
					}), reset(O), append(C, E);
				},
				$$slots: { default: !0 }
			});
			var L = sibling(I, 2), z = child(L);
			ControlVariables(z, {
				label: "Value",
				get variable() {
					return D().variables.value;
				},
				type: "checkbox",
				get value() {
					return D().value;
				},
				onChange: O,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(z, 2), {
				label: "Brightness",
				get variable() {
					return D().variables.brightness;
				},
				type: "number",
				get value() {
					return D().brightness;
				},
				onChange: O,
				get api() {
					return E;
				}
			}), reset(L), append(C, F);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return D();
		},
		set props(C) {
			D(C), flushSync();
		}
	});
}
create_custom_element(Led, { props: {} }, [], [], !0);
var root_1$25 = /* @__PURE__ */ from_html("<div class=\"flex items-center\"><!> <!></div> <div class=\"flex items-center\"><!> <!></div> <!> <div class=\"flex items-center\"><!> <!></div> <!>", 1);
function Scale(C, T) {
	push(T, !0);
	let E = getContext("mcxa_api"), D = [
		{
			value: lv_scale_mode_t.LV_SCALE_MODE_ROUND_INNER,
			name: "ROUND_INNER"
		},
		{
			value: lv_scale_mode_t.LV_SCALE_MODE_ROUND_OUTER,
			name: "ROUND_OUTER"
		},
		{
			value: lv_scale_mode_t.LV_SCALE_MODE_HORIZONTAL_BOTTOM,
			name: "BOTTOM"
		},
		{
			value: lv_scale_mode_t.LV_SCALE_MODE_HORIZONTAL_TOP,
			name: "TOP"
		},
		{
			value: lv_scale_mode_t.LV_SCALE_MODE_VERTICAL_LEFT,
			name: "LEFT"
		},
		{
			value: lv_scale_mode_t.LV_SCALE_MODE_VERTICAL_RIGHT,
			name: "RIGHT"
		}
	];
	proxy([
		!1,
		!1,
		!1,
		!1,
		!1,
		!1
	]);
	let O = prop(T, "props", 7);
	function F(C, T) {
		T && (T = toCamelCase(T), O()[T] = C);
	}
	return WgtAccordionItem(C, {
		label: "Scale",
		children: (C, T) => {
			var I = root_1$25(), L = first_child(I), z = child(L);
			ControlVariables(z, {
				label: "Total Tick Count",
				get variable() {
					return O().variables.totalTickCnt;
				},
				type: "number",
				get value() {
					return O().totalTickCnt;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(z, 2), {
				label: "Major Tick Every",
				get variable() {
					return O().variables.majorTickEvery;
				},
				type: "number",
				get value() {
					return O().majorTickEvery;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), reset(L);
			var B = sibling(L, 2), V = child(B);
			ControlVariables(V, {
				label: "Min",
				get variable() {
					return O().variables.min;
				},
				type: "number",
				get value() {
					return O().min;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(V, 2), {
				label: "Max",
				get variable() {
					return O().variables.max;
				},
				type: "number",
				get value() {
					return O().max;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), reset(B);
			var U = sibling(B, 2);
			LabelInput(U, {
				label: "Mode",
				type: "option",
				get options() {
					return D;
				},
				get value() {
					return O().mode;
				},
				onChange: F
			});
			var W = sibling(U, 2), G = child(W);
			ControlVariables(G, {
				label: "Angle Range",
				get variable() {
					return O().variables.angleRange;
				},
				type: "number",
				max: 360,
				min: 0,
				get value() {
					return O().angleRange;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(G, 2), {
				label: "Rotation",
				get variable() {
					return O().variables.rotation;
				},
				type: "number",
				max: 360,
				min: 0,
				get value() {
					return O().rotation;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), reset(W), ControlVariables(sibling(W, 2), {
				label: "Label Show",
				get variable() {
					return O().variables.labelShow;
				},
				type: "checkbox",
				get value() {
					return O().labelShow;
				},
				onChange: F,
				get api() {
					return E;
				}
			}), append(C, I);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return O();
		},
		set props(C) {
			O(C), flushSync();
		}
	});
}
create_custom_element(Scale, { props: {} }, [], [], !0);
var root_1$24 = /* @__PURE__ */ from_html("<div>Span</div>");
function Span(C, T) {
	push(T, !0);
	let E = prop(T, "props", 7);
	return proxy([]), WgtAccordionItem(C, {
		label: "Span",
		children: (C, T) => {
			append(C, root_1$24());
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return E();
		},
		set props(C) {
			E(C), flushSync();
		}
	});
}
create_custom_element(Span, { props: {} }, [], [], !0);
var root_2$12 = /* @__PURE__ */ from_html("<div style=\"text-align: left \"></div> <span>label</span> <!>", 1), root_6$2 = /* @__PURE__ */ from_html("<span>Icon</span> <!>", 1), root_8 = /* @__PURE__ */ from_html("Asset <!>", 1), root_9 = /* @__PURE__ */ from_html("<div style=\"text-align: left \"></div> <span>label</span> <!>", 1), root_13 = /* @__PURE__ */ from_html("<div class=\"flex justify-between items-end p-2 gap-2\"><!> <!></div>"), root_1$23 = /* @__PURE__ */ from_html("<div class=\"flex justify-between items-end p-2\"><!> <!></div> <div class=\"flex justify-between items-end p-2\"><!> <!></div> <div class=\"flex justify-between items-end p-2 gap-2\"><!> <!></div> <!>", 1);
function List(C, T) {
	push(T, !0);
	let E = prop(T, "props", 7), D = /* @__PURE__ */ user_derived(() => Asserts.data.filter((C) => C.type === "image").map((C) => ({
		name: C.name,
		value: C.name
	}))), O = /* @__PURE__ */ state(1), F = /* @__PURE__ */ state("text"), I = /* @__PURE__ */ state("button"), L = /* @__PURE__ */ state(""), z = /* @__PURE__ */ state("LV_SYMBOL_FILE"), B = /* @__PURE__ */ state(!1);
	function V(C, T) {
		if (update(O), C === "text") {
			E().addText(T);
			return;
		}
		E().addButton(T, get(B) ? get(L) : get(z));
	}
	function U(C) {
		E().rename(C), update(O);
	}
	return WgtAccordionItem(C, {
		label: "List",
		children: (C, T) => {
			var W = root_1$23(), G = first_child(W), K = child(G);
			Label(K, {
				class: "flex-auto m-1 ",
				children: (C, T) => {
					var E = root_2$12();
					Input(sibling(first_child(E), 4), {
						type: "text",
						size: "sm",
						get value() {
							return get(F);
						},
						set value(C) {
							set(F, C, !0);
						}
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), Button(sibling(K, 2), {
				class: "rounded-full bg-sky-500/100 w-30 h-6 text-white hover:bg-sky-600 focus-within:outline-none",
				onclick: () => V("text", get(F)),
				children: (C, T) => {
					next(), append(C, text("Add Text"));
				},
				$$slots: { default: !0 }
			}), reset(G);
			var J = sibling(G, 2), Y = child(J);
			Checkbox(Y, {
				class: "flex-none mt-2.5 mx-1",
				get checked() {
					return get(B);
				},
				set checked(C) {
					set(B, C, !0);
				},
				children: (C, T) => {
					next(), append(C, text("Custom Icon"));
				},
				$$slots: { default: !0 }
			});
			var X = sibling(Y, 2), Z = (C) => {
				Label(C, {
					class: "flex-auto m-1 ",
					children: (C, T) => {
						var E = root_6$2();
						Select(sibling(first_child(E), 2), {
							get items() {
								return lvSymbolList;
							},
							size: "sm",
							get value() {
								return get(z);
							},
							set value(C) {
								set(z, C, !0);
							}
						}), append(C, E);
					},
					$$slots: { default: !0 }
				});
			}, Q = (C) => {
				Label(C, {
					class: "flex-auto mx-1 my-1",
					children: (C, T) => {
						next();
						var E = root_8();
						Select(sibling(first_child(E)), {
							get items() {
								return get(D);
							},
							size: "sm",
							get value() {
								return get(L);
							},
							set value(C) {
								set(L, C, !0);
							}
						}), append(C, E);
					},
					$$slots: { default: !0 }
				});
			};
			if_block(X, (C) => {
				get(B) ? C(Q, !1) : C(Z);
			}), reset(J);
			var NL = sibling(J, 2), PL = child(NL);
			Label(PL, {
				class: "flex-auto m-1 ",
				children: (C, T) => {
					var E = root_9();
					Input(sibling(first_child(E), 4), {
						type: "text",
						size: "sm",
						get value() {
							return get(I);
						},
						set value(C) {
							set(I, C, !0);
						}
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), Button(sibling(PL, 2), {
				class: "rounded-full bg-sky-500/100 w-30 h-6 text-white hover:bg-sky-600 focus-within:outline-none",
				onclick: () => V("button", get(I)),
				children: (C, T) => {
					next(), append(C, text("Add Button"));
				},
				$$slots: { default: !0 }
			}), reset(NL), WgtAccordionItem(sibling(NL, 2), {
				label: "Items",
				children: (C, T) => {
					var D = comment();
					key(first_child(D), () => get(O), (C) => {
						var T = comment();
						each(first_child(T), 17, () => E().items, index, (C, T, E) => {
							var D = root_13(), O = child(D);
							Input(O, {
								type: "text",
								get value() {
									return get(T).text;
								},
								set value(C) {
									get(T).text = C;
								}
							}), Button(sibling(O, 2), {
								class: "rounded-full bg-sky-500/100 w-20 h-6 text-white hover:bg-sky-600 focus-within:outline-none",
								onclick: () => U(E),
								children: (C, T) => {
									next(), append(C, text("Rename"));
								},
								$$slots: { default: !0 }
							}), reset(D), append(C, D);
						}), append(C, T);
					}), append(C, D);
				},
				$$slots: { default: !0 }
			}), append(C, W);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return E();
		},
		set props(C) {
			E(C), flushSync();
		}
	});
}
create_custom_element(List, { props: {} }, [], [], !0);
var root_2$11 = /* @__PURE__ */ from_html("<span>Header Mode</span> <!>", 1), root_3$8 = /* @__PURE__ */ from_html("<span>Root Back Mode</span> <!>", 1), root_4$6 = /* @__PURE__ */ from_html("<span>Page Mode</span> <!>", 1), root_5$2 = /* @__PURE__ */ from_html("<div style=\"text-align: left \"></div> <span>Title</span> <!>", 1), root_1$22 = /* @__PURE__ */ from_html("<!> <!> <!> <div class=\"flex justify-between items-end p-2 gap-3\"><!> <!></div>", 1);
function Menu(C, T) {
	push(T, !0);
	let E = [{
		name: "Sidebar",
		value: "sidebar"
	}, {
		name: "Page",
		value: "page"
	}], D = prop(T, "props", 7), O = /* @__PURE__ */ state("Item");
	return WgtAccordionItem(C, {
		label: "Menu",
		children: (C, T) => {
			var F = root_1$22(), I = first_child(F);
			Label(I, {
				class: "flex-auto w-18 m-1",
				children: (C, T) => {
					var E = root_2$11();
					Select(sibling(first_child(E), 2), {
						get items() {
							return lvChartTypeList;
						},
						size: "sm",
						get value() {
							return D().headerMode;
						},
						set value(C) {
							D().headerMode = C;
						}
					}), append(C, E);
				},
				$$slots: { default: !0 }
			});
			var L = sibling(I, 2);
			Label(L, {
				class: "flex-auto w-18 m-1",
				children: (C, T) => {
					var E = root_3$8();
					Select(sibling(first_child(E), 2), {
						get items() {
							return lvChartUpdateModeList;
						},
						size: "sm",
						get value() {
							return D().rootBackMode;
						},
						set value(C) {
							D().rootBackMode = C;
						}
					}), append(C, E);
				},
				$$slots: { default: !0 }
			});
			var z = sibling(L, 2);
			Label(z, {
				class: "flex-auto w-18 m-1",
				children: (C, T) => {
					var O = root_4$6();
					Select(sibling(first_child(O), 2), {
						get items() {
							return E;
						},
						size: "sm",
						get value() {
							return D().pageMode;
						},
						set value(C) {
							D().pageMode = C;
						}
					}), append(C, O);
				},
				$$slots: { default: !0 }
			});
			var B = sibling(z, 2), V = child(B);
			Label(V, {
				class: "flex-auto m-1 ",
				children: (C, T) => {
					var E = root_5$2();
					Input(sibling(first_child(E), 4), {
						type: "text",
						size: "sm",
						get value() {
							return get(O);
						},
						set value(C) {
							set(O, C, !0);
						}
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), Button(sibling(V, 2), {
				class: "rounded-full bg-sky-500/100 w-30  text-white hover:bg-sky-600 focus-within:outline-none",
				onclick: () => D().addPage(get(O)),
				children: (C, T) => {
					next(), append(C, text("Add Page"));
				},
				$$slots: { default: !0 }
			}), reset(B), append(C, F);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return D();
		},
		set props(C) {
			D(C), flushSync();
		}
	});
}
create_custom_element(Menu, { props: {} }, [], [], !0);
var root_2$10 = /* @__PURE__ */ from_html("Asset <!>", 1), root_4$5 = /* @__PURE__ */ from_html("<div class=\"flex items-end\"><!></div>"), root_1$21 = /* @__PURE__ */ from_html("<div class=\"flex items-end\"><!> <!></div> <!> <!> <!> <!> <div class=\"flex items-center\"><!> <!> <!> <!></div> <!>", 1);
function MultiStateImage(C, T) {
	push(T, !0);
	let E = getContext("mcxa_api"), D = /* @__PURE__ */ state(""), O = prop(T, "props", 7), F = /* @__PURE__ */ user_derived(() => O().images.map((C, T) => ({
		name: `Image ${T + 1}`,
		value: T
	}))), I = /* @__PURE__ */ user_derived(() => Asserts.data.filter((C) => C.type === "image").map((C) => ({
		name: C.name,
		value: C.name
	})));
	function L(C, T) {
		T && (T = toCamelCase(T), O()[T] = C);
	}
	function z() {
		get(D) && (O().images.push(get(D)), O().addImage(get(D)));
	}
	return WgtAccordionItem(C, {
		label: "MultiStateImage",
		children: (C, T) => {
			var B = root_1$21(), V = first_child(B), U = child(V);
			Label(U, {
				class: "flex-auto mx-1 my-1",
				children: (C, T) => {
					next();
					var E = root_2$10();
					Select(sibling(first_child(E)), {
						get items() {
							return get(I);
						},
						size: "sm",
						get value() {
							return get(D);
						},
						set value(C) {
							set(D, C, !0);
						}
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), Button(sibling(U, 2), {
				size: "sm",
				class: "h-8 bg-sky-500",
				onclick: () => z(),
				children: (C, T) => {
					next(), append(C, text("Add Image"));
				},
				$$slots: { default: !0 }
			}), reset(V);
			var W = sibling(V, 2);
			ControlVariables(W, {
				label: "Active Index",
				get variable() {
					return O().variables.activeIndex;
				},
				type: "option",
				get options() {
					return get(F);
				},
				get value() {
					return O().activeIndex;
				},
				onChange: L,
				get api() {
					return E;
				}
			});
			var G = sibling(W, 2);
			ControlVariables(G, {
				label: "Blend Mode",
				get variable() {
					return O().variables.blendMode;
				},
				type: "option",
				get options() {
					return lvBlendModeList;
				},
				get value() {
					return O().blendMode;
				},
				onChange: L,
				get api() {
					return E;
				}
			});
			var K = sibling(G, 2);
			ControlVariables(K, {
				label: "Align",
				get variable() {
					return O().variables.align;
				},
				type: "option",
				get options() {
					return lvImageAlignList;
				},
				get value() {
					return O().align;
				},
				onChange: L,
				get api() {
					return E;
				}
			});
			var J = sibling(K, 2);
			ControlVariables(J, {
				label: "Rotation",
				get variable() {
					return O().variables.rotation;
				},
				type: "number",
				get value() {
					return O().rotation;
				},
				onChange: L,
				get api() {
					return E;
				}
			});
			var Y = sibling(J, 2), X = child(Y);
			ControlVariables(X, {
				label: "Scale X",
				get variable() {
					return O().variables.scaleX;
				},
				type: "number",
				get value() {
					return O().scaleX;
				},
				onChange: L,
				get api() {
					return E;
				}
			});
			var Z = sibling(X, 2);
			ControlVariables(Z, {
				label: "Scale Y",
				get variable() {
					return O().variables.scaleY;
				},
				type: "number",
				get value() {
					return O().scaleY;
				},
				onChange: L,
				get api() {
					return E;
				}
			});
			var Q = sibling(Z, 2);
			ControlVariables(Q, {
				label: "Pivot X",
				get variable() {
					return O().variables.pivotX;
				},
				type: "number",
				get value() {
					return O().pivotX;
				},
				onChange: L,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(Q, 2), {
				label: "Pivot Y",
				get variable() {
					return O().variables.pivotY;
				},
				type: "number",
				get value() {
					return O().pivotY;
				},
				onChange: L,
				get api() {
					return E;
				}
			}), reset(Y), each(sibling(Y, 2), 17, () => O().images, index, (C, T, E) => {
				var D = root_4$5();
				LabelInput(child(D), {
					label: "Image" + (E + 1),
					type: "option",
					get options() {
						return get(I);
					},
					get value() {
						return O().images[E];
					},
					onChange: (C) => O().setImage(E, C)
				}), reset(D), append(C, D);
			}), append(C, B);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return O();
		},
		set props(C) {
			O(C), flushSync();
		}
	});
}
create_custom_element(MultiStateImage, { props: {} }, [], [], !0);
var root_2$9 = /* @__PURE__ */ from_html("<span>Value</span> <!>", 1), root_4$4 = /* @__PURE__ */ from_html("<div class=\"flex gap-2\"><!></div>"), root_1$20 = /* @__PURE__ */ from_html("<div class=\"flex items-end\"><!> <!></div> <!> <!> <div class=\"flex items-center gap-2\"><!> <!></div> <div class=\"flex items-center gap-2\"><!> <!> <!></div> <div class=\"flex items-center gap-2\"><!> <!></div> <!>", 1);
function MultiStateNum(C, T) {
	push(T, !0);
	let E = getContext("mcxa_api"), D = prop(T, "props", 7), O = /* @__PURE__ */ state(0), F = /* @__PURE__ */ user_derived(() => {
		let C = [];
		for (let T = 0; T < D().values.length; T++) C.push({
			name: `Number ${T + 1}`,
			value: T
		});
		return C;
	}), I = [
		{
			value: 10,
			name: "Decimal"
		},
		{
			value: 16,
			name: "Hexadecimal"
		},
		{
			value: 2,
			name: "Binary"
		},
		{
			value: 8,
			name: "Octal"
		}
	];
	function L(C, T) {
		T && (T = toCamelCase(T), D()[T] = C);
	}
	function z() {
		get(O) !== null && get(O) !== void 0 && (D().values.push(get(O)), D().addValue(get(O)));
	}
	return WgtAccordionItem(C, {
		label: "MultiStateNum",
		children: (C, T) => {
			var B = root_1$20(), V = first_child(B), U = child(V);
			Label(U, {
				class: "flex-auto mx-1 my-1",
				children: (C, T) => {
					var E = root_2$9();
					Input(sibling(first_child(E), 2), {
						type: "number",
						placeholder: "Enter number",
						size: "sm",
						get value() {
							return get(O);
						},
						set value(C) {
							set(O, C, !0);
						}
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), Button(sibling(U, 2), {
				size: "sm",
				class: "h-8 bg-sky-500",
				onclick: () => z(),
				children: (C, T) => {
					next(), append(C, text("Add Value"));
				},
				$$slots: { default: !0 }
			}), reset(V);
			var W = sibling(V, 2);
			ControlVariables(W, {
				label: "Active Index",
				get variable() {
					return D().variables.activeIndex;
				},
				type: "option",
				get options() {
					return get(F);
				},
				get value() {
					return D().activeIndex;
				},
				onChange: L,
				get api() {
					return E;
				}
			});
			var G = sibling(W, 2);
			ControlVariables(G, {
				label: "Radix",
				get variable() {
					return D().variables.radix;
				},
				type: "option",
				get options() {
					return I;
				},
				get value() {
					return D().radix;
				},
				onChange: L,
				get api() {
					return E;
				}
			});
			var K = sibling(G, 2), J = child(K);
			ControlVariables(J, {
				label: "Digit Count",
				get variable() {
					return D().variables.digitCount;
				},
				type: "number",
				get value() {
					return D().digitCount;
				},
				onChange: L,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(J, 2), {
				label: "Digit Position",
				get variable() {
					return D().variables.digitPos;
				},
				type: "number",
				get value() {
					return D().digitPos;
				},
				onChange: L,
				get api() {
					return E;
				}
			}), reset(K);
			var Y = sibling(K, 2), X = child(Y);
			ControlVariables(X, {
				label: "Min",
				get variable() {
					return D().variables.min;
				},
				type: "number",
				get value() {
					return D().min;
				},
				onChange: L,
				get api() {
					return E;
				}
			});
			var Z = sibling(X, 2);
			ControlVariables(Z, {
				label: "Max",
				get variable() {
					return D().variables.max;
				},
				type: "number",
				get value() {
					return D().max;
				},
				onChange: L,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(Z, 2), {
				label: "Step",
				get variable() {
					return D().variables.step;
				},
				type: "number",
				get value() {
					return D().step;
				},
				onChange: L,
				get api() {
					return E;
				}
			}), reset(Y);
			var Q = sibling(Y, 2), NL = child(Q);
			ControlVariables(NL, {
				label: "Show Sign",
				get variable() {
					return D().variables.showSign;
				},
				type: "checkbox",
				get value() {
					return D().showSign;
				},
				onChange: L,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(NL, 2), {
				label: "Pad Zero",
				get variable() {
					return D().variables.padZero;
				},
				type: "checkbox",
				get value() {
					return D().padZero;
				},
				onChange: L,
				get api() {
					return E;
				}
			}), reset(Q), each(sibling(Q, 2), 17, () => D().values, index, (C, T, E, O) => {
				var F = root_4$4();
				LabelInput(child(F), {
					label: "value" + (E + 1),
					type: "number",
					get value() {
						return get(T);
					},
					onChange: (C) => {
						D().values[E] = C, D().setValue(E, C);
					}
				}), reset(F), append(C, F);
			}), append(C, B);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return D();
		},
		set props(C) {
			D(C), flushSync();
		}
	});
}
create_custom_element(MultiStateNum, { props: {} }, [], [], !0);
var root_2$8 = /* @__PURE__ */ from_html("<span>Text</span> <!>", 1), root_4$3 = /* @__PURE__ */ from_html("<div class=\"flex items-end\"><!></div>"), root_1$19 = /* @__PURE__ */ from_html("<div class=\"flex items-end\"><!> <!></div> <!> <!> <div class=\"flex items-center\"><!> <!></div> <!>", 1);
function MultiStateText(C, T) {
	push(T, !0);
	let E = getContext("mcxa_api"), D = prop(T, "props", 7), O = /* @__PURE__ */ state(""), F = /* @__PURE__ */ user_derived(() => D().texts.map((C, T) => ({
		name: `Text ${T + 1}`,
		value: T
	})));
	function I(C, T) {
		T && (T = toCamelCase(T), D()[T] = C);
	}
	function L() {
		get(O) && (D().addText(get(O)), D().texts.push(get(O)), set(O, ""));
	}
	return WgtAccordionItem(C, {
		label: "MultiStateText",
		children: (C, T) => {
			var z = root_1$19(), B = first_child(z), V = child(B);
			Label(V, {
				class: "flex-auto mx-1 my-1",
				children: (C, T) => {
					var E = root_2$8();
					Input(sibling(first_child(E), 2), {
						type: "text",
						placeholder: "Enter text",
						size: "sm",
						get value() {
							return get(O);
						},
						set value(C) {
							set(O, C, !0);
						}
					}), append(C, E);
				},
				$$slots: { default: !0 }
			}), Button(sibling(V, 2), {
				size: "sm",
				class: "h-8 bg-sky-500",
				onclick: L,
				children: (C, T) => {
					next(), append(C, text("Add Text"));
				},
				$$slots: { default: !0 }
			}), reset(B);
			var U = sibling(B, 2);
			ControlVariables(U, {
				label: "Active Index",
				get variable() {
					return D().variables.activeIndex;
				},
				type: "option",
				get options() {
					return get(F);
				},
				get value() {
					return D().activeIndex;
				},
				onChange: I,
				get api() {
					return E;
				}
			});
			var W = sibling(U, 2);
			ControlVariables(W, {
				label: "Long Mode",
				get variable() {
					return D().variables.longMode;
				},
				type: "option",
				get options() {
					return textModeList;
				},
				get value() {
					return D().longMode;
				},
				onChange: I,
				get api() {
					return E;
				}
			});
			var G = sibling(W, 2), K = child(G);
			ControlVariables(K, {
				label: "Selection Start",
				get variable() {
					return D().variables.selectionStart;
				},
				type: "number",
				get value() {
					return D().selectionStart;
				},
				onChange: I,
				get api() {
					return E;
				}
			}), ControlVariables(sibling(K, 2), {
				label: "Selection End",
				get variable() {
					return D().variables.selectionEnd;
				},
				type: "number",
				get value() {
					return D().selectionEnd;
				},
				onChange: I,
				get api() {
					return E;
				}
			}), reset(G), each(sibling(G, 2), 17, () => D().texts, index, (C, T, E, O) => {
				var I = root_4$3();
				LabelInput(child(I), {
					label: `Text ${E + 1}`,
					type: "option",
					get options() {
						return get(F);
					},
					value: E,
					onChange: (C) => {
						D().setText(E, C);
					}
				}), reset(I), append(C, I);
			}), append(C, z);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return D();
		},
		set props(C) {
			D(C), flushSync();
		}
	});
}
create_custom_element(MultiStateText, { props: {} }, [], [], !0);
var root_1$18 = /* @__PURE__ */ from_html("<span> </span> <div class=\"w-[60px] h-[25px] overflow-hidden border-[1px] border-solid border-gray-500\"><!></div>", 1);
function ColorPicker(C, T) {
	push(T, !0);
	let E = prop(T, "label", 7, "Color"), D = prop(T, "color", 15), O = prop(T, "opa", 15), F = prop(T, "onChange", 7), I = prop(T, "disabled", 7, !1);
	function L(C) {
		let T = C.hex;
		T && (T.length === 7 && (F() && F()(T, 255), D(T), O() !== void 0 && O(255)), T.length === 9 && (F() && F()(T.substring(0, 7), parseInt(T.substring(7, 9), 16)), D(T.substring(0, 7)), O() !== void 0 && O(parseInt(T.substring(7, 9), 16))));
	}
	return Label(C, {
		class: "flex-auto w-18 my-2 text-white",
		children: (C, T) => {
			var F = root_1$18(), z = first_child(F), B = child(z, !0);
			reset(z);
			var V = sibling(z, 2), U = child(V);
			{
				let C = /* @__PURE__ */ user_derived(() => hexWithAlpha(D(), O() ? O() : 255));
				MCXAColorPicker(U, {
					get color() {
						return get(C);
					},
					onChange: L,
					get disabled() {
						return I();
					}
				});
			}
			reset(V), template_effect(() => set_text(B, E())), append(C, F);
		},
		$$slots: { default: !0 }
	}), pop({
		get label() {
			return E();
		},
		set label(C = "Color") {
			E(C), flushSync();
		},
		get color() {
			return D();
		},
		set color(C) {
			D(C), flushSync();
		},
		get opa() {
			return O();
		},
		set opa(C) {
			O(C), flushSync();
		},
		get onChange() {
			return F();
		},
		set onChange(C) {
			F(C), flushSync();
		},
		get disabled() {
			return I();
		},
		set disabled(C = !1) {
			I(C), flushSync();
		}
	});
}
create_custom_element(ColorPicker, {
	label: {},
	color: {},
	opa: {},
	onChange: {},
	disabled: {}
}, [], [], !0);
var root_1$17 = /* @__PURE__ */ from_html("<!> <div class=\"flex gap-2 items-center\"><!> <!></div>", 1);
function Circle(C, T) {
	push(T, !0);
	let E = prop(T, "props", 7);
	return WgtAccordionItem(C, {
		label: "Circle",
		children: (C, T) => {
			var D = root_1$17(), O = first_child(D);
			LabelInput(O, {
				label: "Radius",
				type: "number",
				get value() {
					return E().radius;
				},
				set value(C) {
					E().radius = C;
				}
			});
			var F = sibling(O, 2), I = child(F);
			ColorPicker(I, {
				label: "Fill Color",
				opa: 255,
				get color() {
					return E().fillColor;
				},
				set color(C) {
					E().fillColor = C;
				}
			}), ColorPicker(sibling(I, 2), {
				label: "Outline Color",
				opa: 255,
				get color() {
					return E().outlineColor;
				},
				set color(C) {
					E().outlineColor = C;
				}
			}), reset(F), append(C, D);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return E();
		},
		set props(C) {
			E(C), flushSync();
		}
	});
}
create_custom_element(Circle, { props: {} }, [], [], !0);
var root_1$16 = /* @__PURE__ */ from_html("<div class=\"flex gap-2 items-center\"><!> <!></div> <div class=\"flex gap-2 items-center\"><!> <!></div>", 1);
function Ellipse(C, T) {
	push(T, !0);
	let E = prop(T, "props", 7);
	return WgtAccordionItem(C, {
		label: "Ellipse",
		children: (C, T) => {
			var D = root_1$16(), O = first_child(D), F = child(O);
			LabelInput(F, {
				label: "Radius X",
				type: "number",
				get value() {
					return E().radiusX;
				},
				set value(C) {
					E().radiusX = C;
				}
			}), LabelInput(sibling(F, 2), {
				label: "Radius Y",
				type: "number",
				get value() {
					return E().radiusY;
				},
				set value(C) {
					E().radiusY = C;
				}
			}), reset(O);
			var I = sibling(O, 2), L = child(I);
			ColorPicker(L, {
				label: "Fill Color",
				opa: 255,
				get color() {
					return E().fillColor;
				},
				set color(C) {
					E().fillColor = C;
				}
			}), ColorPicker(sibling(L, 2), {
				label: "Outline Color",
				opa: 255,
				get color() {
					return E().outlineColor;
				},
				set color(C) {
					E().outlineColor = C;
				}
			}), reset(I), append(C, D);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return E();
		},
		set props(C) {
			E(C), flushSync();
		}
	});
}
create_custom_element(Ellipse, { props: {} }, [], [], !0);
var root_1$15 = /* @__PURE__ */ from_html("<!> <div class=\"flex gap-2 items-center\"><!> <!></div> <div class=\"flex gap-2 items-center\"><!> <!></div>", 1);
function PartCircle(C, T) {
	push(T, !0);
	let E = prop(T, "props", 7);
	return WgtAccordionItem(C, {
		label: "Part Circle",
		children: (C, T) => {
			var D = root_1$15(), O = first_child(D);
			LabelInput(O, {
				label: "Radius",
				type: "number",
				get value() {
					return E().radius;
				},
				set value(C) {
					E().radius = C;
				}
			});
			var F = sibling(O, 2), I = child(F);
			LabelInput(I, {
				label: "Start Angle",
				type: "number",
				get value() {
					return E().startAngle;
				},
				set value(C) {
					E().startAngle = C;
				}
			}), LabelInput(sibling(I, 2), {
				label: "End Angle",
				type: "number",
				get value() {
					return E().endAngle;
				},
				set value(C) {
					E().endAngle = C;
				}
			}), reset(F);
			var L = sibling(F, 2), z = child(L);
			ColorPicker(z, {
				label: "Fill Color",
				opa: 255,
				get color() {
					return E().fillColor;
				},
				set color(C) {
					E().fillColor = C;
				}
			}), ColorPicker(sibling(z, 2), {
				label: "Outline Color",
				opa: 255,
				get color() {
					return E().outlineColor;
				},
				set color(C) {
					E().outlineColor = C;
				}
			}), reset(L), append(C, D);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return E();
		},
		set props(C) {
			E(C), flushSync();
		}
	});
}
create_custom_element(PartCircle, { props: {} }, [], [], !0);
var root_1$14 = /* @__PURE__ */ from_html("<div class=\"flex gap-2 items-center\"><!> <!></div> <div class=\"flex gap-2 items-center\"><!> <!></div> <div class=\"flex gap-2 items-center\"><!> <!></div>", 1);
function PartEllipse(C, T) {
	push(T, !0);
	let E = prop(T, "props", 7);
	return WgtAccordionItem(C, {
		label: "Part Ellipse",
		children: (C, T) => {
			var D = root_1$14(), O = first_child(D), F = child(O);
			LabelInput(F, {
				label: "Radius X",
				type: "number",
				get value() {
					return E().radiusX;
				},
				set value(C) {
					E().radiusX = C;
				}
			}), LabelInput(sibling(F, 2), {
				label: "Radius Y",
				type: "number",
				get value() {
					return E().radiusY;
				},
				set value(C) {
					E().radiusY = C;
				}
			}), reset(O);
			var I = sibling(O, 2), L = child(I);
			LabelInput(L, {
				label: "Start Angle",
				type: "number",
				get value() {
					return E().startAngle;
				},
				set value(C) {
					E().startAngle = C;
				}
			}), LabelInput(sibling(L, 2), {
				label: "End Angle",
				type: "number",
				get value() {
					return E().endAngle;
				},
				set value(C) {
					E().endAngle = C;
				}
			}), reset(I);
			var z = sibling(I, 2), B = child(z);
			ColorPicker(B, {
				label: "Fill Color",
				opa: 255,
				get color() {
					return E().fillColor;
				},
				set color(C) {
					E().fillColor = C;
				}
			}), ColorPicker(sibling(B, 2), {
				label: "Outline Color",
				opa: 255,
				get color() {
					return E().outlineColor;
				},
				set color(C) {
					E().outlineColor = C;
				}
			}), reset(z), append(C, D);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return E();
		},
		set props(C) {
			E(C), flushSync();
		}
	});
}
create_custom_element(PartEllipse, { props: {} }, [], [], !0);
var root_1$13 = /* @__PURE__ */ from_html("<div class=\"flex gap-2 items-center\"><!> <!></div> <!> <!> <!> <!> <div class=\"flex gap-2 items-center\"><!> <!></div> <div class=\"flex gap-2 items-center\"><!> <!></div>", 1);
function Pipe(C, T) {
	push(T, !0);
	let E = prop(T, "props", 7), D = [
		{
			name: "Line",
			value: lv_pipe_shape_t.LV_PIPE_SHAPE_LINE
		},
		{
			name: "Round",
			value: lv_pipe_shape_t.LV_PIPE_SHAPE_ROUND
		},
		{
			name: "T Shape",
			value: lv_pipe_shape_t.LV_PIPE_SHAPE_T_SHAPE
		},
		{
			name: "Cross",
			value: lv_pipe_shape_t.LV_PIPE_SHAPE_CROSS
		}
	];
	return WgtAccordionItem(C, {
		label: "Pipe",
		children: (C, T) => {
			var O = root_1$13(), F = first_child(O), I = child(F);
			LabelInput(I, {
				label: "Width",
				type: "number",
				get value() {
					return E().width;
				},
				set value(C) {
					E().width = C;
				}
			}), LabelInput(sibling(I, 2), {
				label: "Height",
				type: "number",
				get value() {
					return E().height;
				},
				set value(C) {
					E().height = C;
				}
			}), reset(F);
			var L = sibling(F, 2);
			LabelInput(L, {
				label: "Offset",
				type: "number",
				get value() {
					return E().offset;
				},
				set value(C) {
					E().offset = C;
				}
			});
			var z = sibling(L, 2);
			LabelInput(z, {
				label: "Pipe Shape",
				type: "option",
				get options() {
					return D;
				},
				get value() {
					return E().pipeShape;
				},
				set value(C) {
					E().pipeShape = C;
				}
			});
			var B = sibling(z, 2);
			{
				let C = /* @__PURE__ */ user_derived(() => E().pipeShape !== lv_pipe_shape_t.LV_PIPE_SHAPE_ROUND);
				LabelInput(B, {
					label: "Radius",
					type: "number",
					get disabled() {
						return get(C);
					},
					get value() {
						return E().radius;
					},
					set value(C) {
						E().radius = C;
					}
				});
			}
			var V = sibling(B, 2);
			LabelInput(V, {
				label: "Start Flow",
				type: "checkbox",
				get value() {
					return E().start;
				},
				set value(C) {
					E().start = C;
				}
			});
			var U = sibling(V, 2), W = child(U);
			LabelInput(W, {
				label: "Flow Speed",
				type: "number",
				get value() {
					return E().flowSpeed;
				},
				set value(C) {
					E().flowSpeed = C;
				}
			}), LabelInput(sibling(W, 2), {
				label: "Flow Rate",
				type: "number",
				get value() {
					return E().flowRate;
				},
				set value(C) {
					E().flowRate = C;
				}
			}), reset(U);
			var G = sibling(U, 2), K = child(G);
			ColorPicker(K, {
				label: "Start Color",
				opa: 255,
				get color() {
					return E().startColor;
				},
				set color(C) {
					E().startColor = C;
				}
			}), ColorPicker(sibling(K, 2), {
				label: "End Color",
				opa: 255,
				get color() {
					return E().endColor;
				},
				set color(C) {
					E().endColor = C;
				}
			}), reset(G), append(C, O);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return E();
		},
		set props(C) {
			E(C), flushSync();
		}
	});
}
create_custom_element(Pipe, { props: {} }, [], [], !0);
function Index(C, T) {
	push(T, !0);
	let E = {
		Id: Name,
		Layout,
		Flags,
		States,
		ARC: Arc$1,
		Image: Image$1,
		Label: Label$1,
		TabView,
		TextArea,
		Calendar,
		CheckBox: Checkbox$1,
		DropDown: Dropdown,
		Imgbutton,
		KeyBoard: Keyboard,
		Roller,
		Slider,
		SpinBox: Spinbox,
		Bar,
		Chart,
		Led,
		Scale,
		Span,
		List,
		Menu,
		MultiStateImage,
		MultiStateNum,
		MultiStateText,
		Circle,
		Ellipse,
		PartCircle,
		PartEllipse,
		Pipe
	}, D = prop(T, "props", 7);
	return Accordion(C, {
		class: "height-full width-full  p-px ",
		children: (C, T) => {
			AccordionItem(C, {
				activeClass: "bg-gray-800 text-white",
				inactiveClass: "bg-gray-800 text-white",
				class: "bg-gray-800",
				header: (C) => {
					next();
					var T = text();
					template_effect(() => {
						var C, E;
						return set_text(T, (C = (E = D()[0][1]) == null ? void 0 : E.type) == null ? "Common" : C);
					}), append(C, T);
				},
				children: (C, T) => {
					var O = comment();
					each(first_child(O), 17, D, index, (C, T) => {
						var D = /* @__PURE__ */ user_derived(() => to_array(get(T), 2));
						let O = () => get(D)[0], F = () => get(D)[1];
						var I = comment(), L = first_child(I), z = (C) => {
							let T = /* @__PURE__ */ user_derived(() => E[O()]);
							var D = comment();
							component(first_child(D), () => get(T), (C, T) => {
								T(C, { get props() {
									return F();
								} });
							}), append(C, D);
						};
						if_block(L, (C) => {
							O() && C(z);
						}), append(C, I);
					}), append(C, O);
				},
				$$slots: {
					header: !0,
					default: !0
				}
			});
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return D();
		},
		set props(C) {
			D(C), flushSync();
		}
	});
}
create_custom_element(Index, { props: {} }, [], [], !0);
var root$6 = /* @__PURE__ */ from_html("<div class=\"flex items-center\"><!> <div class=\"flex items-center gap-1\"><!></div></div>");
function StateInput(C, T) {
	push(T, !0);
	let E = prop(T, "disabled", 15), D = prop(T, "children", 7);
	var O = {
		get disabled() {
			return E();
		},
		set disabled(C) {
			E(C), flushSync();
		},
		get children() {
			return D();
		},
		set children(C) {
			D(C), flushSync();
		}
	}, F = root$6(), I = child(F);
	Checkbox(I, {
		class: "flex-none mt-2.5 mx-1",
		get checked() {
			return E();
		},
		set checked(C) {
			E(C);
		}
	});
	var L = sibling(I, 2);
	return snippet(child(L), () => {
		var C;
		return (C = D()) == null ? noop : C;
	}), reset(L), reset(F), append(C, F), pop(O);
}
create_custom_element(StateInput, {
	disabled: {},
	children: {}
}, [], [], !0);
var root_4$2 = /* @__PURE__ */ from_html("<span>Bg Main Color</span> <div class=\"w-[60px] h-[25px] overflow-hidden border-[1px] border-solid border-gray-500\"><!></div>", 1), root_3$7 = /* @__PURE__ */ from_html("<!> <!>", 1), root_6$1 = /* @__PURE__ */ from_html("<span>Bg Grad Color</span> <div class=\"w-[60px] h-[25px] overflow-hidden border-[1px] border-solid border-gray-500\"><!></div>", 1), root_5$1 = /* @__PURE__ */ from_html("<!> <!>", 1), root_1$12 = /* @__PURE__ */ from_html("<!> <!> <!> <!> <!>", 1);
function Background(C, T) {
	push(T, !0);
	let E = /* @__PURE__ */ state(proxy([
		!1,
		!1,
		!1,
		!1,
		!1,
		!1
	])), D = prop(T, "props", 7);
	function O(C, T) {
		T && (T = toCamelCase(T), D()[T] = C);
	}
	function F(C) {
		let T = C.hex;
		T && (T.length === 7 && (D().bgColor = T, D().bgOpa = 255), T.length === 9 && (D().bgColor = T.substring(0, 7), D().bgOpa = parseInt(T.substring(7, 9), 16)));
	}
	function I(C) {
		let T = C.hex;
		T && (T.length === 7 && (D().bgGradientColor = T, D().bgGradientColorOpa = 255), T.length === 9 && (D().bgGradientColor = T.substring(0, 7), D().bgGradientColorOpa = parseInt(T.substring(7, 9), 16)));
	}
	return WgtAccordionItem(C, {
		label: "Background",
		children: (C, T) => {
			var L = root_1$12(), z = first_child(L);
			StateInput(z, {
				get disabled() {
					return get(E)[0];
				},
				set disabled(C) {
					get(E)[0] = C;
				},
				children: (C, T) => {
					{
						let T = /* @__PURE__ */ user_derived(() => !get(E)[0]);
						LabelInput(C, {
							label: "Bg Radius",
							type: "number",
							get value() {
								return D().bgRadius;
							},
							get disabled() {
								return get(T);
							},
							onChange: O
						});
					}
				},
				$$slots: { default: !0 }
			});
			var B = sibling(z, 2);
			StateInput(B, {
				get disabled() {
					return get(E)[1];
				},
				set disabled(C) {
					get(E)[1] = C;
				},
				children: (C, T) => {
					var I = root_3$7(), L = first_child(I);
					Label(L, {
						class: "flex-auto w-18 my-2 text-white",
						children: (C, T) => {
							var O = root_4$2(), I = sibling(first_child(O), 2), L = child(I);
							{
								let C = /* @__PURE__ */ user_derived(() => hexWithAlpha(D().bgColor, D().bgOpa)), T = /* @__PURE__ */ user_derived(() => !get(E)[1]);
								MCXAColorPicker(L, {
									get color() {
										return get(C);
									},
									get disabled() {
										return get(T);
									},
									onChange: F
								});
							}
							reset(I), append(C, O);
						},
						$$slots: { default: !0 }
					});
					var z = sibling(L, 2);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(E)[1]);
						LabelInput(z, {
							label: "Bg Main Stop",
							type: "number",
							get value() {
								return D().bgMainStop;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					append(C, I);
				},
				$$slots: { default: !0 }
			});
			var V = sibling(B, 2);
			StateInput(V, {
				get disabled() {
					return get(E)[3];
				},
				set disabled(C) {
					get(E)[3] = C;
				},
				children: (C, T) => {
					var F = root_5$1(), L = first_child(F);
					Label(L, {
						class: "flex-auto w-18 my-2 text-white",
						children: (C, T) => {
							var O = root_6$1(), F = sibling(first_child(O), 2), L = child(F);
							{
								let C = /* @__PURE__ */ user_derived(() => hexWithAlpha(D().bgGradientColor, D().bgGradientColorOpa)), T = /* @__PURE__ */ user_derived(() => !get(E)[3]);
								MCXAColorPicker(L, {
									get color() {
										return get(C);
									},
									get disabled() {
										return get(T);
									},
									onChange: I
								});
							}
							reset(F), append(C, O);
						},
						$$slots: { default: !0 }
					});
					var z = sibling(L, 2);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(E)[3]);
						LabelInput(z, {
							label: "Bg Gradient Stop",
							type: "number",
							get value() {
								return D().bgGradientStop;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					append(C, F);
				},
				$$slots: { default: !0 }
			});
			var U = sibling(V, 2);
			StateInput(U, {
				get disabled() {
					return get(E)[4];
				},
				set disabled(C) {
					get(E)[4] = C;
				},
				children: (C, T) => {
					{
						let T = /* @__PURE__ */ user_derived(() => !get(E)[4]);
						LabelInput(C, {
							label: "Gradient Direction",
							type: "option",
							get options() {
								return lvGradDirList;
							},
							get value() {
								return D().gradientDir;
							},
							get disabled() {
								return get(T);
							},
							onChange: (C) => {
								D().gradientDir = C;
							}
						});
					}
				},
				$$slots: { default: !0 }
			}), PropertyInput(sibling(U, 2), {
				label: "Clip Corner",
				type: "checkbox",
				onChange: O,
				get value() {
					return D().clipCorner;
				}
			}), append(C, L);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return D();
		},
		set props(C) {
			D(C), flushSync();
		}
	});
}
create_custom_element(Background, { props: {} }, [], [], !0);
var root_1$11 = /* @__PURE__ */ from_html("<!> <!> <!> <!> <!>", 1);
function BackgroundImage(C, T) {
	push(T, !0);
	let E = /* @__PURE__ */ state(proxy([
		!1,
		!1,
		!1
	])), D = prop(T, "props", 7), O = /* @__PURE__ */ user_derived(() => {
		let C = Asserts.data.filter((C) => C.type === "image").map((C) => ({
			name: C.name,
			value: C.name
		}));
		return C.push({
			name: "None",
			value: ""
		}), C;
	});
	function F(C, T) {
		if (!T) return;
		let E = toCamelCase(T);
		D()[E] = C;
	}
	return WgtAccordionItem(C, {
		label: "Background Image",
		children: (C, T) => {
			var I = root_1$11(), L = first_child(I);
			StateInput(L, {
				get disabled() {
					return get(E)[0];
				},
				set disabled(C) {
					get(E)[0] = C;
				},
				children: (C, T) => {
					{
						let T = /* @__PURE__ */ user_derived(() => !get(E)[0]);
						LabelInput(C, {
							label: "Bg Image",
							type: "option",
							get options() {
								return get(O);
							},
							get value() {
								return D().bgImage;
							},
							get disabled() {
								return get(T);
							},
							onChange: F
						});
					}
				},
				$$slots: { default: !0 }
			});
			var z = sibling(L, 2);
			LabelInput(z, {
				label: "Bg Image Opa",
				type: "number",
				get value() {
					return D().bgImageOpa;
				},
				onChange: F
			});
			var B = sibling(z, 2);
			StateInput(B, {
				get disabled() {
					return get(E)[1];
				},
				set disabled(C) {
					get(E)[1] = C;
				},
				children: (C, T) => {
					{
						let T = /* @__PURE__ */ user_derived(() => !get(E)[1]);
						ColorPicker(C, {
							label: "Bg Image Color",
							get disabled() {
								return get(T);
							},
							get color() {
								return D().bgImageRecolor;
							},
							set color(C) {
								D().bgImageRecolor = C;
							},
							get opa() {
								return D().bgImageRecolorAlpha;
							},
							set opa(C) {
								D().bgImageRecolorAlpha = C;
							}
						});
					}
				},
				$$slots: { default: !0 }
			});
			var V = sibling(B, 2);
			StateInput(V, {
				get disabled() {
					return get(E)[2];
				},
				set disabled(C) {
					get(E)[2] = C;
				},
				children: (C, T) => {
					{
						let T = /* @__PURE__ */ user_derived(() => !get(E)[2]);
						LabelInput(C, {
							label: "Bg Image Recolor Alpha",
							type: "number",
							get value() {
								return D().bgImageRecolorAlpha;
							},
							get disabled() {
								return get(T);
							},
							onChange: F
						});
					}
				},
				$$slots: { default: !0 }
			}), PropertyInput(sibling(V, 2), {
				label: "Bg Image Tiled",
				type: "checkbox",
				onChange: F,
				get value() {
					return D().bgImageTiled;
				}
			}), append(C, I);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return D();
		},
		set props(C) {
			D(C), flushSync();
		}
	});
}
create_custom_element(BackgroundImage, { props: {} }, [], [], !0);
var root_1$10 = /* @__PURE__ */ from_html("<div class=\"right-tab\"><!> <!> <!></div>");
function Border(C, T) {
	push(T, !0);
	let E = prop(T, "props", 7), D = /* @__PURE__ */ state(proxy([
		!1,
		!1,
		!1
	])), O = [
		{
			name: "Left",
			value: lv_border_side_t$1.LV_BORDER_SIDE_LEFT
		},
		{
			name: "Right",
			value: lv_border_side_t$1.LV_BORDER_SIDE_RIGHT
		},
		{
			name: "Top",
			value: lv_border_side_t$1.LV_BORDER_SIDE_TOP
		},
		{
			name: "Bottom",
			value: lv_border_side_t$1.LV_BORDER_SIDE_BOTTOM
		}
	], F = /* @__PURE__ */ user_derived(() => O.filter((C) => C.value & E().borderSide).map((C) => C.value));
	function I(C, T) {
		T && (T = toCamelCase(T), console.log(T, C), E()[T] = C);
	}
	return WgtAccordionItem(C, {
		label: "Border",
		children: (C, T) => {
			var L = root_1$10(), z = child(L);
			StateInput(z, {
				get disabled() {
					return get(D)[0];
				},
				set disabled(C) {
					get(D)[0] = C;
				},
				children: (C, T) => {
					{
						let T = /* @__PURE__ */ user_derived(() => !get(D)[0]);
						ColorPicker(C, {
							label: "Border Color",
							get disabled() {
								return get(T);
							},
							get color() {
								return E().borderColor;
							},
							set color(C) {
								E().borderColor = C;
							},
							get opa() {
								return E().borderColorOpa;
							},
							set opa(C) {
								E().borderColorOpa = C;
							}
						});
					}
				},
				$$slots: { default: !0 }
			});
			var B = sibling(z, 2);
			StateInput(B, {
				get disabled() {
					return get(D)[1];
				},
				set disabled(C) {
					get(D)[1] = C;
				},
				children: (C, T) => {
					{
						let T = /* @__PURE__ */ user_derived(() => !get(D)[1]);
						LabelInput(C, {
							label: "Border Width",
							type: "number",
							get value() {
								return E().borderWidth;
							},
							get disabled() {
								return get(T);
							},
							onChange: I
						});
					}
				},
				$$slots: { default: !0 }
			}), StateInput(sibling(B, 2), {
				get disabled() {
					return get(D)[2];
				},
				set disabled(C) {
					get(D)[2] = C;
				},
				children: (C, T) => {
					MultiSelect(C, {
						class: "w-full",
						get value() {
							return get(F);
						},
						get items() {
							return O;
						},
						onchange: (C) => {
							let T = C.currentTarget.value.reduce((C, T) => C | T, 0);
							E().borderSide = T;
						}
					});
				},
				$$slots: { default: !0 }
			}), reset(L), append(C, L);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return E();
		},
		set props(C) {
			E(C), flushSync();
		}
	});
}
create_custom_element(Border, { props: {} }, [], [], !0);
var root_3$6 = /* @__PURE__ */ from_html("<!> <!>", 1), root_1$9 = /* @__PURE__ */ from_html("<!> <!>", 1);
function Outline(C, T) {
	push(T, !0);
	let E = prop(T, "props", 7), D = /* @__PURE__ */ state(proxy([!1, !1]));
	function O(C, T) {
		T && (T = toCamelCase(T), E()[T] = C);
	}
	return WgtAccordionItem(C, {
		label: "Outline",
		children: (C, T) => {
			var F = root_1$9(), I = first_child(F);
			StateInput(I, {
				get disabled() {
					return get(D)[0];
				},
				set disabled(C) {
					get(D)[0] = C;
				},
				children: (C, T) => {
					{
						let T = /* @__PURE__ */ user_derived(() => !get(D)[0]);
						ColorPicker(C, {
							label: "Outline Color",
							get disabled() {
								return get(T);
							},
							get color() {
								return E().outlineColor;
							},
							set color(C) {
								E().outlineColor = C;
							},
							get opa() {
								return E().outlineColorAlpha;
							},
							set opa(C) {
								E().outlineColorAlpha = C;
							}
						});
					}
				},
				$$slots: { default: !0 }
			}), StateInput(sibling(I, 2), {
				get disabled() {
					return get(D)[1];
				},
				set disabled(C) {
					get(D)[1] = C;
				},
				children: (C, T) => {
					var F = root_3$6(), I = first_child(F);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(D)[1]);
						LabelInput(I, {
							label: "Outline Width",
							type: "number",
							get value() {
								return E().outlineWidth;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					var L = sibling(I, 2);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(D)[1]);
						LabelInput(L, {
							label: "Outline Pad",
							type: "number",
							get value() {
								return E().outlinePad;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					append(C, F);
				},
				$$slots: { default: !0 }
			}), append(C, F);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return E();
		},
		set props(C) {
			E(C), flushSync();
		}
	});
}
create_custom_element(Outline, { props: {} }, [], [], !0);
var root_3$5 = /* @__PURE__ */ from_html("<!> <!>", 1), root_4$1 = /* @__PURE__ */ from_html("<!> <!>", 1), root_1$8 = /* @__PURE__ */ from_html("<div class=\"right-tab\"><!> <!> <!></div>");
function Shadow(C, T) {
	push(T, !0);
	let E = prop(T, "props", 7), D = /* @__PURE__ */ state(proxy([
		!1,
		!1,
		!1
	]));
	function O(C, T) {
		T && (T = toCamelCase(T), E()[T] = C);
	}
	return WgtAccordionItem(C, {
		label: "Shadow",
		children: (C, T) => {
			var F = root_1$8(), I = child(F);
			StateInput(I, {
				get disabled() {
					return get(D)[0];
				},
				set disabled(C) {
					get(D)[0] = C;
				},
				children: (C, T) => {
					{
						let T = /* @__PURE__ */ user_derived(() => !get(D)[0]);
						ColorPicker(C, {
							label: "Shadow Color",
							get disabled() {
								return get(T);
							},
							get color() {
								return E().shadowColor;
							},
							set color(C) {
								E().shadowColor = C;
							},
							get opa() {
								return E().shadowColorAlpha;
							},
							set opa(C) {
								E().shadowColorAlpha = C;
							}
						});
					}
				},
				$$slots: { default: !0 }
			});
			var L = sibling(I, 2);
			StateInput(L, {
				get disabled() {
					return get(D)[1];
				},
				set disabled(C) {
					get(D)[1] = C;
				},
				children: (C, T) => {
					var F = root_3$5(), I = first_child(F);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(D)[1]);
						LabelInput(I, {
							label: "Shadow Width",
							type: "number",
							get value() {
								return E().shadowWidth;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					var L = sibling(I, 2);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(D)[1]);
						LabelInput(L, {
							label: "Shadow Spread",
							type: "number",
							get value() {
								return E().shadowSpread;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					append(C, F);
				},
				$$slots: { default: !0 }
			}), StateInput(sibling(L, 2), {
				get disabled() {
					return get(D)[2];
				},
				set disabled(C) {
					get(D)[2] = C;
				},
				children: (C, T) => {
					var F = root_4$1(), I = first_child(F);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(D)[2]);
						LabelInput(I, {
							label: "Shadow O X",
							type: "number",
							get value() {
								return E().shadowOX;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					var L = sibling(I, 2);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(D)[2]);
						LabelInput(L, {
							label: "Shadow O Y",
							type: "number",
							get value() {
								return E().shadowOY;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					append(C, F);
				},
				$$slots: { default: !0 }
			}), reset(F), append(C, F);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return E();
		},
		set props(C) {
			E(C), flushSync();
		}
	});
}
create_custom_element(Shadow, { props: {} }, [], [], !0);
function Blend(C, T) {
	push(T, !0);
	let E = /* @__PURE__ */ state(proxy([!1])), D = prop(T, "props", 7);
	function O(C, T) {
		T && (T = toCamelCase(T), D()[T] = C);
	}
	return WgtAccordionItem(C, {
		label: "Blend",
		children: (C, T) => {
			StateInput(C, {
				get disabled() {
					return get(E)[0];
				},
				set disabled(C) {
					get(E)[0] = C;
				},
				children: (C, T) => {
					{
						let T = /* @__PURE__ */ user_derived(() => !get(E)[0]);
						LabelInput(C, {
							label: "Blend Mode",
							type: "option",
							get options() {
								return lvBlendModeList;
							},
							get value() {
								return D().blendMode;
							},
							get disabled() {
								return get(T);
							},
							onChange: O
						});
					}
				},
				$$slots: { default: !0 }
			});
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return D();
		},
		set props(C) {
			D(C), flushSync();
		}
	});
}
create_custom_element(Blend, { props: {} }, [], [], !0);
var root_2$7 = /* @__PURE__ */ from_html("<!> <!> <!> <!>", 1), root_3$4 = /* @__PURE__ */ from_html("<!> <!>", 1), root_1$7 = /* @__PURE__ */ from_html("<!> <!>", 1);
function Paddings(C, T) {
	push(T, !0);
	let E = /* @__PURE__ */ state(proxy([!1, !1])), D = prop(T, "props", 7);
	function O(C, T) {
		T && (T = toCamelCase(T), D()[T] = C);
	}
	return WgtAccordionItem(C, {
		label: "Paddings",
		children: (C, T) => {
			var F = root_1$7(), I = first_child(F);
			StateInput(I, {
				get disabled() {
					return get(E)[0];
				},
				set disabled(C) {
					get(E)[0] = C;
				},
				children: (C, T) => {
					var F = root_2$7(), I = first_child(F);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(E)[0]);
						LabelInput(I, {
							label: "Pad Left",
							type: "number",
							get value() {
								return D().padLeft;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					var L = sibling(I, 2);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(E)[0]);
						LabelInput(L, {
							label: "Pad Top",
							type: "number",
							get value() {
								return D().padTop;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					var z = sibling(L, 2);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(E)[0]);
						LabelInput(z, {
							label: "Pad Right",
							type: "number",
							get value() {
								return D().padRight;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					var B = sibling(z, 2);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(E)[0]);
						LabelInput(B, {
							label: "Pad Bottom",
							type: "number",
							get value() {
								return D().padBottom;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					append(C, F);
				},
				$$slots: { default: !0 }
			}), StateInput(sibling(I, 2), {
				get disabled() {
					return get(E)[1];
				},
				set disabled(C) {
					get(E)[1] = C;
				},
				children: (C, T) => {
					var F = root_3$4(), I = first_child(F);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(E)[1]);
						LabelInput(I, {
							label: "Pad Row",
							type: "number",
							get value() {
								return D().padRow;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					var L = sibling(I, 2);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(E)[1]);
						LabelInput(L, {
							label: "Pad Column",
							type: "number",
							get value() {
								return D().padColumn;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					append(C, F);
				},
				$$slots: { default: !0 }
			}), append(C, F);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return D();
		},
		set props(C) {
			D(C), flushSync();
		}
	});
}
create_custom_element(Paddings, { props: {} }, [], [], !0);
let lv_align_t = /* @__PURE__ */ function(C) {
	return C[C.LV_ALIGN_DEFAULT = 0] = "LV_ALIGN_DEFAULT", C[C.LV_ALIGN_TOP_LEFT = 1] = "LV_ALIGN_TOP_LEFT", C[C.LV_ALIGN_TOP_MID = 2] = "LV_ALIGN_TOP_MID", C[C.LV_ALIGN_TOP_RIGHT = 3] = "LV_ALIGN_TOP_RIGHT", C[C.LV_ALIGN_BOTTOM_LEFT = 4] = "LV_ALIGN_BOTTOM_LEFT", C[C.LV_ALIGN_BOTTOM_MID = 5] = "LV_ALIGN_BOTTOM_MID", C[C.LV_ALIGN_BOTTOM_RIGHT = 6] = "LV_ALIGN_BOTTOM_RIGHT", C[C.LV_ALIGN_LEFT_MID = 7] = "LV_ALIGN_LEFT_MID", C[C.LV_ALIGN_RIGHT_MID = 8] = "LV_ALIGN_RIGHT_MID", C[C.LV_ALIGN_CENTER = 9] = "LV_ALIGN_CENTER", C[C.LV_ALIGN_OUT_TOP_LEFT = 10] = "LV_ALIGN_OUT_TOP_LEFT", C[C.LV_ALIGN_OUT_TOP_MID = 11] = "LV_ALIGN_OUT_TOP_MID", C[C.LV_ALIGN_OUT_TOP_RIGHT = 12] = "LV_ALIGN_OUT_TOP_RIGHT", C[C.LV_ALIGN_OUT_BOTTOM_LEFT = 13] = "LV_ALIGN_OUT_BOTTOM_LEFT", C[C.LV_ALIGN_OUT_BOTTOM_MID = 14] = "LV_ALIGN_OUT_BOTTOM_MID", C[C.LV_ALIGN_OUT_BOTTOM_RIGHT = 15] = "LV_ALIGN_OUT_BOTTOM_RIGHT", C[C.LV_ALIGN_OUT_LEFT_TOP = 16] = "LV_ALIGN_OUT_LEFT_TOP", C[C.LV_ALIGN_OUT_LEFT_MID = 17] = "LV_ALIGN_OUT_LEFT_MID", C[C.LV_ALIGN_OUT_LEFT_BOTTOM = 18] = "LV_ALIGN_OUT_LEFT_BOTTOM", C[C.LV_ALIGN_OUT_RIGHT_TOP = 19] = "LV_ALIGN_OUT_RIGHT_TOP", C[C.LV_ALIGN_OUT_RIGHT_MID = 20] = "LV_ALIGN_OUT_RIGHT_MID", C[C.LV_ALIGN_OUT_RIGHT_BOTTOM = 21] = "LV_ALIGN_OUT_RIGHT_BOTTOM", C;
}({}), lv_obj_flag_t = /* @__PURE__ */ function(C) {
	return C[C.LV_OBJ_FLAG_HIDDEN = 1] = "LV_OBJ_FLAG_HIDDEN", C[C.LV_OBJ_FLAG_CLICKABLE = 2] = "LV_OBJ_FLAG_CLICKABLE", C[C.LV_OBJ_FLAG_CLICK_FOCUSABLE = 4] = "LV_OBJ_FLAG_CLICK_FOCUSABLE", C[C.LV_OBJ_FLAG_CHECKABLE = 8] = "LV_OBJ_FLAG_CHECKABLE", C[C.LV_OBJ_FLAG_SCROLLABLE = 16] = "LV_OBJ_FLAG_SCROLLABLE", C[C.LV_OBJ_FLAG_SCROLL_ELASTIC = 32] = "LV_OBJ_FLAG_SCROLL_ELASTIC", C[C.LV_OBJ_FLAG_SCROLL_MOMENTUM = 64] = "LV_OBJ_FLAG_SCROLL_MOMENTUM", C[C.LV_OBJ_FLAG_SCROLL_ONE = 128] = "LV_OBJ_FLAG_SCROLL_ONE", C[C.LV_OBJ_FLAG_SCROLL_CHAIN_HOR = 256] = "LV_OBJ_FLAG_SCROLL_CHAIN_HOR", C[C.LV_OBJ_FLAG_SCROLL_CHAIN_VER = 512] = "LV_OBJ_FLAG_SCROLL_CHAIN_VER", C[C.LV_OBJ_FLAG_SCROLL_CHAIN = 768] = "LV_OBJ_FLAG_SCROLL_CHAIN", C[C.LV_OBJ_FLAG_SCROLL_ON_FOCUS = 1024] = "LV_OBJ_FLAG_SCROLL_ON_FOCUS", C[C.LV_OBJ_FLAG_SCROLL_WITH_ARROW = 2048] = "LV_OBJ_FLAG_SCROLL_WITH_ARROW", C[C.LV_OBJ_FLAG_SNAPPABLE = 4096] = "LV_OBJ_FLAG_SNAPPABLE", C[C.LV_OBJ_FLAG_PRESS_LOCK = 8192] = "LV_OBJ_FLAG_PRESS_LOCK", C[C.LV_OBJ_FLAG_EVENT_BUBBLE = 16384] = "LV_OBJ_FLAG_EVENT_BUBBLE", C[C.LV_OBJ_FLAG_GESTURE_BUBBLE = 32768] = "LV_OBJ_FLAG_GESTURE_BUBBLE", C[C.LV_OBJ_FLAG_ADV_HITTEST = 65536] = "LV_OBJ_FLAG_ADV_HITTEST", C[C.LV_OBJ_FLAG_IGNORE_LAYOUT = 131072] = "LV_OBJ_FLAG_IGNORE_LAYOUT", C[C.LV_OBJ_FLAG_FLOATING = 262144] = "LV_OBJ_FLAG_FLOATING", C[C.LV_OBJ_FLAG_SEND_DRAW_TASK_EVENTS = 524288] = "LV_OBJ_FLAG_SEND_DRAW_TASK_EVENTS", C[C.LV_OBJ_FLAG_OVERFLOW_VISIBLE = 1048576] = "LV_OBJ_FLAG_OVERFLOW_VISIBLE", C[C.LV_OBJ_FLAG_LAYOUT_1 = 8388608] = "LV_OBJ_FLAG_LAYOUT_1", C[C.LV_OBJ_FLAG_LAYOUT_2 = 16777216] = "LV_OBJ_FLAG_LAYOUT_2", C[C.LV_OBJ_FLAG_WIDGET_1 = 33554432] = "LV_OBJ_FLAG_WIDGET_1", C[C.LV_OBJ_FLAG_WIDGET_2 = 67108864] = "LV_OBJ_FLAG_WIDGET_2", C[C.LV_OBJ_FLAG_USER_1 = 134217728] = "LV_OBJ_FLAG_USER_1", C[C.LV_OBJ_FLAG_USER_2 = 268435456] = "LV_OBJ_FLAG_USER_2", C[C.LV_OBJ_FLAG_USER_3 = 536870912] = "LV_OBJ_FLAG_USER_3", C[C.LV_OBJ_FLAG_USER_4 = 1073741824] = "LV_OBJ_FLAG_USER_4", C;
}({}), lv_scrollbar_mode_t = /* @__PURE__ */ function(C) {
	return C[C.LV_SCROLLBAR_MODE_OFF = 0] = "LV_SCROLLBAR_MODE_OFF", C[C.LV_SCROLLBAR_MODE_ON = 1] = "LV_SCROLLBAR_MODE_ON", C[C.LV_SCROLLBAR_MODE_ACTIVE = 2] = "LV_SCROLLBAR_MODE_ACTIVE", C[C.LV_SCROLLBAR_MODE_AUTO = 3] = "LV_SCROLLBAR_MODE_AUTO", C;
}({}), lv_scroll_snap_t = /* @__PURE__ */ function(C) {
	return C[C.LV_SCROLL_SNAP_NONE = 0] = "LV_SCROLL_SNAP_NONE", C[C.LV_SCROLL_SNAP_START = 1] = "LV_SCROLL_SNAP_START", C[C.LV_SCROLL_SNAP_END = 2] = "LV_SCROLL_SNAP_END", C[C.LV_SCROLL_SNAP_CENTER = 3] = "LV_SCROLL_SNAP_CENTER", C;
}({}), lv_border_side_t = /* @__PURE__ */ function(C) {
	return C[C.LV_BORDER_SIDE_NONE = 0] = "LV_BORDER_SIDE_NONE", C[C.LV_BORDER_SIDE_BOTTOM = 1] = "LV_BORDER_SIDE_BOTTOM", C[C.LV_BORDER_SIDE_TOP = 2] = "LV_BORDER_SIDE_TOP", C[C.LV_BORDER_SIDE_LEFT = 4] = "LV_BORDER_SIDE_LEFT", C[C.LV_BORDER_SIDE_RIGHT = 8] = "LV_BORDER_SIDE_RIGHT", C[C.LV_BORDER_SIDE_FULL = 15] = "LV_BORDER_SIDE_FULL", C[C.LV_BORDER_SIDE_INTERNAL = 16] = "LV_BORDER_SIDE_INTERNAL", C;
}({}), lv_text_align_t = /* @__PURE__ */ function(C) {
	return C[C.LV_TEXT_ALIGN_AUTO = 0] = "LV_TEXT_ALIGN_AUTO", C[C.LV_TEXT_ALIGN_LEFT = 1] = "LV_TEXT_ALIGN_LEFT", C[C.LV_TEXT_ALIGN_CENTER = 2] = "LV_TEXT_ALIGN_CENTER", C[C.LV_TEXT_ALIGN_RIGHT = 3] = "LV_TEXT_ALIGN_RIGHT", C;
}({}), lv_state_t = /* @__PURE__ */ function(C) {
	return C[C.LV_STATE_CHECKED = 1] = "LV_STATE_CHECKED", C[C.LV_STATE_FOCUSED = 2] = "LV_STATE_FOCUSED", C[C.LV_STATE_FOCUS_KEY = 4] = "LV_STATE_FOCUS_KEY", C[C.LV_STATE_EDITED = 8] = "LV_STATE_EDITED", C[C.LV_STATE_HOVERED = 16] = "LV_STATE_HOVERED", C[C.LV_STATE_PRESSED = 32] = "LV_STATE_PRESSED", C[C.LV_STATE_SCROLLED = 64] = "LV_STATE_SCROLLED", C[C.LV_STATE_DISABLED = 128] = "LV_STATE_DISABLED", C[C.LV_STATE_USER_1 = 4096] = "LV_STATE_USER_1", C[C.LV_STATE_USER_2 = 8192] = "LV_STATE_USER_2", C[C.LV_STATE_USER_3 = 16384] = "LV_STATE_USER_3", C[C.LV_STATE_USER_4 = 32768] = "LV_STATE_USER_4", C[C.LV_STATE_ANY = 65535] = "LV_STATE_ANY", C;
}({}), lv_grad_dir_t = /* @__PURE__ */ function(C) {
	return C[C.LV_GRAD_DIR_NONE = 0] = "LV_GRAD_DIR_NONE", C[C.LV_GRAD_DIR_VER = 1] = "LV_GRAD_DIR_VER", C[C.LV_GRAD_DIR_HOR = 2] = "LV_GRAD_DIR_HOR", C;
}({}), lv_chart_type_t = /* @__PURE__ */ function(C) {
	return C[C.LV_CHART_TYPE_NONE = 0] = "LV_CHART_TYPE_NONE", C[C.LV_CHART_TYPE_LINE = 1] = "LV_CHART_TYPE_LINE", C[C.LV_CHART_TYPE_BAR = 2] = "LV_CHART_TYPE_BAR", C[C.LV_CHART_TYPE_SCATTER = 3] = "LV_CHART_TYPE_SCATTER", C;
}({}), lv_bar_mode_t = /* @__PURE__ */ function(C) {
	return C[C.LV_BAR_MODE_NORMAL = 0] = "LV_BAR_MODE_NORMAL", C[C.LV_BAR_MODE_SYMMETRICAL = 1] = "LV_BAR_MODE_SYMMETRICAL", C[C.LV_BAR_MODE_RANGE = 2] = "LV_BAR_MODE_RANGE", C;
}({}), lv_slider_mode_t = /* @__PURE__ */ function(C) {
	return C[C.LV_SLIDER_MODE_NORMAL = 0] = "LV_SLIDER_MODE_NORMAL", C[C.LV_SLIDER_MODE_SYMMETRICAL = 1] = "LV_SLIDER_MODE_SYMMETRICAL", C[C.LV_SLIDER_MODE_RANGE = 2] = "LV_SLIDER_MODE_RANGE", C;
}({}), lv_arc_mode_t = /* @__PURE__ */ function(C) {
	return C[C.LV_ARC_MODE_NORMAL = 0] = "LV_ARC_MODE_NORMAL", C[C.LV_ARC_MODE_SYMMETRICAL = 1] = "LV_ARC_MODE_SYMMETRICAL", C[C.LV_ARC_MODE_REVERSE = 2] = "LV_ARC_MODE_REVERSE", C;
}({}), lv_label_long_mode_t = /* @__PURE__ */ function(C) {
	return C[C.LV_LABEL_LONG_WRAP = 0] = "LV_LABEL_LONG_WRAP", C[C.LV_LABEL_LONG_SCROLL = 1] = "LV_LABEL_LONG_SCROLL", C[C.LV_LABEL_LONG_SCROLL_CIRCULAR = 2] = "LV_LABEL_LONG_SCROLL_CIRCULAR", C[C.LV_LABEL_LONG_CLIP = 3] = "LV_LABEL_LONG_CLIP", C;
}({}), lv_dir_t = /* @__PURE__ */ function(C) {
	return C[C.LV_DIR_NONE = 0] = "LV_DIR_NONE", C[C.LV_DIR_LEFT = 1] = "LV_DIR_LEFT", C[C.LV_DIR_RIGHT = 2] = "LV_DIR_RIGHT", C[C.LV_DIR_TOP = 4] = "LV_DIR_TOP", C[C.LV_DIR_BOTTOM = 8] = "LV_DIR_BOTTOM", C[C.LV_DIR_HOR = 3] = "LV_DIR_HOR", C[C.LV_DIR_VER = 12] = "LV_DIR_VER", C[C.LV_DIR_ALL = 15] = "LV_DIR_ALL", C;
}({}), lv_text_decor_t = /* @__PURE__ */ function(C) {
	return C[C.LV_TEXT_DECOR_NONE = 0] = "LV_TEXT_DECOR_NONE", C[C.LV_TEXT_DECOR_UNDERLINE = 1] = "LV_TEXT_DECOR_UNDERLINE", C[C.LV_TEXT_DECOR_STRIKETHROUGH = 2] = "LV_TEXT_DECOR_STRIKETHROUGH", C;
}({}), lv_event_code_t = /* @__PURE__ */ function(C) {
	return C[C.LV_EVENT_ALL = 0] = "LV_EVENT_ALL", C[C.LV_EVENT_PRESSED = 1] = "LV_EVENT_PRESSED", C[C.LV_EVENT_PRESSING = 2] = "LV_EVENT_PRESSING", C[C.LV_EVENT_PRESS_LOST = 3] = "LV_EVENT_PRESS_LOST", C[C.LV_EVENT_SHORT_CLICKED = 4] = "LV_EVENT_SHORT_CLICKED", C[C.LV_EVENT_LONG_PRESSED = 5] = "LV_EVENT_LONG_PRESSED", C[C.LV_EVENT_LONG_PRESSED_REPEAT = 6] = "LV_EVENT_LONG_PRESSED_REPEAT", C[C.LV_EVENT_CLICKED = 7] = "LV_EVENT_CLICKED", C[C.LV_EVENT_RELEASED = 8] = "LV_EVENT_RELEASED", C[C.LV_EVENT_SCROLL_BEGIN = 9] = "LV_EVENT_SCROLL_BEGIN", C[C.LV_EVENT_SCROLL_THROW_BEGIN = 10] = "LV_EVENT_SCROLL_THROW_BEGIN", C[C.LV_EVENT_SCROLL_END = 11] = "LV_EVENT_SCROLL_END", C[C.LV_EVENT_SCROLL = 12] = "LV_EVENT_SCROLL", C[C.LV_EVENT_GESTURE = 13] = "LV_EVENT_GESTURE", C[C.LV_EVENT_KEY = 14] = "LV_EVENT_KEY", C[C.LV_EVENT_FOCUSED = 15] = "LV_EVENT_FOCUSED", C[C.LV_EVENT_DEFOCUSED = 16] = "LV_EVENT_DEFOCUSED", C[C.LV_EVENT_LEAVE = 17] = "LV_EVENT_LEAVE", C[C.LV_EVENT_HIT_TEST = 18] = "LV_EVENT_HIT_TEST", C[C.LV_EVENT_INDEV_RESET = 19] = "LV_EVENT_INDEV_RESET", C[C.LV_EVENT_COVER_CHECK = 20] = "LV_EVENT_COVER_CHECK", C[C.LV_EVENT_REFR_EXT_DRAW_SIZE = 21] = "LV_EVENT_REFR_EXT_DRAW_SIZE", C[C.LV_EVENT_DRAW_MAIN_BEGIN = 22] = "LV_EVENT_DRAW_MAIN_BEGIN", C[C.LV_EVENT_DRAW_MAIN = 23] = "LV_EVENT_DRAW_MAIN", C[C.LV_EVENT_DRAW_MAIN_END = 24] = "LV_EVENT_DRAW_MAIN_END", C[C.LV_EVENT_DRAW_POST_BEGIN = 25] = "LV_EVENT_DRAW_POST_BEGIN", C[C.LV_EVENT_DRAW_POST = 26] = "LV_EVENT_DRAW_POST", C[C.LV_EVENT_DRAW_POST_END = 27] = "LV_EVENT_DRAW_POST_END", C[C.LV_EVENT_DRAW_TASK_ADDED = 28] = "LV_EVENT_DRAW_TASK_ADDED", C[C.LV_EVENT_VALUE_CHANGED = 29] = "LV_EVENT_VALUE_CHANGED", C[C.LV_EVENT_INSERT = 30] = "LV_EVENT_INSERT", C[C.LV_EVENT_REFRESH = 31] = "LV_EVENT_REFRESH", C[C.LV_EVENT_READY = 32] = "LV_EVENT_READY", C[C.LV_EVENT_CANCEL = 33] = "LV_EVENT_CANCEL", C[C.LV_EVENT_CREATE = 34] = "LV_EVENT_CREATE", C[C.LV_EVENT_DELETE = 35] = "LV_EVENT_DELETE", C[C.LV_EVENT_CHILD_CHANGED = 36] = "LV_EVENT_CHILD_CHANGED", C[C.LV_EVENT_CHILD_CREATED = 37] = "LV_EVENT_CHILD_CREATED", C[C.LV_EVENT_CHILD_DELETED = 38] = "LV_EVENT_CHILD_DELETED", C[C.LV_EVENT_SCREEN_UNLOAD_START = 39] = "LV_EVENT_SCREEN_UNLOAD_START", C[C.LV_EVENT_SCREEN_LOAD_START = 40] = "LV_EVENT_SCREEN_LOAD_START", C[C.LV_EVENT_SCREEN_LOADED = 41] = "LV_EVENT_SCREEN_LOADED", C[C.LV_EVENT_SCREEN_UNLOADED = 42] = "LV_EVENT_SCREEN_UNLOADED", C[C.LV_EVENT_SIZE_CHANGED = 43] = "LV_EVENT_SIZE_CHANGED", C[C.LV_EVENT_STYLE_CHANGED = 44] = "LV_EVENT_STYLE_CHANGED", C[C.LV_EVENT_LAYOUT_CHANGED = 45] = "LV_EVENT_LAYOUT_CHANGED", C[C.LV_EVENT_GET_SELF_SIZE = 46] = "LV_EVENT_GET_SELF_SIZE", C[C.LV_EVENT_INVALIDATE_AREA = 47] = "LV_EVENT_INVALIDATE_AREA", C[C.LV_EVENT_RESOLUTION_CHANGED = 48] = "LV_EVENT_RESOLUTION_CHANGED", C[C.LV_EVENT_COLOR_FORMAT_CHANGED = 49] = "LV_EVENT_COLOR_FORMAT_CHANGED", C[C.LV_EVENT_REFR_REQUEST = 50] = "LV_EVENT_REFR_REQUEST", C[C.LV_EVENT_REFR_START = 51] = "LV_EVENT_REFR_START", C[C.LV_EVENT_REFR_READY = 52] = "LV_EVENT_REFR_READY", C[C.LV_EVENT_RENDER_START = 53] = "LV_EVENT_RENDER_START", C[C.LV_EVENT_RENDER_READY = 54] = "LV_EVENT_RENDER_READY", C[C.LV_EVENT_FLUSH_START = 55] = "LV_EVENT_FLUSH_START", C[C.LV_EVENT_FLUSH_FINISH = 56] = "LV_EVENT_FLUSH_FINISH", C[C.LV_EVENT_VSYNC = 57] = "LV_EVENT_VSYNC", C[C._LV_EVENT_LAST = 58] = "_LV_EVENT_LAST", C[C.LV_EVENT_PREPROCESS = 32768] = "LV_EVENT_PREPROCESS", C;
}({});
function format(C, T = 2, E = !1) {
	let D = C.split("_").slice(T);
	if (D) {
		let C = "";
		return D.forEach((T) => {
			C += T + " ";
		}), C = C.trimEnd(), E && (C = C.toLowerCase().replace("flag ", "")), C;
	}
	return " ";
}
function enumToOpts(C, T = 2, E = !1) {
	let D = [];
	for (let O in C) if (Object.prototype.hasOwnProperty.call(C, O)) {
		if (isNaN(Number(C[O]))) continue;
		let F = format(O, T, E), I = C[O];
		D.push({
			label: F,
			value: I
		});
	}
	return D;
}
enumToOpts(lv_align_t), enumToOpts(lv_dir_t), enumToOpts(lv_obj_flag_t, 3, !0), enumToOpts(lv_scrollbar_mode_t, 3), enumToOpts(lv_scroll_snap_t), enumToOpts(lv_border_side_t);
const LvTextAlignOpts = enumToOpts(lv_text_align_t, 3);
enumToOpts(lv_state_t, 2, !0), enumToOpts(lv_grad_dir_t, 3, !0);
const StateOpts$1 = [
	{
		label: "DEFAULT",
		value: 0
	},
	{
		label: "CHECKED",
		value: lv_state_t.LV_STATE_CHECKED
	},
	{
		label: "FOCUSED",
		value: lv_state_t.LV_STATE_FOCUSED
	},
	{
		label: "FOCUS_KEY",
		value: lv_state_t.LV_STATE_FOCUS_KEY
	},
	{
		label: "PRESSED",
		value: lv_state_t.LV_STATE_PRESSED
	},
	{
		label: "DISABLE",
		value: lv_state_t.LV_STATE_DISABLED
	},
	{
		label: "SCROLLED",
		value: lv_state_t.LV_STATE_SCROLLED
	},
	{
		label: "CHECKED | FOCUSED",
		value: lv_state_t.LV_STATE_CHECKED | lv_state_t.LV_STATE_FOCUSED
	},
	{
		label: "CHECKED | PRESSED",
		value: lv_state_t.LV_STATE_CHECKED | lv_state_t.LV_STATE_PRESSED
	},
	{
		label: "CHECKED | FOCUS_KEY",
		value: lv_state_t.LV_STATE_CHECKED | lv_state_t.LV_STATE_FOCUS_KEY
	},
	{
		label: "USER_1",
		value: lv_state_t.LV_STATE_USER_1
	},
	{
		label: "USER_2",
		value: lv_state_t.LV_STATE_USER_2
	},
	{
		label: "USER_3",
		value: lv_state_t.LV_STATE_USER_3
	},
	{
		label: "USER_4",
		value: lv_state_t.LV_STATE_USER_4
	}
];
StateOpts$1.map((C) => ({
	label: C.label,
	value: C.label
})), new Map(StateOpts$1.map((C) => [C.label, C.value])), enumToOpts(lv_slider_mode_t, 3, !0), enumToOpts(lv_arc_mode_t, 3, !0);
var lv_common_flags = /* @__PURE__ */ function(C) {
	return C[C.LV_OBJ_FLAG_HIDDEN = 1] = "LV_OBJ_FLAG_HIDDEN", C[C.LV_OBJ_FLAG_CLICKABLE = 2] = "LV_OBJ_FLAG_CLICKABLE", C[C.LV_OBJ_FLAG_CLICK_FOCUSABLE = 4] = "LV_OBJ_FLAG_CLICK_FOCUSABLE", C[C.LV_OBJ_FLAG_CHECKABLE = 8] = "LV_OBJ_FLAG_CHECKABLE", C[C.LV_OBJ_FLAG_PRESS_LOCK = 2048] = "LV_OBJ_FLAG_PRESS_LOCK", C[C.LV_OBJ_FLAG_EVENT_BUBBLE = 4096] = "LV_OBJ_FLAG_EVENT_BUBBLE", C[C.LV_OBJ_FLAG_GESTURE_BUBBLE = 8192] = "LV_OBJ_FLAG_GESTURE_BUBBLE", C[C.LV_OBJ_FLAG_ADV_HITTEST = 16384] = "LV_OBJ_FLAG_ADV_HITTEST", C[C.LV_OBJ_FLAG_IGNORE_LAYOUT = 32768] = "LV_OBJ_FLAG_IGNORE_LAYOUT", C[C.LV_OBJ_FLAG_FLOATING = 65536] = "LV_OBJ_FLAG_FLOATING", C[C.LV_OBJ_FLAG_SNAPABLE = 1024] = "LV_OBJ_FLAG_SNAPABLE", C[C.LV_OBJ_FLAG_SCROLLABLE = 16] = "LV_OBJ_FLAG_SCROLLABLE", C[C.LV_OBJ_FLAG_SCROLL_ELASTIC = 32] = "LV_OBJ_FLAG_SCROLL_ELASTIC", C[C.LV_OBJ_FLAG_SCROLL_MOMENTUM = 64] = "LV_OBJ_FLAG_SCROLL_MOMENTUM", C[C.LV_OBJ_FLAG_SCROLL_ONE = 128] = "LV_OBJ_FLAG_SCROLL_ONE", C[C.LV_OBJ_FLAG_SCROLL_CHAIN = 256] = "LV_OBJ_FLAG_SCROLL_CHAIN", C[C.LV_OBJ_FLAG_SCROLL_ON_FOCUS = 512] = "LV_OBJ_FLAG_SCROLL_ON_FOCUS", C;
}(lv_common_flags || {});
enumToOpts(lv_common_flags, 3, !0), enumToOpts(lv_label_long_mode_t), enumToOpts(lv_bar_mode_t, 3, !0), enumToOpts(lv_chart_type_t, 3, !0);
const LvTextDecorOpts = enumToOpts(lv_text_decor_t, 3, !0);
enumToOpts(lv_event_code_t, 2, !0), enumToOpts(lv_event_code_t, 0, !0);
var root_2$6 = /* @__PURE__ */ from_html("<div class=\"w-[60px] h-[25px] overflow-hidden border-[1px] border-solid border-gray-500\"><!></div>"), root_3$3 = /* @__PURE__ */ from_html("<!> <!>", 1), root_1$6 = /* @__PURE__ */ from_html("<!> <!> <!> <!> <!>", 1);
function Text$1(C, T) {
	push(T, !0);
	let E = LvTextAlignOpts.map((C) => ({
		value: C.value,
		name: C.label
	})), D = LvTextDecorOpts.map((C) => ({
		value: C.value,
		name: C.label
	})), O = /* @__PURE__ */ state(proxy([
		!1,
		!1,
		!1,
		!1,
		!1
	])), F = prop(T, "props", 7), I = /* @__PURE__ */ user_derived(() => {
		let C = [];
		for (let T in lvglBinFont) C.push({
			value: T,
			name: T
		});
		return C.push(...lvDefaultFontList), C;
	});
	function L(C, T) {
		T && (T = toCamelCase(T), F()[T] = C);
	}
	function z(C) {
		let T = C.hex;
		T && (T.length === 7 && (F().textColor = T), T.length === 9 && (F().textColor = T.substring(0, 7), F().opa = parseInt(T.substring(7, 9), 16)));
	}
	return WgtAccordionItem(C, {
		label: "Text",
		children: (C, T) => {
			var B = root_1$6(), V = first_child(B);
			StateInput(V, {
				get disabled() {
					return get(O)[0];
				},
				set disabled(C) {
					get(O)[0] = C;
				},
				children: (C, T) => {
					var E = root_2$6(), D = child(E);
					{
						let C = /* @__PURE__ */ user_derived(() => hexWithAlpha(F().textColor, F().opa)), T = /* @__PURE__ */ user_derived(() => !get(O)[0]);
						MCXAColorPicker(D, {
							get color() {
								return get(C);
							},
							get disabled() {
								return get(T);
							},
							onChange: z
						});
					}
					reset(E), append(C, E);
				},
				$$slots: { default: !0 }
			});
			var U = sibling(V, 2);
			StateInput(U, {
				get disabled() {
					return get(O)[1];
				},
				set disabled(C) {
					get(O)[1] = C;
				},
				children: (C, T) => {
					var E = root_3$3(), D = first_child(E);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(O)[1]);
						LabelInput(D, {
							label: "Letter Space",
							type: "number",
							get value() {
								return F().letterSpace;
							},
							get disabled() {
								return get(C);
							},
							onChange: L
						});
					}
					var I = sibling(D, 2);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(O)[1]);
						LabelInput(I, {
							label: "Line Space",
							type: "number",
							get value() {
								return F().lineSpace;
							},
							get disabled() {
								return get(C);
							},
							onChange: L
						});
					}
					append(C, E);
				},
				$$slots: { default: !0 }
			});
			var W = sibling(U, 2);
			StateInput(W, {
				get disabled() {
					return get(O)[2];
				},
				set disabled(C) {
					get(O)[2] = C;
				},
				children: (C, T) => {
					{
						let T = /* @__PURE__ */ user_derived(() => !get(O)[2]);
						LabelInput(C, {
							label: "Text Align",
							type: "option",
							get options() {
								return E;
							},
							get value() {
								return F().textAlign;
							},
							get disabled() {
								return get(T);
							},
							onChange: L
						});
					}
				},
				$$slots: { default: !0 }
			});
			var G = sibling(W, 2);
			StateInput(G, {
				get disabled() {
					return get(O)[3];
				},
				set disabled(C) {
					get(O)[3] = C;
				},
				children: (C, T) => {
					{
						let T = /* @__PURE__ */ user_derived(() => !get(O)[3]);
						LabelInput(C, {
							label: "Text Decor",
							type: "option",
							get options() {
								return D;
							},
							get value() {
								return F().textDector;
							},
							get disabled() {
								return get(T);
							},
							onChange: L
						});
					}
				},
				$$slots: { default: !0 }
			}), StateInput(sibling(G, 2), {
				get disabled() {
					return get(O)[4];
				},
				set disabled(C) {
					get(O)[4] = C;
				},
				children: (C, T) => {
					{
						let T = /* @__PURE__ */ user_derived(() => !get(O)[4]);
						LabelInput(C, {
							label: "Text Font",
							type: "option",
							get options() {
								return get(I);
							},
							get value() {
								return F().textFont;
							},
							get disabled() {
								return get(T);
							},
							onChange: L
						});
					}
				},
				$$slots: { default: !0 }
			}), append(C, B);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return F();
		},
		set props(C) {
			F(C), flushSync();
		}
	});
}
create_custom_element(Text$1, { props: {} }, [], [], !0);
var root_2$5 = /* @__PURE__ */ from_html("<div class=\"w-[60px] h-[25px] overflow-hidden border-[1px] border-solid border-gray-500\"><!></div>"), root_1$5 = /* @__PURE__ */ from_html("<div class=\"right-tab\"><!> <!> <!></div>");
function Arc(C, T) {
	push(T, !0);
	let E = /* @__PURE__ */ state(proxy([!1, !1])), D = prop(T, "props", 7), O = /* @__PURE__ */ user_derived(() => Asserts.data.filter((C) => C.type === "image").map((C) => ({
		name: C.name,
		value: C.name
	})));
	function F(C, T) {
		T && (T = toCamelCase(T), D()[T] = C);
	}
	function I(C) {
		let T = C.hex;
		T && (T.length === 7 && (D().arcColor = T), T.length === 9 && (D().arcColor = T.substring(0, 7), D().opa = parseInt(T.substring(7, 9), 16)));
	}
	return WgtAccordionItem(C, {
		label: "Arc",
		children: (C, T) => {
			var L = root_1$5(), z = child(L);
			StateInput(z, {
				get disabled() {
					return get(E)[0];
				},
				set disabled(C) {
					get(E)[0] = C;
				},
				children: (C, T) => {
					var O = root_2$5(), F = child(O);
					{
						let C = /* @__PURE__ */ user_derived(() => hexWithAlpha(D().arcColor, D().opa)), T = /* @__PURE__ */ user_derived(() => !get(E)[0]);
						MCXAColorPicker(F, {
							get color() {
								return get(C);
							},
							get disabled() {
								return get(T);
							},
							onChange: I
						});
					}
					reset(O), append(C, O);
				},
				$$slots: { default: !0 }
			});
			var B = sibling(z, 2);
			StateInput(B, {
				get disabled() {
					return get(E)[1];
				},
				set disabled(C) {
					get(E)[1] = C;
				},
				children: (C, T) => {
					{
						let T = /* @__PURE__ */ user_derived(() => !get(E)[1]);
						LabelInput(C, {
							label: "Arc Image",
							type: "option",
							get options() {
								return get(O);
							},
							get value() {
								return D().arcImage;
							},
							get disabled() {
								return get(T);
							},
							onChange: F
						});
					}
				},
				$$slots: { default: !0 }
			}), PropertyInput(sibling(B, 2), {
				label: "Arc Rounded",
				type: "checkbox",
				get value() {
					return D().arcRounded;
				},
				onChange: (C) => {
					D().arcRounded = C;
				}
			}), reset(L), append(C, L);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return D();
		},
		set props(C) {
			D(C), flushSync();
		}
	});
}
create_custom_element(Arc, { props: {} }, [], [], !0);
var root_2$4 = /* @__PURE__ */ from_html("<!> <!>", 1), root_3$2 = /* @__PURE__ */ from_html("<!> <!>", 1), root_5 = /* @__PURE__ */ from_html("<!> <!>", 1), root_6 = /* @__PURE__ */ from_html("<!> <!>", 1), root_1$4 = /* @__PURE__ */ from_html("<!> <!> <!> <!> <!>", 1);
function Transform(C, T) {
	push(T, !0);
	let E = prop(T, "props", 7), D = /* @__PURE__ */ state(proxy([
		!1,
		!1,
		!1,
		!1,
		!1
	]));
	function O(C, T) {
		T && (T = toCamelCase(T), E()[T] = C);
	}
	return WgtAccordionItem(C, {
		label: "Transform",
		children: (C, T) => {
			var F = root_1$4(), I = first_child(F);
			StateInput(I, {
				get disabled() {
					return get(D)[0];
				},
				set disabled(C) {
					get(D)[0] = C;
				},
				children: (C, T) => {
					var F = root_2$4(), I = first_child(F);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(D)[0]);
						LabelInput(I, {
							label: "Min Width",
							type: "number",
							get value() {
								return E().minWidth;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					var L = sibling(I, 2);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(D)[0]);
						LabelInput(L, {
							label: "Max Width",
							type: "number",
							get value() {
								return E().maxWidth;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					append(C, F);
				},
				$$slots: { default: !0 }
			});
			var L = sibling(I, 2);
			StateInput(L, {
				get disabled() {
					return get(D)[1];
				},
				set disabled(C) {
					get(D)[1] = C;
				},
				children: (C, T) => {
					var F = root_3$2(), I = first_child(F);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(D)[1]);
						LabelInput(I, {
							label: "Min Height",
							type: "number",
							get value() {
								return E().minHeight;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					var L = sibling(I, 2);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(D)[1]);
						LabelInput(L, {
							label: "Max Height",
							type: "number",
							get value() {
								return E().maxHeight;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					append(C, F);
				},
				$$slots: { default: !0 }
			});
			var z = sibling(L, 2);
			StateInput(z, {
				get disabled() {
					return get(D)[2];
				},
				set disabled(C) {
					get(D)[2] = C;
				},
				children: (C, T) => {
					{
						let T = /* @__PURE__ */ user_derived(() => !get(D)[2]);
						LabelInput(C, {
							label: "Transform Rotation",
							type: "number",
							get value() {
								return E().rotation;
							},
							get disabled() {
								return get(T);
							},
							onChange: O
						});
					}
				},
				$$slots: { default: !0 }
			});
			var B = sibling(z, 2);
			StateInput(B, {
				get disabled() {
					return get(D)[3];
				},
				set disabled(C) {
					get(D)[3] = C;
				},
				children: (C, T) => {
					var F = root_5(), I = first_child(F);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(D)[3]);
						LabelInput(I, {
							label: "Scale X",
							type: "number",
							get value() {
								return E().scaleX;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					var L = sibling(I, 2);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(D)[3]);
						LabelInput(L, {
							label: "Scale Y",
							type: "number",
							get value() {
								return E().scaleY;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					append(C, F);
				},
				$$slots: { default: !0 }
			}), StateInput(sibling(B, 2), {
				get disabled() {
					return get(D)[4];
				},
				set disabled(C) {
					get(D)[4] = C;
				},
				children: (C, T) => {
					var F = root_6(), I = first_child(F);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(D)[4]);
						LabelInput(I, {
							label: "Translate X",
							type: "number",
							get value() {
								return E().translateX;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					var L = sibling(I, 2);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(D)[4]);
						LabelInput(L, {
							label: "Translate Y",
							type: "number",
							get value() {
								return E().translateY;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					append(C, F);
				},
				$$slots: { default: !0 }
			}), append(C, F);
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return E();
		},
		set props(C) {
			E(C), flushSync();
		}
	});
}
create_custom_element(Transform, { props: {} }, [], [], !0);
var root_2$3 = /* @__PURE__ */ from_html("<span>Image reColor</span>"), root_1$3 = /* @__PURE__ */ from_html("<div class=\"right-tab\"><div class=\"flex\"><!> <!></div></div>");
function Image(C, T) {
	push(T, !0);
	let E = /* @__PURE__ */ state(proxy([!1]));
	WgtAccordionItem(C, {
		label: "Image",
		children: (C, T) => {
			var D = root_1$3(), O = child(D), F = child(O);
			Checkbox(F, {
				class: "flex-none mt-2.5 mx-1",
				get checked() {
					return get(E)[0];
				},
				set checked(C) {
					get(E)[0] = C;
				}
			}), Label(sibling(F, 2), {
				class: "flex-auto w-16 m-1",
				children: (C, T) => {
					append(C, root_2$3());
				},
				$$slots: { default: !0 }
			}), reset(O), reset(D), append(C, D);
		},
		$$slots: { default: !0 }
	}), pop();
}
create_custom_element(Image, {}, [], [], !0);
var root_2$2 = /* @__PURE__ */ from_html("<span>Line Color</span>"), root_1$2 = /* @__PURE__ */ from_html("<div class=\"flex\"><!> <!></div> <!> <!>", 1);
function Line(C, T) {
	push(T, !0);
	let E = /* @__PURE__ */ state(proxy([
		!1,
		!1,
		!1
	]));
	function D(C, T) {
		T && (T = toCamelCase(T));
	}
	WgtAccordionItem(C, {
		label: "Line",
		children: (C, T) => {
			var O = root_1$2(), F = first_child(O), I = child(F);
			Checkbox(I, {
				class: "flex-none mt-2.5 mx-1",
				get checked() {
					return get(E)[0];
				},
				set checked(C) {
					get(E)[0] = C;
				}
			}), Label(sibling(I, 2), {
				class: "flex-auto w-16 m-1",
				children: (C, T) => {
					append(C, root_2$2());
				},
				$$slots: { default: !0 }
			}), reset(F);
			var L = sibling(F, 2);
			StateInput(L, {
				get disabled() {
					return get(E)[1];
				},
				set disabled(C) {
					get(E)[1] = C;
				},
				children: (C, T) => {
					{
						let T = /* @__PURE__ */ user_derived(() => !get(E)[1]);
						LabelInput(C, {
							label: "Line Width",
							type: "number",
							value: 5,
							get disabled() {
								return get(T);
							},
							onChange: D
						});
					}
				},
				$$slots: { default: !0 }
			}), PropertyInput(sibling(L, 2), {
				label: "Line Rounded",
				type: "checkbox",
				onChange: D,
				value: !1
			}), append(C, O);
		},
		$$slots: { default: !0 }
	}), pop();
}
create_custom_element(Line, {}, [], [], !0);
function Size(C, T) {
	push(T, !0);
	let E = /* @__PURE__ */ state(proxy([!1]));
	function D(C, T) {
		T && (T = toCamelCase(T));
	}
	WgtAccordionItem(C, {
		label: "Size",
		children: (C, T) => {
			StateInput(C, {
				get disabled() {
					return get(E)[0];
				},
				set disabled(C) {
					get(E)[0] = C;
				},
				children: (C, T) => {
					{
						let T = /* @__PURE__ */ user_derived(() => !get(E)[0]);
						LabelInput(C, {
							label: "Size",
							type: "number",
							value: 5,
							get disabled() {
								return get(T);
							},
							onChange: D
						});
					}
				},
				$$slots: { default: !0 }
			});
		},
		$$slots: { default: !0 }
	}), pop();
}
create_custom_element(Size, {}, [], [], !0);
function Animation(C, T) {
	push(T, !0);
	let E = /* @__PURE__ */ state(proxy([!1]));
	function D(C, T) {
		T && (T = toCamelCase(T));
	}
	WgtAccordionItem(C, {
		label: "Animation",
		children: (C, T) => {
			StateInput(C, {
				get disabled() {
					return get(E)[0];
				},
				set disabled(C) {
					get(E)[0] = C;
				},
				children: (C, T) => {
					{
						let T = /* @__PURE__ */ user_derived(() => !get(E)[0]);
						LabelInput(C, {
							label: "Animation Time",
							type: "number",
							value: 5,
							get disabled() {
								return get(T);
							},
							onChange: D
						});
					}
				},
				$$slots: { default: !0 }
			});
		},
		$$slots: { default: !0 }
	}), pop();
}
create_custom_element(Animation, {}, [], [], !0);
var root_2$1 = /* @__PURE__ */ from_html("<!> <!> <!> <!>", 1);
function Margin(C, T) {
	push(T, !0);
	let E = /* @__PURE__ */ state(proxy([!1])), D = prop(T, "props", 7);
	function O(C, T) {
		T && (T = T.slice(7).toLowerCase(), D()[T] = C);
	}
	return WgtAccordionItem(C, {
		label: "Margin",
		children: (C, T) => {
			StateInput(C, {
				get disabled() {
					return get(E)[0];
				},
				set disabled(C) {
					get(E)[0] = C;
				},
				children: (C, T) => {
					var F = root_2$1(), I = first_child(F);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(E)[0]);
						LabelInput(I, {
							label: "Margin Left",
							type: "number",
							get value() {
								return D().left;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					var L = sibling(I, 2);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(E)[0]);
						LabelInput(L, {
							label: "Margin Right",
							type: "number",
							get value() {
								return D().right;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					var z = sibling(L, 2);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(E)[0]);
						LabelInput(z, {
							label: "Margin Top",
							type: "number",
							get value() {
								return D().top;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					var B = sibling(z, 2);
					{
						let C = /* @__PURE__ */ user_derived(() => !get(E)[0]);
						LabelInput(B, {
							label: "Margin Bottom",
							type: "number",
							get value() {
								return D().bottom;
							},
							get disabled() {
								return get(C);
							},
							onChange: O
						});
					}
					append(C, F);
				},
				$$slots: { default: !0 }
			});
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return D();
		},
		set props(C) {
			D(C), flushSync();
		}
	});
}
create_custom_element(Margin, { props: {} }, [], [], !0);
var root_3$1 = /* @__PURE__ */ from_html("<!> <!>", 1);
function Index$1(C, T) {
	push(T, !0);
	let E = [];
	for (let C of StateOpts) E.push({
		value: C.value,
		name: C.label
	});
	let D = {
		Background,
		BackgroundImage,
		Border,
		Outline,
		Shadow,
		Blend,
		Paddings,
		Arc,
		Transform,
		Text: Text$1,
		Margin,
		Image,
		Line,
		Size,
		Animation
	}, O = prop(T, "props", 7), F = prop(T, "rest", 7);
	return Accordion(C, {
		class: "height-full width-full  p-px ",
		children: (C, T) => {
			AccordionItem(C, {
				activeClass: "bg-gray-800 text-white",
				inactiveClass: "bg-gray-800 text-white",
				class: "bg-gray-800",
				header: (C) => {
					next(), append(C, text("Styles Settings"));
				},
				children: (C, T) => {
					var I = root_3$1(), L = first_child(I);
					LabelInput(L, {
						label: "STATE",
						type: "option",
						get options() {
							return E;
						},
						get value() {
							return F().curStyleState;
						},
						onChange: (C) => {
							F().curStyleState = C, widgetProps.update++;
						}
					}), each(sibling(L, 2), 17, O, index, (C, T) => {
						var E = /* @__PURE__ */ user_derived(() => to_array(get(T), 2));
						let O = () => get(E)[0], F = () => get(E)[1];
						var I = comment(), L = first_child(I), z = (C) => {
							AccordionItem(C, {
								activeClass: "bg-gray-800 text-white",
								inactiveClass: "bg-gray-800 text-white",
								class: "bg-gray-800",
								header: (C) => {
									next();
									var T = text();
									template_effect(() => set_text(T, `STYLES(${O()})`)), append(C, T);
								},
								children: (C, T) => {
									var E = comment();
									each(first_child(E), 17, F, index, (C, T) => {
										var E = /* @__PURE__ */ user_derived(() => to_array(get(T), 2));
										let O = () => get(E)[0], F = () => get(E)[1], I = /* @__PURE__ */ user_derived(() => D[O()]);
										var L = comment();
										component(first_child(L), () => get(I), (C, T) => {
											T(C, { get props() {
												return F();
											} });
										}), append(C, L);
									}), append(C, E);
								},
								$$slots: {
									header: !0,
									default: !0
								}
							});
						};
						if_block(L, (C) => {
							F().length > 0 && C(z);
						}), append(C, I);
					}), append(C, I);
				},
				$$slots: {
					header: !0,
					default: !0
				}
			});
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return O();
		},
		set props(C) {
			O(C), flushSync();
		},
		get rest() {
			return F();
		},
		set rest(C) {
			F(C), flushSync();
		}
	});
}
create_custom_element(Index$1, {
	props: {},
	rest: {}
}, [], [], !0);
var root$5 = /* @__PURE__ */ from_html("<!> <!> <!>", 1);
function SetProperty(C, T) {
	push(T, !0);
	let E = [
		{
			value: 0,
			name: "width"
		},
		{
			value: 1,
			name: "height"
		},
		{
			value: 2,
			name: "x"
		},
		{
			value: 3,
			name: "y"
		},
		{
			value: 4,
			name: "value"
		}
	], D = prop(T, "action", 7), O = /* @__PURE__ */ user_derived(() => widgetTreeToArray(widgetStores.widgets).filter((C) => {
		let T = C.widgetType.toLowerCase();
		return T !== "screen" && T !== "tabview";
	}).map((C) => ({
		value: C.id,
		name: C.name
	})));
	var F = {
		get action() {
			return D();
		},
		set action(C) {
			D(C), flushSync();
		}
	}, I = root$5(), L = first_child(I);
	LabelInput(L, {
		label: "Target",
		get value() {
			return D().targetId;
		},
		type: "option",
		get options() {
			return get(O);
		},
		onChange: (C) => {
			D().targetId = C;
		}
	});
	var z = sibling(L, 2);
	return LabelInput(z, {
		label: "Property",
		get value() {
			return D().type;
		},
		type: "option",
		get options() {
			return E;
		},
		onChange: (C) => {
			D().type = C;
		}
	}), LabelInput(sibling(z, 2), {
		label: "Value",
		get value() {
			return D().value;
		},
		type: "number",
		onChange: (C) => {
			D().value = C;
		}
	}), append(C, I), pop(F);
}
create_custom_element(SetProperty, { action: {} }, [], [], !0);
var root_2 = /* @__PURE__ */ from_html("<div class=\"mr-2\"><!> <!></div> <div class=\"flex\"><!></div>", 1);
function CallFun(C, T) {
	push(T, !0);
	let E = prop(T, "action", 7);
	return AccordionItem(C, {
		activeClass: "bg-gray-800 text-white",
		inactiveClass: "bg-gray-800 text-white",
		class: "bg-gray-800",
		header: (C) => {
			next(), append(C, text("Action(CALL FUNCTION)"));
		},
		children: (C, T) => {
			var E = root_2(), D = first_child(E), O = child(D);
			Label(O, {
				class: "flex-auto w-18 mt-1 px-1",
				children: (C, T) => {
					next(), append(C, text("Function name"));
				},
				$$slots: { default: !0 }
			}), Input(sibling(O, 2), {
				type: "text",
				required: !0,
				size: "sm",
				class: "px-1 ml-1"
			}), reset(D);
			var F = sibling(D, 2);
			Checkbox(child(F), {
				class: "flex-none m-1 mt-3",
				children: (C, T) => {
					next(), append(C, text("Do not export function"));
				},
				$$slots: { default: !0 }
			}), reset(F), append(C, E);
		},
		$$slots: {
			header: !0,
			default: !0
		}
	}), pop({
		get action() {
			return E();
		},
		set action(C) {
			E(C), flushSync();
		}
	});
}
create_custom_element(CallFun, { action: {} }, [], [], !0);
var root$4 = /* @__PURE__ */ from_html("<!> <!>", 1);
function ChangeScreen(C, T) {
	push(T, !0);
	let E = prop(T, "action", 7), D = prop(T, "screens", 7);
	var O = {
		get action() {
			return E();
		},
		set action(C) {
			E(C), flushSync();
		},
		get screens() {
			return D();
		},
		set screens(C) {
			D(C), flushSync();
		}
	}, F = root$4(), I = first_child(F);
	return LabelInput(I, {
		label: "Screen Name",
		type: "option",
		get options() {
			return D();
		},
		get value() {
			return E().value;
		},
		onChange: (C) => {
			E().value = C;
		}
	}), LabelInput(sibling(I, 2), {
		label: "Screen Name",
		type: "checkbox",
		get value() {
			return E().isDelete;
		},
		set value(C) {
			E().isDelete = C;
		}
	}), append(C, F), pop(O);
}
create_custom_element(ChangeScreen, {
	action: {},
	screens: {}
}, [], [], !0);
const actionList = [
	{
		value: 0,
		name: "SET PROPERTY"
	},
	{
		value: 1,
		name: "CALL FUNCTION"
	},
	{
		value: 2,
		name: "CHANGE VARIABLE"
	},
	{
		value: 3,
		name: "CHANGE SCREEN"
	}
], targetTypeList = [{
	value: 0,
	name: "Basic"
}];
var root_1$1 = /* @__PURE__ */ from_html("<span>Variable</span> <!>", 1), root$3 = /* @__PURE__ */ from_html("<!> <!> <!>", 1);
function ChangeVariable(C, T) {
	var E;
	push(T, !0);
	let D = [{
		value: "set",
		name: "Set"
	}, {
		value: "modify",
		name: "Modify"
	}], O = prop(T, "action", 7), F = /* @__PURE__ */ state("set"), I = /* @__PURE__ */ state(proxy((E = O().variable) == null ? "" : E)), L = /* @__PURE__ */ user_derived(() => getValueType(get(I), api));
	function z(C) {
		set(I, C.str, !0), O().variable = C.str;
	}
	var B = {
		get action() {
			return O();
		},
		set action(C) {
			O(C), flushSync();
		}
	}, V = root$3(), U = first_child(V);
	Label(U, {
		class: "flex-auto w-18 my-2 text-white",
		children: (C, T) => {
			var E = root_1$1();
			Cascader(sibling(first_child(E), 2), {
				onChange: z,
				get value() {
					return get(I);
				},
				checkToClosePopup: !0,
				get api() {
					return api;
				}
			}), append(C, E);
		},
		$$slots: { default: !0 }
	});
	var W = sibling(U, 2);
	LabelInput(W, {
		type: "option",
		label: "Operator",
		get options() {
			return D;
		},
		get value() {
			return get(F);
		},
		onChange: (C) => {
			let T = C;
			O().varOperator = T, set(F, T, !0);
		}
	});
	var G = sibling(W, 2);
	{
		let C = /* @__PURE__ */ user_derived(() => get(F) === "set" ? "Value" : "Step");
		LabelInput(G, {
			get label() {
				return get(C);
			},
			get type() {
				return get(L);
			},
			get value() {
				return O().value;
			},
			onChange: (C) => {
				O().value = C;
			}
		});
	}
	return append(C, V), pop(B);
}
create_custom_element(ChangeVariable, { action: {} }, [], [], !0);
var root_1 = /* @__PURE__ */ from_html("<span>Action</span> <!>", 1), root_3 = /* @__PURE__ */ from_html("<span>Type</span> <!>", 1), root$2 = /* @__PURE__ */ from_html("<div class=\"flex items-end gap-2\"><!> <!> <!></div>");
function ActionSelect(C, T) {
	push(T, !0);
	let E = prop(T, "addAction", 7), D = prop(T, "idx", 7), O = /* @__PURE__ */ state(0), F = /* @__PURE__ */ state(0);
	var I = {
		get addAction() {
			return E();
		},
		set addAction(C) {
			E(C), flushSync();
		},
		get idx() {
			return D();
		},
		set idx(C) {
			D(C), flushSync();
		}
	}, L = root$2(), z = child(L);
	Label(z, {
		children: (C, T) => {
			var E = root_1();
			Select(sibling(first_child(E), 2), {
				get items() {
					return actionList;
				},
				placeholder: "",
				size: "sm",
				get value() {
					return get(O);
				},
				set value(C) {
					set(O, C, !0);
				}
			}), append(C, E);
		},
		$$slots: { default: !0 }
	});
	var B = sibling(z, 2), V = (C) => {
		Label(C, {
			children: (C, T) => {
				var E = root_3();
				Select(sibling(first_child(E), 2), {
					get items() {
						return targetTypeList;
					},
					value: get(F),
					placeholder: "",
					size: "sm"
				}), append(C, E);
			},
			$$slots: { default: !0 }
		});
	};
	return if_block(B, (C) => {
		get(O) === 0 && C(V);
	}), Button(sibling(B, 2), {
		class: "bg-sky-500/100 h-8",
		onclick: () => E()(D(), get(O), get(F)),
		children: (C, T) => {
			next(), append(C, text("add"));
		},
		$$slots: { default: !0 }
	}), reset(L), append(C, L), pop(I);
}
create_custom_element(ActionSelect, {
	addAction: {},
	idx: {}
}, [], [], !0);
var root_4 = /* @__PURE__ */ from_html("<div class=\"flex items-center \"><!> <!></div>"), root_11 = /* @__PURE__ */ from_html("<div class=\"w-full flex items-center justify-between\"><span> </span> <!></div>"), root_10 = /* @__PURE__ */ from_html("<!> <div class=\"items-center relative\"></div>", 1), root_7 = /* @__PURE__ */ from_html("<div class=\"flex items-center gap-2\"><!> <!></div> <!> <!>", 1), root$1 = /* @__PURE__ */ from_html("<!> <div class=\"text-center py-6 px-3\"><!></div>", 1);
function Event$1(C, E) {
	push(E, !0);
	let D = prop(E, "events", 7);
	proxy([]);
	let O = LvInputEventCodeOpts.map((C) => ({
		value: C.value,
		name: C.label
	})), F = {
		0: SetProperty,
		1: CallFun,
		2: ChangeVariable,
		3: ChangeScreen
	}, I = 1, L = /* @__PURE__ */ state(0);
	function z() {
		if (widgetProps.curlvglShape == null) return;
		let C = {
			name: "Event " + I++,
			trigger: 0,
			actions: []
		};
		D().push(C);
		let E = _objectSpread2(_objectSpread2({}, C), {}, {
			actionName: 0,
			actionType: 0
		});
		widgetProps.curlvglShape.addEvent(E);
	}
	function B(C, T, E) {
		if (C < 0 || C >= D().length || widgetProps.curlvglShape == null) return;
		let O = {
			idx: C,
			actionData: {
				actionName: T,
				targetId: "",
				value: 0
			}
		};
		if (widgetProps.curlvglShape) {
			let T = widgetProps.curlvglShape.events;
			T[C].addAction(O.actionData, widgetProps.curlvglShape);
			let E = T[C].actions[T[C].actions.length - 1];
			D()[C].actions.push(E.pickAttributes());
		}
	}
	function V(C) {
		C < 0 || C >= D().length || (D().splice(C, 1), widgetProps.curlvglShape && widgetProps.curlvglShape.events.splice(C, 1));
	}
	function U(C, T) {
		D()[C].actions.splice(T, 1), widgetProps.curlvglShape && widgetProps.curlvglShape.events[C].actions.splice(T, 1);
	}
	var W = {
		get events() {
			return D();
		},
		set events(C) {
			D(C), flushSync();
		}
	}, G = root$1(), K = first_child(G);
	Accordion(K, {
		class: "height-full width-full  p-px ",
		children: (C, T) => {
			var E = comment();
			key(first_child(E), () => get(L), (C) => {
				var T = comment();
				each(first_child(T), 17, D, index, (C, T, E) => {
					AccordionItem(C, {
						activeClass: "bg-gray-800 text-white",
						inactiveClass: "bg-gray-800 text-white",
						class: "bg-gray-800 h-8",
						open: !0,
						header: (C) => {
							var T = root_4(), D = child(T);
							Label(D, {
								class: "text-white",
								children: (C, T) => {
									next();
									var D = text();
									D.nodeValue = `Event ${E + 1}`, append(C, D);
								},
								$$slots: { default: !0 }
							}), Button(sibling(D, 2), {
								onclick: (C) => V(E),
								children: (C, T) => {
									CloseOutline(C, {});
								},
								$$slots: { default: !0 }
							}), reset(T), append(C, T);
						},
						children: (C, I) => {
							var L = root_7(), z = first_child(L), V = child(z);
							key(V, () => widgetProps.update, (C) => {
								LabelInput(C, {
									label: "Event Name",
									get value() {
										return get(T).name;
									},
									type: "string",
									onChange: (C) => {
										D()[E] && (D()[E].name = C);
									}
								});
							}), LabelInput(sibling(V, 2), {
								label: "Trigger",
								get value() {
									return get(T).trigger;
								},
								type: "option",
								get options() {
									return O;
								},
								onChange: (C) => {
									get(T).trigger = C;
								}
							}), reset(z);
							var W = sibling(z, 2);
							Accordion(W, {
								class: "my-1 height-full width-full  p-px ",
								children: (C, D) => {
									var O = comment();
									each(first_child(O), 19, () => get(T).actions, (C) => C.id, (C, T, D) => {
										var O = root_10();
										AccordionItem(first_child(O), {
											activeClass: "bg-gray-800 text-white",
											inactiveClass: "bg-gray-800 text-white",
											class: "bg-gray-800 h-[40px]",
											open: !1,
											header: (C) => {
												var O = root_11(), F = child(O), I = child(F, !0);
												reset(F), Button(sibling(F, 2), {
													onclick: (C) => U(E, get(D)),
													children: (C, T) => {
														CloseOutline(C, {});
													},
													$$slots: { default: !0 }
												}), reset(O), template_effect(() => set_text(I, actionList[get(T).actionName].name)), append(C, O);
											},
											children: (C, E) => {
												let D = /* @__PURE__ */ user_derived(() => F[get(T).actionName]);
												var O = comment();
												component(first_child(O), () => get(D), (C, E) => {
													E(C, { get action() {
														return get(T);
													} });
												}), append(C, O);
											},
											$$slots: {
												header: !0,
												default: !0
											}
										}), next(2), append(C, O);
									}), append(C, O);
								},
								$$slots: { default: !0 }
							}), ActionSelect(sibling(W, 2), {
								idx: E,
								addAction: B
							}), append(C, L);
						},
						$$slots: {
							header: !0,
							default: !0
						}
					});
				}), append(C, T);
			}), append(C, E);
		},
		$$slots: { default: !0 }
	});
	var J = sibling(K, 2);
	return Button(child(J), {
		class: "rounded-full bg-sky-500/100  focus-within:outline-none",
		onclick: () => z(),
		children: (C, T) => {
			next(), append(C, text("Add Event"));
		},
		$$slots: { default: !0 }
	}), reset(J), append(C, G), pop(W);
}
create_custom_element(Event$1, { events: {} }, [], [], !0);
function Index$2(C, T) {
	push(T, !0);
	let E = prop(T, "props", 7);
	return Accordion(C, {
		class: "height-full width-full  p-px ",
		children: (C, T) => {
			AccordionItem(C, {
				activeClass: "bg-gray-800 text-white",
				inactiveClass: "bg-gray-800 text-white",
				class: "bg-gray-800",
				header: (C) => {
					next(), append(C, text("Events"));
				},
				children: (C, T) => {
					Event$1(C, { get events() {
						return E();
					} });
				},
				$$slots: {
					header: !0,
					default: !0
				}
			});
		},
		$$slots: { default: !0 }
	}), pop({
		get props() {
			return E();
		},
		set props(C) {
			E(C), flushSync();
		}
	});
}
create_custom_element(Index$2, { props: {} }, [], [], !0);
var root = /* @__PURE__ */ from_html("<div class=\"wrapper svelte-j40dwj\"></div>"), $$css = {
	hash: "svelte-j40dwj",
	code: ".wrapper.svelte-j40dwj {height:-moz-max-content;height:max-content;width:100%;\r\n    /* overflow-y: hidden; */}"
};
function PropWidget(C, T) {
	push(T, !0), append_styles(C, $$css);
	let E = {
		Widgets: Index,
		Styles: Index$1,
		Events: Index$2
	}, D = prop(T, "api", 7);
	setContext("mcxa_api", D());
	let O = [
		["Widgets", [
			["Id", {
				name: "arc1",
				type: "ARC"
			}],
			["Layout", {
				isValid: !0,
				align: 0,
				x: 135,
				y: 70,
				width: 150,
				height: 150,
				variables: {
					align: { type: "number" },
					x: { type: "number" },
					y: { type: "number" },
					width: { type: "number" },
					height: { type: "number" }
				}
			}],
			["Flags", {
				value: 0,
				type: "ARC"
			}],
			["States", {
				value: 0,
				type: "ARC"
			}],
			["ARC", {
				rotation: 0,
				bgAngleStart: 135,
				bgAngleEnd: 45,
				angleStart: 135,
				angleEnd: 135,
				minValue: 0,
				maxValue: 100,
				mode: 0,
				value: 50,
				variables: {
					rotation: { type: "number" },
					bgAngleStart: { type: "number" },
					bgAngleEnd: { type: "number" },
					angleStart: { type: "number" },
					angleEnd: { type: "number" },
					minValue: { type: "number" },
					maxValue: { type: "number" },
					mode: { type: "number" },
					value: { type: "number" }
				}
			}]
		]],
		[
			"Styles",
			[
				["Main", [
					["Background", {
						enableFlag: 0,
						bgRadius: 0,
						bgColor: "#000000",
						bgOpa: 0,
						bgGradientColor: "#ffffff",
						bgMainStop: 0,
						bgGradientStop: 255,
						gradientDir: 0,
						clipCorner: !1
					}],
					["BackgroundImage", {
						enableFlag: 0,
						bgImage: "",
						bgImageOpa: 255,
						bgImageRecolor: "#000000",
						bgImageRecolorAlpha: 0,
						bgImageRecolorTheme: "#000",
						bgImageTiled: !1
					}],
					["Border", {
						enableFlag: 0,
						borderColor: "#ffffff",
						borderColorOpa: 255,
						borderTheme: "#000",
						borderWidth: 0,
						borderSide: 15,
						post: !1
					}],
					["Outline", {
						enableFlag: 0,
						outlineColor: "#ffffff",
						outlineColorAlpha: 255,
						outlineTheme: "#000",
						outlineWidth: 0,
						outlinePad: 0
					}],
					["Shadow", {
						enableFlag: 0,
						shadowColor: "#ffffff",
						shadowColorAlpha: 255,
						shadowTheme: "#000",
						shadowWidth: 0,
						shadowSpread: 0,
						shadowOX: 0,
						shadowOY: 0
					}],
					["Blend", {
						enableFlag: 0,
						blendMode: 0
					}],
					["Paddings", {
						enableFlag: 0,
						padLeft: 0,
						padRight: 0,
						padTop: 0,
						padBottom: 0,
						padRow: 0,
						padColumn: 0
					}],
					["Margin", {
						left: 0,
						right: 0,
						top: 0,
						bottom: 0
					}],
					["Arc", {
						arcWidth: 12,
						arcColor: "#e0e0e0",
						opa: 255,
						themeColor: "",
						arcRounded: !0,
						arcImage: ""
					}],
					["Transform", {
						minWidth: 0,
						maxWidth: 536870911,
						minHeight: 0,
						maxHeight: 536870911,
						rotation: 0,
						scaleX: 256,
						scaleY: 256,
						translateX: 0,
						translateY: 0
					}]
				]],
				["INDICATOR", [
					["Background", {
						enableFlag: 0,
						bgRadius: 0,
						bgColor: "#000000",
						bgOpa: 0,
						bgGradientColor: "#ffffff",
						bgMainStop: 0,
						bgGradientStop: 255,
						gradientDir: 0,
						clipCorner: !1
					}],
					["BackgroundImage", {
						enableFlag: 0,
						bgImage: "",
						bgImageOpa: 255,
						bgImageRecolor: "#000000",
						bgImageRecolorAlpha: 0,
						bgImageRecolorTheme: "#000",
						bgImageTiled: !1
					}],
					["Border", {
						enableFlag: 0,
						borderColor: "#ffffff",
						borderColorOpa: 255,
						borderTheme: "#000",
						borderWidth: 0,
						borderSide: 15,
						post: !1
					}],
					["Outline", {
						enableFlag: 0,
						outlineColor: "#ffffff",
						outlineColorAlpha: 255,
						outlineTheme: "#000",
						outlineWidth: 0,
						outlinePad: 0
					}],
					["Shadow", {
						enableFlag: 0,
						shadowColor: "#ffffff",
						shadowColorAlpha: 255,
						shadowTheme: "#000",
						shadowWidth: 0,
						shadowSpread: 0,
						shadowOX: 0,
						shadowOY: 0
					}],
					["Blend", {
						enableFlag: 0,
						blendMode: 0
					}],
					["Paddings", {
						enableFlag: 0,
						padLeft: 0,
						padRight: 0,
						padTop: 0,
						padBottom: 0,
						padRow: 0,
						padColumn: 0
					}],
					["Margin", {
						left: 0,
						right: 0,
						top: 0,
						bottom: 0
					}],
					["Arc", {
						arcWidth: 12,
						arcColor: "#2196f3",
						opa: 255,
						themeColor: "",
						arcRounded: !0,
						arcImage: ""
					}]
				]],
				["KNOB", [
					["Background", {
						enableFlag: 0,
						bgRadius: 32767,
						bgColor: "#2196f3",
						bgOpa: 255,
						bgGradientColor: "#ffffff",
						bgMainStop: 0,
						bgGradientStop: 255,
						gradientDir: 0,
						clipCorner: !1
					}],
					["BackgroundImage", {
						enableFlag: 0,
						bgImage: "",
						bgImageOpa: 255,
						bgImageRecolor: "#000000",
						bgImageRecolorAlpha: 0,
						bgImageRecolorTheme: "#000",
						bgImageTiled: !1
					}],
					["Border", {
						enableFlag: 0,
						borderColor: "#ffffff",
						borderColorOpa: 255,
						borderTheme: "#000",
						borderWidth: 0,
						borderSide: 15,
						post: !1
					}],
					["Outline", {
						enableFlag: 0,
						outlineColor: "#ffffff",
						outlineColorAlpha: 255,
						outlineTheme: "#000",
						outlineWidth: 0,
						outlinePad: 0
					}],
					["Shadow", {
						enableFlag: 0,
						shadowColor: "#ffffff",
						shadowColorAlpha: 255,
						shadowTheme: "#000",
						shadowWidth: 0,
						shadowSpread: 0,
						shadowOX: 0,
						shadowOY: 0
					}],
					["Blend", {
						enableFlag: 0,
						blendMode: 0
					}],
					["Paddings", {
						enableFlag: 0,
						padLeft: 5,
						padRight: 5,
						padTop: 5,
						padBottom: 5,
						padRow: 0,
						padColumn: 0
					}],
					["Margin", {
						left: 0,
						right: 0,
						top: 0,
						bottom: 0
					}]
				]]
			],
			{ curStyleState: 0 }
		],
		["Events", []]
	], F = /* @__PURE__ */ user_derived(() => deepWatch(O, (C) => {
		console.log("widgetProps.props changed:", C.path, C.newValue), C.path.split(".").length;
	}, [
		"x",
		"y",
		"width",
		"height"
	]));
	var I = {
		get api() {
			return D();
		},
		set api(C) {
			D(C), flushSync();
		}
	}, L = root();
	return each(L, 21, () => get(F), index, (C, T) => {
		var D = comment(), O = first_child(D), F = (C) => {
			let D = /* @__PURE__ */ user_derived(() => E[get(T)[0]]);
			var O = comment(), F = first_child(O);
			{
				let C = /* @__PURE__ */ user_derived(() => {
					var C;
					return (C = get(T)[2]) == null ? {} : C;
				});
				component(F, () => get(D), (E, D) => {
					D(E, {
						get props() {
							return get(T)[1];
						},
						get rest() {
							return get(C);
						}
					});
				});
			}
			append(C, O);
		};
		if_block(O, (C) => {
			get(T).length >= 0 && C(F);
		}), append(C, D);
	}), reset(L), append(C, L), pop(I);
}
customElements.define("prop-widget", create_custom_element(PropWidget, { api: {} }, [], [], !0));
