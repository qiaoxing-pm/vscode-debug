(function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const s of i) if (s.type === "childList") for (const f of s.addedNodes) f.tagName === "LINK" && f.rel === "modulepreload" && r(f) }).observe(document, { childList: !0, subtree: !0 }); function n(i) { const s = {}; return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function r(i) { if (i.ep) return; i.ep = !0; const s = n(i); fetch(i.href, s) } })(); const Ze = !1; var At = Array.isArray, Ot = Array.prototype.indexOf, Nt = Array.from, Rt = Object.defineProperty, oe = Object.getOwnPropertyDescriptor, Pt = Object.prototype, Ft = Array.prototype, Ct = Object.getPrototypeOf, Ve = Object.isExtensible; function Dt(e) { for (var t = 0; t < e.length; t++)e[t]() } function Je() { var e, t, n = new Promise((r, i) => { e = r, t = i }); return { promise: n, resolve: e, reject: t } } const m = 2, Ce = 4, De = 8, q = 16, Q = 32, X = 64, Te = 128, b = 1024, S = 2048, U = 4096, K = 8192, $ = 16384, Qe = 32768, we = 65536, Be = 1 << 17, Xe = 1 << 18, fe = 1 << 19, It = 1 << 20, P = 256, me = 512, ye = 32768, Ne = 1 << 21, Ie = 1 << 22, W = 1 << 23, Ae = Symbol("$state"), te = new class extends Error { name = "StaleReactionError"; message = "The reaction that called `getAbortSignal()` was re-run or destroyed" }; function Lt() { throw new Error("https://svelte.dev/e/async_derived_orphan") } function Mt() { throw new Error("https://svelte.dev/e/effect_update_depth_exceeded") } function jt() { throw new Error("https://svelte.dev/e/state_descriptors_fixed") } function qt() { throw new Error("https://svelte.dev/e/state_prototype_fixed") } function Ut() { throw new Error("https://svelte.dev/e/state_unsafe_mutation") } function Vt() { throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror") } const Bt = 2, g = Symbol(); function Yt() { console.warn("https://svelte.dev/e/svelte_boundary_reset_noop") } function et(e) { return e === this.v } let Kt = !1, F = null; function ie(e) { F = e } function tt(e, t = !1, n) { F = { p: F, i: !1, c: null, e: null, s: e, x: null, l: null } } function nt(e) { var t = F, n = t.e; if (n !== null) { t.e = null; for (var r of n) cn(r) } return t.i = !0, F = t.p, {} } function rt() { return !0 } let ne = []; function $t() { var e = ne; ne = [], Dt(e) } function Le(e) { if (ne.length === 0) { var t = ne; queueMicrotask(() => { t === ne && $t() }) } ne.push(e) } function it(e) { var t = p; if (t === null) return v.f |= W, e; if ((t.f & Qe) === 0) { if ((t.f & Te) === 0) throw e; t.b.error(e) } else se(e, t) } function se(e, t) { for (; t !== null;) { if ((t.f & Te) !== 0) try { t.b.error(e); return } catch (n) { e = n } t = t.parent } throw e } const de = new Set; let w = null, N = null, B = [], Me = null, Re = !1; class C { committed = !1; current = new Map; previous = new Map; #n = new Set; #r = new Set; #a = 0; #s = 0; #u = null; #l = []; #i = []; skipped_effects = new Set; is_fork = !1; process(t) { B = [], this.apply(); var n = { parent: null, effect: null, effects: [], render_effects: [], block_effects: [] }; for (const r of t) this.#e(r, n); this.is_fork || this.#f(), this.#s > 0 || this.is_fork ? (this.#t(n.effects), this.#t(n.render_effects), this.#t(n.block_effects)) : (w = null, Ye(n.render_effects), Ye(n.effects), this.#u?.resolve()), N = null } #e(t, n) { t.f ^= b; for (var r = t.first; r !== null;) { var i = r.f, s = (i & (Q | X)) !== 0, f = s && (i & b) !== 0, o = f || (i & K) !== 0 || this.skipped_effects.has(r); if ((r.f & Te) !== 0 && r.b?.is_pending() && (n = { parent: n, effect: r, effects: [], render_effects: [], block_effects: [] }), !o && r.fn !== null) { s ? r.f ^= b : (i & Ce) !== 0 ? n.effects.push(r) : ve(r) && ((r.f & q) !== 0 && n.block_effects.push(r), _e(r)); var l = r.first; if (l !== null) { r = l; continue } } var u = r.parent; for (r = r.next; r === null && u !== null;)u === n.effect && (this.#t(n.effects), this.#t(n.render_effects), this.#t(n.block_effects), n = n.parent), r = u.next, u = u.parent } } #t(t) { for (const n of t) ((n.f & S) !== 0 ? this.#l : this.#i).push(n), E(n, b) } capture(t, n) { this.previous.has(t) || this.previous.set(t, n), (t.f & W) === 0 && (this.current.set(t, t.v), N?.set(t, t.v)) } activate() { w = this, this.apply() } deactivate() { w = null, N = null } flush() { if (this.activate(), B.length > 0) { if (Wt(), w !== null && w !== this) return } else this.#a === 0 && this.process([]); this.deactivate() } discard() { for (const t of this.#r) t(this); this.#r.clear() } #f() { if (this.#s === 0) { for (const t of this.#n) t(); this.#n.clear() } this.#a === 0 && this.#o() } #o() { if (de.size > 1) { this.previous.clear(); var t = N, n = !0, r = { parent: null, effect: null, effects: [], render_effects: [], block_effects: [] }; for (const i of de) { if (i === this) { n = !1; continue } const s = []; for (const [o, l] of this.current) { if (i.current.has(o)) if (n && l !== i.current.get(o)) i.current.set(o, l); else continue; s.push(o) } if (s.length === 0) continue; const f = [...i.current.keys()].filter(o => !this.current.has(o)); if (f.length > 0) { const o = new Set, l = new Map; for (const u of s) st(u, f, o, l); if (B.length > 0) { w = i, i.apply(); for (const u of B) i.#e(u, r); B = [], i.deactivate() } } } w = null, N = t } this.committed = !0, de.delete(this) } increment(t) { this.#a += 1, t && (this.#s += 1) } decrement(t) { this.#a -= 1, t && (this.#s -= 1), this.revive() } revive() { for (const t of this.#l) E(t, S), le(t); for (const t of this.#i) E(t, U), le(t); this.#l = [], this.#i = [], this.flush() } oncommit(t) { this.#n.add(t) } ondiscard(t) { this.#r.add(t) } settled() { return (this.#u ??= Je()).promise } static ensure() { if (w === null) { const t = w = new C; de.add(w), C.enqueue(() => { w === t && t.flush() }) } return w } static enqueue(t) { Le(t) } apply() { } } function Wt() { var e = re; Re = !0; try { var t = 0; for ($e(!0); B.length > 0;) { var n = C.ensure(); if (t++ > 1e3) { var r, i; zt() } n.process(B), z.clear() } } finally { Re = !1, $e(e), Me = null } } function zt() { try { Mt() } catch (e) { se(e, Me) } } let M = null; function Ye(e) { var t = e.length; if (t !== 0) { for (var n = 0; n < t;) { var r = e[n++]; if ((r.f & ($ | K)) === 0 && ve(r) && (M = new Set, _e(r), r.deps === null && r.first === null && r.nodes_start === null && (r.teardown === null && r.ac === null ? mt(r) : r.fn = null), M?.size > 0)) { z.clear(); for (const i of M) { if ((i.f & ($ | K)) !== 0) continue; const s = [i]; let f = i.parent; for (; f !== null;)M.has(f) && (M.delete(f), s.push(f)), f = f.parent; for (let o = s.length - 1; o >= 0; o--) { const l = s[o]; (l.f & ($ | K)) === 0 && _e(l) } } M.clear() } } M = null } } function st(e, t, n, r) { if (!n.has(e) && (n.add(e), e.reactions !== null)) for (const i of e.reactions) { const s = i.f; (s & m) !== 0 ? st(i, t, n, r) : (s & (Ie | q)) !== 0 && (s & S) === 0 && lt(i, t, r) && (E(i, S), le(i)) } } function lt(e, t, n) { const r = n.get(e); if (r !== void 0) return r; if (e.deps !== null) for (const i of e.deps) { if (t.includes(i)) return !0; if ((i.f & m) !== 0 && lt(i, t, n)) return n.set(i, !0), !0 } return n.set(e, !1), !1 } function le(e) { for (var t = Me = e; t.parent !== null;) { t = t.parent; var n = t.f; if (Re && t === p && (n & q) !== 0 && (n & Xe) === 0) return; if ((n & (X | Q)) !== 0) { if ((n & b) === 0) return; t.f ^= b } } B.push(t) } function Ht(e) { let t = 0, n = Se(0), r; return () => { on() && (A(n), vn(() => (t === 0 && (r = Tn(() => e(() => ae(n)))), t += 1, () => { Le(() => { t -= 1, t === 0 && (r?.(), r = void 0, ae(n)) }) }))) } } var Gt = we | fe | Te; function Zt(e, t, n) { new Jt(e, t, n) } class Jt { parent; #n = !1; #r; #a = null; #s; #u; #l; #i = null; #e = null; #t = null; #f = null; #o = null; #h = 0; #c = 0; #v = !1; #_ = null; #m = Ht(() => (this.#_ = Se(this.#h), () => { this.#_ = null })); constructor(t, n, r) { this.#r = t, this.#s = n, this.#u = r, this.parent = p.b, this.#n = !!this.#s.pending, this.#l = pn(() => { p.b = this; { var i = this.#g(); try { this.#i = Z(() => r(i)) } catch (s) { this.error(s) } this.#c > 0 ? this.#p() : this.#n = !1 } return () => { this.#o?.remove() } }, Gt) } #y() { try { this.#i = Z(() => this.#u(this.#r)) } catch (t) { this.error(t) } this.#n = !1 } #b() { const t = this.#s.pending; t && (this.#e = Z(() => t(this.#r)), C.enqueue(() => { var n = this.#g(); this.#i = this.#d(() => (C.ensure(), Z(() => this.#u(n)))), this.#c > 0 ? this.#p() : (ge(this.#e, () => { this.#e = null }), this.#n = !1) })) } #g() { var t = this.#r; return this.#n && (this.#o = vt(), this.#r.before(this.#o), t = this.#o), t } is_pending() { return this.#n || !!this.parent && this.parent.is_pending() } has_pending_snippet() { return !!this.#s.pending } #d(t) { var n = p, r = v, i = F; I(this.#l), x(this.#l), ie(this.#l.ctx); try { return t() } catch (s) { return it(s), null } finally { I(n), x(r), ie(i) } } #p() { const t = this.#s.pending; this.#i !== null && (this.#f = document.createDocumentFragment(), this.#f.append(this.#o), yn(this.#i, this.#f)), this.#e === null && (this.#e = Z(() => t(this.#r))) } #w(t) { if (!this.has_pending_snippet()) { this.parent && this.parent.#w(t); return } this.#c += t, this.#c === 0 && (this.#n = !1, this.#e && ge(this.#e, () => { this.#e = null }), this.#f && (this.#r.before(this.#f), this.#f = null)) } update_pending_count(t) { this.#w(t), this.#h += t, this.#_ && Ee(this.#_, this.#h) } get_effect_pending() { return this.#m(), A(this.#_) } error(t) { var n = this.#s.onerror; let r = this.#s.failed; if (this.#v || !n && !r) throw t; this.#i && (D(this.#i), this.#i = null), this.#e && (D(this.#e), this.#e = null), this.#t && (D(this.#t), this.#t = null); var i = !1, s = !1; const f = () => { if (i) { Yt(); return } i = !0, s && Vt(), C.ensure(), this.#h = 0, this.#t !== null && ge(this.#t, () => { this.#t = null }), this.#n = this.has_pending_snippet(), this.#i = this.#d(() => (this.#v = !1, Z(() => this.#u(this.#r)))), this.#c > 0 ? this.#p() : this.#n = !1 }; var o = v; try { x(null), s = !0, n?.(t, f), s = !1 } catch (l) { se(l, this.#l && this.#l.parent) } finally { x(o) } r && Le(() => { this.#t = this.#d(() => { C.ensure(), this.#v = !0; try { return Z(() => { r(this.#r, () => t, () => f) }) } catch (l) { return se(l, this.#l.parent), null } finally { this.#v = !1 } }) }) } } function Qt(e, t, n, r) { const i = en; if (n.length === 0 && e.length === 0) { r(t.map(i)); return } var s = w, f = p, o = Xt(); function l() { Promise.all(n.map(u => tn(u))).then(u => { o(); try { r([...t.map(i), ...u]) } catch (a) { (f.f & $) === 0 && se(a, f) } s?.deactivate(), be() }).catch(u => { se(u, f) }) } e.length > 0 ? Promise.all(e).then(() => { o(); try { return l() } finally { s?.deactivate(), be() } }) : l() } function Xt() { var e = p, t = v, n = F, r = w; return function (s = !0) { I(e), x(t), ie(n), s && r?.activate() } } function be() { I(null), x(null), ie(null) } function en(e) { var t = m | S, n = v !== null && (v.f & m) !== 0 ? v : null; return p === null || n !== null && (n.f & P) !== 0 ? t |= P : p.f |= fe, { ctx: F, deps: null, effects: null, equals: et, f: t, fn: e, reactions: null, rv: 0, v: g, wv: 0, parent: n ?? p, ac: null } } function tn(e, t) { let n = p; n === null && Lt(); var r = n.b, i = void 0, s = Se(g), f = !v, o = new Map; return hn(() => { var l = Je(); i = l.promise; try { Promise.resolve(e()).then(l.resolve, l.reject).then(() => { u === w && u.committed && u.deactivate(), be() }) } catch (_) { l.reject(_), be() } var u = w; if (f) { var a = !r.is_pending(); r.update_pending_count(1), u.increment(a), o.get(u)?.reject(te), o.delete(u), o.set(u, l) } const h = (_, c = void 0) => { if (u.activate(), c) c !== te && (s.f |= W, Ee(s, c)); else { (s.f & W) !== 0 && (s.f ^= W), Ee(s, _); for (const [d, O] of o) { if (o.delete(d), d === u) break; O.reject(te) } } f && (r.update_pending_count(-1), u.decrement(a)) }; l.promise.then(h, _ => h(null, _ || "unknown")) }), an(() => { for (const l of o.values()) l.reject(te) }), new Promise(l => { function u(a) { function h() { a === i ? l(s) : u(i) } a.then(h, h) } u(i) }) } function ft(e) { var t = e.effects; if (t !== null) { e.effects = null; for (var n = 0; n < t.length; n += 1)D(t[n]) } } function nn(e) { for (var t = e.parent; t !== null;) { if ((t.f & m) === 0) return t; t = t.parent } return null } function je(e) { var t, n = p; I(nn(e)); try { e.f &= ~ye, ft(e), t = Tt(e) } finally { I(n) } return t } function ut(e) { var t = je(e); if (e.equals(t) || (e.v = t, e.wv = Et()), !he) if (N !== null) N.set(e, e.v); else { var n = (Y || (e.f & P) !== 0) && e.deps !== null ? U : b; E(e, n) } } let Pe = new Set; const z = new Map; let ot = !1; function Se(e, t) { var n = { f: 0, v: e, reactions: null, equals: et, rv: 0, wv: 0 }; return n } function L(e, t) { const n = Se(e); return bn(n), n } function V(e, t, n = !1) { v !== null && (!R || (v.f & Be) !== 0) && rt() && (v.f & (m | q | Ie | Be)) !== 0 && !j?.includes(e) && Ut(); let r = n ? ue(t) : t; return Ee(e, r) } function Ee(e, t) { if (!e.equals(t)) { var n = e.v; he ? z.set(e, t) : z.set(e, n), e.v = t; var r = C.ensure(); r.capture(e, n), (e.f & m) !== 0 && ((e.f & S) !== 0 && je(e), E(e, (e.f & P) === 0 ? b : U)), e.wv = Et(), at(e, S), p !== null && (p.f & b) !== 0 && (p.f & (Q | X)) === 0 && (k === null ? En([e]) : k.push(e)), !r.is_fork && Pe.size > 0 && !ot && rn() } return t } function rn() { ot = !1; const e = Array.from(Pe); for (const t of e) (t.f & b) !== 0 && E(t, U), ve(t) && _e(t); Pe.clear() } function sn(e, t = 1) { var n = A(e), r = t === 1 ? n++ : n--; return V(e, n), r } function ae(e) { V(e, e.v + 1) } function at(e, t) { var n = e.reactions; if (n !== null) for (var r = n.length, i = 0; i < r; i++) { var s = n[i], f = s.f, o = (f & S) === 0; o && E(s, t), (f & m) !== 0 ? (f & ye) === 0 && (s.f |= ye, at(s, U)) : o && ((f & q) !== 0 && M !== null && M.add(s), le(s)) } } function ue(e) { if (typeof e != "object" || e === null || Ae in e) return e; const t = Ct(e); if (t !== Pt && t !== Ft) return e; var n = new Map, r = At(e), i = L(0), s = J, f = o => { if (J === s) return o(); var l = v, u = J; x(null), ze(s); var a = o(); return x(l), ze(u), a }; return r && n.set("length", L(e.length)), new Proxy(e, { defineProperty(o, l, u) { (!("value" in u) || u.configurable === !1 || u.enumerable === !1 || u.writable === !1) && jt(); var a = n.get(l); return a === void 0 ? a = f(() => { var h = L(u.value); return n.set(l, h), h }) : V(a, u.value, !0), !0 }, deleteProperty(o, l) { var u = n.get(l); if (u === void 0) { if (l in o) { const a = f(() => L(g)); n.set(l, a), ae(i) } } else V(u, g), ae(i); return !0 }, get(o, l, u) { if (l === Ae) return e; var a = n.get(l), h = l in o; if (a === void 0 && (!h || oe(o, l)?.writable) && (a = f(() => { var c = ue(h ? o[l] : g), d = L(c); return d }), n.set(l, a)), a !== void 0) { var _ = A(a); return _ === g ? void 0 : _ } return Reflect.get(o, l, u) }, getOwnPropertyDescriptor(o, l) { var u = Reflect.getOwnPropertyDescriptor(o, l); if (u && "value" in u) { var a = n.get(l); a && (u.value = A(a)) } else if (u === void 0) { var h = n.get(l), _ = h?.v; if (h !== void 0 && _ !== g) return { enumerable: !0, configurable: !0, value: _, writable: !0 } } return u }, has(o, l) { if (l === Ae) return !0; var u = n.get(l), a = u !== void 0 && u.v !== g || Reflect.has(o, l); if (u !== void 0 || p !== null && (!a || oe(o, l)?.writable)) { u === void 0 && (u = f(() => { var _ = a ? ue(o[l]) : g, c = L(_); return c }), n.set(l, u)); var h = A(u); if (h === g) return !1 } return a }, set(o, l, u, a) { var h = n.get(l), _ = l in o; if (r && l === "length") for (var c = u; c < h.v; c += 1) { var d = n.get(c + ""); d !== void 0 ? V(d, g) : c in o && (d = f(() => L(g)), n.set(c + "", d)) } if (h === void 0) (!_ || oe(o, l)?.writable) && (h = f(() => L(void 0)), V(h, ue(u)), n.set(l, h)); else { _ = h.v !== g; var O = f(() => ue(u)); V(h, O) } var G = Reflect.getOwnPropertyDescriptor(o, l); if (G?.set && G.set.call(a, u), !_) { if (r && typeof l == "string") { var Ue = n.get("length"), ke = Number(l); Number.isInteger(ke) && ke >= Ue.v && V(Ue, ke + 1) } ae(i) } return !0 }, ownKeys(o) { A(i); var l = Reflect.ownKeys(o).filter(h => { var _ = n.get(h); return _ === void 0 || _.v !== g }); for (var [u, a] of n) a.v !== g && !(u in o) && l.push(u); return l }, setPrototypeOf() { qt() } }) } var Ke, ct, _t, ht; function ln() { if (Ke === void 0) { Ke = window, ct = /Firefox/.test(navigator.userAgent); var e = Element.prototype, t = Node.prototype, n = Text.prototype; _t = oe(t, "firstChild").get, ht = oe(t, "nextSibling").get, Ve(e) && (e.__click = void 0, e.__className = void 0, e.__attributes = null, e.__style = void 0, e.__e = void 0), Ve(n) && (n.__t = void 0) } } function vt(e = "") { return document.createTextNode(e) } function dt(e) { return _t.call(e) } function qe(e) { return ht.call(e) } function Oe(e, t) { return dt(e) } function fn(e, t = 1, n = !1) { let r = e; for (; t--;)r = qe(r); return r } function pt(e) { var t = v, n = p; x(null), I(null); try { return e() } finally { x(t), I(n) } } function un(e, t) { var n = t.last; n === null ? t.last = t.first = e : (n.next = e, e.prev = n, t.last = e) } function H(e, t, n, r = !0) { var i = p; i !== null && (i.f & K) !== 0 && (e |= K); var s = { ctx: F, deps: null, nodes_start: null, nodes_end: null, f: e | S, first: null, fn: t, last: null, next: null, parent: i, b: i && i.b, prev: null, teardown: null, transitions: null, wv: 0, ac: null }; if (n) try { _e(s), s.f |= Qe } catch (l) { throw D(s), l } else t !== null && le(s); if (r) { var f = s; if (n && f.deps === null && f.teardown === null && f.nodes_start === null && f.first === f.last && (f.f & fe) === 0 && (f = f.first, (e & q) !== 0 && (e & we) !== 0 && f !== null && (f.f |= we)), f !== null && (f.parent = i, i !== null && un(f, i), v !== null && (v.f & m) !== 0 && (e & X) === 0)) { var o = v; (o.effects ??= []).push(f) } } return s } function on() { return v !== null && !R } function an(e) { const t = H(De, null, !1); return E(t, b), t.teardown = e, t } function cn(e) { return H(Ce | It, e, !1) } function _n(e) { C.ensure(); const t = H(X | fe, e, !0); return (n = {}) => new Promise(r => { n.outro ? ge(t, () => { D(t), r(void 0) }) : (D(t), r(void 0)) }) } function hn(e) { return H(Ie | fe, e, !0) } function vn(e, t = 0) { return H(De | t, e, !0) } function dn(e, t = [], n = [], r = [], i = !1) { Qt(r, t, n, s => { H(i ? Ce : De, () => e(...s.map(A)), !0) }) } function pn(e, t = 0) { var n = H(q | t, e, !0); return n } function Z(e, t = !0) { return H(Q | fe, e, !0, t) } function gt(e) { var t = e.teardown; if (t !== null) { const n = he, r = v; We(!0), x(null); try { t.call(null) } finally { We(n), x(r) } } } function wt(e, t = !1) { var n = e.first; for (e.first = e.last = null; n !== null;) { const i = n.ac; i !== null && pt(() => { i.abort(te) }); var r = n.next; (n.f & X) !== 0 ? n.parent = null : D(n, t), n = r } } function gn(e) { for (var t = e.first; t !== null;) { var n = t.next; (t.f & Q) === 0 && D(t), t = n } } function D(e, t = !0) { var n = !1; (t || (e.f & Xe) !== 0) && e.nodes_start !== null && e.nodes_end !== null && (wn(e.nodes_start, e.nodes_end), n = !0), wt(e, t && !n), xe(e, 0), E(e, $); var r = e.transitions; if (r !== null) for (const s of r) s.stop(); gt(e); var i = e.parent; i !== null && i.first !== null && mt(e), e.next = e.prev = e.teardown = e.ctx = e.deps = e.fn = e.nodes_start = e.nodes_end = e.ac = null } function wn(e, t) { for (; e !== null;) { var n = e === t ? null : qe(e); e.remove(), e = n } } function mt(e) { var t = e.parent, n = e.prev, r = e.next; n !== null && (n.next = r), r !== null && (r.prev = n), t !== null && (t.first === e && (t.first = r), t.last === e && (t.last = n)) } function ge(e, t, n = !0) { var r = []; yt(e, r, !0), mn(r, () => { n && D(e), t && t() }) } function mn(e, t) { var n = e.length; if (n > 0) { var r = () => --n || t(); for (var i of e) i.out(r) } else t() } function yt(e, t, n) { if ((e.f & K) === 0) { if (e.f ^= K, e.transitions !== null) for (const f of e.transitions) (f.is_global || n) && t.push(f); for (var r = e.first; r !== null;) { var i = r.next, s = (r.f & we) !== 0 || (r.f & Q) !== 0 && (e.f & q) !== 0; yt(r, t, s ? n : !1), r = i } } } function yn(e, t) { for (var n = e.nodes_start, r = e.nodes_end; n !== null;) { var i = n === r ? null : qe(n); t.append(n), n = i } } let re = !1; function $e(e) { re = e } let he = !1; function We(e) { he = e } let v = null, R = !1; function x(e) { v = e } let p = null; function I(e) { p = e } let j = null; function bn(e) { v !== null && (j === null ? j = [e] : j.push(e)) } let y = null, T = 0, k = null; function En(e) { k = e } let bt = 1, ce = 0, J = ce; function ze(e) { J = e } let Y = !1; function Et() { return ++bt } function ve(e) { var t = e.f; if ((t & S) !== 0) return !0; if ((t & U) !== 0) { var n = e.deps, r = (t & P) !== 0; if (t & m && (e.f &= ~ye), n !== null) { var i, s, f = (t & me) !== 0, o = r && p !== null && !Y, l = n.length; if ((f || o) && (p === null || (p.f & $) === 0)) { var u = e, a = u.parent; for (i = 0; i < l; i++)s = n[i], (f || !s?.reactions?.includes(u)) && (s.reactions ??= []).push(u); f && (u.f ^= me), o && a !== null && (a.f & P) === 0 && (u.f ^= P) } for (i = 0; i < l; i++)if (s = n[i], ve(s) && ut(s), s.wv > e.wv) return !0 } (!r || p !== null && !Y) && E(e, b) } return !1 } function xt(e, t, n = !0) { var r = e.reactions; if (r !== null && !j?.includes(e)) for (var i = 0; i < r.length; i++) { var s = r[i]; (s.f & m) !== 0 ? xt(s, t, !1) : t === s && (n ? E(s, S) : (s.f & b) !== 0 && E(s, U), le(s)) } } function Tt(e) { var t = y, n = T, r = k, i = v, s = Y, f = j, o = F, l = R, u = J, a = e.f; y = null, T = 0, k = null, Y = (a & P) !== 0 && (R || !re || v === null), v = (a & (Q | X)) === 0 ? e : null, j = null, ie(e.ctx), R = !1, J = ++ce, e.ac !== null && (pt(() => { e.ac.abort(te) }), e.ac = null); try { e.f |= Ne; var h = e.fn, _ = h(), c = e.deps; if (y !== null) { var d; if (xe(e, T), c !== null && T > 0) for (c.length = T + y.length, d = 0; d < y.length; d++)c[T + d] = y[d]; else e.deps = c = y; if (!Y || (a & m) !== 0 && e.reactions !== null) for (d = T; d < c.length; d++)(c[d].reactions ??= []).push(e) } else c !== null && T < c.length && (xe(e, T), c.length = T); if (rt() && k !== null && !R && c !== null && (e.f & (m | U | S)) === 0) for (d = 0; d < k.length; d++)xt(k[d], e); return i !== null && i !== e && (ce++, k !== null && (r === null ? r = k : r.push(...k))), (e.f & W) !== 0 && (e.f ^= W), _ } catch (O) { return it(O) } finally { e.f ^= Ne, y = t, T = n, k = r, v = i, Y = s, j = f, ie(o), R = l, J = u } } function xn(e, t) { let n = t.reactions; if (n !== null) { var r = Ot.call(n, e); if (r !== -1) { var i = n.length - 1; i === 0 ? n = t.reactions = null : (n[r] = n[i], n.pop()) } } n === null && (t.f & m) !== 0 && (y === null || !y.includes(t)) && (E(t, U), (t.f & (P | me)) === 0 && (t.f ^= me), ft(t), xe(t, 0)) } function xe(e, t) { var n = e.deps; if (n !== null) for (var r = t; r < n.length; r++)xn(e, n[r]) } function _e(e) { var t = e.f; if ((t & $) === 0) { E(e, b); var n = p, r = re; p = e, re = !0; try { (t & q) !== 0 ? gn(e) : wt(e), gt(e); var i = Tt(e); e.teardown = typeof i == "function" ? i : null, e.wv = bt; var s; Ze && Kt && (e.f & S) !== 0 && e.deps } finally { re = r, p = n } } } function A(e) { var t = e.f, n = (t & m) !== 0; if (v !== null && !R) { var r = p !== null && (p.f & $) !== 0; if (!r && !j?.includes(e)) { var i = v.deps; if ((v.f & Ne) !== 0) e.rv < ce && (e.rv = ce, y === null && i !== null && i[T] === e ? T++ : y === null ? y = [e] : (!Y || !y.includes(e)) && y.push(e)); else { (v.deps ??= []).push(e); var s = e.reactions; s === null ? e.reactions = [v] : s.includes(v) || s.push(v) } } } else if (n && e.deps === null && e.effects === null) { var f = e, o = f.parent; o !== null && (o.f & P) === 0 && (f.f ^= P) } if (he) { if (z.has(e)) return z.get(e); if (n) { f = e; var l = f.v; return ((f.f & b) === 0 && f.reactions !== null || St(f)) && (l = je(f)), z.set(f, l), l } } else if (n) { if (f = e, N?.has(f)) return N.get(f); ve(f) && ut(f) } if (N?.has(e)) return N.get(e); if ((e.f & W) !== 0) throw e.v; return e.v } function St(e) { if (e.v === g) return !0; if (e.deps === null) return !1; for (const t of e.deps) if (z.has(t) || (t.f & m) !== 0 && St(t)) return !0; return !1 } function Tn(e) { var t = R; try { return R = !0, e() } finally { R = t } } const Sn = -7169; function E(e, t) { e.f = e.f & Sn | t } const kn = ["touchstart", "touchmove"]; function An(e) { return kn.includes(e) } const kt = new Set, Fe = new Set; function On(e) { for (var t = 0; t < e.length; t++)kt.add(e[t]); for (var n of Fe) n(e) } let He = null; function pe(e) { var t = this, n = t.ownerDocument, r = e.type, i = e.composedPath?.() || [], s = i[0] || e.target; He = e; var f = 0, o = He === e && e.__root; if (o) { var l = i.indexOf(o); if (l !== -1 && (t === document || t === window)) { e.__root = t; return } var u = i.indexOf(t); if (u === -1) return; l <= u && (f = l) } if (s = i[f] || e.target, s !== t) { Rt(e, "currentTarget", { configurable: !0, get() { return s || n } }); var a = v, h = p; x(null), I(null); try { for (var _, c = []; s !== null;) { var d = s.assignedSlot || s.parentNode || s.host || null; try { var O = s["__" + r]; O != null && (!s.disabled || e.target === s) && O.call(s, e) } catch (G) { _ ? c.push(G) : _ = G } if (e.cancelBubble || d === t || d === null) break; s = d } if (_) { for (let G of c) queueMicrotask(() => { throw G }); throw _ } } finally { e.__root = t, delete e.currentTarget, x(a), I(h) } } } function Nn(e) { var t = document.createElement("template"); return t.innerHTML = e.replaceAll("<!>", "<!---->"), t.content } function Rn(e, t) { var n = p; n.nodes_start === null && (n.nodes_start = e, n.nodes_end = t) } function Pn(e, t) { var n = (t & Bt) !== 0, r, i = !e.startsWith("<!>"); return () => { r === void 0 && (r = Nn(i ? e : "<!>" + e), r = dt(r)); var s = n || ct ? document.importNode(r, !0) : r.cloneNode(!0); return Rn(s, s), s } } function Fn(e, t) { e !== null && e.before(t) } function Ge(e, t) { var n = t == null ? "" : typeof t == "object" ? t + "" : t; n !== (e.__t ??= e.nodeValue) && (e.__t = n, e.nodeValue = n + "") } function Cn(e, t) { return Dn(e, t) } const ee = new Map; function Dn(e, { target: t, anchor: n, props: r = {}, events: i, context: s, intro: f = !0 }) { ln(); var o = new Set, l = h => { for (var _ = 0; _ < h.length; _++) { var c = h[_]; if (!o.has(c)) { o.add(c); var d = An(c); t.addEventListener(c, pe, { passive: d }); var O = ee.get(c); O === void 0 ? (document.addEventListener(c, pe, { passive: d }), ee.set(c, 1)) : ee.set(c, O + 1) } } }; l(Nt(kt)), Fe.add(l); var u = void 0, a = _n(() => { var h = n ?? t.appendChild(vt()); return Zt(h, { pending: () => { } }, _ => { if (s) { tt({}); var c = F; c.c = s } i && (r.$$events = i), u = e(_, r) || {}, s && nt() }), () => { for (var _ of o) { t.removeEventListener(_, pe); var c = ee.get(_); --c === 0 ? (document.removeEventListener(_, pe), ee.delete(_)) : ee.set(_, c) } Fe.delete(l), h !== n && h.parentNode?.removeChild(h) } }); return In.set(u, a), u } let In = new WeakMap; const Ln = "5"; typeof window < "u" && ((window.__svelte ??= {}).v ??= new Set).add(Ln); const Mn = globalThis.emit; var jn = Pn('<div class="wrapper"><h1> </h1> <button> </button></div>'); function qn(e, t) { tt(t, !0); let n = L(0), r = null; var i = jn(), s = Oe(i), f = Oe(s), o = fn(s, 2); o.__click = () => { r ? (clearInterval(r), r = null) : r = setInterval(() => { sn(n), console.log("count", A(n)), Mn("cart:add", { "from A": A(n) }) }, 2) }; var l = Oe(o); dn(() => { Ge(f, `发送:${A(n) ?? ""}`), Ge(l, A(n)) }), Fn(e, i), nt() } On(["click"]); Cn(qn, { target: document.getElementById("app") });
