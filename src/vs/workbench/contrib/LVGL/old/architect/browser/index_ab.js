(function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const s of i) if (s.type === "childList") for (const l of s.addedNodes) l.tagName === "LINK" && l.rel === "modulepreload" && r(l) }).observe(document, { childList: !0, subtree: !0 }); function n(i) { const s = {}; return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function r(i) { if (i.ep) return; i.ep = !0; const s = n(i); fetch(i.href, s) } })(); const Xe = !1; var Mt = Array.isArray, Lt = Array.prototype.indexOf, jt = Array.from, qt = Object.defineProperty, ce = Object.getOwnPropertyDescriptor, Bt = Object.prototype, Ut = Array.prototype, Vt = Object.getPrototypeOf, Ke = Object.isExtensible; function Yt(e) { for (var t = 0; t < e.length; t++)e[t]() } function et() { var e, t, n = new Promise((r, i) => { e = r, t = i }); return { promise: n, resolve: e, reject: t } } const m = 2, De = 4, Ie = 8, B = 16, H = 32, X = 64, Se = 128, b = 1024, S = 2048, U = 4096, $ = 8192, K = 16384, Me = 32768, me = 65536, We = 1 << 17, tt = 1 << 18, ue = 1 << 19, $t = 1 << 20, N = 256, ye = 512, be = 32768, Re = 1 << 21, Le = 1 << 22, W = 1 << 23, Ne = Symbol("$state"), te = new class extends Error { name = "StaleReactionError"; message = "The reaction that called `getAbortSignal()` was re-run or destroyed" }; function Kt(e) { throw new Error("https://svelte.dev/e/lifecycle_outside_component") } function Wt() { throw new Error("https://svelte.dev/e/async_derived_orphan") } function zt(e) { throw new Error("https://svelte.dev/e/effect_in_teardown") } function Ht() { throw new Error("https://svelte.dev/e/effect_in_unowned_derived") } function Gt(e) { throw new Error("https://svelte.dev/e/effect_orphan") } function Zt() { throw new Error("https://svelte.dev/e/effect_update_depth_exceeded") } function Jt() { throw new Error("https://svelte.dev/e/state_descriptors_fixed") } function Qt() { throw new Error("https://svelte.dev/e/state_prototype_fixed") } function Xt() { throw new Error("https://svelte.dev/e/state_unsafe_mutation") } function en() { throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror") } const tn = 2, g = Symbol(); function nn() { console.warn("https://svelte.dev/e/svelte_boundary_reset_noop") } function nt(e) { return e === this.v } let rn = !1, A = null; function se(e) { A = e } function je(e, t = !1, n) { A = { p: A, i: !1, c: null, e: null, s: e, x: null, l: null } } function qe(e) { var t = A, n = t.e; if (n !== null) { t.e = null; for (var r of n) mt(r) } return t.i = !0, A = t.p, {} } function rt() { return !0 } let ne = []; function sn() { var e = ne; ne = [], Yt(e) } function Be(e) { if (ne.length === 0) { var t = ne; queueMicrotask(() => { t === ne && sn() }) } ne.push(e) } function it(e) { var t = d; if (t === null) return v.f |= W, e; if ((t.f & Me) === 0) { if ((t.f & Se) === 0) throw e; t.b.error(e) } else fe(e, t) } function fe(e, t) { for (; t !== null;) { if ((t.f & Se) !== 0) try { t.b.error(e); return } catch (n) { e = n } t = t.parent } throw e } const pe = new Set; let w = null, P = null, V = [], Ue = null, Pe = !1; class D { committed = !1; current = new Map; previous = new Map; #n = new Set; #r = new Set; #a = 0; #s = 0; #u = null; #f = []; #i = []; skipped_effects = new Set; is_fork = !1; process(t) { V = [], this.apply(); var n = { parent: null, effect: null, effects: [], render_effects: [], block_effects: [] }; for (const r of t) this.#e(r, n); this.is_fork || this.#l(), this.#s > 0 || this.is_fork ? (this.#t(n.effects), this.#t(n.render_effects), this.#t(n.block_effects)) : (w = null, ze(n.render_effects), ze(n.effects), this.#u?.resolve()), P = null } #e(t, n) { t.f ^= b; for (var r = t.first; r !== null;) { var i = r.f, s = (i & (H | X)) !== 0, l = s && (i & b) !== 0, o = l || (i & $) !== 0 || this.skipped_effects.has(r); if ((r.f & Se) !== 0 && r.b?.is_pending() && (n = { parent: n, effect: r, effects: [], render_effects: [], block_effects: [] }), !o && r.fn !== null) { s ? r.f ^= b : (i & De) !== 0 ? n.effects.push(r) : de(r) && ((r.f & B) !== 0 && n.block_effects.push(r), ve(r)); var f = r.first; if (f !== null) { r = f; continue } } var u = r.parent; for (r = r.next; r === null && u !== null;)u === n.effect && (this.#t(n.effects), this.#t(n.render_effects), this.#t(n.block_effects), n = n.parent), r = u.next, u = u.parent } } #t(t) { for (const n of t) ((n.f & S) !== 0 ? this.#f : this.#i).push(n), x(n, b) } capture(t, n) { this.previous.has(t) || this.previous.set(t, n), (t.f & W) === 0 && (this.current.set(t, t.v), P?.set(t, t.v)) } activate() { w = this, this.apply() } deactivate() { w = null, P = null } flush() { if (this.activate(), V.length > 0) { if (fn(), w !== null && w !== this) return } else this.#a === 0 && this.process([]); this.deactivate() } discard() { for (const t of this.#r) t(this); this.#r.clear() } #l() { if (this.#s === 0) { for (const t of this.#n) t(); this.#n.clear() } this.#a === 0 && this.#o() } #o() { if (pe.size > 1) { this.previous.clear(); var t = P, n = !0, r = { parent: null, effect: null, effects: [], render_effects: [], block_effects: [] }; for (const i of pe) { if (i === this) { n = !1; continue } const s = []; for (const [o, f] of this.current) { if (i.current.has(o)) if (n && f !== i.current.get(o)) i.current.set(o, f); else continue; s.push(o) } if (s.length === 0) continue; const l = [...i.current.keys()].filter(o => !this.current.has(o)); if (l.length > 0) { const o = new Set, f = new Map; for (const u of s) st(u, l, o, f); if (V.length > 0) { w = i, i.apply(); for (const u of V) i.#e(u, r); V = [], i.deactivate() } } } w = null, P = t } this.committed = !0, pe.delete(this) } increment(t) { this.#a += 1, t && (this.#s += 1) } decrement(t) { this.#a -= 1, t && (this.#s -= 1), this.revive() } revive() { for (const t of this.#f) x(t, S), le(t); for (const t of this.#i) x(t, U), le(t); this.#f = [], this.#i = [], this.flush() } oncommit(t) { this.#n.add(t) } ondiscard(t) { this.#r.add(t) } settled() { return (this.#u ??= et()).promise } static ensure() { if (w === null) { const t = w = new D; pe.add(w), D.enqueue(() => { w === t && t.flush() }) } return w } static enqueue(t) { Be(t) } apply() { } } function fn() { var e = ie; Pe = !0; try { var t = 0; for (Ge(!0); V.length > 0;) { var n = D.ensure(); if (t++ > 1e3) { var r, i; ln() } n.process(V), z.clear() } } finally { Pe = !1, Ge(e), Ue = null } } function ln() { try { Zt() } catch (e) { fe(e, Ue) } } let L = null; function ze(e) { var t = e.length; if (t !== 0) { for (var n = 0; n < t;) { var r = e[n++]; if ((r.f & (K | $)) === 0 && de(r) && (L = new Set, ve(r), r.deps === null && r.first === null && r.nodes_start === null && (r.teardown === null && r.ac === null ? xt(r) : r.fn = null), L?.size > 0)) { z.clear(); for (const i of L) { if ((i.f & (K | $)) !== 0) continue; const s = [i]; let l = i.parent; for (; l !== null;)L.has(l) && (L.delete(l), s.push(l)), l = l.parent; for (let o = s.length - 1; o >= 0; o--) { const f = s[o]; (f.f & (K | $)) === 0 && ve(f) } } L.clear() } } L = null } } function st(e, t, n, r) { if (!n.has(e) && (n.add(e), e.reactions !== null)) for (const i of e.reactions) { const s = i.f; (s & m) !== 0 ? st(i, t, n, r) : (s & (Le | B)) !== 0 && (s & S) === 0 && ft(i, t, r) && (x(i, S), le(i)) } } function ft(e, t, n) { const r = n.get(e); if (r !== void 0) return r; if (e.deps !== null) for (const i of e.deps) { if (t.includes(i)) return !0; if ((i.f & m) !== 0 && ft(i, t, n)) return n.set(i, !0), !0 } return n.set(e, !1), !1 } function le(e) { for (var t = Ue = e; t.parent !== null;) { t = t.parent; var n = t.f; if (Pe && t === d && (n & B) !== 0 && (n & tt) === 0) return; if ((n & (X | H)) !== 0) { if ((n & b) === 0) return; t.f ^= b } } V.push(t) } function un(e) { let t = 0, n = Ae(0), r; return () => { bn() && (E(n), Sn(() => (t === 0 && (r = Rt(() => e(() => _e(n)))), t += 1, () => { Be(() => { t -= 1, t === 0 && (r?.(), r = void 0, _e(n)) }) }))) } } var on = me | ue | Se; function an(e, t, n) { new cn(e, t, n) } class cn { parent; #n = !1; #r; #a = null; #s; #u; #f; #i = null; #e = null; #t = null; #l = null; #o = null; #h = 0; #c = 0; #v = !1; #_ = null; #m = un(() => (this.#_ = Ae(this.#h), () => { this.#_ = null })); constructor(t, n, r) { this.#r = t, this.#s = n, this.#u = r, this.parent = d.b, this.#n = !!this.#s.pending, this.#f = An(() => { d.b = this; { var i = this.#g(); try { this.#i = J(() => r(i)) } catch (s) { this.error(s) } this.#c > 0 ? this.#p() : this.#n = !1 } return () => { this.#o?.remove() } }, on) } #y() { try { this.#i = J(() => this.#u(this.#r)) } catch (t) { this.error(t) } this.#n = !1 } #b() { const t = this.#s.pending; t && (this.#e = J(() => t(this.#r)), D.enqueue(() => { var n = this.#g(); this.#i = this.#d(() => (D.ensure(), J(() => this.#u(n)))), this.#c > 0 ? this.#p() : (we(this.#e, () => { this.#e = null }), this.#n = !1) })) } #g() { var t = this.#r; return this.#n && (this.#o = dt(), this.#r.before(this.#o), t = this.#o), t } is_pending() { return this.#n || !!this.parent && this.parent.is_pending() } has_pending_snippet() { return !!this.#s.pending } #d(t) { var n = d, r = v, i = A; M(this.#f), T(this.#f), se(this.#f.ctx); try { return t() } catch (s) { return it(s), null } finally { M(n), T(r), se(i) } } #p() { const t = this.#s.pending; this.#i !== null && (this.#l = document.createDocumentFragment(), this.#l.append(this.#o), Pn(this.#i, this.#l)), this.#e === null && (this.#e = J(() => t(this.#r))) } #w(t) { if (!this.has_pending_snippet()) { this.parent && this.parent.#w(t); return } this.#c += t, this.#c === 0 && (this.#n = !1, this.#e && we(this.#e, () => { this.#e = null }), this.#l && (this.#r.before(this.#l), this.#l = null)) } update_pending_count(t) { this.#w(t), this.#h += t, this.#_ && xe(this.#_, this.#h) } get_effect_pending() { return this.#m(), E(this.#_) } error(t) { var n = this.#s.onerror; let r = this.#s.failed; if (this.#v || !n && !r) throw t; this.#i && (I(this.#i), this.#i = null), this.#e && (I(this.#e), this.#e = null), this.#t && (I(this.#t), this.#t = null); var i = !1, s = !1; const l = () => { if (i) { nn(); return } i = !0, s && en(), D.ensure(), this.#h = 0, this.#t !== null && we(this.#t, () => { this.#t = null }), this.#n = this.has_pending_snippet(), this.#i = this.#d(() => (this.#v = !1, J(() => this.#u(this.#r)))), this.#c > 0 ? this.#p() : this.#n = !1 }; var o = v; try { T(null), s = !0, n?.(t, l), s = !1 } catch (f) { fe(f, this.#f && this.#f.parent) } finally { T(o) } r && Be(() => { this.#t = this.#d(() => { D.ensure(), this.#v = !0; try { return J(() => { r(this.#r, () => t, () => l) }) } catch (f) { return fe(f, this.#f.parent), null } finally { this.#v = !1 } }) }) } } function _n(e, t, n, r) { const i = vn; if (n.length === 0 && e.length === 0) { r(t.map(i)); return } var s = w, l = d, o = hn(); function f() { Promise.all(n.map(u => dn(u))).then(u => { o(); try { r([...t.map(i), ...u]) } catch (a) { (l.f & K) === 0 && fe(a, l) } s?.deactivate(), Ee() }).catch(u => { fe(u, l) }) } e.length > 0 ? Promise.all(e).then(() => { o(); try { return f() } finally { s?.deactivate(), Ee() } }) : f() } function hn() { var e = d, t = v, n = A, r = w; return function (s = !0) { M(e), T(t), se(n), s && r?.activate() } } function Ee() { M(null), T(null), se(null) } function vn(e) { var t = m | S, n = v !== null && (v.f & m) !== 0 ? v : null; return d === null || n !== null && (n.f & N) !== 0 ? t |= N : d.f |= ue, { ctx: A, deps: null, effects: null, equals: nt, f: t, fn: e, reactions: null, rv: 0, v: g, wv: 0, parent: n ?? d, ac: null } } function dn(e, t) { let n = d; n === null && Wt(); var r = n.b, i = void 0, s = Ae(g), l = !v, o = new Map; return kn(() => { var f = et(); i = f.promise; try { Promise.resolve(e()).then(f.resolve, f.reject).then(() => { u === w && u.committed && u.deactivate(), Ee() }) } catch (_) { f.reject(_), Ee() } var u = w; if (l) { var a = !r.is_pending(); r.update_pending_count(1), u.increment(a), o.get(u)?.reject(te), o.delete(u), o.set(u, f) } const h = (_, c = void 0) => { if (u.activate(), c) c !== te && (s.f |= W, xe(s, c)); else { (s.f & W) !== 0 && (s.f ^= W), xe(s, _); for (const [p, R] of o) { if (o.delete(p), p === u) break; R.reject(te) } } l && (r.update_pending_count(-1), u.decrement(a)) }; f.promise.then(h, _ => h(null, _ || "unknown")) }), En(() => { for (const f of o.values()) f.reject(te) }), new Promise(f => { function u(a) { function h() { a === i ? f(s) : u(i) } a.then(h, h) } u(i) }) } function lt(e) { var t = e.effects; if (t !== null) { e.effects = null; for (var n = 0; n < t.length; n += 1)I(t[n]) } } function pn(e) { for (var t = e.parent; t !== null;) { if ((t.f & m) === 0) return t; t = t.parent } return null } function Ve(e) { var t, n = d; M(pn(e)); try { e.f &= ~be, lt(e), t = Ot(e) } finally { M(n) } return t } function ut(e) { var t = Ve(e); if (e.equals(t) || (e.v = t, e.wv = St()), !oe) if (P !== null) P.set(e, e.v); else { var n = (Y || (e.f & N) !== 0) && e.deps !== null ? U : b; x(e, n) } } let Fe = new Set; const z = new Map; let ot = !1; function Ae(e, t) { var n = { f: 0, v: e, reactions: null, equals: nt, rv: 0, wv: 0 }; return n } function C(e, t) { const n = Ae(e); return Fn(n), n } function j(e, t, n = !1) { v !== null && (!F || (v.f & We) !== 0) && rt() && (v.f & (m | B | Le | We)) !== 0 && !q?.includes(e) && Xt(); let r = n ? ae(t) : t; return xe(e, r) } function xe(e, t) { if (!e.equals(t)) { var n = e.v; oe ? z.set(e, t) : z.set(e, n), e.v = t; var r = D.ensure(); r.capture(e, n), (e.f & m) !== 0 && ((e.f & S) !== 0 && Ve(e), x(e, (e.f & N) === 0 ? b : U)), e.wv = St(), ct(e, S), d !== null && (d.f & b) !== 0 && (d.f & (H | X)) === 0 && (O === null ? Cn([e]) : O.push(e)), !r.is_fork && Fe.size > 0 && !ot && gn() } return t } function gn() { ot = !1; const e = Array.from(Fe); for (const t of e) (t.f & b) !== 0 && x(t, U), de(t) && ve(t); Fe.clear() } function at(e, t = 1) { var n = E(e), r = t === 1 ? n++ : n--; return j(e, n), r } function _e(e) { j(e, e.v + 1) } function ct(e, t) { var n = e.reactions; if (n !== null) for (var r = n.length, i = 0; i < r; i++) { var s = n[i], l = s.f, o = (l & S) === 0; o && x(s, t), (l & m) !== 0 ? (l & be) === 0 && (s.f |= be, ct(s, U)) : o && ((l & B) !== 0 && L !== null && L.add(s), le(s)) } } function ae(e) { if (typeof e != "object" || e === null || Ne in e) return e; const t = Vt(e); if (t !== Bt && t !== Ut) return e; var n = new Map, r = Mt(e), i = C(0), s = Q, l = o => { if (Q === s) return o(); var f = v, u = Q; T(null), Je(s); var a = o(); return T(f), Je(u), a }; return r && n.set("length", C(e.length)), new Proxy(e, { defineProperty(o, f, u) { (!("value" in u) || u.configurable === !1 || u.enumerable === !1 || u.writable === !1) && Jt(); var a = n.get(f); return a === void 0 ? a = l(() => { var h = C(u.value); return n.set(f, h), h }) : j(a, u.value, !0), !0 }, deleteProperty(o, f) { var u = n.get(f); if (u === void 0) { if (f in o) { const a = l(() => C(g)); n.set(f, a), _e(i) } } else j(u, g), _e(i); return !0 }, get(o, f, u) { if (f === Ne) return e; var a = n.get(f), h = f in o; if (a === void 0 && (!h || ce(o, f)?.writable) && (a = l(() => { var c = ae(h ? o[f] : g), p = C(c); return p }), n.set(f, a)), a !== void 0) { var _ = E(a); return _ === g ? void 0 : _ } return Reflect.get(o, f, u) }, getOwnPropertyDescriptor(o, f) { var u = Reflect.getOwnPropertyDescriptor(o, f); if (u && "value" in u) { var a = n.get(f); a && (u.value = E(a)) } else if (u === void 0) { var h = n.get(f), _ = h?.v; if (h !== void 0 && _ !== g) return { enumerable: !0, configurable: !0, value: _, writable: !0 } } return u }, has(o, f) { if (f === Ne) return !0; var u = n.get(f), a = u !== void 0 && u.v !== g || Reflect.has(o, f); if (u !== void 0 || d !== null && (!a || ce(o, f)?.writable)) { u === void 0 && (u = l(() => { var _ = a ? ae(o[f]) : g, c = C(_); return c }), n.set(f, u)); var h = E(u); if (h === g) return !1 } return a }, set(o, f, u, a) { var h = n.get(f), _ = f in o; if (r && f === "length") for (var c = u; c < h.v; c += 1) { var p = n.get(c + ""); p !== void 0 ? j(p, g) : c in o && (p = l(() => C(g)), n.set(c + "", p)) } if (h === void 0) (!_ || ce(o, f)?.writable) && (h = l(() => C(void 0)), j(h, ae(u)), n.set(f, h)); else { _ = h.v !== g; var R = l(() => ae(u)); j(h, R) } var Z = Reflect.getOwnPropertyDescriptor(o, f); if (Z?.set && Z.set.call(a, u), !_) { if (r && typeof f == "string") { var $e = n.get("length"), Oe = Number(f); Number.isInteger(Oe) && Oe >= $e.v && j($e, Oe + 1) } _e(i) } return !0 }, ownKeys(o) { E(i); var f = Reflect.ownKeys(o).filter(h => { var _ = n.get(h); return _ === void 0 || _.v !== g }); for (var [u, a] of n) a.v !== g && !(u in o) && f.push(u); return f }, setPrototypeOf() { Qt() } }) } var He, _t, ht, vt; function wn() { if (He === void 0) { He = window, _t = /Firefox/.test(navigator.userAgent); var e = Element.prototype, t = Node.prototype, n = Text.prototype; ht = ce(t, "firstChild").get, vt = ce(t, "nextSibling").get, Ke(e) && (e.__click = void 0, e.__className = void 0, e.__attributes = null, e.__style = void 0, e.__e = void 0), Ke(n) && (n.__t = void 0) } } function dt(e = "") { return document.createTextNode(e) } function pt(e) { return ht.call(e) } function Ye(e) { return vt.call(e) } function re(e, t) { return pt(e) } function gt(e, t = 1, n = !1) { let r = e; for (; t--;)r = Ye(r); return r } function wt(e) { var t = v, n = d; T(null), M(null); try { return e() } finally { T(t), M(n) } } function mn(e) { d === null && v === null && Gt(), v !== null && (v.f & N) !== 0 && d === null && Ht(), oe && zt() } function yn(e, t) { var n = t.last; n === null ? t.last = t.first = e : (n.next = e, e.prev = n, t.last = e) } function G(e, t, n, r = !0) { var i = d; i !== null && (i.f & $) !== 0 && (e |= $); var s = { ctx: A, deps: null, nodes_start: null, nodes_end: null, f: e | S, first: null, fn: t, last: null, next: null, parent: i, b: i && i.b, prev: null, teardown: null, transitions: null, wv: 0, ac: null }; if (n) try { ve(s), s.f |= Me } catch (f) { throw I(s), f } else t !== null && le(s); if (r) { var l = s; if (n && l.deps === null && l.teardown === null && l.nodes_start === null && l.first === l.last && (l.f & ue) === 0 && (l = l.first, (e & B) !== 0 && (e & me) !== 0 && l !== null && (l.f |= me)), l !== null && (l.parent = i, i !== null && yn(l, i), v !== null && (v.f & m) !== 0 && (e & X) === 0)) { var o = v; (o.effects ??= []).push(l) } } return s } function bn() { return v !== null && !F } function En(e) { const t = G(Ie, null, !1); return x(t, b), t.teardown = e, t } function xn(e) { mn(); var t = d.f, n = !v && (t & H) !== 0 && (t & Me) === 0; if (n) { var r = A; (r.e ??= []).push(e) } else return mt(e) } function mt(e) { return G(De | $t, e, !1) } function Tn(e) { D.ensure(); const t = G(X | ue, e, !0); return (n = {}) => new Promise(r => { n.outro ? we(t, () => { I(t), r(void 0) }) : (I(t), r(void 0)) }) } function kn(e) { return G(Le | ue, e, !0) } function Sn(e, t = 0) { return G(Ie | t, e, !0) } function yt(e, t = [], n = [], r = [], i = !1) { _n(r, t, n, s => { G(i ? De : Ie, () => e(...s.map(E)), !0) }) } function An(e, t = 0) { var n = G(B | t, e, !0); return n } function J(e, t = !0) { return G(H | ue, e, !0, t) } function bt(e) { var t = e.teardown; if (t !== null) { const n = oe, r = v; Ze(!0), T(null); try { t.call(null) } finally { Ze(n), T(r) } } } function Et(e, t = !1) { var n = e.first; for (e.first = e.last = null; n !== null;) { const i = n.ac; i !== null && wt(() => { i.abort(te) }); var r = n.next; (n.f & X) !== 0 ? n.parent = null : I(n, t), n = r } } function On(e) { for (var t = e.first; t !== null;) { var n = t.next; (t.f & H) === 0 && I(t), t = n } } function I(e, t = !0) { var n = !1; (t || (e.f & tt) !== 0) && e.nodes_start !== null && e.nodes_end !== null && (Nn(e.nodes_start, e.nodes_end), n = !0), Et(e, t && !n), Te(e, 0), x(e, K); var r = e.transitions; if (r !== null) for (const s of r) s.stop(); bt(e); var i = e.parent; i !== null && i.first !== null && xt(e), e.next = e.prev = e.teardown = e.ctx = e.deps = e.fn = e.nodes_start = e.nodes_end = e.ac = null } function Nn(e, t) { for (; e !== null;) { var n = e === t ? null : Ye(e); e.remove(), e = n } } function xt(e) { var t = e.parent, n = e.prev, r = e.next; n !== null && (n.next = r), r !== null && (r.prev = n), t !== null && (t.first === e && (t.first = r), t.last === e && (t.last = n)) } function we(e, t, n = !0) { var r = []; Tt(e, r, !0), Rn(r, () => { n && I(e), t && t() }) } function Rn(e, t) { var n = e.length; if (n > 0) { var r = () => --n || t(); for (var i of e) i.out(r) } else t() } function Tt(e, t, n) { if ((e.f & $) === 0) { if (e.f ^= $, e.transitions !== null) for (const l of e.transitions) (l.is_global || n) && t.push(l); for (var r = e.first; r !== null;) { var i = r.next, s = (r.f & me) !== 0 || (r.f & H) !== 0 && (e.f & B) !== 0; Tt(r, t, s ? n : !1), r = i } } } function Pn(e, t) { for (var n = e.nodes_start, r = e.nodes_end; n !== null;) { var i = n === r ? null : Ye(n); t.append(n), n = i } } let ie = !1; function Ge(e) { ie = e } let oe = !1; function Ze(e) { oe = e } let v = null, F = !1; function T(e) { v = e } let d = null; function M(e) { d = e } let q = null; function Fn(e) { v !== null && (q === null ? q = [e] : q.push(e)) } let y = null, k = 0, O = null; function Cn(e) { O = e } let kt = 1, he = 0, Q = he; function Je(e) { Q = e } let Y = !1; function St() { return ++kt } function de(e) { var t = e.f; if ((t & S) !== 0) return !0; if ((t & U) !== 0) { var n = e.deps, r = (t & N) !== 0; if (t & m && (e.f &= ~be), n !== null) { var i, s, l = (t & ye) !== 0, o = r && d !== null && !Y, f = n.length; if ((l || o) && (d === null || (d.f & K) === 0)) { var u = e, a = u.parent; for (i = 0; i < f; i++)s = n[i], (l || !s?.reactions?.includes(u)) && (s.reactions ??= []).push(u); l && (u.f ^= ye), o && a !== null && (a.f & N) === 0 && (u.f ^= N) } for (i = 0; i < f; i++)if (s = n[i], de(s) && ut(s), s.wv > e.wv) return !0 } (!r || d !== null && !Y) && x(e, b) } return !1 } function At(e, t, n = !0) { var r = e.reactions; if (r !== null && !q?.includes(e)) for (var i = 0; i < r.length; i++) { var s = r[i]; (s.f & m) !== 0 ? At(s, t, !1) : t === s && (n ? x(s, S) : (s.f & b) !== 0 && x(s, U), le(s)) } } function Ot(e) { var t = y, n = k, r = O, i = v, s = Y, l = q, o = A, f = F, u = Q, a = e.f; y = null, k = 0, O = null, Y = (a & N) !== 0 && (F || !ie || v === null), v = (a & (H | X)) === 0 ? e : null, q = null, se(e.ctx), F = !1, Q = ++he, e.ac !== null && (wt(() => { e.ac.abort(te) }), e.ac = null); try { e.f |= Re; var h = e.fn, _ = h(), c = e.deps; if (y !== null) { var p; if (Te(e, k), c !== null && k > 0) for (c.length = k + y.length, p = 0; p < y.length; p++)c[k + p] = y[p]; else e.deps = c = y; if (!Y || (a & m) !== 0 && e.reactions !== null) for (p = k; p < c.length; p++)(c[p].reactions ??= []).push(e) } else c !== null && k < c.length && (Te(e, k), c.length = k); if (rt() && O !== null && !F && c !== null && (e.f & (m | U | S)) === 0) for (p = 0; p < O.length; p++)At(O[p], e); return i !== null && i !== e && (he++, O !== null && (r === null ? r = O : r.push(...O))), (e.f & W) !== 0 && (e.f ^= W), _ } catch (R) { return it(R) } finally { e.f ^= Re, y = t, k = n, O = r, v = i, Y = s, q = l, se(o), F = f, Q = u } } function Dn(e, t) { let n = t.reactions; if (n !== null) { var r = Lt.call(n, e); if (r !== -1) { var i = n.length - 1; i === 0 ? n = t.reactions = null : (n[r] = n[i], n.pop()) } } n === null && (t.f & m) !== 0 && (y === null || !y.includes(t)) && (x(t, U), (t.f & (N | ye)) === 0 && (t.f ^= ye), lt(t), Te(t, 0)) } function Te(e, t) { var n = e.deps; if (n !== null) for (var r = t; r < n.length; r++)Dn(e, n[r]) } function ve(e) { var t = e.f; if ((t & K) === 0) { x(e, b); var n = d, r = ie; d = e, ie = !0; try { (t & B) !== 0 ? On(e) : Et(e), bt(e); var i = Ot(e); e.teardown = typeof i == "function" ? i : null, e.wv = kt; var s; Xe && rn && (e.f & S) !== 0 && e.deps } finally { ie = r, d = n } } } function E(e) { var t = e.f, n = (t & m) !== 0; if (v !== null && !F) { var r = d !== null && (d.f & K) !== 0; if (!r && !q?.includes(e)) { var i = v.deps; if ((v.f & Re) !== 0) e.rv < he && (e.rv = he, y === null && i !== null && i[k] === e ? k++ : y === null ? y = [e] : (!Y || !y.includes(e)) && y.push(e)); else { (v.deps ??= []).push(e); var s = e.reactions; s === null ? e.reactions = [v] : s.includes(v) || s.push(v) } } } else if (n && e.deps === null && e.effects === null) { var l = e, o = l.parent; o !== null && (o.f & N) === 0 && (l.f ^= N) } if (oe) { if (z.has(e)) return z.get(e); if (n) { l = e; var f = l.v; return ((l.f & b) === 0 && l.reactions !== null || Nt(l)) && (f = Ve(l)), z.set(l, f), f } } else if (n) { if (l = e, P?.has(l)) return P.get(l); de(l) && ut(l) } if (P?.has(e)) return P.get(e); if ((e.f & W) !== 0) throw e.v; return e.v } function Nt(e) { if (e.v === g) return !0; if (e.deps === null) return !1; for (const t of e.deps) if (z.has(t) || (t.f & m) !== 0 && Nt(t)) return !0; return !1 } function Rt(e) { var t = F; try { return F = !0, e() } finally { F = t } } const In = -7169; function x(e, t) { e.f = e.f & In | t } const Mn = ["touchstart", "touchmove"]; function Ln(e) { return Mn.includes(e) } const Pt = new Set, Ce = new Set; function Ft(e) { for (var t = 0; t < e.length; t++)Pt.add(e[t]); for (var n of Ce) n(e) } let Qe = null; function ge(e) { var t = this, n = t.ownerDocument, r = e.type, i = e.composedPath?.() || [], s = i[0] || e.target; Qe = e; var l = 0, o = Qe === e && e.__root; if (o) { var f = i.indexOf(o); if (f !== -1 && (t === document || t === window)) { e.__root = t; return } var u = i.indexOf(t); if (u === -1) return; f <= u && (l = f) } if (s = i[l] || e.target, s !== t) { qt(e, "currentTarget", { configurable: !0, get() { return s || n } }); var a = v, h = d; T(null), M(null); try { for (var _, c = []; s !== null;) { var p = s.assignedSlot || s.parentNode || s.host || null; try { var R = s["__" + r]; R != null && (!s.disabled || e.target === s) && R.call(s, e) } catch (Z) { _ ? c.push(Z) : _ = Z } if (e.cancelBubble || p === t || p === null) break; s = p } if (_) { for (let Z of c) queueMicrotask(() => { throw Z }); throw _ } } finally { e.__root = t, delete e.currentTarget, T(a), M(h) } } } function jn(e) { var t = document.createElement("template"); return t.innerHTML = e.replaceAll("<!>", "<!---->"), t.content } function qn(e, t) { var n = d; n.nodes_start === null && (n.nodes_start = e, n.nodes_end = t) } function Ct(e, t) { var n = (t & tn) !== 0, r, i = !e.startsWith("<!>"); return () => { r === void 0 && (r = jn(i ? e : "<!>" + e), r = pt(r)); var s = n || _t ? document.importNode(r, !0) : r.cloneNode(!0); return qn(s, s), s } } function Dt(e, t) { e !== null && e.before(t) } function ke(e, t) { var n = t == null ? "" : typeof t == "object" ? t + "" : t; n !== (e.__t ??= e.nodeValue) && (e.__t = n, e.nodeValue = n + "") } function It(e, t) { return Bn(e, t) } const ee = new Map; function Bn(e, { target: t, anchor: n, props: r = {}, events: i, context: s, intro: l = !0 }) { wn(); var o = new Set, f = h => { for (var _ = 0; _ < h.length; _++) { var c = h[_]; if (!o.has(c)) { o.add(c); var p = Ln(c); t.addEventListener(c, ge, { passive: p }); var R = ee.get(c); R === void 0 ? (document.addEventListener(c, ge, { passive: p }), ee.set(c, 1)) : ee.set(c, R + 1) } } }; f(jt(Pt)), Ce.add(f); var u = void 0, a = Tn(() => { var h = n ?? t.appendChild(dt()); return an(h, { pending: () => { } }, _ => { if (s) { je({}); var c = A; c.c = s } i && (r.$$events = i), u = e(_, r) || {}, s && qe() }), () => { for (var _ of o) { t.removeEventListener(_, ge); var c = ee.get(_); --c === 0 ? (document.removeEventListener(_, ge), ee.delete(_)) : ee.set(_, c) } Ce.delete(f), h !== n && h.parentNode?.removeChild(h) } }); return Un.set(u, a), u } let Un = new WeakMap; function Vn(e) { A === null && Kt(), xn(() => { const t = Rt(e); if (typeof t == "function") return t }) } const Yn = "5"; typeof window < "u" && ((window.__svelte ??= {}).v ??= new Set).add(Yn); const $n = globalThis.emit, Kn = globalThis.onEvent; var Wn = Ct('<div class="wrapper"><h1> </h1> <button> </button></div>'); function zn(e, t) { je(t, !0); let n = C(0), r = null; var i = Wn(), s = re(i), l = re(s), o = gt(s, 2); o.__click = () => { r ? (clearInterval(r), r = null) : r = setInterval(() => { at(n), console.log("count", E(n)), $n("cart:add", { "from A": E(n) }) }, 2) }; var f = re(o); yt(() => { ke(l, `发送:${E(n) ?? ""}`), ke(f, E(n)) }), Dt(e, i), qe() } Ft(["click"]); var Hn = Ct('<div class="wrapper"><h1> </h1> <button> </button></div>'); function Gn(e, t) { je(t, !0); let n = C(0); Vn(() => { Kn("cart:add", f => j(n, f["from A"], !0)) }); var r = Hn(), i = re(r), s = re(i), l = gt(i, 2); l.__click = () => { at(n), console.log(E(n)) }; var o = re(l); yt(() => { ke(s, `接受:${E(n) ?? ""}`), ke(o, E(n)) }), Dt(e, r), qe() } Ft(["click"]); It(zn, { target: document.getElementById("app") }); It(Gn, { target: document.getElementById("app2") });
