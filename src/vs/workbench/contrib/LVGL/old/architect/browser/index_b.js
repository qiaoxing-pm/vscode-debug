(function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const s of i) if (s.type === "childList") for (const l of s.addedNodes) l.tagName === "LINK" && l.rel === "modulepreload" && r(l) }).observe(document, { childList: !0, subtree: !0 }); function n(i) { const s = {}; return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function r(i) { if (i.ep) return; i.ep = !0; const s = n(i); fetch(i.href, s) } })(); const Je = !1; var Nt = Array.isArray, Rt = Array.prototype.indexOf, Pt = Array.from, Ft = Object.defineProperty, ae = Object.getOwnPropertyDescriptor, Ct = Object.prototype, Dt = Array.prototype, It = Object.getPrototypeOf, Be = Object.isExtensible; function Mt(e) { for (var t = 0; t < e.length; t++)e[t]() } function Qe() { var e, t, n = new Promise((r, i) => { e = r, t = i }); return { promise: n, resolve: e, reject: t } } const m = 2, Ce = 4, De = 8, U = 16, H = 32, X = 64, Te = 128, b = 1024, S = 2048, V = 4096, K = 8192, $ = 16384, Ie = 32768, we = 65536, Ye = 1 << 17, Xe = 1 << 18, le = 1 << 19, Lt = 1 << 20, O = 256, me = 512, ye = 32768, Ne = 1 << 21, Me = 1 << 22, W = 1 << 23, Ae = Symbol("$state"), te = new class extends Error { name = "StaleReactionError"; message = "The reaction that called `getAbortSignal()` was re-run or destroyed" }; function jt(e) { throw new Error("https://svelte.dev/e/lifecycle_outside_component") } function qt() { throw new Error("https://svelte.dev/e/async_derived_orphan") } function Ut(e) { throw new Error("https://svelte.dev/e/effect_in_teardown") } function Vt() { throw new Error("https://svelte.dev/e/effect_in_unowned_derived") } function Bt(e) { throw new Error("https://svelte.dev/e/effect_orphan") } function Yt() { throw new Error("https://svelte.dev/e/effect_update_depth_exceeded") } function Kt() { throw new Error("https://svelte.dev/e/state_descriptors_fixed") } function $t() { throw new Error("https://svelte.dev/e/state_prototype_fixed") } function Wt() { throw new Error("https://svelte.dev/e/state_unsafe_mutation") } function zt() { throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror") } const Ht = 2, g = Symbol(); function Gt() { console.warn("https://svelte.dev/e/svelte_boundary_reset_noop") } function et(e) { return e === this.v } let Zt = !1, k = null; function ie(e) { k = e } function tt(e, t = !1, n) { k = { p: k, i: !1, c: null, e: null, s: e, x: null, l: null } } function nt(e) { var t = k, n = t.e; if (n !== null) { t.e = null; for (var r of n) gt(r) } return t.i = !0, k = t.p, {} } function rt() { return !0 } let ne = []; function Jt() { var e = ne; ne = [], Mt(e) } function Le(e) { if (ne.length === 0) { var t = ne; queueMicrotask(() => { t === ne && Jt() }) } ne.push(e) } function it(e) { var t = d; if (t === null) return v.f |= W, e; if ((t.f & Ie) === 0) { if ((t.f & Te) === 0) throw e; t.b.error(e) } else se(e, t) } function se(e, t) { for (; t !== null;) { if ((t.f & Te) !== 0) try { t.b.error(e); return } catch (n) { e = n } t = t.parent } throw e } const de = new Set; let w = null, R = null, B = [], je = null, Re = !1; class C { committed = !1; current = new Map; previous = new Map; #n = new Set; #r = new Set; #a = 0; #s = 0; #u = null; #f = []; #i = []; skipped_effects = new Set; is_fork = !1; process(t) { B = [], this.apply(); var n = { parent: null, effect: null, effects: [], render_effects: [], block_effects: [] }; for (const r of t) this.#e(r, n); this.is_fork || this.#l(), this.#s > 0 || this.is_fork ? (this.#t(n.effects), this.#t(n.render_effects), this.#t(n.block_effects)) : (w = null, Ke(n.render_effects), Ke(n.effects), this.#u?.resolve()), R = null } #e(t, n) { t.f ^= b; for (var r = t.first; r !== null;) { var i = r.f, s = (i & (H | X)) !== 0, l = s && (i & b) !== 0, o = l || (i & K) !== 0 || this.skipped_effects.has(r); if ((r.f & Te) !== 0 && r.b?.is_pending() && (n = { parent: n, effect: r, effects: [], render_effects: [], block_effects: [] }), !o && r.fn !== null) { s ? r.f ^= b : (i & Ce) !== 0 ? n.effects.push(r) : ve(r) && ((r.f & U) !== 0 && n.block_effects.push(r), he(r)); var f = r.first; if (f !== null) { r = f; continue } } var u = r.parent; for (r = r.next; r === null && u !== null;)u === n.effect && (this.#t(n.effects), this.#t(n.render_effects), this.#t(n.block_effects), n = n.parent), r = u.next, u = u.parent } } #t(t) { for (const n of t) ((n.f & S) !== 0 ? this.#f : this.#i).push(n), E(n, b) } capture(t, n) { this.previous.has(t) || this.previous.set(t, n), (t.f & W) === 0 && (this.current.set(t, t.v), R?.set(t, t.v)) } activate() { w = this, this.apply() } deactivate() { w = null, R = null } flush() { if (this.activate(), B.length > 0) { if (Qt(), w !== null && w !== this) return } else this.#a === 0 && this.process([]); this.deactivate() } discard() { for (const t of this.#r) t(this); this.#r.clear() } #l() { if (this.#s === 0) { for (const t of this.#n) t(); this.#n.clear() } this.#a === 0 && this.#o() } #o() { if (de.size > 1) { this.previous.clear(); var t = R, n = !0, r = { parent: null, effect: null, effects: [], render_effects: [], block_effects: [] }; for (const i of de) { if (i === this) { n = !1; continue } const s = []; for (const [o, f] of this.current) { if (i.current.has(o)) if (n && f !== i.current.get(o)) i.current.set(o, f); else continue; s.push(o) } if (s.length === 0) continue; const l = [...i.current.keys()].filter(o => !this.current.has(o)); if (l.length > 0) { const o = new Set, f = new Map; for (const u of s) st(u, l, o, f); if (B.length > 0) { w = i, i.apply(); for (const u of B) i.#e(u, r); B = [], i.deactivate() } } } w = null, R = t } this.committed = !0, de.delete(this) } increment(t) { this.#a += 1, t && (this.#s += 1) } decrement(t) { this.#a -= 1, t && (this.#s -= 1), this.revive() } revive() { for (const t of this.#f) E(t, S), fe(t); for (const t of this.#i) E(t, V), fe(t); this.#f = [], this.#i = [], this.flush() } oncommit(t) { this.#n.add(t) } ondiscard(t) { this.#r.add(t) } settled() { return (this.#u ??= Qe()).promise } static ensure() { if (w === null) { const t = w = new C; de.add(w), C.enqueue(() => { w === t && t.flush() }) } return w } static enqueue(t) { Le(t) } apply() { } } function Qt() { var e = re; Re = !0; try { var t = 0; for (We(!0); B.length > 0;) { var n = C.ensure(); if (t++ > 1e3) { var r, i; Xt() } n.process(B), z.clear() } } finally { Re = !1, We(e), je = null } } function Xt() { try { Yt() } catch (e) { se(e, je) } } let L = null; function Ke(e) { var t = e.length; if (t !== 0) { for (var n = 0; n < t;) { var r = e[n++]; if ((r.f & ($ | K)) === 0 && ve(r) && (L = new Set, he(r), r.deps === null && r.first === null && r.nodes_start === null && (r.teardown === null && r.ac === null ? yt(r) : r.fn = null), L?.size > 0)) { z.clear(); for (const i of L) { if ((i.f & ($ | K)) !== 0) continue; const s = [i]; let l = i.parent; for (; l !== null;)L.has(l) && (L.delete(l), s.push(l)), l = l.parent; for (let o = s.length - 1; o >= 0; o--) { const f = s[o]; (f.f & ($ | K)) === 0 && he(f) } } L.clear() } } L = null } } function st(e, t, n, r) { if (!n.has(e) && (n.add(e), e.reactions !== null)) for (const i of e.reactions) { const s = i.f; (s & m) !== 0 ? st(i, t, n, r) : (s & (Me | U)) !== 0 && (s & S) === 0 && ft(i, t, r) && (E(i, S), fe(i)) } } function ft(e, t, n) { const r = n.get(e); if (r !== void 0) return r; if (e.deps !== null) for (const i of e.deps) { if (t.includes(i)) return !0; if ((i.f & m) !== 0 && ft(i, t, n)) return n.set(i, !0), !0 } return n.set(e, !1), !1 } function fe(e) { for (var t = je = e; t.parent !== null;) { t = t.parent; var n = t.f; if (Re && t === d && (n & U) !== 0 && (n & Xe) === 0) return; if ((n & (X | H)) !== 0) { if ((n & b) === 0) return; t.f ^= b } } B.push(t) } function en(e) { let t = 0, n = Se(0), r; return () => { pn() && (F(n), bn(() => (t === 0 && (r = At(() => e(() => ce(n)))), t += 1, () => { Le(() => { t -= 1, t === 0 && (r?.(), r = void 0, ce(n)) }) }))) } } var tn = we | le | Te; function nn(e, t, n) { new rn(e, t, n) } class rn { parent; #n = !1; #r; #a = null; #s; #u; #f; #i = null; #e = null; #t = null; #l = null; #o = null; #h = 0; #c = 0; #v = !1; #_ = null; #m = en(() => (this.#_ = Se(this.#h), () => { this.#_ = null })); constructor(t, n, r) { this.#r = t, this.#s = n, this.#u = r, this.parent = d.b, this.#n = !!this.#s.pending, this.#f = xn(() => { d.b = this; { var i = this.#g(); try { this.#i = J(() => r(i)) } catch (s) { this.error(s) } this.#c > 0 ? this.#p() : this.#n = !1 } return () => { this.#o?.remove() } }, tn) } #y() { try { this.#i = J(() => this.#u(this.#r)) } catch (t) { this.error(t) } this.#n = !1 } #b() { const t = this.#s.pending; t && (this.#e = J(() => t(this.#r)), C.enqueue(() => { var n = this.#g(); this.#i = this.#d(() => (C.ensure(), J(() => this.#u(n)))), this.#c > 0 ? this.#p() : (ge(this.#e, () => { this.#e = null }), this.#n = !1) })) } #g() { var t = this.#r; return this.#n && (this.#o = vt(), this.#r.before(this.#o), t = this.#o), t } is_pending() { return this.#n || !!this.parent && this.parent.is_pending() } has_pending_snippet() { return !!this.#s.pending } #d(t) { var n = d, r = v, i = k; I(this.#f), x(this.#f), ie(this.#f.ctx); try { return t() } catch (s) { return it(s), null } finally { I(n), x(r), ie(i) } } #p() { const t = this.#s.pending; this.#i !== null && (this.#l = document.createDocumentFragment(), this.#l.append(this.#o), An(this.#i, this.#l)), this.#e === null && (this.#e = J(() => t(this.#r))) } #w(t) { if (!this.has_pending_snippet()) { this.parent && this.parent.#w(t); return } this.#c += t, this.#c === 0 && (this.#n = !1, this.#e && ge(this.#e, () => { this.#e = null }), this.#l && (this.#r.before(this.#l), this.#l = null)) } update_pending_count(t) { this.#w(t), this.#h += t, this.#_ && Ee(this.#_, this.#h) } get_effect_pending() { return this.#m(), F(this.#_) } error(t) { var n = this.#s.onerror; let r = this.#s.failed; if (this.#v || !n && !r) throw t; this.#i && (D(this.#i), this.#i = null), this.#e && (D(this.#e), this.#e = null), this.#t && (D(this.#t), this.#t = null); var i = !1, s = !1; const l = () => { if (i) { Gt(); return } i = !0, s && zt(), C.ensure(), this.#h = 0, this.#t !== null && ge(this.#t, () => { this.#t = null }), this.#n = this.has_pending_snippet(), this.#i = this.#d(() => (this.#v = !1, J(() => this.#u(this.#r)))), this.#c > 0 ? this.#p() : this.#n = !1 }; var o = v; try { x(null), s = !0, n?.(t, l), s = !1 } catch (f) { se(f, this.#f && this.#f.parent) } finally { x(o) } r && Le(() => { this.#t = this.#d(() => { C.ensure(), this.#v = !0; try { return J(() => { r(this.#r, () => t, () => l) }) } catch (f) { return se(f, this.#f.parent), null } finally { this.#v = !1 } }) }) } } function sn(e, t, n, r) { const i = ln; if (n.length === 0 && e.length === 0) { r(t.map(i)); return } var s = w, l = d, o = fn(); function f() { Promise.all(n.map(u => un(u))).then(u => { o(); try { r([...t.map(i), ...u]) } catch (a) { (l.f & $) === 0 && se(a, l) } s?.deactivate(), be() }).catch(u => { se(u, l) }) } e.length > 0 ? Promise.all(e).then(() => { o(); try { return f() } finally { s?.deactivate(), be() } }) : f() } function fn() { var e = d, t = v, n = k, r = w; return function (s = !0) { I(e), x(t), ie(n), s && r?.activate() } } function be() { I(null), x(null), ie(null) } function ln(e) { var t = m | S, n = v !== null && (v.f & m) !== 0 ? v : null; return d === null || n !== null && (n.f & O) !== 0 ? t |= O : d.f |= le, { ctx: k, deps: null, effects: null, equals: et, f: t, fn: e, reactions: null, rv: 0, v: g, wv: 0, parent: n ?? d, ac: null } } function un(e, t) { let n = d; n === null && qt(); var r = n.b, i = void 0, s = Se(g), l = !v, o = new Map; return yn(() => { var f = Qe(); i = f.promise; try { Promise.resolve(e()).then(f.resolve, f.reject).then(() => { u === w && u.committed && u.deactivate(), be() }) } catch (_) { f.reject(_), be() } var u = w; if (l) { var a = !r.is_pending(); r.update_pending_count(1), u.increment(a), o.get(u)?.reject(te), o.delete(u), o.set(u, f) } const h = (_, c = void 0) => { if (u.activate(), c) c !== te && (s.f |= W, Ee(s, c)); else { (s.f & W) !== 0 && (s.f ^= W), Ee(s, _); for (const [p, N] of o) { if (o.delete(p), p === u) break; N.reject(te) } } l && (r.update_pending_count(-1), u.decrement(a)) }; f.promise.then(h, _ => h(null, _ || "unknown")) }), gn(() => { for (const f of o.values()) f.reject(te) }), new Promise(f => { function u(a) { function h() { a === i ? f(s) : u(i) } a.then(h, h) } u(i) }) } function lt(e) { var t = e.effects; if (t !== null) { e.effects = null; for (var n = 0; n < t.length; n += 1)D(t[n]) } } function on(e) { for (var t = e.parent; t !== null;) { if ((t.f & m) === 0) return t; t = t.parent } return null } function qe(e) { var t, n = d; I(on(e)); try { e.f &= ~ye, lt(e), t = St(e) } finally { I(n) } return t } function ut(e) { var t = qe(e); if (e.equals(t) || (e.v = t, e.wv = xt()), !ue) if (R !== null) R.set(e, e.v); else { var n = (Y || (e.f & O) !== 0) && e.deps !== null ? V : b; E(e, n) } } let Pe = new Set; const z = new Map; let ot = !1; function Se(e, t) { var n = { f: 0, v: e, reactions: null, equals: et, rv: 0, wv: 0 }; return n } function M(e, t) { const n = Se(e); return On(n), n } function j(e, t, n = !1) { v !== null && (!P || (v.f & Ye) !== 0) && rt() && (v.f & (m | U | Me | Ye)) !== 0 && !q?.includes(e) && Wt(); let r = n ? oe(t) : t; return Ee(e, r) } function Ee(e, t) { if (!e.equals(t)) { var n = e.v; ue ? z.set(e, t) : z.set(e, n), e.v = t; var r = C.ensure(); r.capture(e, n), (e.f & m) !== 0 && ((e.f & S) !== 0 && qe(e), E(e, (e.f & O) === 0 ? b : V)), e.wv = xt(), at(e, S), d !== null && (d.f & b) !== 0 && (d.f & (H | X)) === 0 && (A === null ? Nn([e]) : A.push(e)), !r.is_fork && Pe.size > 0 && !ot && an() } return t } function an() { ot = !1; const e = Array.from(Pe); for (const t of e) (t.f & b) !== 0 && E(t, V), ve(t) && he(t); Pe.clear() } function cn(e, t = 1) { var n = F(e), r = t === 1 ? n++ : n--; return j(e, n), r } function ce(e) { j(e, e.v + 1) } function at(e, t) { var n = e.reactions; if (n !== null) for (var r = n.length, i = 0; i < r; i++) { var s = n[i], l = s.f, o = (l & S) === 0; o && E(s, t), (l & m) !== 0 ? (l & ye) === 0 && (s.f |= ye, at(s, V)) : o && ((l & U) !== 0 && L !== null && L.add(s), fe(s)) } } function oe(e) { if (typeof e != "object" || e === null || Ae in e) return e; const t = It(e); if (t !== Ct && t !== Dt) return e; var n = new Map, r = Nt(e), i = M(0), s = Q, l = o => { if (Q === s) return o(); var f = v, u = Q; x(null), He(s); var a = o(); return x(f), He(u), a }; return r && n.set("length", M(e.length)), new Proxy(e, { defineProperty(o, f, u) { (!("value" in u) || u.configurable === !1 || u.enumerable === !1 || u.writable === !1) && Kt(); var a = n.get(f); return a === void 0 ? a = l(() => { var h = M(u.value); return n.set(f, h), h }) : j(a, u.value, !0), !0 }, deleteProperty(o, f) { var u = n.get(f); if (u === void 0) { if (f in o) { const a = l(() => M(g)); n.set(f, a), ce(i) } } else j(u, g), ce(i); return !0 }, get(o, f, u) { if (f === Ae) return e; var a = n.get(f), h = f in o; if (a === void 0 && (!h || ae(o, f)?.writable) && (a = l(() => { var c = oe(h ? o[f] : g), p = M(c); return p }), n.set(f, a)), a !== void 0) { var _ = F(a); return _ === g ? void 0 : _ } return Reflect.get(o, f, u) }, getOwnPropertyDescriptor(o, f) { var u = Reflect.getOwnPropertyDescriptor(o, f); if (u && "value" in u) { var a = n.get(f); a && (u.value = F(a)) } else if (u === void 0) { var h = n.get(f), _ = h?.v; if (h !== void 0 && _ !== g) return { enumerable: !0, configurable: !0, value: _, writable: !0 } } return u }, has(o, f) { if (f === Ae) return !0; var u = n.get(f), a = u !== void 0 && u.v !== g || Reflect.has(o, f); if (u !== void 0 || d !== null && (!a || ae(o, f)?.writable)) { u === void 0 && (u = l(() => { var _ = a ? oe(o[f]) : g, c = M(_); return c }), n.set(f, u)); var h = F(u); if (h === g) return !1 } return a }, set(o, f, u, a) { var h = n.get(f), _ = f in o; if (r && f === "length") for (var c = u; c < h.v; c += 1) { var p = n.get(c + ""); p !== void 0 ? j(p, g) : c in o && (p = l(() => M(g)), n.set(c + "", p)) } if (h === void 0) (!_ || ae(o, f)?.writable) && (h = l(() => M(void 0)), j(h, oe(u)), n.set(f, h)); else { _ = h.v !== g; var N = l(() => oe(u)); j(h, N) } var Z = Reflect.getOwnPropertyDescriptor(o, f); if (Z?.set && Z.set.call(a, u), !_) { if (r && typeof f == "string") { var Ve = n.get("length"), ke = Number(f); Number.isInteger(ke) && ke >= Ve.v && j(Ve, ke + 1) } ce(i) } return !0 }, ownKeys(o) { F(i); var f = Reflect.ownKeys(o).filter(h => { var _ = n.get(h); return _ === void 0 || _.v !== g }); for (var [u, a] of n) a.v !== g && !(u in o) && f.push(u); return f }, setPrototypeOf() { $t() } }) } var $e, ct, _t, ht; function _n() { if ($e === void 0) { $e = window, ct = /Firefox/.test(navigator.userAgent); var e = Element.prototype, t = Node.prototype, n = Text.prototype; _t = ae(t, "firstChild").get, ht = ae(t, "nextSibling").get, Be(e) && (e.__click = void 0, e.__className = void 0, e.__attributes = null, e.__style = void 0, e.__e = void 0), Be(n) && (n.__t = void 0) } } function vt(e = "") { return document.createTextNode(e) } function dt(e) { return _t.call(e) } function Ue(e) { return ht.call(e) } function Oe(e, t) { return dt(e) } function hn(e, t = 1, n = !1) { let r = e; for (; t--;)r = Ue(r); return r } function pt(e) { var t = v, n = d; x(null), I(null); try { return e() } finally { x(t), I(n) } } function vn(e) { d === null && v === null && Bt(), v !== null && (v.f & O) !== 0 && d === null && Vt(), ue && Ut() } function dn(e, t) { var n = t.last; n === null ? t.last = t.first = e : (n.next = e, e.prev = n, t.last = e) } function G(e, t, n, r = !0) { var i = d; i !== null && (i.f & K) !== 0 && (e |= K); var s = { ctx: k, deps: null, nodes_start: null, nodes_end: null, f: e | S, first: null, fn: t, last: null, next: null, parent: i, b: i && i.b, prev: null, teardown: null, transitions: null, wv: 0, ac: null }; if (n) try { he(s), s.f |= Ie } catch (f) { throw D(s), f } else t !== null && fe(s); if (r) { var l = s; if (n && l.deps === null && l.teardown === null && l.nodes_start === null && l.first === l.last && (l.f & le) === 0 && (l = l.first, (e & U) !== 0 && (e & we) !== 0 && l !== null && (l.f |= we)), l !== null && (l.parent = i, i !== null && dn(l, i), v !== null && (v.f & m) !== 0 && (e & X) === 0)) { var o = v; (o.effects ??= []).push(l) } } return s } function pn() { return v !== null && !P } function gn(e) { const t = G(De, null, !1); return E(t, b), t.teardown = e, t } function wn(e) { vn(); var t = d.f, n = !v && (t & H) !== 0 && (t & Ie) === 0; if (n) { var r = k; (r.e ??= []).push(e) } else return gt(e) } function gt(e) { return G(Ce | Lt, e, !1) } function mn(e) { C.ensure(); const t = G(X | le, e, !0); return (n = {}) => new Promise(r => { n.outro ? ge(t, () => { D(t), r(void 0) }) : (D(t), r(void 0)) }) } function yn(e) { return G(Me | le, e, !0) } function bn(e, t = 0) { return G(De | t, e, !0) } function En(e, t = [], n = [], r = [], i = !1) { sn(r, t, n, s => { G(i ? Ce : De, () => e(...s.map(F)), !0) }) } function xn(e, t = 0) { var n = G(U | t, e, !0); return n } function J(e, t = !0) { return G(H | le, e, !0, t) } function wt(e) { var t = e.teardown; if (t !== null) { const n = ue, r = v; ze(!0), x(null); try { t.call(null) } finally { ze(n), x(r) } } } function mt(e, t = !1) { var n = e.first; for (e.first = e.last = null; n !== null;) { const i = n.ac; i !== null && pt(() => { i.abort(te) }); var r = n.next; (n.f & X) !== 0 ? n.parent = null : D(n, t), n = r } } function Tn(e) { for (var t = e.first; t !== null;) { var n = t.next; (t.f & H) === 0 && D(t), t = n } } function D(e, t = !0) { var n = !1; (t || (e.f & Xe) !== 0) && e.nodes_start !== null && e.nodes_end !== null && (Sn(e.nodes_start, e.nodes_end), n = !0), mt(e, t && !n), xe(e, 0), E(e, $); var r = e.transitions; if (r !== null) for (const s of r) s.stop(); wt(e); var i = e.parent; i !== null && i.first !== null && yt(e), e.next = e.prev = e.teardown = e.ctx = e.deps = e.fn = e.nodes_start = e.nodes_end = e.ac = null } function Sn(e, t) { for (; e !== null;) { var n = e === t ? null : Ue(e); e.remove(), e = n } } function yt(e) { var t = e.parent, n = e.prev, r = e.next; n !== null && (n.next = r), r !== null && (r.prev = n), t !== null && (t.first === e && (t.first = r), t.last === e && (t.last = n)) } function ge(e, t, n = !0) { var r = []; bt(e, r, !0), kn(r, () => { n && D(e), t && t() }) } function kn(e, t) { var n = e.length; if (n > 0) { var r = () => --n || t(); for (var i of e) i.out(r) } else t() } function bt(e, t, n) { if ((e.f & K) === 0) { if (e.f ^= K, e.transitions !== null) for (const l of e.transitions) (l.is_global || n) && t.push(l); for (var r = e.first; r !== null;) { var i = r.next, s = (r.f & we) !== 0 || (r.f & H) !== 0 && (e.f & U) !== 0; bt(r, t, s ? n : !1), r = i } } } function An(e, t) { for (var n = e.nodes_start, r = e.nodes_end; n !== null;) { var i = n === r ? null : Ue(n); t.append(n), n = i } } let re = !1; function We(e) { re = e } let ue = !1; function ze(e) { ue = e } let v = null, P = !1; function x(e) { v = e } let d = null; function I(e) { d = e } let q = null; function On(e) { v !== null && (q === null ? q = [e] : q.push(e)) } let y = null, T = 0, A = null; function Nn(e) { A = e } let Et = 1, _e = 0, Q = _e; function He(e) { Q = e } let Y = !1; function xt() { return ++Et } function ve(e) { var t = e.f; if ((t & S) !== 0) return !0; if ((t & V) !== 0) { var n = e.deps, r = (t & O) !== 0; if (t & m && (e.f &= ~ye), n !== null) { var i, s, l = (t & me) !== 0, o = r && d !== null && !Y, f = n.length; if ((l || o) && (d === null || (d.f & $) === 0)) { var u = e, a = u.parent; for (i = 0; i < f; i++)s = n[i], (l || !s?.reactions?.includes(u)) && (s.reactions ??= []).push(u); l && (u.f ^= me), o && a !== null && (a.f & O) === 0 && (u.f ^= O) } for (i = 0; i < f; i++)if (s = n[i], ve(s) && ut(s), s.wv > e.wv) return !0 } (!r || d !== null && !Y) && E(e, b) } return !1 } function Tt(e, t, n = !0) { var r = e.reactions; if (r !== null && !q?.includes(e)) for (var i = 0; i < r.length; i++) { var s = r[i]; (s.f & m) !== 0 ? Tt(s, t, !1) : t === s && (n ? E(s, S) : (s.f & b) !== 0 && E(s, V), fe(s)) } } function St(e) { var t = y, n = T, r = A, i = v, s = Y, l = q, o = k, f = P, u = Q, a = e.f; y = null, T = 0, A = null, Y = (a & O) !== 0 && (P || !re || v === null), v = (a & (H | X)) === 0 ? e : null, q = null, ie(e.ctx), P = !1, Q = ++_e, e.ac !== null && (pt(() => { e.ac.abort(te) }), e.ac = null); try { e.f |= Ne; var h = e.fn, _ = h(), c = e.deps; if (y !== null) { var p; if (xe(e, T), c !== null && T > 0) for (c.length = T + y.length, p = 0; p < y.length; p++)c[T + p] = y[p]; else e.deps = c = y; if (!Y || (a & m) !== 0 && e.reactions !== null) for (p = T; p < c.length; p++)(c[p].reactions ??= []).push(e) } else c !== null && T < c.length && (xe(e, T), c.length = T); if (rt() && A !== null && !P && c !== null && (e.f & (m | V | S)) === 0) for (p = 0; p < A.length; p++)Tt(A[p], e); return i !== null && i !== e && (_e++, A !== null && (r === null ? r = A : r.push(...A))), (e.f & W) !== 0 && (e.f ^= W), _ } catch (N) { return it(N) } finally { e.f ^= Ne, y = t, T = n, A = r, v = i, Y = s, q = l, ie(o), P = f, Q = u } } function Rn(e, t) { let n = t.reactions; if (n !== null) { var r = Rt.call(n, e); if (r !== -1) { var i = n.length - 1; i === 0 ? n = t.reactions = null : (n[r] = n[i], n.pop()) } } n === null && (t.f & m) !== 0 && (y === null || !y.includes(t)) && (E(t, V), (t.f & (O | me)) === 0 && (t.f ^= me), lt(t), xe(t, 0)) } function xe(e, t) { var n = e.deps; if (n !== null) for (var r = t; r < n.length; r++)Rn(e, n[r]) } function he(e) { var t = e.f; if ((t & $) === 0) { E(e, b); var n = d, r = re; d = e, re = !0; try { (t & U) !== 0 ? Tn(e) : mt(e), wt(e); var i = St(e); e.teardown = typeof i == "function" ? i : null, e.wv = Et; var s; Je && Zt && (e.f & S) !== 0 && e.deps } finally { re = r, d = n } } } function F(e) { var t = e.f, n = (t & m) !== 0; if (v !== null && !P) { var r = d !== null && (d.f & $) !== 0; if (!r && !q?.includes(e)) { var i = v.deps; if ((v.f & Ne) !== 0) e.rv < _e && (e.rv = _e, y === null && i !== null && i[T] === e ? T++ : y === null ? y = [e] : (!Y || !y.includes(e)) && y.push(e)); else { (v.deps ??= []).push(e); var s = e.reactions; s === null ? e.reactions = [v] : s.includes(v) || s.push(v) } } } else if (n && e.deps === null && e.effects === null) { var l = e, o = l.parent; o !== null && (o.f & O) === 0 && (l.f ^= O) } if (ue) { if (z.has(e)) return z.get(e); if (n) { l = e; var f = l.v; return ((l.f & b) === 0 && l.reactions !== null || kt(l)) && (f = qe(l)), z.set(l, f), f } } else if (n) { if (l = e, R?.has(l)) return R.get(l); ve(l) && ut(l) } if (R?.has(e)) return R.get(e); if ((e.f & W) !== 0) throw e.v; return e.v } function kt(e) { if (e.v === g) return !0; if (e.deps === null) return !1; for (const t of e.deps) if (z.has(t) || (t.f & m) !== 0 && kt(t)) return !0; return !1 } function At(e) { var t = P; try { return P = !0, e() } finally { P = t } } const Pn = -7169; function E(e, t) { e.f = e.f & Pn | t } const Fn = ["touchstart", "touchmove"]; function Cn(e) { return Fn.includes(e) } const Ot = new Set, Fe = new Set; function Dn(e) { for (var t = 0; t < e.length; t++)Ot.add(e[t]); for (var n of Fe) n(e) } let Ge = null; function pe(e) { var t = this, n = t.ownerDocument, r = e.type, i = e.composedPath?.() || [], s = i[0] || e.target; Ge = e; var l = 0, o = Ge === e && e.__root; if (o) { var f = i.indexOf(o); if (f !== -1 && (t === document || t === window)) { e.__root = t; return } var u = i.indexOf(t); if (u === -1) return; f <= u && (l = f) } if (s = i[l] || e.target, s !== t) { Ft(e, "currentTarget", { configurable: !0, get() { return s || n } }); var a = v, h = d; x(null), I(null); try { for (var _, c = []; s !== null;) { var p = s.assignedSlot || s.parentNode || s.host || null; try { var N = s["__" + r]; N != null && (!s.disabled || e.target === s) && N.call(s, e) } catch (Z) { _ ? c.push(Z) : _ = Z } if (e.cancelBubble || p === t || p === null) break; s = p } if (_) { for (let Z of c) queueMicrotask(() => { throw Z }); throw _ } } finally { e.__root = t, delete e.currentTarget, x(a), I(h) } } } function In(e) { var t = document.createElement("template"); return t.innerHTML = e.replaceAll("<!>", "<!---->"), t.content } function Mn(e, t) { var n = d; n.nodes_start === null && (n.nodes_start = e, n.nodes_end = t) } function Ln(e, t) { var n = (t & Ht) !== 0, r, i = !e.startsWith("<!>"); return () => { r === void 0 && (r = In(i ? e : "<!>" + e), r = dt(r)); var s = n || ct ? document.importNode(r, !0) : r.cloneNode(!0); return Mn(s, s), s } } function jn(e, t) { e !== null && e.before(t) } function Ze(e, t) { var n = t == null ? "" : typeof t == "object" ? t + "" : t; n !== (e.__t ??= e.nodeValue) && (e.__t = n, e.nodeValue = n + "") } function qn(e, t) { return Un(e, t) } const ee = new Map; function Un(e, { target: t, anchor: n, props: r = {}, events: i, context: s, intro: l = !0 }) { _n(); var o = new Set, f = h => { for (var _ = 0; _ < h.length; _++) { var c = h[_]; if (!o.has(c)) { o.add(c); var p = Cn(c); t.addEventListener(c, pe, { passive: p }); var N = ee.get(c); N === void 0 ? (document.addEventListener(c, pe, { passive: p }), ee.set(c, 1)) : ee.set(c, N + 1) } } }; f(Pt(Ot)), Fe.add(f); var u = void 0, a = mn(() => { var h = n ?? t.appendChild(vt()); return nn(h, { pending: () => { } }, _ => { if (s) { tt({}); var c = k; c.c = s } i && (r.$$events = i), u = e(_, r) || {}, s && nt() }), () => { for (var _ of o) { t.removeEventListener(_, pe); var c = ee.get(_); --c === 0 ? (document.removeEventListener(_, pe), ee.delete(_)) : ee.set(_, c) } Fe.delete(f), h !== n && h.parentNode?.removeChild(h) } }); return Vn.set(u, a), u } let Vn = new WeakMap; function Bn(e) { k === null && jt(), wn(() => { const t = At(e); if (typeof t == "function") return t }) } const Yn = "5"; typeof window < "u" && ((window.__svelte ??= {}).v ??= new Set).add(Yn); const Kn = globalThis.onEvent; var $n = Ln('<div class="wrapper"><h1> </h1> <button> </button></div>'); function Wn(e, t) { tt(t, !0); let n = M(0); Bn(() => { Kn("cart:add", f => j(n, f["from A"], !0)) }); var r = $n(), i = Oe(r), s = Oe(i), l = hn(i, 2); l.__click = () => { cn(n), console.log(F(n)) }; var o = Oe(l); En(() => { Ze(s, `接受:${F(n) ?? ""}`), Ze(o, F(n)) }), jn(e, r), nt() } Dn(["click"]); qn(Wn, { target: document.getElementById("appb") });
